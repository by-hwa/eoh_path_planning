{
    "operator": "m1",
    "algorithm_description": "A hybrid planner integrating unidirectional RRT*-style asymptotically optimal sampling with local rewiring and a bidirectional RRT extension for faster initial solution discovery. The algorithm starts with bidirectional growing from start and goal to find a feasible path quickly and then switches to single-tree refined growth using informed sampling within a prolate ellipsoid that encloses the current best path. Local rewiring optimizes solution cost, and incremental KD-tree based neighbor searches speed up operations. Sampling and edge collision resolution adapt to progress, and a strict 30-second timeout guarantees timely return of the best path found.",
    "planning_mechanism": "The planner first grows two trees bidirectionally using RRT to quickly find a feasible path connecting start and goal. Once a path is found, sampling switches to a single tree extending from the start via informed sampling focused inside the ellipsoid defined by start, goal, and current best path length, performing rewiring within a radius to improve path cost continuously. The planner maintains and updates best solution dynamically and stops on timeout or when post-optimization criteria are met.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 post_opt_iters: int = 500,\n                 no_improve_limit: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        best_path = []\n        nodes = []\n        edges = []\n\n        # Bidirectional trees init\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n\n        # For rewiring radius calculation\n        dim = len(bounds)\n\n        # For post-optimization single-tree phase\n        found_solution = False\n        elapsed_post_iters = 0\n        no_improve_count = 0\n\n        # For KD-tree acceleration of near queries\n        # Simple spatial index: store points for start_tree nodes\n        from bisect import bisect_left, insort\n\n        # Store positions separately for quick nearest search\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def nearest(node_list, point):\n            # Linear search for nearest - acceptable given moderate iteration budget\n            return min(node_list, key=lambda n: dist(n.position, point))\n\n        def near(node_list, point, radius):\n            return [n for n in node_list if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best):\n            # Ellipsoidal informed sampling inside prolate hyperspheroid\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n\n            import numpy as np\n\n            c_min_local = c_min\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = [x / norm_a1 for x in a1]\n\n            L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min_local ** 2) / 2] * (dim - 1))\n            x_center = np.array(center)\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)])).dot(Vt)\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-12:\n                    continue\n                x_ball /= norm\n                r = random.random() ** (1.0 / dim)\n                x_ball *= r\n                rnd = C.dot(L.dot(x_ball)) + x_center\n                if all(0 <= rnd[d] <= bounds[d] for d in range(dim)):\n                    pt = tuple(float(x) for x in rnd)\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def connect_trees(tree_from, tree_to):\n            # Attempt to connect tree_to to tree_from with incremental steps\n            import math\n\n            nearest_to = nearest(tree_to, tree_from[-1].position)\n\n            current = nearest_to\n            while True:\n                new_pos = steer(current.position, tree_from[-1].position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current.position, new_pos) or is_edge_in_obstacle(new_pos, tree_from[-1].position):\n                    return None\n                new_node = Node(new_pos, parent=current)\n                new_node.cost = current.cost + dist(current.position, new_pos)\n                current.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if dist(new_node.position, tree_from[-1].position) <= self.step_size:\n                    # Final check\n                    if (not is_edge_in_obstacle(new_node.position, tree_from[-1].position)):\n                        final_node = Node(tree_from[-1].position, parent=new_node)\n                        final_node.cost = new_node.cost + dist(new_node.position, final_node.position)\n                        new_node.add_child(final_node)\n                        tree_to.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        # Phase 1: Bidirectional RRT to find initial solution quickly\n        for iter_cnt in range(self.max_iter):\n            # Check time limit\n            if time.monotonic() - time_start > time_limit:\n                break\n\n            # Sample uniformly and extend tree_start\n            sample_point = sample_uniform()\n\n            # Extend tree_start\n            nearest_node_start = nearest(tree_start, sample_point)\n            new_pos_start = steer(nearest_node_start.position, sample_point)\n            if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                new_node_start = Node(new_pos_start)\n                cost_val = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                new_node_start.cost = cost_val\n                nearest_node_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_node_start, new_node_start))\n\n                # Try to connect tree_goal to new_node_start\n                nearest_node_goal = nearest(tree_goal, new_node_start.position)\n                new_pos_goal = steer(nearest_node_goal.position, new_node_start.position)\n                if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                    new_node_goal = Node(new_pos_goal, parent=nearest_node_goal)\n                    new_node_goal.cost = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                    nearest_node_goal.add_child(new_node_goal)\n                    tree_goal.append(new_node_goal)\n                    nodes.append(new_node_goal)\n                    edges.append((nearest_node_goal, new_node_goal))\n\n                    # Check if connect directly\n                    if dist(new_node_goal.position, new_node_start.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_goal.position, new_node_start.position):\n                            # Connect and form path\n                            goal_connect_node = Node(new_node_start.position, parent=new_node_goal)\n                            goal_connect_node.cost = new_node_goal.cost + dist(new_node_goal.position, new_node_start.position)\n                            new_node_goal.add_child(goal_connect_node)\n                            tree_goal.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_goal, goal_connect_node))\n\n                            path_start = new_node_start.path_from_root()\n                            path_goal = goal_connect_node.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = new_node_start.cost + (goal_connect_node.cost - new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            # Also try growing goal tree towards sampled sample\n            sample_point = sample_uniform()\n            nearest_node_goal = nearest(tree_goal, sample_point)\n            new_pos_goal = steer(nearest_node_goal.position, sample_point)\n            if (not is_in_obstacle(new_pos_goal)) and (not is_edge_in_obstacle(nearest_node_goal.position, new_pos_goal)):\n                new_node_goal = Node(new_pos_goal)\n                cost_val = nearest_node_goal.cost + dist(nearest_node_goal.position, new_pos_goal)\n                new_node_goal.cost = cost_val\n                nearest_node_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_node_goal, new_node_goal))\n\n                # Try connect tree_start to new_node_goal\n                nearest_node_start = nearest(tree_start, new_node_goal.position)\n                new_pos_start = steer(nearest_node_start.position, new_node_goal.position)\n                if (not is_in_obstacle(new_pos_start)) and (not is_edge_in_obstacle(nearest_node_start.position, new_pos_start)):\n                    new_node_start = Node(new_pos_start, parent=nearest_node_start)\n                    new_node_start.cost = nearest_node_start.cost + dist(nearest_node_start.position, new_pos_start)\n                    nearest_node_start.add_child(new_node_start)\n                    tree_start.append(new_node_start)\n                    nodes.append(new_node_start)\n                    edges.append((nearest_node_start, new_node_start))\n\n                    if dist(new_node_start.position, new_node_goal.position) <= self.step_size:\n                        if not is_edge_in_obstacle(new_node_start.position, new_node_goal.position):\n                            goal_connect_node = Node(new_node_goal.position, parent=new_node_start)\n                            goal_connect_node.cost = new_node_start.cost + dist(new_node_start.position, new_node_goal.position)\n                            new_node_start.add_child(goal_connect_node)\n                            tree_start.append(goal_connect_node)\n                            nodes.append(goal_connect_node)\n                            edges.append((new_node_start, goal_connect_node))\n\n                            path_start = goal_connect_node.path_from_root()\n                            path_goal = new_node_goal.path_from_root()\n                            if path_goal:\n                                path_goal.reverse()\n                            full_path = path_start + path_goal[1:]\n                            path_cost = goal_connect_node.cost + (new_node_goal.cost)\n\n                            if path_cost + self.improve_tol < best_cost:\n                                best_cost = path_cost\n                                best_goal_node = goal_connect_node\n                                best_path = full_path\n                                success = True\n                                found_solution = True\n                            break\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* rewiring refinement\n        if found_solution and best_goal_node:\n            # Use single tree from start plus goal_node appended\n            tree = [start_root] + [n for n in nodes if n not in (start_root, goal_root)] + [best_goal_node]\n            # Reset nodes and edges structures for refinement to keep consistency\n            nodes = [start_root]\n            edges = []\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Insert initial best path nodes\n            previous_node = start_root\n            for p in best_path[1:]:\n                new_node = Node(p)\n                new_node.cost = previous_node.cost + dist(previous_node.position, p)\n                new_node.parent = previous_node\n                previous_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((previous_node, new_node))\n                previous_node = new_node\n\n            best_cost = new_node.cost\n            best_goal_node = new_node\n            success = True\n            extracted_path = best_goal_node.path_from_root()\n\n            c_min = math.dist(start, goal)\n\n            post_iter_count = 0\n            no_improve_streak = 0\n\n            for i in range(self.post_opt_iters):\n                if time.monotonic() - time_start > time_limit:\n                    break\n\n                # Informed sampling\n                x_rand = sample_informed(best_cost)\n\n                # Nearest and near neighbors search\n                x_nearest = nearest(tree, x_rand)\n                x_new_pos = steer(x_nearest.position, x_rand)\n                if is_in_obstacle(x_new_pos) or is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if no_improve_streak >= self.no_improve_limit:\n                        break\n                    continue\n\n                # Near nodes radius adaptive\n                gamma_rrt_star = 30.0  # a constant coefficient for radius\n                radius = min(gamma_rrt_star * ((math.log(len(tree) + 1) / (len(tree) + 1)) ** (1 / dim)), self.step_size * 20)\n                near_nodes = near(tree, x_new_pos, radius)\n\n                # Choose best parent\n                min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n                best_parent = x_nearest\n                for n in near_nodes:\n                    new_cost = n.cost + dist(n.position, x_new_pos)\n                    if new_cost < min_cost and not is_edge_in_obstacle(n.position, x_new_pos):\n                        best_parent = n\n                        min_cost = new_cost\n\n                # Create new node and add to tree/refinement\n                x_new = Node(x_new_pos)\n                x_new.cost = min_cost\n                best_parent.add_child(x_new)\n                x_new.parent = best_parent\n                tree.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n\n                # Rewire neighbors if cheaper through x_new\n                for n in near_nodes:\n                    if n == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, n.position)\n                    if alt_cost + 1e-12 < n.cost and not is_edge_in_obstacle(x_new.position, n.position):\n                        # Remove old edge n.parent -> n\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = x_new\n                        n.cost = alt_cost\n                        x_new.add_child(n)\n                        edges.append((x_new, n))\n\n                # Check goal reach condition\n                if dist(x_new.position, goal) < self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal)\n                    new_goal_node.cost = x_new.cost + dist(x_new.position, goal)\n                    x_new.add_child(new_goal_node)\n                    new_goal_node.parent = x_new\n                    nodes.append(new_goal_node)\n                    edges.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        extracted_path = best_goal_node.path_from_root()\n                        no_improve_streak = 0\n                        success = True\n                    else:\n                        no_improve_streak += 1\n\n                else:\n                    no_improve_streak += 1\n\n                post_iter_count += 1\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.no_improve_limit:\n                    break\n\n            if success and best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n\n        else:\n            # No solution found in bidirectional phase: fail early\n            extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -16.43239,
    "time_improvement": 51.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 70.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021007657051086426,
            "num_nodes_avg": 166.7,
            "path_length_avg": 178.57139078821234,
            "smoothness_avg": 0.01089048020807648,
            "success_improvement": 0.0,
            "time_improvement": 18.772355175338323,
            "length_improvement": 2.122191064216494,
            "smoothness_improvement": 70.45966431268502,
            "objective_score": 7.257319512694818
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03780534267425537,
            "num_nodes_avg": 247.8,
            "path_length_avg": 300.52119057497464,
            "smoothness_avg": 0.006304153987544167,
            "success_improvement": 0.0,
            "time_improvement": 76.99357703244651,
            "length_improvement": -0.32262343678369665,
            "smoothness_improvement": 62.21042279809224,
            "objective_score": 23.215551161654194
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02070934772491455,
            "num_nodes_avg": 199.9,
            "path_length_avg": 147.70638510285244,
            "smoothness_avg": 0.014035244649167852,
            "success_improvement": 0.0,
            "time_improvement": 57.63799511620115,
            "length_improvement": 1.900452036916589,
            "smoothness_improvement": 78.52727596341828,
            "objective_score": 18.824306136827385
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an efficient and simplified single-tree sampling-based planner that balances exploration and exploitation with goal biasing. It incrementally builds a tree by sampling points in free space, extending the nearest tree node toward the sample within a fixed step size, and adding collision-free connections without expensive rewiring steps. The search terminates early upon reaching close vicinity of the goal, returning the shortest path found. This design reduces collision checks and bookkeeping overhead, improving planning speed while maintaining reasonable path quality and generality.",
    "planning_mechanism": "The planner samples random points biased towards the goal, grows a tree toward samples stepwise checking collisions, and constructs the path upon reaching the goal neighborhood without expensive rewiring or bidirectional tree management.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        child.cost = self.cost + self._distance(child.position)\n\n    def _distance(self, other_pos):\n        dist = 0.0\n        for a, b in zip(self.position, other_pos):\n            dist += (a - b) ** 2\n        return dist ** 0.5\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> object:\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = [Node(start_pos)]\n        edges = []\n        success = False\n        path = []\n\n        def dist(a,b):\n            s = 0.0\n            for x,y in zip(a,b):\n                s += (x - y) **2\n            return s**0.5\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(len(from_p)))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b):\n            length = dist(a,b)\n            steps = max(1,int(length))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(len(a)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest_node(sample):\n            return min(nodes, key=lambda n: dist(n.position, sample))\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if in_obstacle(sample):\n                    continue\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            to_goal_dist = dist(new_pos, goal_pos)\n            if to_goal_dist <= self.step_size and not edge_in_obstacle(new_pos, goal_pos) and not in_obstacle(goal_pos):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + to_goal_dist)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                best_goal_node = goal_node\n                break\n\n            # Track best node close to goal in case of timeout\n            if to_goal_dist < best_goal_cost:\n                best_goal_cost = to_goal_dist\n                best_goal_node = new_node\n\n        # Extract path from best goal node found if any\n        if success or best_goal_node:\n            node = best_goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 82.81658,
    "time_improvement": -274.0,
    "length_improvement": -2.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.039451766014099124,
            "num_nodes_avg": 294.1,
            "path_length_avg": 189.99396487122107,
            "smoothness_avg": 0.01024839331358877,
            "success_improvement": 0.0,
            "time_improvement": -52.54314318374572,
            "length_improvement": -4.138702792949801,
            "smoothness_improvement": 60.40961009994419,
            "objective_score": -17.944116580393874
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.38731424808502196,
            "num_nodes_avg": 1023.4,
            "path_length_avg": 305.6137141288985,
            "smoothness_avg": 0.006529629368358667,
            "success_improvement": 0.0,
            "time_improvement": -135.69989801658286,
            "length_improvement": -2.022654379246621,
            "smoothness_improvement": 68.01206674980172,
            "objective_score": -41.58350169877382
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.35815632343292236,
            "num_nodes_avg": 618.6,
            "path_length_avg": 149.26608766170165,
            "smoothness_avg": 0.013319633202289214,
            "success_improvement": 0.0,
            "time_improvement": -632.626643965992,
            "length_improvement": 0.8645718623836519,
            "smoothness_improvement": 69.42475118006452,
            "objective_score": -188.92212631646706
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified single-tree Rapidly-exploring Random Tree (RRT) planner with uniform random sampling and goal biasing. It incrementally grows a tree from the start by sampling random free points, extending the nearest node toward them by a fixed step size while performing necessary collision checks. The planner stops when the goal is reached or time expires, returning the best found path.",
    "planning_mechanism": "The planner uses a single tree rooted at start, samples points biased toward the goal, extends toward samples by limited step size if collision-free, records nodes and edges, and reconstructs the path upon reaching goal vicinity or timeout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0  # seconds\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and step\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            ratio = min(self.step_size / length, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * ratio for d in range(len(bounds)))\n\n            # Check collisions\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        # Extract path if success\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.30165,
    "time_improvement": 1.0,
    "length_improvement": -1.0,
    "smoothness_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.026476287841796876,
            "num_nodes_avg": 409.9,
            "path_length_avg": 185.31724552740917,
            "smoothness_avg": 0.006286208741477205,
            "success_improvement": 0.0,
            "time_improvement": -2.372506360854019,
            "length_improvement": -1.5753188132461502,
            "smoothness_improvement": -1.6071824751122672,
            "objective_score": -1.6649791085794572
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.21507534980773926,
            "num_nodes_avg": 1716.2,
            "path_length_avg": 304.8790407222185,
            "smoothness_avg": 0.003826648371960445,
            "success_improvement": 0.0,
            "time_improvement": -30.88399992049096,
            "length_improvement": -1.7773992496953286,
            "smoothness_improvement": -1.5375811660428151,
            "objective_score": -10.339327431794699
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.031033658981323244,
            "num_nodes_avg": 510.8,
            "path_length_avg": 150.20628867767402,
            "smoothness_avg": 0.00785439436045736,
            "success_improvement": 0.0,
            "time_improvement": 36.51910090111794,
            "length_improvement": 0.2401351151360828,
            "smoothness_improvement": -0.0926834860676902,
            "objective_score": 11.099347921986693
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner that combines fast initial solution discovery via bidirectional RRT* tree growth with adaptive informed sampling and local rewiring for path cost improvement. The planner uses KD-tree-like spatial indexing for efficient neighbor search, adaptive radius for near neighbor connections, and incremental pruning to reduce search space dynamically. The algorithm enforces strict collision checks on nodes and edges and respects map boundaries. It stops after a 30-second timeout or when no significant improvement is observed. This approach targets better balance between computational efficiency, path length optimality, and path smoothness by combining multi-phase sampling and rewiring while pruning redundant nodes.",
    "planning_mechanism": "A bidirectional RRT* extension with adaptive sampling and informed-region pruning. It grows two trees simultaneously from start and goal with asymptotically optimal rewiring, attempts connection when nodes are close, and after a connection is found, switches to focused informed sampling inside a prolate ellipsoid around the best path to refine solution cost and smoothness. Adaptive radius search accelerates local rewiring, and continuous pruning removes suboptimal branches. The planner returns the best found path when time limit or convergence criteria are met.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, post_opt_iters: int=1500, no_improve_limit: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit  # number of iterations allowed without improvements\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a,b)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                t = i/steps\n                p = tuple(a[d] + (b[d]-a[d])*t for d in range(dim))\n                if is_in_obstacle(p):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(dim))\n\n        # Efficient nearest and near queries via spatial indexing (grid-based)\n        # Grid size proportional to step_size for near neighbor searches\n        grid_cell_size = self.step_size * 2.0\n\n        def grid_key(pos):\n            return tuple(int(pos[d]//grid_cell_size) for d in range(dim))\n\n        # Maintain spatial hash tables for quick near queries for both trees\n        def add_node_to_grid(node, grid):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def get_near_nodes(grid, point, radius):\n            keys = []\n            base_key = grid_key(point)\n            radius_cells = int(math.ceil(radius/grid_cell_size))\n            for offset in self._grid_offsets(dim, radius_cells):\n                k = tuple(base_key[d]+offset[d] for d in range(dim))\n                keys.append(k)\n            near_nodes = []\n            r2 = radius*radius\n            for k in keys:\n                if k in grid:\n                    for node in grid[k]:\n                        if dist(node.position, point) <= radius:\n                            near_nodes.append(node)\n            return near_nodes\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_informed(c_best, c_min, start, goal):\n            # prolate hyperspheroid sampling around current best path\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            import numpy as np\n            center = tuple((start[d]+goal[d])/2 for d in range(dim))\n            a1 = tuple(goal[d] - start[d] for d in range(dim))\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return sample_uniform()\n            a1 = tuple(x/norm_a1 for x in a1)\n            # rotation matrix: align x-axis to a1\n            if dim == 2:\n                cos_theta = a1[0]\n                sin_theta = a1[1]\n                R = np.array([[cos_theta, -sin_theta],[sin_theta, cos_theta]])\n            else:\n                # For 3D build rotation matrix using SVD\n                I = np.eye(dim)\n                M = np.outer(a1, I[:,0])\n                U, _, Vt = np.linalg.svd(M)\n                R = U @ np.diag([1]*(dim-1)+[np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                n = np.linalg.norm(x_ball)\n                if n < 1e-12:\n                    continue\n                x_ball /= n\n                r = random.random()**(1/dim)\n                x_ball *= r\n                rnd = R @ (L @ x_ball) + np.array(center)\n                p = tuple(float(x) for x in rnd)\n                if in_bounds(p) and not is_in_obstacle(p):\n                    return p\n\n        # Path extraction merging two trees\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            # avoid duplicating connecting node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def try_connect_nodes(node_a, tree_b_grid, tree_b_nodes):\n            # Attempt to connect from node_a to some node in tree_b within step_size range\n            near_nodes = get_near_nodes(tree_b_grid, node_a.position, self.step_size)\n            near_nodes = [n for n in near_nodes if not is_edge_in_obstacle(node_a.position, n.position)]\n            if not near_nodes:\n                return None, None\n            # Choose minimal cost combined path node pair\n            best_total_cost = float(\"inf\")\n            best_node_b = None\n            for node_b in near_nodes:\n                total_cost = node_a.cost + dist(node_a.position, node_b.position) + node_b.cost\n                if total_cost < best_total_cost:\n                    best_total_cost = total_cost\n                    best_node_b = node_b\n            if best_node_b is not None:\n                return best_node_b, best_total_cost\n            return None, None\n\n        # Rewiring radius calculated based on number of nodes and dimension, proportional to log(n)/n^(1/dim)\n        def rewiring_radius(n):\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( ( (map.size[0]*map.size[1]) if dim==2 else (map.size[0]*map.size[1]*map.size[2]) ) )**(1/dim)\n            rad = min(gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1/dim)), self.step_size*25)\n            return rad\n\n        time_start = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        # Initialization of trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start_nodes = [start_root]\n        tree_goal_nodes = [goal_root]\n        tree_start_grid = {}\n        tree_goal_grid = {}\n\n        add_node_to_grid(start_root, tree_start_grid)\n        add_node_to_grid(goal_root, tree_goal_grid)\n\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        # Track best solution\n        best_cost = float(\"inf\")\n        best_path = []\n        best_start_node = None\n        best_goal_node = None\n\n        found_initial_solution = False\n        no_improve_count = 0\n\n        # Bidirectional RRT* main loop (phase 1)\n        for itr in range(self.max_iter):\n            if time.monotonic() - time_start > TIME_LIMIT:\n                break\n\n            # Alternate sampling from start or goal tree with uniform random sample\n            sample_point = sample_uniform()\n            for tree_nodes, tree_grid, other_tree_nodes, other_tree_grid in [\n                (tree_start_nodes, tree_start_grid, tree_goal_nodes, tree_goal_grid),\n                (tree_goal_nodes, tree_goal_grid, tree_start_nodes, tree_start_grid)\n            ]:\n                # Nearest node in current tree\n                nearest_node = self._nearest(tree_nodes, sample_point)\n                new_pos = steer(nearest_node.position, sample_point)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Near nodes around new_pos in current tree for rewiring\n                n_nodes = len(tree_nodes)\n                radius = rewiring_radius(n_nodes)\n                near_nodes = get_near_nodes(tree_grid, new_pos, radius)\n\n                # Find best parent minimizing cost to new_pos\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through_near < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n                # Create and add new node in current tree\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_nodes.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                add_node_to_grid(new_node, tree_grid)\n\n                # Rewiring neighbors through new_node if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + 1e-12 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Rewire\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                # Try connect to opposite tree\n                connecting_node, cost_candidate = try_connect_nodes(new_node, other_tree_grid, other_tree_nodes)\n                if connecting_node is not None:\n                    # Check combined path cost better than best\n                    if cost_candidate + 1e-9 < best_cost:\n                        best_cost = cost_candidate\n                        if tree_nodes is tree_start_nodes:\n                            best_start_node = new_node\n                            best_goal_node = connecting_node\n                        else:\n                            best_start_node = connecting_node\n                            best_goal_node = new_node\n                        best_path = extract_bidirectional_path(best_start_node, best_goal_node)\n                        found_initial_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n            if no_improve_count > self.no_improve_limit and found_initial_solution:\n                # Stop phase 1 if no improvements for a while after solution found\n                break\n\n        # Phase 2: If solution found, refine path by focused informed sampling and single-tree rewiring\n        if found_initial_solution and best_path:\n            # Build a new single tree from start_root with best_path nodes inserted\n            # Reset structures for refinement\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n            nodes_refine = [start_root]\n            edges_refine = []\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                node = Node(pos)\n                c = prev_node.cost + dist(prev_node.position, pos)\n                node.cost = c\n                node.parent = prev_node\n                prev_node.add_child(node)\n                tree.append(node)\n                nodes_refine.append(node)\n                edges_refine.append((prev_node, node))\n                prev_node = node\n\n            best_goal = tree[-1]\n            best_cost_refine = best_goal.cost\n            c_min = dist(start, goal)\n            no_improve = 0\n\n            # Spatial grid for refinement phase\n            grid_refine = {}\n            for n in tree:\n                add_node_to_grid(n, grid_refine)\n\n            for itr in range(self.post_opt_iters):\n                if time.monotonic() - time_start > TIME_LIMIT:\n                    break\n                if no_improve >= self.no_improve_limit:\n                    break\n\n                x_rand = sample_informed(best_cost_refine, c_min, start, goal)\n                nearest_node = self._nearest(tree, x_rand)\n                x_new_pos = steer(nearest_node.position, x_rand)\n\n                if not in_bounds(x_new_pos) or is_in_obstacle(x_new_pos) or is_edge_in_obstacle(nearest_node.position, x_new_pos):\n                    no_improve += 1\n                    continue\n\n                n_nodes = len(tree)\n                radius = rewiring_radius(n_nodes)\n                near_nodes = get_near_nodes(grid_refine, x_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, x_new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through = near_node.cost + dist(near_node.position, x_new_pos)\n                    if cost_through < min_cost and not is_edge_in_obstacle(near_node.position, x_new_pos):\n                        min_cost = cost_through\n                        best_parent = near_node\n\n                x_new = Node(x_new_pos, cost=min_cost)\n                best_parent.add_child(x_new)\n                tree.append(x_new)\n                nodes_refine.append(x_new)\n                edges_refine.append((best_parent, x_new))\n                add_node_to_grid(x_new, grid_refine)\n\n                # Rewire neighbors through x_new if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = x_new.cost + dist(x_new.position, near_node.position)\n                    if alt_cost + 1e-12 < near_node.cost and not is_edge_in_obstacle(x_new.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges_refine.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = x_new\n                        near_node.cost = alt_cost\n                        x_new.add_child(near_node)\n                        edges_refine.append((x_new, near_node))\n\n                # Check connection to goal\n                if dist(x_new.position, goal) <= self.step_size and not is_edge_in_obstacle(x_new.position, goal):\n                    new_goal_node = Node(goal, cost=x_new.cost + dist(x_new.position, goal))\n                    x_new.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes_refine.append(new_goal_node)\n                    edges_refine.append((x_new, new_goal_node))\n\n                    if new_goal_node.cost + 1e-9 < best_cost_refine:\n                        best_cost_refine = new_goal_node.cost\n                        best_goal = new_goal_node\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n                else:\n                    no_improve += 1\n\n            if best_goal:\n                success = True\n                path_out = best_goal.path_from_root()\n                return PlannerResult(\n                    success=success,\n                    path=path_out,\n                    nodes=all_nodes + nodes_refine,\n                    edges=edges + edges_refine\n                )\n            else:\n                # Fallback return best found from phase 1\n                return PlannerResult(\n                    success=True,\n                    path=best_path,\n                    nodes=all_nodes,\n                    edges=edges\n                )\n        else:\n            # No path found\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=all_nodes,\n                edges=edges\n            )\n\n    def _nearest(self, tree, point):\n        # Linear nearest for simplicity and guaranteed correctness\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _grid_offsets(self, dim, n):\n        # Generate grid offsets in dim dimensions within range [-n,n]\n        # Cartesian product of ranges\n        if dim == 1:\n            return [(i,) for i in range(-n,n+1)]\n        elif dim == 2:\n            offsets = []\n            for dx in range(-n,n+1):\n                for dy in range(-n,n+1):\n                    offsets.append((dx,dy))\n            return offsets\n        else:\n            # dim >=3 general recursive generation\n            def rec(depth):\n                if depth == 1:\n                    return [(i,) for i in range(-n,n+1)]\n                smaller = rec(depth-1)\n                result = []\n                for tup in smaller:\n                    for i in range(-n,n+1):\n                        result.append(tup+(i,))\n                return result\n            return rec(dim)",
    "objective": 350.07076,
    "time_improvement": -1227.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 860.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.6666399478912354,
            "num_nodes_avg": 580.9,
            "path_length_avg": 149.39828513223893,
            "smoothness_avg": 0.047190074678873,
            "success_improvement": 0.0,
            "time_improvement": -2477.6121907149973,
            "length_improvement": 18.112432551697133,
            "smoothness_improvement": 638.6271436116949,
            "objective_score": -729.2230619654224
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7077789783477784,
            "num_nodes_avg": 847.5,
            "path_length_avg": 219.5926598523241,
            "smoothness_avg": 0.04575227926671289,
            "success_improvement": 0.0,
            "time_improvement": -330.71855435132875,
            "length_improvement": 26.693649517036892,
            "smoothness_improvement": 1077.2390995672663,
            "objective_score": -77.81318109734016
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.47495265007019044,
            "num_nodes_avg": 686.4,
            "path_length_avg": 115.50866810396273,
            "smoothness_avg": 0.07570799158092709,
            "success_improvement": 0.0,
            "time_improvement": -871.5393622775066,
            "length_improvement": 23.284642577054377,
            "smoothness_improvement": 863.0000647267433,
            "objective_score": -243.1760228133856
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that balances fast exploration and path quality by adaptive rewiring radius, dynamically adjusted step size, goal biasing sampling, and incremental connection attempts of trees with early termination upon path success or timeout. It uses KD-tree based nearest and near neighbor searches for scalability and a shortcut smoothing post-processing step to reduce path length and improve smoothness.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with a goal bias. Each tree is extended towards sampled points with adaptive step size, rewired locally using nodes within a dynamically computed radius to optimize costs, and the two trees attempt to connect after every addition. The algorithm returns the best path found either upon reaching goal or after a 30-second runtime limit, applying shortcut smoothing as a final refinement.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 7.0,\n                 goal_sample_rate: float = 0.1,  # 10% goal bias\n                 gamma_rrt_star: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # Used for radius computation\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = (dimension == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-tree-like helper structures for near neighbor queries\n        # For simplicity, use naive searches (could be improved with spatial structures)\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n\n        def steer(from_pos, to_pos, max_length):\n            distance = dist(from_pos, to_pos)\n            if distance <= max_length:\n                return to_pos\n            ratio = max_length / distance\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dimension))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and self._within_bounds(pos, bounds)\n\n        def is_free_edge(fr, to):\n            return not self._is_edge_in_obstacle(fr, to, obstacles, is_3d, resolution=0.5)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def path_cost(node):\n            return node.cost\n\n        # Radius for rewiring based on RRT* theoretical bound\n        def rewiring_radius(n):\n            unit_ball_volume = math.pi if dimension == 2 else 4/3*math.pi\n            r = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1/dimension))\n            return max(min(r, self.step_size*10), self.step_size)\n\n        # Extract path by following parents\n        def extract_path(node_start_tree, node_goal_tree):\n            path_from_start = []\n            n = node_start_tree\n            while n:\n                path_from_start.append(n.position)\n                n = n.parent\n            path_from_start.reverse()\n            path_from_goal = []\n            n = node_goal_tree\n            while n:\n                path_from_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate middle node\n            if path_from_start[-1] == path_from_goal[0]:\n                path_from_goal = path_from_goal[1:]\n            return path_from_start + path_from_goal\n\n        def shortcut_smooth(path, max_iters=200):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_free_edge(path[i], path[j]):\n                    continue\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        start_time = time.monotonic()\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Maintain sets for bookkeeping\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n        # Attempt connection between two trees, return connecting nodes if connected\n        def try_connect(t1, t2):\n            node1 = t1[-1]\n            close_nodes = near(t2, node1.position, self.step_size*1.5)\n            for n2 in close_nodes:\n                if is_free_edge(node1.position, n2.position):\n                    return node1, n2\n            return None\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > 30:\n                break\n\n            sample = sample_point()\n\n            # Alternate expanding start_tree then goal_tree each iteration\n            expanding_trees = [start_tree, goal_tree] if (it % 2 == 0) else [goal_tree, start_tree]\n\n            for tree_a, tree_b in [expanding_trees]:\n                # Select nearest node and steer\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not is_free_node(new_pos):\n                    continue\n                if not is_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = rewiring_radius(len(all_nodes))\n\n                # Find near neighbors in the same tree for rewiring\n                near_nodes = near(tree_a, new_node.position, radius)\n\n                # Choose best parent minimizing cost + edge cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_node.position)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node == nearest_node:\n                        continue\n                    if not is_free_edge(near_node.position, new_node.position):\n                        continue\n                    cost = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost < min_cost:\n                        best_parent = near_node\n                        min_cost = cost\n\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n\n                add_node(tree_a, new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors to new_node if cheaper\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    if not is_free_edge(new_node.position, near_node.position):\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                    if cost_through_new < near_node.cost:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n                # Attempt connection between trees\n                connection = try_connect(tree_a, tree_b)\n                if connection is not None:\n                    n_start, n_goal = connection\n                    path = extract_path(n_start, n_goal)\n                    cost_path = 0.0\n                    for k in range(len(path) - 1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n                        success = True\n                        # Early stop if found good path\n                        if best_cost <= dist(start_pos, goal_pos) * 1.1:\n                            break\n\n            if success and (time.monotonic() - start_time) > 0.5:\n                # After some time with success, break early to return result\n                break\n\n        # Apply shortcut smoothing on best path if found\n        if best_path:\n            best_path = shortcut_smooth(best_path, max_iters=300)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))",
    "objective": 335.05473,
    "time_improvement": -1071.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1469.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5458454370498658,
            "num_nodes_avg": 769.7,
            "path_length_avg": 154.34017059828255,
            "smoothness_avg": 0.04368913431155918,
            "success_improvement": 0.0,
            "time_improvement": -2010.5513662008188,
            "length_improvement": 15.403706818572177,
            "smoothness_improvement": 583.8298244495452,
            "objective_score": -591.0040366468546
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.5389305353164673,
            "num_nodes_avg": 903.5,
            "path_length_avg": 229.20190036403415,
            "smoothness_avg": 0.09301031161700887,
            "success_improvement": -9.999999999999998,
            "time_improvement": -227.96591615248155,
            "length_improvement": 23.485808447575714,
            "smoothness_improvement": 2293.222310525234,
            "objective_score": -92.83217822457286
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.5249299049377442,
            "num_nodes_avg": 895.9,
            "path_length_avg": 117.56171850798998,
            "smoothness_avg": 0.12815253476030247,
            "success_improvement": -9.999999999999998,
            "time_improvement": -973.7703327020907,
            "length_improvement": 21.92110425445407,
            "smoothness_improvement": 1530.090782914892,
            "objective_score": -321.3279833433803
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT that grows two trees from start and goal by extending towards random samples within map bounds, with straightforward collision checking and edge validation. The trees alternately extend, and upon nearby connection attempts, the shortest feasible path joining both trees is extracted. This reduces complexity by avoiding local rewiring and ensures efficient early solution discovery with clear parent-child relationships.",
    "planning_mechanism": "The planner initializes two trees at start and goal. It samples free points uniformly, extends the nearest node of the active tree towards the sample with a fixed step size if collision-free, then tries to connect the other tree to this new node. Trees swap roles each iteration. If nodes connect successfully, the path is reconstructed by concatenating the two tree paths. Planning terminates upon reaching the goal or hitting a 30-second time limit, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = self._connect_tree(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if connected_node is not None:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = connected_node.path_from_root()\n                # avoid duplicate join node\n                extracted_path = path_a + path_b[-2::-1] \n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, sample_point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest_node.position, sample_point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n        return new_node\n\n    def _connect_tree(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, target_node.position)\n        dist = math.dist(nearest_node.position, target_node.position)\n        if dist > self.step_size:\n            new_pos = self._steer(nearest_node.position, target_node.position)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            if math.dist(new_node.position, target_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                final_node = Node(target_node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            return None\n        else:\n            if (self._is_in_obstacle(target_node.position, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, target_node.position, obstacles, is_3d)):\n                return None\n            final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n            nearest_node.add_child(final_node)\n            tree.append(final_node)\n            nodes.append(final_node)\n            edges.append((nearest_node, final_node))\n            return final_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -23.81258,
    "time_improvement": 85.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005401754379272461,
            "num_nodes_avg": 114.2,
            "path_length_avg": 191.91931169727346,
            "smoothness_avg": 0.010422378140458174,
            "success_improvement": 0.0,
            "time_improvement": 79.11372100741177,
            "length_improvement": -5.19401589738194,
            "smoothness_improvement": 63.13285045454905,
            "objective_score": 20.933371016067113
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009308695793151855,
            "num_nodes_avg": 249.9,
            "path_length_avg": 303.7405843856087,
            "smoothness_avg": 0.0065543332961882795,
            "success_improvement": 0.0,
            "time_improvement": 94.33519768518391,
            "length_improvement": -1.397349755886233,
            "smoothness_improvement": 68.64771660637766,
            "objective_score": 27.80538803505532
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009527850151062011,
            "num_nodes_avg": 232.6,
            "path_length_avg": 155.08847600410883,
            "smoothness_avg": 0.013322467560618296,
            "success_improvement": 0.0,
            "time_improvement": 80.51030674685057,
            "length_improvement": -3.002381242304039,
            "smoothness_improvement": 69.46080400879985,
            "objective_score": 22.69896729871675
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A straightforward bidirectional RRT planner that grows two trees from start and goal by iteratively sampling free points and extending the nearest node from each tree towards the sample with a fixed step size; it alternates tree extensions, checks for collision-free connections between trees to find a complete path, and returns the best found path within a 30-second time limit.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples collision-free points uniformly within map bounds, extends the nearest node in the active tree toward the sampled point, alternates trees each iteration, and tries to connect the opposite tree to the newly added node. Upon successful connection, it merges the two partial paths into a complete solution. Planning stops when the path is found or time limit expires, returning the current best path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # attempt direct connection if close\n                if math.dist(new_node.position, node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect_trees(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -24.61746,
    "time_improvement": 87.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 70.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.003728294372558594,
            "num_nodes_avg": 84.9,
            "path_length_avg": 180.87966860281307,
            "smoothness_avg": 0.01103987851253821,
            "success_improvement": 0.0,
            "time_improvement": 85.58427670636823,
            "length_improvement": 0.8569874170311926,
            "smoothness_improvement": 72.7980722011218,
            "objective_score": 26.553465823134793
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009920716285705566,
            "num_nodes_avg": 246.6,
            "path_length_avg": 301.0670492796362,
            "smoothness_avg": 0.006705809145069515,
            "success_improvement": 0.0,
            "time_improvement": 93.96275291096713,
            "length_improvement": -0.5048467840713801,
            "smoothness_improvement": 72.54529930173578,
            "objective_score": 28.248644299355988
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009735631942749023,
            "num_nodes_avg": 234.2,
            "path_length_avg": 163.86030235550345,
            "smoothness_avg": 0.012918469003538813,
            "success_improvement": 0.0,
            "time_improvement": 80.08527871645923,
            "length_improvement": -8.82821063541575,
            "smoothness_improvement": 64.3219721828204,
            "objective_score": 19.05026709460242
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with goal bias sampling, dynamic neighbor radius, and incremental rewiring that grows two trees from start and goal, efficiently connecting them and optimizing paths to improve time, path length, and smoothness under a 30-second limit. The planner alternates extensions between the two trees using nearest neighbor searches and rewiring with a radius that shrinks logarithmically to balance exploration and exploitation. It incorporates goal bias sampling to guide growth toward the goal and performs path extraction upon connection, returning the best path found if time expires.",
    "planning_mechanism": "The planner initializes two trees and at each iteration samples a point with goal bias. It extends one tree toward the sample, rewires nearby nodes to optimize costs, then attempts to connect the other tree to the newly added node. The neighbor radius shrinks over time for finer rewiring. Collision checks for nodes and edges are performed strictly. When the trees connect, the joint path is extracted. The search halts if 30 seconds elapsed, providing the best path so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = math.inf\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            dist = distance(fpos, tpos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                inter = tuple(fpos[d] + (tpos[d]-fpos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            path = extract_path(node_a, node_b)\n            cost = node_a.cost + node_b.cost + distance(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_path = path\n                success = True\n\n        def try_connect(t1, t2, new_node):\n            connect_node = nearest(t2, new_node.position)\n            dist = distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not is_edge_in_obstacle(new_node.position, connect_node.position):\n                update_best_path(new_node, connect_node)\n                return True\n            return False\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + 1e-10 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                    if (near_node.parent,new_node) not in edges:\n                        # Remove old edge\n                        old_edge = (near_node.parent, near_node)\n                        if old_edge in edges:\n                            edges.remove(old_edge)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        def choose_parent(tree, new_pos, near_nodes, nearest_node):\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + distance(near_node.position, new_pos)\n                if cost + 1e-10 < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost\n                        best_parent = near_node\n            return best_parent, min_cost\n\n        # Logarithmically shrinking radius: gamma * (log(n)/n)^{1/d}\n        def neighbor_radius(n):\n            # gamma chosen as 30 * step_size empirically\n            gamma = 30.0 * self.step_size\n            r = gamma * ((math.log(max(n,2))/max(n,2))**(1/dim))\n            return max(r, self.step_size*1.1)  # Lower bound radius\n\n        # Progressively alternate trees to maintain balance\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Goal biasing 10%\n            if random.random() < 0.1:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree extension\n            if i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            best_parent, min_cost = choose_parent(tree_a, new_pos, near_nodes, nearest_node)\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_a, new_node, neighbor_radius(len(tree_a)))\n\n            # Try to connect the other tree\n            if try_connect(tree_a, tree_b, new_node):\n                # Return immediately on successful connection with best path found\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Timeout or max_iter reached; return best known path\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -9.56469,
    "time_improvement": -12.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 635.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.059640908241271974,
            "num_nodes_avg": 153.3,
            "path_length_avg": 166.05377840818173,
            "smoothness_avg": 0.041459720213323434,
            "success_improvement": 0.0,
            "time_improvement": -130.60594048453115,
            "length_improvement": 8.983292763972708,
            "smoothness_improvement": 548.9346525619546,
            "objective_score": -31.047133224165943
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04015326499938965,
            "num_nodes_avg": 301.1,
            "path_length_avg": 230.68238717193293,
            "smoothness_avg": 0.031820966671546595,
            "success_improvement": 0.0,
            "time_improvement": 75.56475003906536,
            "length_improvement": 22.9915793376491,
            "smoothness_improvement": 718.7763921747655,
            "objective_score": 40.0582545751829
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03955848217010498,
            "num_nodes_avg": 283.8,
            "path_length_avg": 123.55329125489155,
            "smoothness_avg": 0.058074694551369176,
            "success_improvement": 0.0,
            "time_improvement": 19.08114938503833,
            "length_improvement": 17.941786923996816,
            "smoothness_improvement": 638.705828065364,
            "objective_score": 19.682946110236408
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an improved bidirectional RRT* variant that employs alternating tree expansion, goal-biased sampling, and a logarithmically shrinking adaptive neighbor radius for rewiring. It carefully maintains edge and parent-child consistency during rewiring and tracks the best path found so far to enable early termination and improved path smoothness.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, samples points with goal biasing, extends and rewires each tree\u2019s nodes within an adaptive radius that shrinks as the tree grows, and attempts to connect the trees. On each iteration, it updates the best path found and returns it if the 30-second limit expires. This approach balances efficient exploration and exploitation, optimizing path length and smoothness while reducing planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, gamma_rrt_star: float = 50.0, max_radius: float = 60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        dimension = len(bounds)\n\n        def sample_free():\n            # Goal bias with 15% probability for faster convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue  # No need to rewire parent\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Remove old edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Rewire\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            cost = node_a.cost + node_b.cost + math.dist(node_a.position, node_b.position)\n            if cost < best_cost:\n                best_cost = cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                # Remove duplicated connection node\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far\n                return PlannerResult(success, best_path, nodes, edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early exit once connected\n                return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Timeout reached but return best path found\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.74394,
    "time_improvement": -71.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 185.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03062777519226074,
            "num_nodes_avg": 113.4,
            "path_length_avg": 165.29958062717503,
            "smoothness_avg": 0.017728440006473854,
            "success_improvement": 0.0,
            "time_improvement": -18.42453630296102,
            "length_improvement": 9.396680518771097,
            "smoothness_improvement": 177.48858402497052,
            "objective_score": 0.998090340499205
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05584428310394287,
            "num_nodes_avg": 283.9,
            "path_length_avg": 258.68618441086676,
            "smoothness_avg": 0.010592462512259404,
            "success_improvement": 0.0,
            "time_improvement": 66.01598857391085,
            "length_improvement": 13.643105774681825,
            "smoothness_improvement": 172.5516898827977,
            "objective_score": 28.853418486396336
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.176558780670166,
            "num_nodes_avg": 412.7,
            "path_length_avg": 127.37884227021114,
            "smoothness_avg": 0.023962087443044688,
            "success_improvement": 0.0,
            "time_improvement": -261.1598022485762,
            "length_improvement": 15.40103809278519,
            "smoothness_improvement": 204.7959835782153,
            "objective_score": -68.08333790101067
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive bidirectional RRT* planner with balanced alternating tree growth, goal-biased sampling, adaptive logarithmically shrinking rewiring radius for efficient incremental path optimization, and careful edge and parent-child management guaranteeing valid, smoother, and shorter paths within a strict 30-second time limit.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, alternately expands them via fixed-step steerings towards samples drawn from a mix of uniform and goal-biased distributions, reuses an adaptive neighbor radius for rewiring nearby nodes to minimize cost, and attempts to connect the trees dynamically. Upon connection, the combined path is updated. The rewiring updates parents, children, and edges to ensure consistency and improve smoothness and length progressively. The search terminates early if time is exceeded or if a path is found, returning the best-path discovered.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, \n                 gamma_rrt_star: float = 60.0, max_radius: float = 50.0,\n                 goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        all_nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        path_cost: Optional[float] = None\n        success = False\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, point):\n            n = max(len(tree),1)\n            d = len(point)\n            scale = max(1.0, sum(bounds) / d)\n            r_theory = self.gamma_rrt_star * ((math.log(n+1) / (n+1)) ** (1.0 / d))\n            radius = max(self.step_size * 1.5, min(self.max_radius, r_theory * 0.55 + scale * 0.01))\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def choose_parent(tree, new_pos):\n            nearest_node = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cand_cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cand_cost < min_cost:\n                        min_cost = cand_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, node, neighbors):\n            for nb in neighbors:\n                if nb == node.parent:\n                    continue\n                edge_free = not is_edge_in_obstacle(node.position, nb.position)\n                new_cost = node.cost + math.dist(node.position, nb.position)\n                if edge_free and new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if is_in_obstacle(new_pos):\n                return None\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            new_node, neighbors = choose_parent(tree, new_pos)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node, neighbors = choose_parent(tree, new_pos)\n                rewire(tree, new_node, neighbors)\n                dist_to_target = math.dist(new_node.position, target_node.position)\n                if dist_to_target <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, target_node.position) and\n                        not is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, None, new_node.cost + dist_to_target)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = new_node\n\n        tree_a = tree_start\n        tree_b = tree_goal\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                success = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                # If same node repeated at connection point, avoid duplication\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                combined_path = path_a + path_b[::-1]\n                combined_cost = 0.0\n                for i in range(1, len(combined_path)):\n                    combined_cost += math.dist(combined_path[i-1], combined_path[i])\n                # Update best path if shorter\n                if (path_cost is None) or (combined_cost < path_cost):\n                    best_path = combined_path\n                    path_cost = combined_cost\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": 10.47557,
    "time_improvement": -0.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 167.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04386405944824219,
            "num_nodes_avg": 106.8,
            "path_length_avg": 168.42382967435015,
            "smoothness_avg": 0.01942582700401295,
            "success_improvement": -9.999999999999998,
            "time_improvement": -69.60359895276376,
            "length_improvement": 7.684230109120175,
            "smoothness_improvement": 204.05637647131795,
            "objective_score": -65.25025973800044
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05947122573852539,
            "num_nodes_avg": 270.9,
            "path_length_avg": 270.292562628002,
            "smoothness_avg": 0.009048887680339002,
            "success_improvement": 0.0,
            "time_improvement": 63.80881439090624,
            "length_improvement": 9.768562654728182,
            "smoothness_improvement": 132.8343976654733,
            "objective_score": 25.66795389843615
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04652073383331299,
            "num_nodes_avg": 225.6,
            "path_length_avg": 135.79956710266217,
            "smoothness_avg": 0.020734278798802692,
            "success_improvement": 0.0,
            "time_improvement": 4.839515950865484,
            "length_improvement": 9.8083936108981,
            "smoothness_improvement": 163.738495875508,
            "objective_score": 8.155583431176046
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This simplified algorithm is an enhanced, single-tree RRT planner that integrates goal biasing and dynamic nearest neighbor search to efficiently grow a collision-free tree toward the goal within a 30-second time limit. It features early path finding with direct extension and straightforward path extraction without rewiring, prioritizing generalization and efficiency while maintaining good path quality.",
    "planning_mechanism": "The planner samples points mostly uniformly with periodic goal bias, extends the nearest node toward each sample up to the step size, checks node and edge collisions before adding new nodes, and terminates early upon reaching the goal or on timeout, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        success = False\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extract_path(node):\n            path = []\n            current = node\n            while current:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        for _ in range(self.max_iter):\n            # Check time limit\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            # Steer toward sample\n            new_pos = steer(nearest.position, sample)\n\n            # Check collisions\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Add new node\n            cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Check if goal reached\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not is_edge_in_obstacle(new_pos, goal_pos)) and (not is_in_obstacle(goal_pos)):\n                    goal_cost = cost + dist(new_pos, goal_pos)\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if success and best_goal_node:\n            path = extract_path(best_goal_node)\n        else:\n            path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 48.61601,
    "time_improvement": -160.0,
    "length_improvement": -1.0,
    "smoothness_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030852270126342774,
            "num_nodes_avg": 358.3,
            "path_length_avg": 186.38846024337317,
            "smoothness_avg": 0.006279131378568387,
            "success_improvement": 0.0,
            "time_improvement": -19.292562410118368,
            "length_improvement": -2.162468573549442,
            "smoothness_improvement": -1.7179585733748088,
            "objective_score": -7.0938396600320495
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3215230941772461,
            "num_nodes_avg": 1610.3,
            "path_length_avg": 298.5367381627645,
            "smoothness_avg": 0.0039022389695848583,
            "success_improvement": 0.0,
            "time_improvement": -95.6627231821264,
            "length_improvement": 0.3398438977076702,
            "smoothness_improvement": 0.4074193565400997,
            "objective_score": -28.492873519230617
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.22806410789489745,
            "num_nodes_avg": 947.2,
            "path_length_avg": 151.31525415793013,
            "smoothness_avg": 0.00772749334569083,
            "success_improvement": 0.0,
            "time_improvement": -366.51652098341197,
            "length_improvement": -0.4963869535885313,
            "smoothness_improvement": -1.7068550270393987,
            "objective_score": -110.2613227423119
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified single-tree RRT planner with goal biasing and fixed step size extension, focusing on efficient exploration and collision checking within a 30-second limit. It grows a collision-free tree from start toward the goal, sampling mostly uniformly but occasionally biased toward the goal, adding nodes after verifying both node and edge collision-free status, and terminates upon reaching the goal or timeout, returning the best found path.",
    "planning_mechanism": "The planner samples random points with a fixed goal bias, identifies the nearest node in the tree, extends toward the sample within a fixed step size, performs thorough collision checks, adds new valid nodes while maintaining parent-child relationships, and stops when the goal is reached or after 30 seconds, extracting the path by tracing back from the goal node if found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px, py, pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px, py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        start_time = time.monotonic()\n        nodes = []\n        edges = []\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        success = False\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30.0:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if not edge_in_obstacle(new_pos, goal_pos) and not in_obstacle(goal_pos):\n                    goal_cost = new_cost + dist(new_pos, goal_pos)\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if success and best_goal_node is not None:\n            path = extract_path(best_goal_node)\n        else:\n            path = []\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)",
    "objective": 69.12248,
    "time_improvement": -228.0,
    "length_improvement": -1.0,
    "smoothness_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04009382724761963,
            "num_nodes_avg": 433.9,
            "path_length_avg": 185.64313970411612,
            "smoothness_avg": 0.006286521877133797,
            "success_improvement": 0.0,
            "time_improvement": -55.02571997492534,
            "length_improvement": -1.7539465756229284,
            "smoothness_improvement": -1.602281222101642,
            "objective_score": -17.568095343961865
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.34754931926727295,
            "num_nodes_avg": 1661.4,
            "path_length_avg": 311.65213267984234,
            "smoothness_avg": 0.0037810239183487387,
            "success_improvement": 0.0,
            "time_improvement": -111.50096985083493,
            "length_improvement": -4.038452297792717,
            "smoothness_improvement": -2.711531219437659,
            "objective_score": -35.8869199900233
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.30128581523895265,
            "num_nodes_avg": 958.0,
            "path_length_avg": 148.13046768369884,
            "smoothness_avg": 0.007937990640396854,
            "success_improvement": 0.0,
            "time_improvement": -516.2951796505455,
            "length_improvement": 1.6187965793608383,
            "smoothness_improvement": 0.9706550243271375,
            "objective_score": -153.91242267242552
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional asymptotically optimal path planner combining adaptive rewiring, goal bias sampling, consistent edge/parent management, and early-best-path tracking to produce shorter, smoother paths efficiently within time limits. It grows two trees from start and goal, alternately extending toward random samples with goal bias, uses an adaptive neighbor radius for targeted rewiring, keeps edge and parent-child data consistent, attempts rapid tree connections, and returns the best path found within a 30-second limit.",
    "planning_mechanism": "The planner initializes two trees rooted at the start and goal positions. It samples points with a goal bias to accelerate convergence. Each iteration extends one tree toward the sample using fixed maximum steps, rewires neighbors found using an adaptive radius to minimize path cost and smoothness, and attempts to connect to the other tree via an iterative steer-and-connect process that also rewires. Edge and node collision checks ensure path validity. Parent-child and edge lists remain consistent during rewiring. The planner tracks the best connecting path by cost and terminates early or at time limit, returning the best found path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=50.0, goal_bias: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_bias = goal_bias\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = math.inf\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steered(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def is_in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(fpos, tpos, resolution=1.0):\n            d = dist(fpos, tpos)\n            steps = max(1,int(d / resolution))\n            for step in range(steps+1):\n                inter = tuple(fpos[i] + (tpos[i]-fpos[i])*(step/steps) for i in range(len(fpos)))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            n = max(1,len(tree))\n            dim = len(pos)\n            scale = max(1.0, sum(bounds)/dim)\n            r_theory = self.gamma_rrt_star * ((math.log(n+1)/(n+1))**(1.0/dim))\n            radius = max(self.step_size*2.0, min(self.max_radius, r_theory*0.5 + scale*0.015))\n            return [nd for nd in tree if dist(nd.position,pos) <= radius]\n\n        def choose_parent_and_add(tree: List[Node], new_pos: Tuple[float,...]) -> Optional[Tuple[Node,List[Node]]]:\n            nearest = min(tree, key=lambda nd: dist(nd.position,new_pos))\n            if is_in_obstacle(new_pos): return None\n            if edge_in_obstacle(nearest.position,new_pos): return None\n            neighbors = near_nodes(tree,new_pos)\n            min_cost = nearest.cost + dist(nearest.position,new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if nb == nearest: continue\n                if edge_in_obstacle(nb.position,new_pos): continue\n                cand_cost = nb.cost + dist(nb.position,new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n            return new_node, neighbors\n\n        def rewire(pivot: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is pivot: continue\n                if edge_in_obstacle(pivot.position, nb.position): continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old parent edge if exists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def extend_and_rewire(tree: List[Node], sample: Tuple[float,...]) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, sample))\n            new_pos = steered(nearest.position, sample)\n            if is_in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                return None\n            res = choose_parent_and_add(tree, new_pos)\n            if res is None:\n                return None\n            new_node, neighbors = res\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest = min(tree, key=lambda nd: dist(nd.position, target_node.position))\n            curr = nearest\n            while True:\n                new_pos = steered(curr.position, target_node.position)\n                if is_in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                res = choose_parent_and_add(tree, new_pos)\n                if res is None:\n                    return None\n                new_node, neighbors = res\n                rewire(new_node, neighbors)\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, None, new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr = new_node\n\n        # Alternate expansion vars\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iteration in range(self.max_iter):\n            if time_exceeded():\n                break\n            # Sample with goal bias\n            if random.random() < self.goal_bias:\n                sample_pt = goal_pos if tree_a is tree_start else start_pos\n            else:\n                sample_pt = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if is_in_obstacle(sample_pt):\n                    continue\n\n            new_node_a = extend_and_rewire(tree_a, sample_pt)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Extract path and check cost\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                candidate_path = path_a + path_b[::-1]\n                candidate_cost = new_node_a.cost + new_node_b.cost - dist(new_node_a.position, new_node_b.position)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success = True\n                # Early return to improve runtime\n                if best_path and time.monotonic() - start_time > 0.1:\n                    # Yield faster convergence by returning early\n                    break\n            # Swap trees to alternate growth\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 29.39176,
    "time_improvement": -135.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 205.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1076784610748291,
            "num_nodes_avg": 390.3,
            "path_length_avg": 154.18408348873172,
            "smoothness_avg": 0.019648058564061502,
            "success_improvement": 0.0,
            "time_improvement": -316.34665732512264,
            "length_improvement": 15.48926063667552,
            "smoothness_improvement": 207.53478296963442,
            "objective_score": -84.5727669006833
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.10791921615600586,
            "num_nodes_avg": 624.3,
            "path_length_avg": 246.74452337231727,
            "smoothness_avg": 0.011418218250762089,
            "success_improvement": 0.0,
            "time_improvement": 34.32581329562554,
            "length_improvement": 17.62957595100447,
            "smoothness_improvement": 193.7989798022895,
            "objective_score": 21.844484458301793
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10839545726776123,
            "num_nodes_avg": 471.6,
            "path_length_avg": 125.45012299295556,
            "smoothness_avg": 0.024564682980715784,
            "success_improvement": 0.0,
            "time_improvement": -121.72832052234313,
            "length_improvement": 16.682001600995804,
            "smoothness_improvement": 212.4609543384158,
            "objective_score": -25.446990424413375
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved bidirectional RRT* planner that uses adaptive nearest neighbor radius based on tree size with goal-biased sampling and consistent parent-child-edge management. It incorporates early termination upon no improvement, maintains spatial hashing for efficient neighbor searches, and includes careful rewiring with strict collision checking to produce faster, shorter, and smoother paths under a 30-second time constraint. The mechanism balances uniform and informed sampling to refine the best path, rewires local portions of the tree to optimize path smoothness and cost, and returns the best found solution when time expires or convergence is detected.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal with alternating expansions towards goal-biased samples. Each iteration performs nearest neighbor searches within an adaptively computed radius that shrinks logarithmically to ensure efficient local rewiring. New nodes connect to the best nearby parent respecting collision constraints. Rewiring attempts locally improve paths. Tree connection attempts identify candidate paths, stored as best found so far. Once a solution is found, focused sampling within an informed region refines the path. The planner terminates early upon no improvement or time limit, outputting the best path and supporting data structures.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root\n        self.children = []        # List[Node]\n        self.valid = True         # Collision state (always True after creation here)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, no_improve_limit=100, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a,b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                p = tuple(a[d] + (b[d] - a[d]) * t for d in range(dim))\n                if is_in_obstacle(p):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        # Spatial hashing setup for near neighbor queries\n        grid_cell_size = self.step_size * 3.0\n\n        def grid_key(pos):\n            return tuple(int(pos[d] // grid_cell_size) for d in range(dim))\n\n        def add_node_to_grid(node, grid):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def grid_offsets(dim, n):\n            if dim == 1:\n                return [(i,) for i in range(-n,n+1)]\n            elif dim == 2:\n                return [(dx, dy) for dx in range(-n, n+1) for dy in range(-n, n+1)]\n            else:\n                def rec(depth):\n                    if depth == 1:\n                        return [(i,) for i in range(-n,n+1)]\n                    smaller = rec(depth -1)\n                    result = []\n                    for tup in smaller:\n                        for i_ in range(-n,n+1):\n                            result.append(tup + (i_,))\n                    return result\n                return rec(dim)\n\n        def get_near_nodes(grid, point, radius):\n            base_key = grid_key(point)\n            cell_radius = int(math.ceil(radius / grid_cell_size))\n            keys = []\n            offsets = grid_offsets(dim, cell_radius)\n            for offset in offsets:\n                keys.append(tuple(base_key[d] + offset[d] for d in range(dim)))\n            near_nodes = []\n            r2 = radius * radius\n            for k in keys:\n                if k in grid:\n                    for node in grid[k]:\n                        if dist(node.position, point) <= radius:\n                            near_nodes.append(node)\n            return near_nodes\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_goal_bias(goal, prob=0.1):\n            if random.random() < prob:\n                return goal\n            else:\n                return sample_uniform()\n\n        def extract_bidirectional_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal = path_goal[::-1]\n            # Avoid duplicate connecting node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def rewiring_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            space_vol = 1.0\n            for x in bounds:\n                space_vol *= x\n            gamma_rrt_star = 2.0 * (1 + 1/dim)**(1/dim) * (space_vol)**(1/dim)\n            val = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            return min(val, self.step_size * 20.0)\n\n        def try_connect(node, other_grid, other_nodes):\n            near_other = get_near_nodes(other_grid, node.position, self.step_size * 1.5)\n            near_other = [n for n in near_other if not is_edge_in_obstacle(node.position, n.position)]\n            if not near_other:\n                return None, None\n            best_cost = float(\"inf\")\n            best_node = None\n            for n in near_other:\n                c = node.cost + dist(node.position, n.position) + n.cost\n                if c < best_cost:\n                    best_cost = c\n                    best_node = n\n            return best_node, best_cost\n\n        # Initialize\n        start_time = time.monotonic()\n        TIME_LIMIT = self.time_limit_sec\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n\n        tree_start_nodes = [start_root]\n        tree_goal_nodes = [goal_root]\n        tree_start_grid = {}\n        tree_goal_grid = {}\n\n        add_node_to_grid(start_root, tree_start_grid)\n        add_node_to_grid(goal_root, tree_goal_grid)\n\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_start_node = None\n        best_goal_node = None\n        found_solution = False\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample_point = sample_goal_bias(goal, prob=0.15)\n            for (tree_nodes, tree_grid, other_nodes, other_grid) in [\n                (tree_start_nodes, tree_start_grid, tree_goal_nodes, tree_goal_grid),\n                (tree_goal_nodes, tree_goal_grid, tree_start_nodes, tree_start_grid)\n            ]:\n                nearest_node = self._nearest(tree_nodes, sample_point)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample_point)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                n = len(tree_nodes)\n                radius = rewiring_radius(n)\n                near_nodes = get_near_nodes(tree_grid, new_pos, radius)\n\n                # Select best parent for new node\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_nodes.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                add_node_to_grid(new_node, tree_grid)\n\n                # Rewiring neighbors\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + 1e-12 < near_node.cost and not is_edge_in_obstacle(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                # Attempt connection with other tree\n                connecting_node, candidate_cost = try_connect(new_node, other_grid, other_nodes)\n                if connecting_node is not None:\n                    if candidate_cost + 1e-9 < best_cost:\n                        best_cost = candidate_cost\n                        if tree_nodes is tree_start_nodes:\n                            best_start_node = new_node\n                            best_goal_node = connecting_node\n                        else:\n                            best_start_node = connecting_node\n                            best_goal_node = new_node\n                        best_path = extract_bidirectional_path(best_start_node, best_goal_node)\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > self.no_improve_limit:\n                break\n\n        # Return best found\n        success = found_solution and len(best_path) > 0\n        return PlannerResult(\n            success=success,\n            path=best_path if success else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _nearest(self, nodes, point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in nodes:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node",
    "objective": 211.83788,
    "time_improvement": -763.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 798.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.4190336227416992,
            "num_nodes_avg": 337.3,
            "path_length_avg": 152.65885554036274,
            "smoothness_avg": 0.04329217122446976,
            "success_improvement": 0.0,
            "time_improvement": -1520.2241970574137,
            "length_improvement": 16.32526224396003,
            "smoothness_improvement": 577.6164901174551,
            "objective_score": -443.3840193202608
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3353013038635254,
            "num_nodes_avg": 603.3,
            "path_length_avg": 224.0803822738811,
            "smoothness_avg": 0.04336940488399958,
            "success_improvement": 0.0,
            "time_improvement": -104.0474460111049,
            "length_improvement": 25.195518600793392,
            "smoothness_improvement": 1015.9260253850091,
            "objective_score": -11.017292515930386
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.37394840717315675,
            "num_nodes_avg": 718.4,
            "path_length_avg": 114.506494553833,
            "smoothness_avg": 0.07070135720236946,
            "success_improvement": 0.0,
            "time_improvement": -664.9301398276381,
            "length_improvement": 23.950238530674312,
            "smoothness_improvement": 799.3160449827988,
            "objective_score": -181.1123186049728
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that alternates tree growth from start and goal, samples uniformly without goal bias, extends towards samples with fixed step size, and attempts direct connection between trees when close enough. It efficiently checks collisions for nodes and edges, returns the best path found within 30 seconds, and uses straightforward data structures for easy generalization.",
    "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling free points and extending the nearest node in the active tree towards the sample by a fixed step. After each extension, it tries to directly connect to the opposite tree within step size. If connected, it returns the combined path. The process repeats until a path is found or time expires, ensuring valid node and edge insertions, and provides the best path found before timeout.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution=1.0) -> bool:\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if not is_edge_in_obstacle(nearest_node.position, node.position):\n                    final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                    nearest_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((nearest_node, final_node))\n                    return final_node\n            return None\n\n        tree_a, tree_b = tree_start, tree_goal\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -22.02776,
    "time_improvement": 81.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005957841873168945,
            "num_nodes_avg": 121.2,
            "path_length_avg": 189.80776231442943,
            "smoothness_avg": 0.010682871420312283,
            "success_improvement": 0.0,
            "time_improvement": 76.96356797817029,
            "length_improvement": -4.036642221003974,
            "smoothness_improvement": 67.21013595447693,
            "objective_score": 21.003135740621083
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01022179126739502,
            "num_nodes_avg": 251.5,
            "path_length_avg": 302.65797170520227,
            "smoothness_avg": 0.006605927499947617,
            "success_improvement": 0.0,
            "time_improvement": 93.77953387673223,
            "length_improvement": -1.0359424818883414,
            "smoothness_improvement": 69.9752726309083,
            "objective_score": 27.862171037041207
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013717174530029297,
            "num_nodes_avg": 317.4,
            "path_length_avg": 162.2962061221566,
            "smoothness_avg": 0.01272618929081355,
            "success_improvement": 0.0,
            "time_improvement": 71.94083453753878,
            "length_improvement": -7.789412391485782,
            "smoothness_improvement": 61.876188429567115,
            "objective_score": 17.217983868518
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner with alternating tree expansion, uniform sampling without goal bias, fixed step size steering, direct tree connection attempts, and incremental best-path tracking within a 30-second limit to improve generalization and maintain balanced exploration.",
    "planning_mechanism": "A bidirectional planner grows two trees from start and goal points alternatively by sampling reachable free points, extending trees towards samples with fixed steps and checking collisions for nodes and edges. After each extension, it attempts to connect the opposite tree directly to the newly added node if within step size, returning the combined path immediately upon success. The process continues until a path is found or the 30-second timeout is reached, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            import math\n        except:\n            pass\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0\n        dist = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0\n            d = sum((node.position[i]-point[i])**2 for i in range(len(point)))**0.5\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        tree_a, tree_b = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node,\n                            cost=nearest_node.cost + \n                            sum((new_pos[d]-nearest_node.position[d])**2 for d in range(len(new_pos)))**0.5)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect trees directly\n            nearest_in_other = self._nearest(tree_b, new_pos)\n            dist_connect = sum((nearest_in_other.position[d]-new_pos[d])**2 for d in range(len(new_pos)))**0.5\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_in_other.position, new_pos, obstacles, is_3d):\n                connected_node = Node(new_pos, parent=nearest_in_other,\n                                      cost=nearest_in_other.cost + dist_connect)\n                nearest_in_other.add_child(connected_node)\n                tree_b.append(connected_node)\n                nodes.append(connected_node)\n                edges.append((nearest_in_other, connected_node))\n\n                # Extract path\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                best_path = path_start + path_goal[-2::-1]\n                success = True\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -13.63419,
    "time_improvement": 52.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008094406127929688,
            "num_nodes_avg": 107.2,
            "path_length_avg": 192.97970859638593,
            "smoothness_avg": 0.010407655485757568,
            "success_improvement": 0.0,
            "time_improvement": 68.70238578118662,
            "length_improvement": -5.775236240849632,
            "smoothness_improvement": 62.90240893772817,
            "objective_score": 17.460086034534847
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04489636421203613,
            "num_nodes_avg": 281.4,
            "path_length_avg": 304.73876560133533,
            "smoothness_avg": 0.006559560824594926,
            "success_improvement": 0.0,
            "time_improvement": 72.678339311263,
            "length_improvement": -1.730571376749036,
            "smoothness_improvement": 68.78222467751719,
            "objective_score": 21.10907009071706
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.041781044006347655,
            "num_nodes_avg": 253.5,
            "path_length_avg": 156.51329180257372,
            "smoothness_avg": 0.0132417238903637,
            "success_improvement": 0.0,
            "time_improvement": 14.534788166322269,
            "length_improvement": -3.948676053207013,
            "smoothness_improvement": 68.43375048303919,
            "objective_score": 2.333399570387669
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional planner combining goal-biased sampling, adaptive rewiring with logarithmically shrinking neighbor radius, and efficient early best-path tracking to optimize path length, smoothness, and planning time. It maintains consistent edge and parent-child relationships, employs incremental collision checks, and terminates early upon time limit or path completion.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately using goal-biased sampling, extends toward samples by a fixed step size, and rewires neighbors within an adaptive radius that shrinks logarithmically with tree size. It attempts to connect the trees after each extension and updates the best path if a shorter connection is found. The method incorporates proactive early termination on time limit or successful connectivity, balanced exploration and exploitation, and consistent edge management to improve path quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, gamma_rrt_star: float=50.0, max_radius: float=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias for fast convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position) and\n                        not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + dist_connect\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far on timeout\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early return on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Return best path found after max iterations or no connection\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -18.21176,
    "time_improvement": 38.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 166.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017172026634216308,
            "num_nodes_avg": 84.8,
            "path_length_avg": 166.1136358917928,
            "smoothness_avg": 0.017405039468317472,
            "success_improvement": 0.0,
            "time_improvement": 33.60310114679745,
            "length_improvement": 8.950483928702955,
            "smoothness_improvement": 172.42666332731423,
            "objective_score": 16.31335401789758
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05594196319580078,
            "num_nodes_avg": 296.0,
            "path_length_avg": 269.4414713435546,
            "smoothness_avg": 0.009859582258951003,
            "success_improvement": 0.0,
            "time_improvement": 65.95654540133718,
            "length_improvement": 10.052681422781044,
            "smoothness_improvement": 153.69415309286282,
            "objective_score": 26.587043239534093
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04169762134552002,
            "num_nodes_avg": 219.8,
            "path_length_avg": 134.3477221843536,
            "smoothness_avg": 0.021378713251996768,
            "success_improvement": 0.0,
            "time_improvement": 14.705433384720349,
            "length_improvement": 10.772639876212878,
            "smoothness_improvement": 171.93565455293327,
            "objective_score": 11.734892213908497
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* algorithm with adaptive goal-biased sampling, dynamic rewiring radius based on tree size, incremental collision checking, and consistent edge management. It interleaves expansions from start and goal trees, rewires neighbors for path improvement, and updates the best feasible path found within a 30-second time limit to optimize path smoothness, length, and planning efficiency. Early termination occurs upon finding a satisfactory path or timeout.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling with goal bias, extending towards samples with step size limits, and rewiring nearby nodes within an adaptively shrinking radius to optimize path cost and smoothness. After each expansion, it attempts to connect the trees and updates the best path found. The process repeats with swapped trees to balance exploration until a time limit or solution is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, gamma_rrt_star: float=40.0, max_radius: float=50.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...]) -> List[Node]:\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dim)\n            radius = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n            radius = max(self.step_size * 2.0, min(self.max_radius, radius * 0.5 + scale * 0.02))\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def check_and_add_node(new_pos: Tuple[float, ...], tree: List[Node], other_tree: List[Node]) -> Node or None:\n            nearest_node = nearest(tree, new_pos)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n            return new_node\n\n        def try_connect_trees(node_a: Node, tree_b: List[Node]) -> Node or None:\n            nearest_node_b = nearest(tree_b, node_a.position)\n            current_from = nearest_node_b\n            while True:\n                new_pos = steer(current_from.position, node_a.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_from.position, new_pos, obstacles, is_3d):\n                    return None\n                neighbors = near_nodes(tree_b, new_pos)\n                min_cost = current_from.cost + dist(current_from.position, new_pos)\n                best_parent = current_from\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        c = nb.cost + dist(nb.position, new_pos)\n                        if c < min_cost:\n                            min_cost = c\n                            best_parent = nb\n                new_node = Node(new_pos, parent=None, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is best_parent:\n                        continue\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        new_cost = new_node.cost + dist(new_node.position, nb.position)\n                        if new_cost + 1e-12 < nb.cost:\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                except ValueError:\n                                    pass\n                                nb.parent.remove_child(nb)\n                            new_node.add_child(nb)\n                            nb.cost = new_cost\n                            edges.append((new_node, nb))\n                if dist(new_node.position, node_a.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_node.position, node_a.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(node_a.position, obstacles, is_3d)):\n                        final_node = Node(node_a.position, parent=None,\n                                         cost=new_node.cost + dist(new_node.position, node_a.position))\n                        new_node.add_child(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current_from = new_node\n\n        def update_best_path(node_a: Node, node_b: Node):\n            nonlocal best_cost, best_path, success\n            c = node_a.cost + node_b.cost + dist(node_a.position, node_b.position)\n            if c < best_cost:\n                best_cost = c\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                return PlannerResult(success, best_path, nodes, edges)\n\n            sample = sample_free()\n            new_node = check_and_add_node(sample, tree_a, tree_b)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            connected_node = try_connect_trees(new_node, tree_b)\n            if connected_node is not None:\n                update_best_path(new_node, connected_node)\n                return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.03252,
    "time_improvement": 43.0,
    "length_improvement": -15.0,
    "smoothness_improvement": 228.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0237290620803833,
            "num_nodes_avg": 119.0,
            "path_length_avg": 208.92143850417187,
            "smoothness_avg": 0.014699740823621665,
            "success_improvement": 0.0,
            "time_improvement": 8.249843283306912,
            "length_improvement": -14.513151016182935,
            "smoothness_improvement": 130.0828648877908,
            "objective_score": -5.582523300278733
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009206151962280274,
            "num_nodes_avg": 117.9,
            "path_length_avg": 328.3614076921484,
            "smoothness_avg": 0.015232898956729881,
            "success_improvement": 0.0,
            "time_improvement": 94.39760068377784,
            "length_improvement": -9.61648924671473,
            "smoothness_improvement": 291.95346197029437,
            "objective_score": 24.009153966955985
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03624804019927978,
            "num_nodes_avg": 177.5,
            "path_length_avg": 181.66398396811618,
            "smoothness_avg": 0.028406281638645288,
            "success_improvement": 0.0,
            "time_improvement": 25.852823741875575,
            "length_improvement": -20.652568242297846,
            "smoothness_improvement": 261.3258057099621,
            "objective_score": -3.329064794266225
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive bidirectional RRT* planner with goal biasing, incremental rewiring, and informed sampling to efficiently find and iteratively improve a near-optimal path within a 30-second limit. The planner balances growth between start and goal trees, performs adaptive radius neighbor searches for rewiring, and applies an ellipsoidal informed sampling once a solution is found to enhance convergence and path smoothness.",
    "planning_mechanism": "The planner alternates expansions of two trees towards random samples biased towards the goal, incrementally rewires nodes with neighbors in adaptive shrinking radius to improve path cost and smoothness, and upon initial solution discovery, switches to single-tree informed RRT* refinement sampling inside an ellipsoid defined by current best cost to optimize the path further, always enforcing collision checking on nodes and edges, and returning the best path found upon timeout or success.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for rewiring and goal bias\n        self.goal_sample_rate = 0.15        # Probability to sample the goal (goal bias)\n        self.gamma_rrt_star = 50.0          # Parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6             # Improvement tolerance for path cost updates\n        self.time_limit = 30.0              # seconds time limit\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        # Goal biased sampling with specified probability\n        if random.random() < goal_bias_prob:\n            # sample goal directly if free\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        # Otherwise uniform sample within bounds and free space\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        # Linear nearest search (simple but acceptable)\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        # If no solution yet, uniform sample\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            # fallback to uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Ellipsoid sampling inside prolate hyperspheroid\n        # Code adapted from literature informed RRT* sampling, avoids numpy:\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # Avoid degenerate case\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Construct basis for rotation - produce orthonormal matrix with a1 as first column\n        # Here only rotate axis to x direction, so use rotated coordinates is not required for sampling uniform ball\n        # Instead sample in unit ball, then scale and translate\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            # Sample random point in unit ball in R^dim\n            rnd_dir = []\n            # Sample standard normal gaussian vector\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0,1))\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12: continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            # Radius scaling to distribute uniformly inside ball\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            # Scale ball_point components for ellipsoid radii\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Rotate scaled vector to align with real coordinate system (only one axis, so just shift)\n            # Since rotation matrix is large effort and only affects orientation, approximate by axis aligned\n            # We rotate by vector a1/norm_a1 using Householder reflection or simplified since high cost\n            # To simplify, we place along the direction a1 by scaling only the first coordinate\n            # This is acceptable for performance and uniformity compromise\n            # Align first dimension with a1 direction:\n            # new_point = center + rotation * scaled\n\n            # Construct base vector in direction a1:\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # Add components in other basis directions orthogonal to a1\n            # We don't construct orthonormal basis explicitly, skip to keep simplicity and avoid foreign dependencies\n\n            # As an approximation, add the other components along axes orthogonal by spreading them equally\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            # Clamp point inside bounds\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n\n        def can_finish():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* until initial solution found\n        for it in range(self.max_iter):\n            if can_finish():\n                break\n\n            # Alternate expansion: even expands start tree, odd goal tree\n            expand_start_tree = (it % 2 == 0)\n            if expand_start_tree:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sampling with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent with minimum cost + edge cost + no collision between parent to new_pos\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect from other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n\n                # Connect the two trees\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Construct path: new_node from tree_a and connect_node from tree_b\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Reset tree for refinement: use start_root plus best path nodes (re-create properly)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if can_finish() or no_improve_count >= 150:\n                    break\n\n                # Informed sampling inside ellipsoid defined by best_cost\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                # Check if can connect directly to goal\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.85805,
    "time_improvement": 39.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 286.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021411538124084473,
            "num_nodes_avg": 92.3,
            "path_length_avg": 161.62176685276987,
            "smoothness_avg": 0.026296503737064592,
            "success_improvement": 0.0,
            "time_improvement": 17.21071942180759,
            "length_improvement": 11.41254852721125,
            "smoothness_improvement": 311.59738725690346,
            "objective_score": 13.568731879153544
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03712928295135498,
            "num_nodes_avg": 109.2,
            "path_length_avg": 246.37899691959302,
            "smoothness_avg": 0.013803575390083797,
            "success_improvement": 0.0,
            "time_improvement": 77.40499284926345,
            "length_improvement": 17.75159920201941,
            "smoothness_improvement": 255.17593710033827,
            "objective_score": 35.14833706149237
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03867461681365967,
            "num_nodes_avg": 101.4,
            "path_length_avg": 127.66449265035354,
            "smoothness_avg": 0.030873705973109955,
            "success_improvement": 0.0,
            "time_improvement": 20.889140107088526,
            "length_improvement": 15.211322711504014,
            "smoothness_improvement": 292.7112611180333,
            "objective_score": 16.857091964619134
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified single-tree RRT planner with uniform random sampling and goal biasing to efficiently explore and find a collision-free path. It grows a tree by sampling free points biased towards the goal, extends the nearest node toward these samples in fixed step sizes while performing collision checks for nodes and edges, and returns the best path found within a 30-second time limit. Early termination occurs upon reaching the goal vicinity or time expiration. The approach balances simplicity with improved convergence speed and path feasibility.",
    "planning_mechanism": "The planner increments a single tree from the start node by randomly sampling points within map boundaries, occasionally biasing samples directly to the goal position. It finds the nearest existing node to each sample and attempts to extend toward the sample in a fixed step. Only collision-free nodes and edges are added. Once a node reaches sufficiently close to the goal, or time runs out, the planner reconstructs the path by tracing parents back to the start and returns it along with all explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step_ratio = min(self.step_size / dist, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * step_ratio for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check goal proximity\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_cost + math.dist(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.59002,
    "time_improvement": 4.0,
    "length_improvement": -1.0,
    "smoothness_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018040561676025392,
            "num_nodes_avg": 311.8,
            "path_length_avg": 183.53508519764716,
            "smoothness_avg": 0.006329305929047844,
            "success_improvement": 0.0,
            "time_improvement": 30.244846786385928,
            "length_improvement": -0.5984884963659995,
            "smoothness_improvement": -0.9326179025910396,
            "objective_score": 8.709697848583223
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1657809019088745,
            "num_nodes_avg": 1443.7,
            "path_length_avg": 311.02144593126803,
            "smoothness_avg": 0.0037945369181750094,
            "success_improvement": 0.0,
            "time_improvement": -0.8858875350264284,
            "length_improvement": -3.8279109078070936,
            "smoothness_improvement": -2.3638320008873523,
            "objective_score": -2.5743319651966217
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05738208293914795,
            "num_nodes_avg": 806.0,
            "path_length_avg": 148.42759319646757,
            "smoothness_avg": 0.007786332159702805,
            "success_improvement": 0.0,
            "time_improvement": -17.37791600197615,
            "length_improvement": 1.4214599613763468,
            "smoothness_improvement": -0.9584296558365674,
            "objective_score": -4.365290972046219
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified RRT planner that grows a single tree from the start by sampling random points within the map bounds and extending towards them by fixed steps while applying goal bias for faster convergence. It performs collision checking on nodes and edges, maintains parent-child node relationships, and stops when a node is close enough to the goal or the 30-second time limit is reached. The final path is reconstructed by tracing parents back from the goal node to the start.",
    "planning_mechanism": "The planner samples points randomly with occasional goal bias, connects each sample by extending from the nearest existing node in fixed steps if collision free, adds the new node to the tree, and terminates when a node reaches the goal vicinity or time runs out. The best found path is then extracted and returned.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        success = False\n        path = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find closest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest.position, sample)\n            if dist == 0:\n                continue\n            ratio = min(self.step_size / dist, 1.0)\n            new_pos = tuple(nearest.position[d] + direction[d] * ratio for d in range(len(bounds)))\n\n            # Check collisions\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Check goal reach\n            if math.dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=cost + math.dist(new_pos, goal_pos))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        if success:\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.99117,
    "time_improvement": -25.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04118959903717041,
            "num_nodes_avg": 528.7,
            "path_length_avg": 184.23268895412014,
            "smoothness_avg": 0.006374486176785206,
            "success_improvement": 0.0,
            "time_improvement": -59.26260186585052,
            "length_improvement": -0.9808561695277501,
            "smoothness_improvement": -0.22544891502305658,
            "objective_score": -18.36842150604692
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.20506422519683837,
            "num_nodes_avg": 1618.7,
            "path_length_avg": 307.1532508775813,
            "smoothness_avg": 0.0038220078464775258,
            "success_improvement": 0.0,
            "time_improvement": -24.791734888963724,
            "length_improvement": -2.536596059065241,
            "smoothness_improvement": -1.6569852291537266,
            "objective_score": -8.96776302827403
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04487700462341308,
            "num_nodes_avg": 560.6,
            "path_length_avg": 140.84907965332886,
            "smoothness_avg": 0.008321789228540783,
            "success_improvement": 0.0,
            "time_improvement": 8.201846128635966,
            "length_improvement": 6.45474780669412,
            "smoothness_improvement": 5.852544736452956,
            "objective_score": 6.362665246289526
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a streamlined single-tree RRT planner with uniform random sampling and simple goal bias to improve convergence. It extends the nearest node toward sampled points by fixed steps avoiding obstacles through direct collision checks. The search stops when a node reaches near the goal or when a 30-second time limit expires. The final path is extracted by tracing parent nodes from the goal back to the start.",
    "planning_mechanism": "The planner grows one tree by sampling randomly within map bounds with occasional goal bias, extending existing nodes in fixed steps if collision-free. It maintains parent references for path extraction, continuously checking for goal proximity or time limit to terminate early and return the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start)]\n        edges = []\n        success = False\n        path = []\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = goal if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            vec = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest.position, sample)\n            if dist == 0:\n                continue\n            step_ratio = min(self.step_size / dist, 1.0)\n            new_pos = tuple(nearest.position[d] + vec[d] * step_ratio for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        if success:\n            node = nodes[-1]\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.94908,
    "time_improvement": -59.0,
    "length_improvement": -2.0,
    "smoothness_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02217707633972168,
            "num_nodes_avg": 352.9,
            "path_length_avg": 186.6064595742724,
            "smoothness_avg": 0.006285783370881306,
            "success_improvement": 0.0,
            "time_improvement": 14.250709834433428,
            "length_improvement": -2.281957461235768,
            "smoothness_improvement": -1.6138404486451148,
            "objective_score": 2.8979692713453415
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2096311330795288,
            "num_nodes_avg": 1644.2,
            "path_length_avg": 304.01194853866093,
            "smoothness_avg": 0.0038451033181220408,
            "success_improvement": 0.0,
            "time_improvement": -27.570924468286844,
            "length_improvement": -1.4879389209591283,
            "smoothness_improvement": -1.0627221087445218,
            "objective_score": -9.169354303605253
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12934305667877197,
            "num_nodes_avg": 800.1,
            "path_length_avg": 153.5693673246972,
            "smoothness_avg": 0.007759987756366477,
            "success_improvement": 0.0,
            "time_improvement": -164.57768112704852,
            "length_improvement": -1.993461589620726,
            "smoothness_improvement": -1.2935285217330796,
            "objective_score": -50.57584893449565
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved bidirectional RRT* path planner with adaptive radius rewiring, efficient goal-biased sampling, incremental rewiring, and progressive ellipsoidal informed sampling to reduce computational overhead and enable fast convergence to smooth, short paths within a 30-second time limit. The planner balances local and global search by alternating tree expansions, adaptively adjusts neighbor radius to limit rewiring complexity, performs strict collision checks with adaptive edge-sampling resolution, and refines the found path iteratively using informed sampling focused on the current best solution's ellipsoidal region.",
    "planning_mechanism": "The algorithm grows two rapidly exploring trees alternately from start and goal positions, leveraging goal-biased sampling to accelerate progress. It uses an adaptive neighborhood radius for efficient rewiring to keep the tree topologies optimized. Once a connecting path is found, the planner switches to a focused single-tree phase employing progressive ellipsoidal informed sampling to refine the path while enforcing strict collision validity and adhering to a 30-second wall-clock limit, returning the best feasible path discovered.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0  # Tuned for efficient rewiring\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self.edge_check_resolution = 0.5  # Adaptive collision check resolution\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = math.dist(from_pos, to_pos)\n        resolution = self.edge_check_resolution\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        dim = len(bounds)\n        for _ in range(50):  # Limit sampling attempts to avoid infinite loops\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # If failed after attempts, return goal fallback (safe if goal free)\n        return goal\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-8:\n            # Uniform fallback sampling\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return start  # Fallback in worst case\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            # Degenerate case fallback\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return start\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n\n        dir_a1 = [x / norm_a1 for x in a1]\n\n        for _ in range(100):\n            # Sample uniformly in unit ball\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Approximate rotation: place first coordinate along a1 direction, add others axis aligned\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # If no sample found, fallback to uniform\n        for _ in range(20):\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return start\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) >= time_limit\n\n        # Adaptive rewiring radius function\n        def rewiring_radius(n):\n            return min(self.gamma_rrt_star * ((math.log(n) / n) ** (1 / dim)), self.step_size * 20)\n\n        # Phase 1: Bidirectional tree grow & connect\n        iter_count = 0\n        while iter_count < self.max_iter and not time_exceeded() and not found_solution:\n            expand_start_tree = (iter_count % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = rewiring_radius(n_nodes)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent (minimal cost + collision check)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                candidate_cost = near.cost + self._dist(near.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adding single node to other tree (reuse new_node position)\n                # To avoid redundant duplicates, reuse new_node's position but create a connecting node on tree_b side\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build candidate path via two nodes\n                if expand_start_tree:\n                    candidate_path = self._build_path(new_node, connect_node)\n                    candidate_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    candidate_path = self._build_path(connect_node, new_node)\n                    candidate_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n            iter_count += 1\n\n        # Phase 2: Single-tree informed refinement if solution found\n        if not found_solution:\n            # No solution found, return empty\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Rebuild tree from best path for refinement\n        tree = [start_root]\n        nodes = [start_root]\n        edges = []\n        start_root.children = []\n        start_root.cost = 0.0\n\n        prev_node = start_root\n        for pos in best_path[1:]:\n            cost = prev_node.cost + self._dist(prev_node.position, pos)\n            new_node = Node(pos, parent=prev_node, cost=cost)\n            prev_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((prev_node, new_node))\n            prev_node = new_node\n\n        best_goal_node = prev_node\n        best_cost = best_goal_node.cost\n\n        c_min = self._dist(start_pos, goal_pos)\n        no_improve_count = 0\n        max_no_improve = 150\n        max_refine_iters = self.max_iter // 2\n\n        iter_refine = 0\n        while iter_refine < max_refine_iters and not time_exceeded() and no_improve_count < max_no_improve:\n            sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n            nearest_node = self._nearest(tree, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                iter_refine += 1\n                continue\n\n            n_nodes = len(tree) + 1\n            radius = rewiring_radius(n_nodes)\n            near_nodes = self._near(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                candidate_cost = near.cost + self._dist(near.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    rewired = True\n\n            # Try connect directly to goal\n            dist_goal = self._dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                    success_state = True\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n            iter_refine += 1\n\n        extracted_path = best_goal_node.path_from_root() if success_state else best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 9.1592,
    "time_improvement": -0.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 191.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.0355947732925415,
            "num_nodes_avg": 97.7,
            "path_length_avg": 169.34803150735613,
            "smoothness_avg": 0.021173403288540414,
            "success_improvement": -9.999999999999998,
            "time_improvement": -37.62979829639735,
            "length_improvement": 7.177660439534381,
            "smoothness_improvement": 231.40974024681444,
            "objective_score": -55.825294523964494
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04145934581756592,
            "num_nodes_avg": 119.5,
            "path_length_avg": 261.3470090404333,
            "smoothness_avg": 0.00968237642867025,
            "success_improvement": 0.0,
            "time_improvement": 74.76993518996642,
            "length_improvement": 12.754845925742062,
            "smoothness_improvement": 149.13451944353858,
            "objective_score": 30.829560709652853
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06774108409881592,
            "num_nodes_avg": 100.0,
            "path_length_avg": 130.17492265567753,
            "smoothness_avg": 0.022988324317448898,
            "success_improvement": 0.0,
            "time_improvement": -38.567770146401806,
            "length_improvement": 13.544014635798563,
            "smoothness_improvement": 192.4097884963542,
            "objective_score": -2.4818733199596332
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner enhanced with adaptive rewiring radius, balanced alternating tree expansions, logarithmically shrinking neighbor radius, goal bias sampling, and incremental path refinement for improved planning speed, path quality, robustness, and smoothness within a strict 30-second time limit. It manages consistent parent-child and edge data to maintain valid, optimized trees and incorporates early best-path updates to expedite convergence.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling the environment with goal bias. Each extension steers towards sampled points using a fixed step size, selects the best parent within a dynamically shrinking neighbor radius, and performs rewiring to improve local paths. Upon connecting both trees within collision-free constraints, it extracts and returns the best path found so far, halting either on success or after 30 seconds.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if not (0 <= pos[i] <= bounds[i]):\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=0.5):\n            dist_edge = dist(fpos, tpos)\n            steps = max(1, int(dist_edge / resolution))\n            for i in range(steps+1):\n                interp = tuple(fpos[d] + (tpos[d] - fpos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            min_node = None\n            min_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near(tree, point, radius):\n            result = []\n            rsq = radius*radius\n            for node in tree:\n                # squared dist for efficiency\n                d = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d <= rsq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            path = extract_path(node_a, node_b)\n            total_cost = node_a.cost + node_b.cost + dist(node_a.position, node_b.position)\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_path = path\n                success = True\n\n        def try_connect(tree_from, tree_to, new_node):\n            conn_node = nearest(tree_to, new_node.position)\n            d = dist(new_node.position, conn_node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(new_node.position, conn_node.position):\n                update_best_path(new_node, conn_node)\n                return True\n            return False\n\n        def choose_parent(tree, new_pos, near_nodes, nearest_node):\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + dist(near_node.position, new_pos)\n                if cost + 1e-10 < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost\n                        best_parent = near_node\n            return best_parent, min_cost\n\n        def rewire(tree, new_node, neighbor_radius):\n            near_nodes = near(tree, new_node.position, neighbor_radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-10 < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        old_edge = (near_node.parent, near_node)\n                        if old_edge in edges:\n                            edges.remove(old_edge)\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        def neighbor_radius(n):\n            gamma = 30.0 * self.step_size\n            r = gamma * ((math.log(max(n,2))/max(n,2))**(1/dim))\n            return max(r, self.step_size * 1.1)\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < 0.1:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample) or is_in_obstacle(sample):\n                continue\n\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            best_parent, min_cost = choose_parent(tree_a, new_pos, near_nodes, nearest_node)\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbor_radius(len(tree_a)))\n\n            # Attempt connect other tree\n            if try_connect(tree_a, tree_b, new_node):\n                # Success: return best found path immediately\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Timeout or max iterations reached\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 51.64923,
    "time_improvement": -50.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 663.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.08148815631866455,
            "num_nodes_avg": 118.6,
            "path_length_avg": 167.51451516823474,
            "smoothness_avg": 0.03840860082076343,
            "success_improvement": -9.999999999999998,
            "time_improvement": -215.0799255134776,
            "length_improvement": 8.182639798932453,
            "smoothness_improvement": 501.178008456583,
            "objective_score": -107.10850373240089
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.08096966743469239,
            "num_nodes_avg": 316.7,
            "path_length_avg": 229.51565353535653,
            "smoothness_avg": 0.03402019370681613,
            "success_improvement": -19.999999999999996,
            "time_improvement": 50.72594811279896,
            "length_improvement": 23.381068608103995,
            "smoothness_improvement": 775.3640878314568,
            "objective_score": -66.87675396214063
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.041243338584899904,
            "num_nodes_avg": 184.5,
            "path_length_avg": 123.51708947492128,
            "smoothness_avg": 0.06395710133934894,
            "success_improvement": 0.0,
            "time_improvement": 15.634691455985571,
            "length_improvement": 17.96583042250956,
            "smoothness_improvement": 713.529608214363,
            "objective_score": 19.037553731373222
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring radius, incremental rewiring, and balanced tree expansion to improve planning efficiency, path quality, and smoothness within a 30-second limit. The planner employs goal bias and ellipsoidal informed sampling after the initial solution, uses kd-tree for efficient neighbor queries, performs rewiring with carefully maintained parent-child consistency, and incrementally attempts early tree connections to find and refine the best path quickly.",
    "planning_mechanism": "The planner starts two trees from start and goal, samples points with adaptive probability distributions (uniform, goal biased, then ellipsoidal informed after initial solution), extends trees towards sampled points capped by step size, rewires neighbors within a dynamically computed radius to minimize costs, and periodically attempts to connect the two trees. It maintains a best path record updated on better connections and terminates early on timeout or upon finding high-quality paths. Throughout, it avoids collisions and maintains consistent graph structures for smooth and feasible paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=4.5, gamma_rrt_star=50.0, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n        from bisect import bisect_left\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        class KDTree:\n            def __init__(self, points):\n                self.dim = dim\n                self.points = points\n                self.idx = list(range(len(points)))\n                self.tree = self._build(0, len(points), 0)\n\n            def _build(self, start, end, axis):\n                if start >= end:\n                    return None\n                mid = (start + end) // 2\n                self.idx[start:end] = sorted(self.idx[start:end], key=lambda i: self.points[i][axis])\n                node = {\n                    'idx': self.idx[mid],\n                    'left': self._build(start, mid, (axis + 1) % self.dim),\n                    'right': self._build(mid + 1, end, (axis + 1) % self.dim),\n                }\n                return node\n\n            def _dist_sq(self, a, b):\n                d = 0.0\n                for i in range(self.dim):\n                    d += (a[i] - b[i]) ** 2\n                return d\n\n            def nearest(self, point):\n                best = [None, float('inf')]  # node index, dist squared\n\n                def recur(node, axis):\n                    if node is None:\n                        return\n                    dist_axis = point[axis] - self.points[node['idx']][axis]\n                    # Explore near side\n                    near = node['left'] if dist_axis < 0 else node['right']\n                    far = node['right'] if dist_axis < 0 else node['left']\n\n                    recur(near, (axis + 1) % self.dim)\n\n                    d_sq = self._dist_sq(point, self.points[node['idx']])\n                    if d_sq < best[1]:\n                        best[0] = node['idx']\n                        best[1] = d_sq\n\n                    if dist_axis * dist_axis < best[1]:\n                        recur(far, (axis + 1) % self.dim)\n\n                recur(self.tree, 0)\n                return best[0], math.sqrt(best[1])\n\n            def neighbors_in_radius(self, point, radius):\n                result = []\n                radius_sq = radius * radius\n\n                def recur(node, axis):\n                    if node is None:\n                        return\n                    dist_axis = point[axis] - self.points[node['idx']][axis]\n                    d_sq = self._dist_sq(point, self.points[node['idx']])\n                    if d_sq <= radius_sq:\n                        result.append(node['idx'])\n                    near = node['left'] if dist_axis < 0 else node['right']\n                    far = node['right'] if dist_axis < 0 else node['left']\n\n                    recur(near, (axis + 1) % self.dim)\n                    if dist_axis * dist_axis <= radius_sq:\n                        recur(far, (axis + 1) % self.dim)\n\n                recur(self.tree, 0)\n                return result\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        pos_list_a = [start_pos]  # For kd-tree\n        pos_list_b = [goal_pos]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            distance = math.dist(fpos, tpos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fpos[d] + (tpos[d] - fpos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_rewire_radius(n):\n            if n <= 1:\n                return self.step_size * 4.0\n            volume = 1.0\n            for size in bounds:\n                volume *= size\n            radius = min(self.gamma_rrt_star * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 15.0)\n            radius = max(radius, self.step_size * 2.0)\n            return radius\n\n        def sample_uniform_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def ellipsoid_sample(start, goal, c_best, dim, bounds):\n            c_min = dist(start, goal)\n            if c_best == float('inf'):\n                return sample_uniform_free()\n            # Define ellipsoid parameters\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            import numpy as np\n\n            # Sample unit ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xx*xx for xx in x))\n                if norm_x == 0:\n                    continue\n                unit_ball = [xx / norm_x for xx in x]\n                r = random.random() ** (1.0 / dim)\n                sample_point = [r * xx for xx in unit_ball]\n\n                # Scale along axes\n                L = [c_best / 2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0] * (dim - 1)\n                # Rotation matrix: align first axis with dir_vec\n                import math\n                def unit_vector(v):\n                    norm = math.sqrt(sum(vv*vv for vv in v))\n                    return [vv / norm for vv in v]\n\n                def rotation_matrix(u):\n                    # Find rotation matrix that rotates [1,0,...,0] to u\n                    import numpy as np\n                    e1 = np.zeros(dim)\n                    e1[0] = 1.0\n                    v = np.cross(e1, np.array(u)) if dim==3 else None\n                    s = np.linalg.norm(v) if dim==3 else None\n                    c = np.dot(e1, np.array(u)) if dim==3 else None\n                    if dim == 3 and s != 0:\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    else:\n                        R = np.eye(dim)\n                    return R\n\n                try:\n                    import numpy as np\n                    u = unit_vector(dir_vec)\n                    R = rotation_matrix(u)\n                    x_np = np.array([sample_point[i] * L[i] for i in range(dim)])\n                    transformed = R @ x_np + np.array(center)\n                    sample = tuple(float(val) for val in transformed)\n                    inside_bounds = True\n                    for d in range(dim):\n                        if sample[d] < 0 or sample[d] > bounds[d]:\n                            inside_bounds = False\n                            break\n                    if inside_bounds and not is_in_obstacle(sample):\n                        return sample\n                except:\n                    # fallback to uniform if numpy not available or error\n                    return sample_uniform_free()\n\n        def sample_point():\n            # Initial phase: uniform with goal bias, later use ellipsoidal informed sampling\n            if success and random.random() < 0.7:\n                # informed sample\n                return ellipsoid_sample(start_pos, goal_pos, best_cost, dim, bounds)\n            elif random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return sample_uniform_free()\n\n        def build_kdtree(nodes_list):\n            return KDTree([n.position for n in nodes_list])\n\n        def nearest(tree_nodes, kdtree, point):\n            idx, dist_val = kdtree.nearest(point)\n            return tree_nodes[idx], dist_val\n\n        def near_nodes(tree_nodes, kdtree, point, radius):\n            idxs = kdtree.neighbors_in_radius(point, radius)\n            return [tree_nodes[idx] for idx in idxs]\n\n        def add_node(new_pos, tree_nodes, other_tree_nodes):\n            if is_in_obstacle(new_pos):\n                return None\n            kdtree = build_kdtree(tree_nodes)\n            nearest_node, ndist = nearest(tree_nodes, kdtree, new_pos)\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            radius = compute_rewire_radius(len(tree_nodes))\n            neighbors = near_nodes(tree_nodes, kdtree, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except Exception:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n            return new_node\n\n        def try_connect(node_a, tree_b_nodes):\n            if len(tree_b_nodes) == 0:\n                return None\n            kdtree_b = build_kdtree(tree_b_nodes)\n            nearest_b_node, dist_to_b = nearest(tree_b_nodes, kdtree_b, node_a.position)\n            current = nearest_b_node\n\n            while True:\n                new_pos = steer(current.position, node_a.position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(current.position, new_pos) :\n                    return None\n                radius = compute_rewire_radius(len(tree_b_nodes))\n                neighbors = near_nodes(tree_b_nodes, kdtree_b, new_pos, radius)\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nb in neighbors:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        c = nb.cost + dist(nb.position, new_pos)\n                        if c < min_cost:\n                            min_cost = c\n                            best_parent = nb\n                new_node = Node(new_pos, parent=None, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_b_nodes.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                # rewire neighbors\n                for nb in neighbors:\n                    if nb is best_parent:\n                        continue\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        new_cost = new_node.cost + dist(new_node.position, nb.position)\n                        if new_cost + 1e-12 < nb.cost:\n                            if nb.parent:\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                except:\n                                    pass\n                                nb.parent.remove_child(nb)\n                            new_node.add_child(nb)\n                            nb.cost = new_cost\n                            edges.append((new_node, nb))\n\n                if dist(new_node.position, node_a.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, node_a.position)\n                        and not is_in_obstacle(node_a.position)):\n                        final_node = Node(node_a.position, parent=None,\n                                         cost=new_node.cost + dist(new_node.position, node_a.position))\n                        new_node.add_child(final_node)\n                        tree_b_nodes.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def update_best_path(node1, node2):\n            nonlocal best_cost, best_path, success\n            total_cost = node1.cost + node2.cost + dist(node1.position, node2.position)\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_start = node1.path_from_root()\n                path_goal = node2.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                success = True\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                return PlannerResult(success, best_path, nodes, edges)\n            sample = sample_point()\n            new_node = add_node(sample, tree_a, tree_b)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            connect_node = try_connect(new_node, tree_b)\n            if connect_node is not None:\n                update_best_path(new_node, connect_node)\n                if best_cost < float('inf'):\n                    return PlannerResult(True, best_path, nodes, edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 24.72207,
    "time_improvement": -51.0,
    "length_improvement": -19.0,
    "smoothness_improvement": 329.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06820833683013916,
            "num_nodes_avg": 120.3,
            "path_length_avg": 234.2575966320891,
            "smoothness_avg": 0.020933923237910414,
            "success_improvement": 0.0,
            "time_improvement": -163.7325306980346,
            "length_improvement": -28.400300763211604,
            "smoothness_improvement": 227.6613574152015,
            "objective_score": -65.02163288026134
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024370360374450683,
            "num_nodes_avg": 104.7,
            "path_length_avg": 301.34880703918304,
            "smoothness_avg": 0.022990283484298154,
            "success_improvement": 0.0,
            "time_improvement": 85.16942900168117,
            "length_improvement": -0.5989056341555588,
            "smoothness_improvement": 491.5565532828561,
            "objective_score": 27.649268086425295
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08496990203857421,
            "num_nodes_avg": 151.8,
            "path_length_avg": 190.6772945541823,
            "smoothness_avg": 0.028812524436861175,
            "success_improvement": 0.0,
            "time_improvement": -73.81017755588643,
            "length_improvement": -26.638779965834814,
            "smoothness_improvement": 266.493184117544,
            "objective_score": -36.79385532567909
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined single-tree RRT planner with goal bias that incrementally grows a collision-free tree toward the goal using fixed step extensions and early termination upon reaching near the goal or timeout. It uniformly samples map space, biases samples to the goal occasionally for faster convergence, and strictly checks for node and edge collisions before insertion. The planner maintains parent links for path extraction, returns the best found path within a 30-second limit, and uses straightforward data structures enabling easy generalization and efficient exploration.",
    "planning_mechanism": "The planner samples a point within map bounds (with goal bias), finds the nearest existing node, extends toward the sample by a fixed step if collision free, inserts the new node, records parent-child edges, and terminates early when a node reaches the goal vicinity or time expires, returning the best path traced back to the start from the goal node if found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start)]\n        edges = []\n        success = False\n        best_goal_node = None\n\n        TIME_LIMIT = 30.0\n        import time, random, math\n        start_time = time.monotonic()\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d: return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h: return True\n            return False\n\n        def edge_in_obstacle(fr, to, resolution=1.0):\n            dist = math.dist(fr,to)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d]) * i/steps for d in range(len(fr)))\n                if in_obstacle(interp): return True\n            return False\n\n        def steer(fr, to):\n            dist = math.dist(fr,to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(fr[d] + (to[d]-fr[d]) * ratio for d in range(len(fr)))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            if in_obstacle(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost+math.dist(nearest_node.position,new_pos))\n            nearest_node.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node,new_node))\n\n            if math.dist(new_pos, goal) <= self.step_size:\n                if not in_obstacle(goal) and not edge_in_obstacle(new_pos, goal):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost+math.dist(new_pos,goal))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    best_goal_node = goal_node\n                    break\n\n        path = best_goal_node.path_from_root() if success else []\n        return PlannerResult(success, path, nodes, edges)",
    "objective": 3.7952,
    "time_improvement": -8.0,
    "length_improvement": -2.0,
    "smoothness_improvement": -2.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030606937408447266,
            "num_nodes_avg": 448.7,
            "path_length_avg": 189.149986502787,
            "smoothness_avg": 0.006125493675626271,
            "success_improvement": 0.0,
            "time_improvement": -18.343965485453005,
            "length_improvement": -3.6761048755180123,
            "smoothness_improvement": -4.122722254030788,
            "objective_score": -7.729466182216862
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1801213502883911,
            "num_nodes_avg": 1535.5,
            "path_length_avg": 301.89650356542927,
            "smoothness_avg": 0.0038536172799975127,
            "success_improvement": 0.0,
            "time_improvement": -9.612760448367213,
            "length_improvement": -0.7817424991869669,
            "smoothness_improvement": -0.8436517373297604,
            "objective_score": -3.3570918927089926
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.047458958625793454,
            "num_nodes_avg": 752.8,
            "path_length_avg": 153.49268830485283,
            "smoothness_avg": 0.007710439008868401,
            "success_improvement": 0.0,
            "time_improvement": 2.9203302879900197,
            "length_improvement": -1.9425350357026514,
            "smoothness_improvement": -1.9237849326004979,
            "objective_score": -0.2990408596875874
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT planner with uniform random sampling, no goal bias, and straightforward fixed-step extension, designed for general applicability in 2D and 3D maps. It performs collision checking for nodes and edges, incrementally grows a tree of safe nodes up to a max iteration or 30 seconds, and returns the path from start to goal if found. The planner maintains necessary node parent links and returns comprehensive nodes and edges without rewiring or advanced optimization.",
    "planning_mechanism": "A random sample within bounds is selected each iteration, the nearest existing node is extended towards it by a fixed step size if collision-free, forming a new node linked to its parent. This process repeats until a node reaches near the goal or time runs out. Final path is extracted by backtracking from the goal node to start.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(fr, to):\n            dist = math.dist(fr, to)\n            steps = max(1, int(dist))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d]) * i / steps for d in range(len(fr)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            dist = math.dist(fr, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(fr[d] + (to[d]-fr[d]) * ratio for d in range(len(fr)))\n\n        nodes = [Node(start)]\n        edges = []\n        found_goal = None\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if in_obstacle(sample):\n                continue\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n            nearest.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= self.step_size:\n                if not in_obstacle(goal) and not edge_in_obstacle(new_pos, goal):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + math.dist(new_pos, goal))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    found_goal = goal_node\n                    break\n\n        path = found_goal.path_from_root() if found_goal else []\n        return PlannerResult(success=bool(found_goal), path=path, nodes=nodes, edges=edges)",
    "objective": 104.35615,
    "time_improvement": -295.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 851.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1210282325744629,
            "num_nodes_avg": 1300.5,
            "path_length_avg": 201.080402098476,
            "smoothness_avg": 0.005955958094825691,
            "success_improvement": 0.0,
            "time_improvement": -367.9645267155869,
            "length_improvement": -10.215354713048102,
            "smoothness_improvement": -6.776322245966066,
            "objective_score": -116.55245245373476
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.4156269311904907,
            "num_nodes_avg": 2011.6,
            "path_length_avg": 303.2804533897727,
            "smoothness_avg": 0.10350869018268913,
            "success_improvement": -9.999999999999998,
            "time_improvement": -152.92956760278904,
            "length_improvement": -1.2437447853397892,
            "smoothness_improvement": 2563.3531526966226,
            "objective_score": -83.80835138855747
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.22756330966949462,
            "num_nodes_avg": 1299.1,
            "path_length_avg": 158.19254103376142,
            "smoothness_avg": 0.0075215744302259205,
            "success_improvement": 0.0,
            "time_improvement": -365.49211320620367,
            "length_improvement": -5.0639534353063675,
            "smoothness_improvement": -4.326128432399766,
            "objective_score": -112.70763666520692
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined single-tree RRT planner using uniform random sampling within map bounds, fixed step-size extensions, and rigorous collision checks. It incrementally grows a tree rooted at start, selecting nearest nodes and steering toward sampled points, terminating early upon reaching the goal vicinity or timeout. The algorithm avoids complex structures to ensure generality and simplicity while returning the best found path if available.",
    "planning_mechanism": "A random sample is drawn in the map bounds, the nearest tree node is extended toward this sample by a fixed step if collision checks succeed, the new node is added to the tree, and this process repeats until the goal is reached within a step distance or the 30-second time limit is exceeded. The resulting path is obtained by backtracking parents from the goal node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start_pos, end_pos, obstacles, is_3d):\n        dist =  max(1, int(((sum((s - e) ** 2 for s, e in zip(start_pos, end_pos))) ** 0.5)))\n        for i in range(dist + 1):\n            interp = tuple(start_pos[d] + (end_pos[d] - start_pos[d]) * i / dist for d in range(len(start_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = (sum((f - t) ** 2 for f, t in zip(from_pos, to_pos))) ** 0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(f + (t - f) * ratio for f, t in zip(from_pos, to_pos))\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = [Node(start)]\n        edges = []\n        found_goal = None\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_cost = new_cost + math.dist(new_pos, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    found_goal = goal_node\n                    break\n\n        path = found_goal.path_from_root() if found_goal else []\n        return PlannerResult(success=found_goal is not None, path=path, nodes=nodes, edges=edges)",
    "objective": 104.95922,
    "time_improvement": -330.0,
    "length_improvement": -10.0,
    "smoothness_improvement": -7.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1370384693145752,
            "num_nodes_avg": 1365.1,
            "path_length_avg": 203.45320223205698,
            "smoothness_avg": 0.005837713182339254,
            "success_improvement": 0.0,
            "time_improvement": -429.8692798407021,
            "length_improvement": -11.51592406568806,
            "smoothness_improvement": -8.627111899316048,
            "objective_score": -135.91347395112004
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.42513716220855713,
            "num_nodes_avg": 1970.2,
            "path_length_avg": 323.017388522541,
            "smoothness_avg": 0.0036631916278845045,
            "success_improvement": 0.0,
            "time_improvement": -158.7170140810821,
            "length_improvement": -7.832501828836709,
            "smoothness_improvement": -5.74344092425071,
            "objective_score": -52.34332252624791
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2457879066467285,
            "num_nodes_avg": 1304.4,
            "path_length_avg": 165.008907903557,
            "smoothness_avg": 0.007314713363006186,
            "success_improvement": 0.0,
            "time_improvement": -402.77143636064807,
            "length_improvement": -9.591059749714246,
            "smoothness_improvement": -6.95738593853909,
            "objective_score": -126.62085368771567
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid planner combining bidirectional RRT* with goal biasing, dynamic rewiring radius, and ellipsoidal informed sampling for efficient, smooth, and near-optimal path planning under a 30-second time limit. It balances tree growth from start and goal, refrains from redundant expansions, performs local rewiring to improve path quality, applies informed sampling to focus search near the best path once found, and returns the best feasible path respecting collision-free constraints on node and edge levels.",
    "planning_mechanism": "The planner alternates expansions in two trees, samples with dynamic goal bias and ellipsoidal informed sampling after an initial solution, extends nearest nodes with fixed step size, rewires neighbors inside an adaptive radius to reduce cost, attempts incremental tree connections, updates the best path continuously, and terminates early on timeout, ensuring collision checks and coherent graph data structures throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # probability to sample the goal in start tree, or start in goal tree\n        self.gamma_rrt_star = 30.0    # parameter for adaptive neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        # Phase 1: Bidirectional RRT* with rewiring until initial solution found or timeout\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n            if found_solution:\n                break\n\n        # Phase 2: Single-tree informed RRT* refinement if solution found\n        if found_solution and best_goal_node:\n            # Rebuild initial tree from best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= 150:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.15409,
    "time_improvement": 46.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 120.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016752243041992188,
            "num_nodes_avg": 101.0,
            "path_length_avg": 166.16054386608698,
            "smoothness_avg": 0.01720486779467732,
            "success_improvement": 0.0,
            "time_improvement": 35.226225155794836,
            "length_improvement": 8.924772924687892,
            "smoothness_improvement": 169.29354195509922,
            "objective_score": 16.76919901132668
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030165815353393556,
            "num_nodes_avg": 131.2,
            "path_length_avg": 276.00347106147785,
            "smoothness_avg": 0.007278728758307568,
            "success_improvement": 0.0,
            "time_improvement": 81.6426076821704,
            "length_improvement": 7.862097040248937,
            "smoothness_improvement": 87.28693360766857,
            "objective_score": 29.64647519683882
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.038816642761230466,
            "num_nodes_avg": 101.8,
            "path_length_avg": 139.6497904528287,
            "smoothness_avg": 0.015978986767897826,
            "success_improvement": 0.0,
            "time_improvement": 20.598618939327068,
            "length_improvement": 7.2512585896514645,
            "smoothness_improvement": 103.25153224154447,
            "objective_score": 11.04659849679672
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A refined bidirectional RRT* planner with adaptive logarithmic rewiring radius, enhanced goal bias sampling, ellipsoidal informed sampling after initial path discovery, and incremental rewiring to optimize path length and smoothness while maintaining efficient planning time under a 30-second hard limit. The algorithm aggressively balances exploration and exploitation by alternating tree expansions, prioritizes collision checks, and updates the best path in real-time to allow early termination and reduce wasted iterations. It ensures consistent parent-child and edge relationships and avoids redundant node insertions during tree connections.",
    "planning_mechanism": "The planner grows two trees from start and goal points alternately, sampling with a dynamic goal bias and switching to ellipsoidal informed sampling after the initial path is found. It uses adaptive neighbor radius based on the logarithm of the current tree size to choose parents and rewire to reduce path costs. After each extension, it tries to connect the opposite tree. Incremental rewiring refines the tree locally improving smoothness and length without global rewiring overhead. The planning stops early if time expires or a solution is found, returning the best path available.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, gamma_rrt_star: float = 50.0, max_radius: float = 60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dimension = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dimension == 3)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(fr, to, resolution=1.0):\n            dist = math.dist(fr, to)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[d] + (to[d] - fr[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _sample_free(goal_bias=0.15):\n            # After finding first path, switch to ellipsoidal informed sampling\n            if best_cost < float('inf'):\n                # Ellipsoidal informed sampling around start and goal\n                c_min = math.dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    c_min = best_cost\n                # Ellipsoid center & axes\n                center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dimension))\n\n                # Generate random point in unit n-ball\n                while True:\n                    # sample uniformly in unit ball\n                    u = [random.gauss(0, 1) for _ in range(dimension)]\n                    norm_u = math.sqrt(sum(ui*ui for ui in u))\n                    if norm_u == 0:\n                        continue\n                    u = [ui / norm_u for ui in u]\n                    r = random.random() ** (1.0 / dimension)\n                    point_ball = [r * ui for ui in u]\n\n                    # Define ellipsoid radii\n                    a1 = best_cost / 2.0\n                    # Radii equal half length along principal axes, fix minor axes as sqrt(best_cost**2 - c_min**2)/2 or small epsilon\n                    sph_radius = math.sqrt(max(best_cost*best_cost - c_min*c_min, 1e-6)) / 2.0\n                    radii = [a1] + [sph_radius]*(dimension-1)\n\n                    # Rotate point_ball to ellipsoid space (rotation aligned with start->goal)\n                    # Construct rotation matrix (only for 2D or 3D; identity otherwise)\n                    def unit_vector(a, b):\n                        diff = [b[i] - a[i] for i in range(dimension)]\n                        norm = math.sqrt(sum(x*x for x in diff))\n                        if norm == 0:\n                            return None\n                        return [x / norm for x in diff]\n\n                    def mat_vec_mul(mat, vec):\n                        return [sum(mat[row][col] * vec[col] for col in range(len(vec))) for row in range(len(mat))]\n\n                    e1 = unit_vector((0.0,) * dimension, (1.0,) + (0.0,) * (dimension-1))\n                    e_startgoal = unit_vector(start_pos, goal_pos)\n                    if e_startgoal is None:\n                        q = [0]*dimension\n                    else:\n                        # find rotation matrix to align e_startgoal to e1 (x-axis)\n                        # specialcase 2D:\n                        if dimension == 2:\n                            cos_theta = e_startgoal[0]\n                            sin_theta = e_startgoal[1]\n                            rot = [\n                                [cos_theta, sin_theta],\n                                [-sin_theta, cos_theta]\n                            ]\n                            y = mat_vec_mul(rot, point_ball)\n                            q = y\n                        elif dimension == 3:\n                            # Rodrigues rotation formula for vector a to b\n                            a = e1\n                            b = e_startgoal\n\n                            v = [a[1]*b[2] - a[2]*b[1],\n                                 a[2]*b[0] - a[0]*b[2],\n                                 a[0]*b[1] - a[1]*b[0]]\n                            s = math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])\n                            c = sum(a[i]*b[i] for i in range(3))\n                            if s == 0:\n                                rot_mat = [[1,0,0],[0,1,0],[0,0,1]]\n                            else:\n                                vx = [[0, -v[2], v[1]],\n                                      [v[2], 0, -v[0]],\n                                      [-v[1], v[0], 0]]\n                                I = [[1,0,0],[0,1,0],[0,0,1]]\n                                vx2 = [[sum(vx[row][k]*vx[k][col] for k in range(3)) for col in range(3)] for row in range(3)]\n                                rot_mat = [[I[row][col] + vx[row][col] + vx2[row][col]*((1 - c)/(s*s)) for col in range(3)] for row in range(3)]\n                            y = mat_vec_mul(rot_mat, point_ball)\n                            q = y\n                        else:\n                            # Identity for higher dims or fallback\n                            q = point_ball\n\n                    # Scale by radii and translate to center\n                    sample = tuple(center[d] + radii[d] * q[d] for d in range(dimension))\n                    if all(0 <= sample[d] <= bounds[d] for d in range(dimension)) and not _is_in_obstacle(sample):\n                        return sample\n            # Otherwise uniform random with goal bias\n            if random.random() < goal_bias:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            # Linear nearest search - can be improved with spatial structures\n            # To reduce cost, pre-check roughly candidates by distance squared < radius*radius if possible\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            # logarithmically shrinking radius as in RRT*\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 1.5, min(self.max_radius, r_theory * 0.6 + scale * 0.01))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if nb is nearest_node:\n                    continue\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb is pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    # Accept only strict improvement with a small tolerance to avoid numerical issues\n                    if new_cost + 1e-9 < nb.cost:\n                        # Remove old edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Add new edge\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            prev_node = None\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position) and\n                            not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                if connect_node == prev_node:\n                    # Prevent looping\n                    return None\n                prev_node = connect_node\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + dist_connect\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                # Remove duplicate connection node if overlapping\n                if path_a[-1] == path_b[-1]:\n                    best_path = path_a + path_b[:-1][::-1]\n                else:\n                    best_path = path_a + path_b[::-1]\n                success = True\n\n        for iter_n in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > TIME_LIMIT:\n                # Time limit reached - return best path so far\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = _sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early termination on solution found\n                if success:\n                    return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n            tree_a, tree_b = tree_b, tree_a\n\n        # Return best path found if time or iterations exhausted\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -11.97663,
    "time_improvement": 17.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 146.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025579071044921874,
            "num_nodes_avg": 113.9,
            "path_length_avg": 165.00236443700175,
            "smoothness_avg": 0.017579890019876775,
            "success_improvement": 0.0,
            "time_improvement": 1.0966481064936076,
            "length_improvement": 9.559589422296998,
            "smoothness_improvement": 175.16345415326725,
            "objective_score": 6.940565356092617
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04253640174865723,
            "num_nodes_avg": 292.7,
            "path_length_avg": 266.73602363563793,
            "smoothness_avg": 0.008638810295050512,
            "success_improvement": 0.0,
            "time_improvement": 74.11449332493942,
            "length_improvement": 10.955837739678174,
            "smoothness_improvement": 122.28281117519862,
            "objective_score": 29.41926469716472
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06123991012573242,
            "num_nodes_avg": 365.4,
            "path_length_avg": 134.39349512727054,
            "smoothness_avg": 0.01895445754592407,
            "success_improvement": 0.0,
            "time_improvement": -25.269294151097345,
            "length_improvement": 10.742239667000755,
            "smoothness_improvement": 141.09930091163125,
            "objective_score": -0.42994794057059416
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bi-directional RRT planner with balanced alternating tree extensions and adaptive goal-biased sampling. It avoids complex rewiring by focusing on efficient sample steering, collision checking, and incremental tree connection attempts. The planner maintains consistent parent-child relationships and early best path updates, providing a fast and general approach that improves planning time, path quality, and smoothness by avoiding unnecessary expansions and redundant nodes.",
    "planning_mechanism": "The planner grows two trees from start and goal by alternately sampling free configurations with a goal bias, extending nearest nodes toward samples using fixed step-size steering. After each extension, it attempts to connect the other tree, building a path upon successful linkage. The planner tracks the best found path at all times and respects a hard 30-second limit, returning the best feasible path if timeout occurs. The approach emphasizes simplicity, efficient collision avoidance, and dynamic tree connection without global rewiring.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal for biasing\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # With goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree_nodes, point):\n            return min(tree_nodes, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extend_tree(tree_nodes, sample_point):\n            nearest_node = nearest(tree_nodes, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos):\n                return None\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree_nodes, target_node):\n            nearest_node = nearest(tree_nodes, target_node.position)\n            d = dist(nearest_node.position, target_node.position)\n            if d > self.step_size:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos):\n                    return None\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_nodes.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # Check if next step can reach target_node.position directly\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_in_obstacle(target_node.position) and\n                        not is_edge_in_obstacle(new_node.position, target_node.position)):\n                        final_node = Node(target_node.position, parent=new_node, cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree_nodes.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if (is_in_obstacle(target_node.position) or\n                    is_edge_in_obstacle(nearest_node.position, target_node.position)):\n                    return None\n                final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + d)\n                nearest_node.add_child(final_node)\n                tree_nodes.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Alternate trees for growth\n        tree_active, tree_passive = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node_active = extend_tree(tree_active, sample)\n            if new_node_active is None:\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n\n            connected_node = try_connect(tree_passive, new_node_active)\n            if connected_node is not None:\n                # Build full path by concatenating new_node_active and connected_node paths\n                path_start = new_node_active.path_from_root()\n                path_goal = connected_node.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n\n                total_cost = new_node_active.cost + (connected_node.cost - connected_node.parent.cost if connected_node.parent else 0)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            tree_active, tree_passive = tree_passive, tree_active\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -23.43194,
    "time_improvement": 79.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 71.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0034517765045166014,
            "num_nodes_avg": 79.4,
            "path_length_avg": 185.06505703303085,
            "smoothness_avg": 0.011033340538317856,
            "success_improvement": 0.0,
            "time_improvement": 86.65345329842545,
            "length_improvement": -1.437090303294974,
            "smoothness_improvement": 72.69573870713502,
            "objective_score": 25.497260501086327
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.011406612396240235,
            "num_nodes_avg": 243.4,
            "path_length_avg": 294.69966400002505,
            "smoothness_avg": 0.006736074735969007,
            "success_improvement": 0.0,
            "time_improvement": 93.05851155282483,
            "length_improvement": 1.620769697286133,
            "smoothness_improvement": 73.32405475500371,
            "objective_score": 29.256635557994148
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020609593391418456,
            "num_nodes_avg": 318.3,
            "path_length_avg": 155.94402055287657,
            "smoothness_avg": 0.013076427668465423,
            "success_improvement": 0.0,
            "time_improvement": 57.8420475865577,
            "length_improvement": -3.57059319494206,
            "smoothness_improvement": 66.33119474139106,
            "objective_score": 15.541914332709027
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, robust bidirectional RRT planner with goal-biased sampling and incremental tree extension that balances exploration between start and goal trees, while performing efficient collision checks and early path updates. It avoids complex rewiring and uses straightforward nearest neighbor selection to maintain generality and simplicity for various environments.",
    "planning_mechanism": "A planning mechanism where two trees grow alternately from start and goal by sampling free configurations biased toward the goal, extending toward these samples in fixed step increments, and attempting quick connections between trees after each extension. The planner tracks the best path incrementally, respects a 30-second runtime limit, and returns the best feasible path found, emphasizing simplicity and consistent collision checking to enhance generalization and robustness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node) -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[dim] + (to_pos[dim] - from_pos[dim]) * (i / steps) for dim in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extend(tree: List[Node], sample_point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node:\n            nearest_node = nearest(tree, target_node.position)\n            d = dist(nearest_node.position, target_node.position)\n            if d > self.step_size:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_in_obstacle(target_node.position) and \n                        not is_edge_in_obstacle(new_node.position, target_node.position)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(target_node.position) or is_edge_in_obstacle(nearest_node.position, target_node.position):\n                    return None\n                final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + d)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree, passive_tree = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            connected = try_connect(passive_tree, new_node)\n            if connected is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected.path_from_root()\n                path_from_goal.reverse()\n                full_path = path_from_start + path_from_goal[1:]\n                total_cost = new_node.cost + (connected.cost - (connected.parent.cost if connected.parent else 0))\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -23.99146,
    "time_improvement": 85.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005986332893371582,
            "num_nodes_avg": 102.9,
            "path_length_avg": 186.3878844459078,
            "smoothness_avg": 0.010717739755280646,
            "success_improvement": 0.0,
            "time_improvement": 76.85340536155462,
            "length_improvement": -2.162152969834569,
            "smoothness_improvement": 67.75590111453309,
            "objective_score": 22.09750933213831
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.012749218940734863,
            "num_nodes_avg": 257.1,
            "path_length_avg": 308.38377975949993,
            "smoothness_avg": 0.006534880980414862,
            "success_improvement": 0.0,
            "time_improvement": 92.24146899067176,
            "length_improvement": -2.9473820186597015,
            "smoothness_improvement": 68.1471945105909,
            "objective_score": 26.244747458558663
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.006320595741271973,
            "num_nodes_avg": 198.8,
            "path_length_avg": 157.6342104276583,
            "smoothness_avg": 0.012998822830330053,
            "success_improvement": 0.0,
            "time_improvement": 87.07090579496337,
            "length_improvement": -4.693136831579113,
            "smoothness_improvement": 65.34406692850246,
            "objective_score": 23.632109974184054
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A goal-biased bidirectional RRT* inspired planner with adaptive rewiring radius that shrinks logarithmically with tree size, ellipsoidal informed sampling after initial solution, and early best-path tracking for efficient convergence, smoothness, and path length optimization within a 30-second limit. The planner alternates tree expansions with rewiring, consistent edge and parent-child management, and incremental collision checking to improve performance and path quality.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately using goal-biased and informed sampling. It performs incremental rewiring within an adaptive radius computed from the number of nodes, reducing unnecessary rewires. Ellipsoidal informed sampling focuses exploration after finding a first solution, accelerating refinement of shorter and smoother paths. The planner maintains early best-path updates, seamless edge management, and terminates either on time limit or path completion, ensuring efficiency and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0, gamma_rrt_star: float = 25.0, max_radius: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dimension = len(bounds)\n        is_3d = dimension == 3\n\n        nodes = []\n        edges = []\n\n        # Setup start and goal trees\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # If we have a current best path, do ellipsoidal informed sampling to speed refinement\n            if success:\n                start_cost = best_cost\n                c_min = math.dist(start_pos, goal_pos)\n                if start_cost < float('inf') and start_cost > c_min:\n                    # Ellipsoid axes and center\n                    center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dimension))\n                    r1 = start_cost / 2.0\n                    axis_lengths = [r1] + [math.sqrt(start_cost**2 - c_min**2) / 2.0 for _ in range(dimension - 1)]\n                    # Rotation from x-axis to line start->goal in workspace frame\n                    def rotation_matrix(d):\n                        if d == 2:\n                            dx = goal_pos[0] - start_pos[0]\n                            dy = goal_pos[1] - start_pos[1]\n                            norm = math.sqrt(dx*dx + dy*dy)\n                            if norm == 0:\n                                return [[1,0],[0,1]]\n                            c = dx / norm\n                            s = dy / norm\n                            return [[c, -s], [s, c]]\n                        elif d == 3:\n                            # Use simpler approximation: identity\n                            return [[1, 0, 0],\n                                    [0, 1, 0],\n                                    [0, 0, 1]]\n                        else:\n                            return [[1]]\n\n                    R = rotation_matrix(dimension)\n\n                    for _ in range(50):\n                        # sample unit ball\n                        x_ball = [random.gauss(0,1) for _ in range(dimension)]\n                        norm = math.sqrt(sum(v*v for v in x_ball))\n                        unit_vector = [v / norm for v in x_ball]\n                        radius = random.random() ** (1.0 / dimension)\n                        sample_unit = [u * radius for u in unit_vector]\n                        # scale by axis\n                        scaled = [axis_lengths[i]*sample_unit[i] for i in range(dimension)]\n                        # rotate by R (only 2D handled precisely)\n                        if dimension == 2:\n                            x = R[0][0]*scaled[0] + R[0][1]*scaled[1]\n                            y = R[1][0]*scaled[0] + R[1][1]*scaled[1]\n                            sample = (x + center[0], y + center[1])\n                        else:\n                            sample = tuple(center[d] + scaled[d] for d in range(dimension))\n                        if (all(0 <= sample[d] <= bounds[d] for d in range(dimension))\n                                and not _is_in_obstacle(sample)):\n                            return sample\n            # Otherwise 15% goal bias\n            if random.random() < 0.15:\n                return goal_pos\n            # Uniform random sampling within bounds and collision free\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            # Linear search nearest node in tree\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            # Space scale factor (average)\n            scale = sum(bounds) / dimension\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 1.5, min(self.max_radius, r_theory * 0.8 + scale * 0.01))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            # Start with nearest node as default parent\n            nearest_node = nearest(tree, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Remove old edge \n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if new_pos == nearest_node.position:\n                return None\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if new_pos == nearest_node.position:\n                    return None\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position) and\n                        not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + dist_connect\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                # avoid duplicated node in connection\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        # Alternate expansion between the two trees\n        tree_primary = tree_a\n        tree_secondary = tree_b\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Return best path found so far on timeout\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_primary = extend_and_rewire(tree_primary, sample)\n            if new_node_primary is None:\n                tree_primary, tree_secondary = tree_secondary, tree_primary\n                continue\n\n            new_node_secondary = connect_and_rewire(tree_secondary, new_node_primary)\n            if new_node_secondary is not None:\n                update_best_path(new_node_primary, new_node_secondary)\n                # Early return after connecting trees\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            tree_primary, tree_secondary = tree_secondary, tree_primary\n\n        # No connection found after max_iter\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 2.29404,
    "time_improvement": 28.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 78.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018444633483886717,
            "num_nodes_avg": 87.7,
            "path_length_avg": 162.38486981390008,
            "smoothness_avg": 0.01294592918476816,
            "success_improvement": 0.0,
            "time_improvement": 28.68247354253476,
            "length_improvement": 10.994279702075547,
            "smoothness_improvement": 102.63190427680313,
            "objective_score": 15.71446940538977
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.035905861854553224,
            "num_nodes_avg": 305.0,
            "path_length_avg": 279.4524678906322,
            "smoothness_avg": 0.006064063529861537,
            "success_improvement": 0.0,
            "time_improvement": 78.14950516496894,
            "length_improvement": 6.7107226248078815,
            "smoothness_improvement": 56.03272239175139,
            "objective_score": 27.75144873633417
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.06068153381347656,
            "num_nodes_avg": 393.0,
            "path_length_avg": 134.21542218800113,
            "smoothness_avg": 0.013738794137780735,
            "success_improvement": -9.999999999999998,
            "time_improvement": -24.127107522093898,
            "length_improvement": 10.860507234341345,
            "smoothness_improvement": 74.75644734027473,
            "objective_score": -50.348045679321984
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* inspired planner with adaptive rewiring radius and goal bias sampling aimed at efficient convergence, path quality, and smoothness. The planner grows two trees alternately from start and goal with goal biased sampling, uses adaptive neighbor radius for rewiring, and returns the best path found within a 30-second time limit. Early success detection and consistent edge management maintain valid tree structure and improve path optimization.",
    "planning_mechanism": "The planner alternates sampling points with a goal bias, extends the trees towards samples by fixed step, rewires nodes adaptively within a shrinking radius, and attempts to connect the two trees when close. The extension incorporates collision checks for nodes and edges, and the algorithm terminates early once a connection forms or time expires, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.05, gamma: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # rewiring constant for radius calc\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(dim))\n\n        def add_node(tree, new_node, parent):\n            new_node.parent = parent\n            new_node.cost = parent.cost + dist(parent.position, new_node.position)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        old_parent = near_node.parent\n                        if old_parent:\n                            try:\n                                edges.remove((old_parent, near_node))\n                                old_parent.children.remove(near_node)\n                            except Exception:\n                                pass\n                        # Update parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n\n        def extract_path(node_start, node_goal):\n            path_from_start = node_start.path_from_root()\n            path_from_goal = node_goal.path_from_root()\n            return path_from_start + path_from_goal[-2::-1]\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            d = dist(nearest_node.position, node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(nearest_node.position, node.position):\n                new_node = Node(node.position)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + d\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                return new_node\n            return None\n\n        def radius_formula(n):\n            # Adaptive rewiring radius: gamma * (log(n)/n)^(1/dim)\n            if n <= 1:\n                return self.step_size * 2\n            return min(self.gamma * ((math.log(n) / n) ** (1/dim)), self.step_size * 10)\n\n        tree_a, tree_b = tree_start, tree_goal\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            add_node(tree_a, new_node, nearest_node)\n\n            radius = radius_formula(len(nodes))\n            rewire(tree_a, new_node, radius)\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                radius = radius_formula(len(nodes))\n                rewire(tree_b, connected_node, radius)\n\n                success = True\n                best_path = extract_path(new_node, connected_node)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -18.67683,
    "time_improvement": 71.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00797412395477295,
            "num_nodes_avg": 134.0,
            "path_length_avg": 194.43248133050582,
            "smoothness_avg": 0.010502394434753481,
            "success_improvement": 0.0,
            "time_improvement": 69.16746561451382,
            "length_improvement": -6.571523997077875,
            "smoothness_improvement": 64.38527921843476,
            "objective_score": 17.129251682199595
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01720106601715088,
            "num_nodes_avg": 297.8,
            "path_length_avg": 303.19790797984706,
            "smoothness_avg": 0.006680768861182183,
            "success_improvement": 0.0,
            "time_improvement": 89.53229960925944,
            "length_improvement": -1.2161887515687315,
            "smoothness_improvement": 71.90099476152727,
            "objective_score": 26.48948160564423
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02234034538269043,
            "num_nodes_avg": 315.0,
            "path_length_avg": 161.06558517019286,
            "smoothness_avg": 0.012649409006098155,
            "success_improvement": 0.0,
            "time_improvement": 54.30170796404502,
            "length_improvement": -6.9720925510639935,
            "smoothness_improvement": 60.8995488753184,
            "objective_score": 12.411754602951703
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner employing goal bias sampling and fixed-radius rewiring with streamlined tree management to improve planning speed and generalization while maintaining path quality. The planner grows two trees alternately from start and goal positions, samples free-space points with goal bias, extends toward samples by a fixed step size, and rewires nearby nodes within a fixed radius if an improved path is found. It attempts to connect the two trees to build a complete path and stops once found or after 30 seconds.",
    "planning_mechanism": "The planner alternates growing two trees by sampling points near the goal or randomly, extends the nearest tree node toward these samples by a fixed step, then rewires nearby nodes within a fixed radius to improve the path cost locally. It attempts to connect the two trees when new nodes get close. Collision checks on nodes and edges ensure safe expansions. The process continues until a path is found or the time limit is reached, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro, to, resolution=1.0):\n            distance = dist(fro, to)\n            steps = max(1, int(distance/resolution))\n            for i in range(steps+1):\n                interp = tuple(fro[d] + (to[d]-fro[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def add_node(tree, new_node, parent):\n            new_node.parent = parent\n            new_node.cost = parent.cost + dist(parent.position, new_node.position)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((parent, new_node))\n\n        def rewire(tree, new_node, radius):\n            nearby = near(tree, new_node.position, radius)\n            for node in nearby:\n                if node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, node.position)\n                if potential_cost < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    # Remove old edge\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, node))\n                            old_parent.children.remove(node)\n                        except Exception:\n                            pass\n                    # Add new edge\n                    node.parent = new_node\n                    node.cost = potential_cost\n                    new_node.children.append(node)\n                    edges.append((new_node, node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        # Alternate expansion flag\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            add_node(tree_a, new_node, nearest_node)\n            rewire(tree_a, new_node, self.rewire_radius)\n\n            connect_node = None\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(nearest_b.position, new_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(nearest_b.position, new_node.position):\n                    connect_node = Node(new_node.position)\n                    add_node(tree_b, connect_node, nearest_b)\n                    rewire(tree_b, connect_node, self.rewire_radius)\n\n            if connect_node:\n                success = True\n                best_path = extract_path(new_node, connect_node)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": -23.2589,
    "time_improvement": 75.0,
    "length_improvement": 0.0,
    "smoothness_improvement": 81.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007635235786437988,
            "num_nodes_avg": 120.8,
            "path_length_avg": 185.1974159725226,
            "smoothness_avg": 0.011504372472738552,
            "success_improvement": 0.0,
            "time_improvement": 70.47780154135476,
            "length_improvement": -1.5096383353920158,
            "smoothness_improvement": 80.06841134303598,
            "objective_score": 20.637899517886396
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019917678833007813,
            "num_nodes_avg": 297.3,
            "path_length_avg": 294.79133907010714,
            "smoothness_avg": 0.00699994740454174,
            "success_improvement": 0.0,
            "time_improvement": 87.87910619638126,
            "length_improvement": 1.5901659201721472,
            "smoothness_improvement": 80.11368857718102,
            "objective_score": 27.71839985390357
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01566154956817627,
            "num_nodes_avg": 244.3,
            "path_length_avg": 149.00452512865786,
            "smoothness_avg": 0.014282481898292926,
            "success_improvement": 0.0,
            "time_improvement": 67.96351830546715,
            "length_improvement": 1.0382892425619512,
            "smoothness_improvement": 81.67211552313378,
            "objective_score": 21.42038961479298
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner using fixed step size and goal bias sampling without rewiring or complex data structures, focusing on straightforward tree expansion and connection to enhance generalization and reduce complexity. It alternates expansion between two trees grown from start and goal, samples points with goal bias, extends toward samples within step size, checks collisions for nodes and edges, and attempts to connect the two trees. The search stops upon connection or after a 30-second limit, returning the best path found.",
    "planning_mechanism": "The planner alternately grows two trees by sampling random points biased towards the goal, extends nearest tree nodes toward samples by a fixed step size while avoiding obstacles, and attempts to connect opposing trees when nodes get sufficiently close. No rewiring or complex data handling is performed. Collision checks enforce safety of nodes and edges. The algorithm runs until success or time expires, returning the constructed path if found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro, to, resolution=1.0):\n            distance = dist(fro, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fro[d] + (to[d] - fro[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(nearest_b.position, new_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(nearest_b.position, new_node.position):\n                    # connect trees\n                    connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist(nearest_b.position, new_node.position))\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((nearest_b, connect_node))\n\n                    # extract path\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    best_path = path_start + path_goal[-2::-1]\n                    success = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": -16.87703,
    "time_improvement": 67.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008156800270080566,
            "num_nodes_avg": 143.4,
            "path_length_avg": 192.35882596423605,
            "smoothness_avg": 0.01059184965373379,
            "success_improvement": 0.0,
            "time_improvement": 68.46113426011283,
            "length_improvement": -5.434920631653378,
            "smoothness_improvement": 65.78544765059377,
            "objective_score": 17.60631513729479
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018184375762939454,
            "num_nodes_avg": 328.3,
            "path_length_avg": 308.9928154929928,
            "smoothness_avg": 0.006518327384456376,
            "success_improvement": 0.0,
            "time_improvement": 88.93390693987794,
            "length_improvement": -3.150695676621227,
            "smoothness_improvement": 67.72125856350583,
            "objective_score": 25.128360968808174
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028204703330993654,
            "num_nodes_avg": 352.1,
            "path_length_avg": 163.40864994837463,
            "smoothness_avg": 0.012918435127118716,
            "success_improvement": 0.0,
            "time_improvement": 42.305870946566436,
            "length_improvement": -8.52824461197727,
            "smoothness_improvement": 64.32154127725727,
            "objective_score": 7.896422223169854
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An optimized bidirectional RRT* planner with adaptive goal biasing, dynamic rewiring radius, and incremental rewiring embedded in balanced tree growth. It integrates efficient pruning of suboptimal nodes and early best-path tracking, enabling swift initial solution discovery and focused ellipsoidal-informed sampling refinement under a strict 30-second time limit. This design leads to significantly reduced planning time while ensuring high path quality and smoothness.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling with an adaptive goal bias that intensifies after first solution, uses dynamic rewiring radii based on tree size and workspace dimension for neighbor selection, performs local incremental rewiring to reduce unnecessary computations, prunes nodes far from current best path to maintain efficiency, and switches to ellipsoidal informed sampling refinement upon initial path discovery. It maintains continuous collision checking and balanced expansion, halting promptly at 30 seconds while returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_base = 0.15       # Base goal bias probability\n        self.gamma_rrt_star = 50.0         # Adaptive radius factor\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        steps = max(1, int(math.dist(p1, p2) / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d]-p1[d]) * (i / steps) for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_p, to_p):\n        dist = math.dist(from_p, to_p)\n        if dist <= self.step_size:\n            return to_p\n        ratio = self.step_size / dist\n        return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(len(from_p)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _path_cost(self, node):\n        return node.cost\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connection node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        while True:\n            # Sample random unit vector in dim-d\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        # Adaptive goal bias: increase after first solution found\n        current_goal_bias = self.goal_sample_base\n\n        # Phase 1: Bidirectional RRT* with rewiring and path searching\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            bias_goal = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, bias_goal, current_goal_bias)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect directly without duplicate node\n                # We select the better root side to reconstruct path\n                connect_node = nearest_other\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                    current_goal_bias = min(0.6, 2*current_goal_bias)  # Increase goal bias to speed up refinement\n                    # Prune nodes far from best path to improve speed\n                    set_best = set(best_path)\n                    def close_to_path(node):\n                        d_min = min(self._dist(node.position, p) for p in best_path)\n                        return d_min <= self.step_size*8\n                    tree_start[:] = [n for n in tree_start if close_to_path(n) or n == start_root]\n                    tree_goal[:] = [n for n in tree_goal if close_to_path(n) or n == goal_root]\n                    # Remove pruned nodes from global\n                    nodes[:] = [n for n in nodes if n in tree_start or n in tree_goal]\n                    edges[:] = [(p,c) for p,c in edges if p in nodes and c in nodes]\n            if found_solution and it - self.max_iter//4 > 0:\n                # Early stop if enough time after initial solution\n                break\n\n        # Phase 2: Single tree informed refinement with ellipsoidal sampling\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                nnode = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nnode)\n                tree.append(nnode)\n                nodes.append(nnode)\n                edges.append((prev, nnode))\n                prev = nnode\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 3\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 53.37434,
    "time_improvement": -109.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 312.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.09546933174133301,
            "num_nodes_avg": 79.8,
            "path_length_avg": 152.49529078606315,
            "smoothness_avg": 0.026756989405374382,
            "success_improvement": -9.999999999999998,
            "time_improvement": -269.1391644234669,
            "length_improvement": 16.414914677641022,
            "smoothness_improvement": 318.80498792658534,
            "objective_score": -119.29877558082251
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05498735904693604,
            "num_nodes_avg": 92.4,
            "path_length_avg": 244.36015213592532,
            "smoothness_avg": 0.01368113483714405,
            "success_improvement": 0.0,
            "time_improvement": 66.53746929361866,
            "length_improvement": 18.425547700032833,
            "smoothness_improvement": 252.02545348283297,
            "objective_score": 32.27669667551946
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.10984148979187011,
            "num_nodes_avg": 75.4,
            "path_length_avg": 119.27048889845426,
            "smoothness_avg": 0.03668586159893248,
            "success_improvement": -9.999999999999998,
            "time_improvement": -124.686252257428,
            "length_improvement": 20.78622032400975,
            "smoothness_improvement": 366.6414516697935,
            "objective_score": -73.10093622447357
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "time_expert",
    "algorithm_description": "An efficient and robust bidirectional RRT* planner with adaptive goal bias, dynamic neighbor radius scaling, incremental rewiring, and ellipsoidal informed sampling for focused refinement. It balances exploration and exploitation by alternating tree expansions, prunes irrelevant nodes after initial solution to maintain efficiency, and aggressively updates the best path while respecting a 30-second time limit to return high-quality, smooth, and short paths.",
    "planning_mechanism": "The planner grows two trees from start and goal with adaptive goal bias and dynamic radius, connecting and rewiring incrementally to optimize path cost. After the first feasible path is found, it prunes distant nodes and switches to ellipsoidal informed sampling to concentrate refinement within the prolate hyperspheroid containing the current best path, iteratively improving path quality without excessive rewiring overhead. Early time checks ensure prompt termination with the best solution so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child:'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float,...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter:int=8000, step_size:float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_base = 0.15      # Starting probability for goal bias sampling\n        self.gamma_rrt_star = 50.0        # Radius scaling factor\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(len(p1)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_p, to_p):\n        dist = math.dist(from_p, to_p)\n        if dist <= self.step_size:\n            return to_p\n        ratio = self.step_size / dist\n        return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(len(from_p)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree:List[Node], point:Tuple[float, ...]) -> Node:\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = self._dist(n.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree:List[Node], point:Tuple[float, ...], radius:float) -> List[Node]:\n        return [n for n in tree if self._dist(n.position, point) <= radius]\n\n    def _build_path(self, node_start:Node, node_goal:Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # degenerate case fallback\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos, goal_pos = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds)==3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic()-time_start > time_limit\n\n        current_goal_bias = self.goal_sample_base\n\n        iter_count = 0\n\n        # Phase 1: Bidirectional RRT* with rewiring\n        while iter_count < self.max_iter and not time_exceeded():\n            expand_start_tree = (iter_count % 2 ==0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            bias_goal = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, bias_goal, current_goal_bias)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n\n            n_nodes = len(tree_a)+1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*15)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees\n                if expand_start_tree:\n                    path = self._build_path(new_node, nearest_other)\n                    total_cost = new_node.cost + nearest_other.cost\n                else:\n                    path = self._build_path(nearest_other, new_node)\n                    total_cost = nearest_other.cost + new_node.cost\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = nearest_other if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                    current_goal_bias = min(0.6, 2*current_goal_bias)\n\n                    # Prune trees to nodes near best path to improve performance\n                    dist_bound = self.step_size * 8\n                    def near_path(n:Node) -> bool:\n                        return any(self._dist(n.position,p) <= dist_bound for p in best_path)\n                    tree_start[:] = [n for n in tree_start if near_path(n) or n == start_root]\n                    tree_goal[:] = [n for n in tree_goal if near_path(n) or n == goal_root]\n\n                    # Update nodes and edges accordingly\n                    nodes[:] = [n for n in nodes if n in tree_start or n in tree_goal]\n                    edges[:] = [(p,c) for p,c in edges if p in nodes and c in nodes]\n\n            # Early stop limit after initial solution and time margin\n            if found_solution and iter_count > self.max_iter//4:\n                break\n\n            iter_count += 1\n\n        # Phase 2: Refinement using ellipsoidal informed sampling on single tree from start_root\n        if found_solution and best_goal_node is not None:\n            # Rebuild tree with best path nodes, disconnected from old trees\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                nnode = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nnode)\n                tree.append(nnode)\n                nodes.append(nnode)\n                edges.append((prev, nnode))\n                prev = nnode\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 3\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree)+1\n                radius = min(self.gamma_rrt_star*((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cand_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cand_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cand_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_this_iter = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_this_iter = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count +=1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_this_iter:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 44.70321,
    "time_improvement": -82.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 307.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.09075837135314942,
            "num_nodes_avg": 78.0,
            "path_length_avg": 150.2656660378966,
            "smoothness_avg": 0.028129428233728233,
            "success_improvement": -19.999999999999996,
            "time_improvement": -250.92389099893063,
            "length_improvement": 17.637007332776157,
            "smoothness_improvement": 340.2866358889402,
            "objective_score": -162.99352972056877
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05405073165893555,
            "num_nodes_avg": 89.9,
            "path_length_avg": 240.5062338725716,
            "smoothness_avg": 0.014194289693012046,
            "success_improvement": 0.0,
            "time_improvement": 67.10745343678603,
            "length_improvement": 19.712096545226892,
            "smoothness_improvement": 265.2292975348194,
            "objective_score": 33.28564044584604
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07893447875976563,
            "num_nodes_avg": 76.6,
            "path_length_avg": 119.30440856566311,
            "smoothness_avg": 0.032694857443585364,
            "success_improvement": 0.0,
            "time_improvement": -61.46441786278448,
            "length_improvement": 20.763692496130616,
            "smoothness_improvement": 315.8761733990618,
            "objective_score": -4.401728994161666
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, balanced goal-biased tree expansions, ellipsoidal informed sampling refinement, and recursive cost propagation for incremental path improvement. It employs efficient incremental rewiring during both bidirectional growth and single-tree refinement phases under a strict 30-second limit, always enforcing collision-free nodes and edges. The planner dynamically balances exploration and exploitation for faster convergence, better path quality, and enhanced smoothness.",
    "planning_mechanism": "The planner alternately expands two trees from start and goal with goal-biased sampling, uses adaptive logarithmic neighbor radius for rewiring, attempts connection to merge trees, and then refines the path using ellipsoidal informed samples with recursive cost updates until time expires, returning the best collision-free path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Cost from root\n        self.children = []               # List[Node]\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15     # Probability to sample goal/start in respective trees\n        self.gamma_rrt_star = 40.0       # Adaption parameter for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0           # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        # Propagate cost updates recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                         self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive cost updates\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n\n            # Attempt connection\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adopting new_node position in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Early exit on first found solution to refine later\n                if found_solution:\n                    break\n\n        # Refinement phase\n        if found_solution and best_goal_node is not None:\n            # Reconstruct single tree from best path (start to goal)\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                             self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.41658,
    "time_improvement": 42.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 216.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025189828872680665,
            "num_nodes_avg": 111.2,
            "path_length_avg": 164.23961870298234,
            "smoothness_avg": 0.022259303009276386,
            "success_improvement": 0.0,
            "time_improvement": 2.6016814779305992,
            "length_improvement": 9.977662445592637,
            "smoothness_improvement": 248.4064289453182,
            "objective_score": 8.009134055461354
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0332127571105957,
            "num_nodes_avg": 114.7,
            "path_length_avg": 258.74349057657577,
            "smoothness_avg": 0.010733412225408526,
            "success_improvement": 0.0,
            "time_improvement": 79.7883927520825,
            "length_improvement": 13.623975327101634,
            "smoothness_improvement": 176.17842752409942,
            "objective_score": 32.99179515950623
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02702016830444336,
            "num_nodes_avg": 94.5,
            "path_length_avg": 128.70631973867714,
            "smoothness_avg": 0.025448376165527135,
            "success_improvement": 0.0,
            "time_improvement": 44.7288964926287,
            "length_improvement": 14.519390765914297,
            "smoothness_improvement": 223.70146642177033,
            "objective_score": 23.24881073944604
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm refines bidirectional RRT* by integrating goal-biased sampling, adaptive logarithmically shrinking neighbor radius for rewiring, and early incremental best-path updates. It balances tree expansions, utilizes efficient collision checks, and incorporates dynamic rewiring to improve planning time, path smoothness, and cost. The planner halts immediately upon a valid path or when the 30-second time limit is reached, returning the best solution found.",
    "planning_mechanism": "A bidirectional planner alternately grows two trees from start and goal using goal-biased samples. Each extension steers with fixed steps, chooses optimal parents within an adaptive neighborhood radius, and rewires neighbors to locally optimize paths. It attempts to connect the two trees at each iteration, updating and tracking the best path by cost. Incremental rewiring and goal biasing accelerate convergence, and strict consistency of parent-child and edges maintains path validity. The algorithm respects map boundaries and obstacle constraints, and enforces early termination on timeout or successful connection.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma_rrt_star=50.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dimension = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dimension == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dimension))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias to enhance convergence\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dimension))\n                if not _is_in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dimension))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            scale = max(1.0, sum(bounds) / dimension)\n            r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dimension))\n            radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def choose_parent(new_pos, tree):\n            neighbors = near_nodes(tree, new_pos)\n            nearest_node = nearest(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if not _is_edge_in_obstacle(nb.position, new_pos):\n                    cost_to_new = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_to_new < min_cost:\n                        min_cost = cost_to_new\n                        best_parent = nb\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(pivot, neighbors):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                if not _is_edge_in_obstacle(pivot.position, nb.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((pivot, nb))\n\n        def extend_and_rewire(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if _is_in_obstacle(new_pos):\n                return None\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node, neighbors = choose_parent(new_pos, tree)\n            rewire(new_node, neighbors)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if _is_in_obstacle(new_pos):\n                    return None\n                if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                connect_node, neighbors = choose_parent(new_pos, tree)\n                rewire(connect_node, neighbors)\n                if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                    if (not _is_edge_in_obstacle(connect_node.position, target_node.position)\n                            and not _is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position, parent=None,\n                                         cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                        connect_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = connect_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            connect_dist = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + node_b.cost + connect_dist\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Time limit reached: return best path found\n                return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b is not None:\n                update_best_path(new_node_a, new_node_b)\n                # Early termination on connection\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # End of iterations: return best available path\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 1.26573,
    "time_improvement": -33.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 181.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027007746696472167,
            "num_nodes_avg": 114.4,
            "path_length_avg": 162.3602534286026,
            "smoothness_avg": 0.017185160995433314,
            "success_improvement": 0.0,
            "time_improvement": -4.427430952468747,
            "length_improvement": 11.007772332928688,
            "smoothness_improvement": 168.98508775293104,
            "objective_score": 6.121359552781243
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05060133934020996,
            "num_nodes_avg": 281.0,
            "path_length_avg": 258.2118047478927,
            "smoothness_avg": 0.010853935606003383,
            "success_improvement": 0.0,
            "time_improvement": 69.20657946109982,
            "length_improvement": 13.80146736044408,
            "smoothness_improvement": 179.27958091628727,
            "objective_score": 29.939252159177833
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12834506034851073,
            "num_nodes_avg": 333.2,
            "path_length_avg": 130.65665794387155,
            "smoothness_avg": 0.023091575071760274,
            "success_improvement": 0.0,
            "time_improvement": -162.53622979897614,
            "length_improvement": 13.224068995149436,
            "smoothness_improvement": 193.72313047001697,
            "objective_score": -39.85781189025309
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that alternates tree growth from start and goal, uses uniform random sampling without goal bias, extends nearest nodes toward samples with a fixed step size, attempts direct connection between trees when close, and returns the first feasible path found within 30 seconds. The planner employs straightforward collision checking and data structures for easy generalization and efficiency.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples free points uniformly within map bounds, extends the nearest node in the active tree towards the sample by a fixed step size, alternates tree expansions each iteration, attempts to connect the opposite tree directly when close enough, and stops upon finding a valid path or after 30 seconds, returning the best found solution.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node,\n                            cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist <= self.step_size:\n                if not is_edge_in_obstacle(nearest_node.position, node.position):\n                    final_node = Node(node.position, parent=nearest_node,\n                                      cost=nearest_node.cost + dist)\n                    nearest_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((nearest_node, final_node))\n                    return final_node\n            return None\n\n        tree_a, tree_b = tree_start, tree_goal\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                best_path = path_from_start + path_from_goal[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -21.21319,
    "time_improvement": 82.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 64.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0060777425765991214,
            "num_nodes_avg": 131.7,
            "path_length_avg": 187.13568301236717,
            "smoothness_avg": 0.010669481346440253,
            "success_improvement": 0.0,
            "time_improvement": 76.49996312548399,
            "length_improvement": -2.572033213737533,
            "smoothness_improvement": 67.00055222136885,
            "objective_score": 21.74177177050952
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.010755228996276855,
            "num_nodes_avg": 286.5,
            "path_length_avg": 307.77318465673557,
            "smoothness_avg": 0.006562217257628354,
            "success_improvement": 0.0,
            "time_improvement": 93.45491060527426,
            "length_improvement": -2.743547798351396,
            "smoothness_improvement": 68.85057661281866,
            "objective_score": 26.734597385635535
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011401820182800292,
            "num_nodes_avg": 279.8,
            "path_length_avg": 170.93021914681088,
            "smoothness_avg": 0.012175197324815262,
            "success_improvement": 0.0,
            "time_improvement": 76.677007471032,
            "length_improvement": -13.523712734941975,
            "smoothness_improvement": 54.86761129206529,
            "objective_score": 15.16321265680474
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional RRT* planner employing adaptive rewiring with recursive cost propagation, goal-biased and ellipsoidal informed sampling for efficient path discovery and refinement within a 30-second time limit. The planner uses balanced tree expansion, accelerated nearest/neighbor search with early pruning, consistent edge management to maintain valid smooth paths, and an iterative refinement phase focusing sampling inside informed ellipsoids to optimize path smoothness and length while minimizing planning time.",
    "planning_mechanism": "The planner alternates growth between two trees starting from start and goal, using goal bias sampling and adaptive rewiring with recursive cost updates to improve cost and smoothness during expansion. Upon first feasible path discovery, it switches to a single informed RRT* refinement sampling inside an ellipsoidal region defined by the current best cost, performing incremental rewiring and edge validation with early exits to improve the path efficiently within a strict time budget.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        cost_diff = new_cost - self.cost\n        if cost_diff >= -1e-10:\n            return  # no improvement\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # Increased goal bias for faster convergence\n        self.gamma_rrt_star = 35.0   # Adaptive radius denominator\n        self.time_limit = 30.0       # Hard time limit\n        self.improve_tol = 1e-8      # Improvement tolerance for rewiring\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        # Early prune: given cost-based ordering could be used, but simple linear search with early pruning\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        results = []\n        radius_sq = radius * radius\n        for node in tree:\n            d_sq = sum((node.position[d] - point[d])**2 for d in range(len(point)))\n            if d_sq <= radius_sq:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node: Node, goal_node: Node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]  # avoid duplicate connecting node\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            # No solution yet or degenerate c_best\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            # Align first dimension with a1 direction\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def timed_out():\n            return (time.monotonic() - time_start) > time_limit\n\n        # Alternate expansions, balanced bidirectional growth\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1/dim)), self.step_size * 12)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Parent selection with collision checking\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring with recursive cost propagation and early pruning\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to opposite tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n                    not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect new_node to nearest_node_other with a new connecting node to avoid cycle\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                # Build path and cost accounting\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                    break  # early break on first solution\n\n            if found_solution:\n                break\n\n        # Refinement phase using single tree and informed sampling inside ellipsoid\n        if found_solution and best_goal_node:\n            # Rebuild tree along best path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos,\n                                                             bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 12)\n\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                    not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -16.10372,
    "time_improvement": 36.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 180.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01814589500427246,
            "num_nodes_avg": 83.5,
            "path_length_avg": 171.00286282648258,
            "smoothness_avg": 0.021156066220707693,
            "success_improvement": 0.0,
            "time_improvement": 29.837567756923196,
            "length_improvement": 6.270621171040864,
            "smoothness_improvement": 231.138377487187,
            "objective_score": 13.869334917137412
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03453171253204346,
            "num_nodes_avg": 95.4,
            "path_length_avg": 275.8258032829333,
            "smoothness_avg": 0.009132420669392393,
            "success_improvement": 0.0,
            "time_improvement": 78.98574306940051,
            "length_improvement": 7.92140765861057,
            "smoothness_improvement": 134.9837616401971,
            "objective_score": 29.12348632418748
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0491445779800415,
            "num_nodes_avg": 70.4,
            "path_length_avg": 139.0214538476142,
            "smoothness_avg": 0.02162775761567572,
            "success_improvement": 0.0,
            "time_improvement": -0.5276882718111559,
            "length_improvement": 7.668569844661061,
            "smoothness_improvement": 175.1034804763868,
            "objective_score": 5.318352827635223
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, recursive cost propagation, consistent edge management, balanced goal-biased tree expansion, and an informed sampling refinement phase. The planner efficiently searches for an initial feasible path by alternately growing two trees rooted at start and goal positions, attempts direct connections between trees, and upon finding a solution, switches to a single-tree RRT* refinement stage using ellipsoidal informed sampling to improve path quality and smoothness. It enforces collision checks, respects map bounds, updates node costs recursively for accurate path cost information, and respects a hard 30-second time limit.",
    "planning_mechanism": "A bidirectional search grows two trees alternately with goal bias; new nodes are connected via adaptive radius-based rewiring with recursive cost updates, and consistent edge/parent management ensures path validity. Upon first feasible path discovery, the planner extracts and reconstructs the path and switches to a single-tree informed RRT* refinement phase using ellipsoidal sampling restricted around the current best solution to efficiently optimize path length and smoothness until the time budget expires.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        cost_diff = new_cost - self.cost\n        if cost_diff >= -1e-10:\n            return\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.gamma_rrt_star = 35.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            # no current solution: uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n\n        while True:\n            # Sample uniformly distributed point inside unit ball\n            dir_vec = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in dir_vec]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        r2 = radius * radius\n        results = []\n        for node in tree:\n            d2 = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n            if d2 <= r2:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # skip duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_sample)\n\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring around new node with recursive update\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connect to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                if found_solution:\n                    break\n            if found_solution:\n                break\n\n        # Refinement phase with informed sampling in single tree\n        if found_solution and best_goal_node:\n            # reconstruct single tree along path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_cnt = 0\n            max_no_improve = 100\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_cnt >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos,\n                                                             bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_cnt = 0\n                        success_state = True\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n\n                if not rewired:\n                    no_improve_cnt += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.08867,
    "time_improvement": 46.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 191.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018129134178161622,
            "num_nodes_avg": 87.7,
            "path_length_avg": 159.48195642085585,
            "smoothness_avg": 0.020940157469454417,
            "success_improvement": 0.0,
            "time_improvement": 29.90237471883181,
            "length_improvement": 12.585412532409453,
            "smoothness_improvement": 227.75893667671562,
            "objective_score": 17.66075461847879
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03702964782714844,
            "num_nodes_avg": 96.4,
            "path_length_avg": 278.5975049247853,
            "smoothness_avg": 0.008970522958574359,
            "success_improvement": 0.0,
            "time_improvement": 77.46562575582567,
            "length_improvement": 6.996133871552073,
            "smoothness_improvement": 130.8180169306414,
            "objective_score": 28.09145813433215
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03448476791381836,
            "num_nodes_avg": 68.8,
            "path_length_avg": 131.4723237466879,
            "smoothness_avg": 0.024630470147202644,
            "success_improvement": 0.0,
            "time_improvement": 29.459685250039865,
            "length_improvement": 12.682342606750513,
            "smoothness_improvement": 213.29776224022515,
            "objective_score": 17.51379995026339
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with balanced alternating expansions, dynamic goal bias sampling, adaptive neighborhood radius based on node count and dimensionality, and ellipsoidal informed sampling after an initial solution. It performs local rewiring on nearby nodes to improve path cost, prunes redundant nodes, and continuously updates the best solution within a 30-second time constraint. The approach avoids duplicate nodes and edges, includes efficient collision checks, and returns the best feasible path found.",
    "planning_mechanism": "The planner alternates expansions growing two trees from start and goal with goal-biased samples, rewiring neighbors within a radius that logarithmically shrinks with the node count. Upon discovering an initial path, it switches to ellipsoidal informed sampling focusing around the best path to further optimize solution quality. The planner performs efficient collision checks on nodes and edges, maintains coherent graph data structures, and returns early upon timeout or solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        # Bidirectional RRT* expansion with rewiring until initial solution or timeout\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase with informed sampling if solution found\n        if found_solution and best_goal_node:\n            # Rebuild single tree along best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= 150:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -22.77866,
    "time_improvement": 55.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 127.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01619422435760498,
            "num_nodes_avg": 103.9,
            "path_length_avg": 166.98336774906028,
            "smoothness_avg": 0.01702685036355233,
            "success_improvement": 0.0,
            "time_improvement": 37.38384527453077,
            "length_improvement": 8.473770115951433,
            "smoothness_improvement": 166.50718258695417,
            "objective_score": 17.13195156486486
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031371259689331056,
            "num_nodes_avg": 129.6,
            "path_length_avg": 273.34460819507376,
            "smoothness_avg": 0.007209358895801632,
            "success_improvement": 0.0,
            "time_improvement": 80.90903511557903,
            "length_improvement": 8.74970199617885,
            "smoothness_improvement": 85.50199708029848,
            "objective_score": 29.95004171778251
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025326037406921388,
            "num_nodes_avg": 98.4,
            "path_length_avg": 135.12326185862528,
            "smoothness_avg": 0.01794263880458675,
            "success_improvement": 0.0,
            "time_improvement": 48.19432583921699,
            "length_improvement": 10.257563351792395,
            "smoothness_improvement": 128.22904120651125,
            "objective_score": 21.25398096887309
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm simplifies a bidirectional RRT* inspired planner focusing on balanced tree growth, goal-biased sampling, and adaptive rewiring within a fixed radius to improve planning time and path quality while enforcing early termination. It uses efficient nearest neighbor search and collision checks, with consistent parent-child-edge management, ensuring robust path extraction and progressive path optimization.",
    "planning_mechanism": "The planner alternates expansion between two trees rooted at start and goal, samples with goal bias, extends towards samples using fixed step size, selects the lowest-cost parent in a neighborhood defined by an adaptive radius, and rewires neighbors to reduce overall cost. It attempts to connect the two trees each iteration, updating the best path found, and stops early on success or when the 30-second timer expires, returning the best path so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Accumulated path cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=30.0, max_radius=60.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n\n        nodes.extend([start_root, goal_root])\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, res=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # 15% goal bias\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            r = min(self.max_radius, self.gamma * ((math.log(n) / n) ** (1/dim)))\n            # Minimal radius to ensure connectivity\n            r = max(r, self.step_size * 2.0)\n            return [node for node in tree if math.dist(node.position, pos) <= r]\n\n        def choose_parent(new_pos, tree):\n            near = near_nodes(tree, new_pos)\n            min_cost = float('inf')\n            best_parent = None\n            for n in near:\n                if not edge_in_obstacle(n.position, new_pos) and not in_obstacle(new_pos):\n                    cost = n.cost + math.dist(n.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = n\n            if best_parent is None:\n                return None, []\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, near\n\n        def rewire(pivot, neighbors):\n            for nbr in neighbors:\n                if nbr == pivot.parent:\n                    continue\n                if not edge_in_obstacle(pivot.position, nbr.position):\n                    new_cost = pivot.cost + math.dist(pivot.position, nbr.position)\n                    if new_cost + 1e-12 < nbr.cost:\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        pivot.add_child(nbr)\n                        nbr.cost = new_cost\n                        edges.append((pivot, nbr))\n\n        def extend_and_rewire(tree, sample_pt):\n            nn = nearest(tree, sample_pt)\n            new_pos = steer(nn.position, sample_pt)\n            if in_obstacle(new_pos) or edge_in_obstacle(nn.position, new_pos):\n                return None\n            new_node, near = choose_parent(new_pos, tree)\n            if new_node is None:\n                return None\n            rewire(new_node, near)\n            return new_node\n\n        def connect_and_rewire(tree, target_node):\n            nn = nearest(tree, target_node.position)\n            curr = nn\n            while True:\n                new_pos = steer(curr.position, target_node.position)\n                if in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                new_node, near = choose_parent(new_pos, tree)\n                if new_node is None:\n                    return None\n                rewire(new_node, near)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not edge_in_obstacle(new_node.position, target_node.position) and\n                        not in_obstacle(target_node.position)):\n                        final_cost = new_node.cost + math.dist(new_node.position, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr = new_node\n\n        def update_best_path(node_a, node_b):\n            nonlocal best_cost, best_path, success\n            dist_connect = math.dist(node_a.position, node_b.position)\n            total_cost = node_a.cost + dist_connect + node_b.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            new_node_a = extend_and_rewire(tree_a, sample)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = connect_and_rewire(tree_b, new_node_a)\n            if new_node_b:\n                update_best_path(new_node_a, new_node_b)\n                # Early success termination\n                return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -14.39238,
    "time_improvement": 28.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 195.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.036160516738891604,
            "num_nodes_avg": 137.5,
            "path_length_avg": 170.255310755654,
            "smoothness_avg": 0.020132973038704545,
            "success_improvement": 0.0,
            "time_improvement": -39.817286773111114,
            "length_improvement": 6.680366306782619,
            "smoothness_improvement": 215.12474750643372,
            "objective_score": -6.8613425103315935
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05319945812225342,
            "num_nodes_avg": 290.3,
            "path_length_avg": 264.8651999509727,
            "smoothness_avg": 0.010833701156430713,
            "success_improvement": 0.0,
            "time_improvement": 67.62549553508794,
            "length_improvement": 11.580372534293478,
            "smoothness_improvement": 178.75893395449754,
            "objective_score": 28.12966685087495
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021524524688720702,
            "num_nodes_avg": 169.1,
            "path_length_avg": 140.13346946776824,
            "smoothness_avg": 0.022950571903377823,
            "success_improvement": 0.0,
            "time_improvement": 55.97050993122008,
            "length_improvement": 6.930022018248291,
            "smoothness_improvement": 191.92958057596346,
            "objective_score": 21.908814093194813
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified single-tree RRT* planner with goal-biased sampling and radius-based rewiring to improve planning efficiency and path quality. It maintains efficient parent-child relationships and collision checks, and terminates early either upon success or when the 30-second time limit is exceeded.",
    "planning_mechanism": "The planner samples points biased toward the goal, extends the tree incrementally by fixed steps toward these samples, chooses the best parent within a radius to minimize path cost, rewires neighbors to improve path quality, and continuously updates the best path to the goal. It returns the best found solution within the time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=20.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, None, 0.0)\n        nodes.append(start_node)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            n = max(1, len(tree))\n            r = min(self.max_radius, self.gamma * ((math.log(n) / n) ** (1/dim)))\n            r = max(r, self.step_size * 2)\n            return [node for node in tree if math.dist(node.position, pos) <= r]\n\n        def choose_parent(new_pos):\n            near = near_nodes(nodes, new_pos)\n            min_cost = float('inf')\n            best_parent = None\n            for node in near:\n                if not edge_in_obstacle(node.position, new_pos) and not in_obstacle(new_pos):\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = node\n            if best_parent is None:\n                return None\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(new_node):\n            near = near_nodes(nodes, new_node.position)\n            for nbr in near:\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost + 1e-12 < nbr.cost:\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        new_node.add_child(nbr)\n                        nbr.cost = new_cost\n                        edges.append((new_node, nbr))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = choose_parent(new_pos)\n            if new_node is None:\n                continue\n            rewire(new_node)\n\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    path = goal_node.path_from_root()\n                    cost = goal_node.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = path\n                        success = True\n                        break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 134.4954,
    "time_improvement": -482.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 172.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11293263435363769,
            "num_nodes_avg": 290.1,
            "path_length_avg": 168.4596958334741,
            "smoothness_avg": 0.015282245776680362,
            "success_improvement": 0.0,
            "time_improvement": -336.6623031822707,
            "length_improvement": 7.664571298968681,
            "smoothness_improvement": 139.20033233291093,
            "objective_score": -95.70394651363544
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6912359714508056,
            "num_nodes_avg": 973.0,
            "path_length_avg": 237.69305750446475,
            "smoothness_avg": 0.011163575271782331,
            "success_improvement": 0.0,
            "time_improvement": -320.65131551933985,
            "length_improvement": 20.65121578969306,
            "smoothness_improvement": 187.24683254121615,
            "objective_score": -82.86843101928002
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4350991725921631,
            "num_nodes_avg": 581.1,
            "path_length_avg": 122.609070469457,
            "smoothness_avg": 0.022798227255712025,
            "success_improvement": 0.0,
            "time_improvement": -790.0170840297242,
            "length_improvement": 18.56889341072031,
            "smoothness_improvement": 189.9917679025667,
            "objective_score": -224.91383032297222
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a streamlined RRT* planner with goal-biased sampling, simplified rewiring, and radius-based neighbor search. It maintains parent-child relationships and avoids recursive rewiring propagation for efficiency. The planner terminates early on success or 30-second timeout, returning the best found path.",
    "planning_mechanism": "The planner samples within map bounds biased towards the goal, extends the tree by fixed steps, selects the best parent node within a dynamically computed radius, rewires nearby nodes to improve path cost locally, and tracks the best path to the goal, all while enforcing collision checks and timing constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=20.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time, math, random\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < 0.15:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest_node(nodes, point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes, pos):\n            n = len(nodes)\n            radius = min(self.max_radius, self.gamma * ((math.log(max(n,1)) / max(n,1)) ** (1/dim)))\n            radius = max(radius, self.step_size*2)\n            return [node for node in nodes if math.dist(node.position, pos) <= radius]\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, None, 0.0)\n        nodes.append(start_node)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            near = near_nodes(nodes, new_pos)\n\n            # Choose best parent among near nodes\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near:\n                if not edge_in_obstacle(node.position, new_pos) and not in_obstacle(new_pos):\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = node\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes locally (no recursion)\n            for node in near:\n                if node is best_parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, node.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                    if new_cost < node.cost:\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.children.remove(node)\n                            except Exception:\n                                pass\n                        new_node.add_child(node)\n                        node.cost = new_cost\n                        edges.append((new_node, node))\n\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, new_node, new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    path = goal_node.path_from_root()\n                    cost = goal_node.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = path\n                        success = True\n                        break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 141.93603,
    "time_improvement": -508.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 170.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12455651760101319,
            "num_nodes_avg": 316.6,
            "path_length_avg": 169.86021998535563,
            "smoothness_avg": 0.014995986547503398,
            "success_improvement": 0.0,
            "time_improvement": -381.60689922194774,
            "length_improvement": 6.896921818597044,
            "smoothness_improvement": 134.71975377442584,
            "objective_score": -109.67031790655396
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6792416334152221,
            "num_nodes_avg": 999.9,
            "path_length_avg": 233.42145687878005,
            "smoothness_avg": 0.011178963070926353,
            "success_improvement": 0.0,
            "time_improvement": -313.35216691909824,
            "length_improvement": 22.07719902975341,
            "smoothness_improvement": 187.64277169657558,
            "objective_score": -79.82111679939453
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4549018383026123,
            "num_nodes_avg": 599.6,
            "path_length_avg": 120.68366762323141,
            "smoothness_avg": 0.022517082590421882,
            "success_improvement": 0.0,
            "time_improvement": -830.5244255781528,
            "length_improvement": 19.84765430335227,
            "smoothness_improvement": 186.41562851201664,
            "objective_score": -236.3166569488744
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner featuring adaptive rewiring radius, balanced goal-biased tree extension, ellipsoidal informed sampling refinement, and integrated caching for nearest neighbor queries to improve runtime. It concurrently grows two trees with dynamic goal biasing, efficiently rewires nodes within an adaptively shrinking radius, and upon finding a feasible path, refines it with focused informed sampling until a 30-second termination, returning the best collision-free path found.",
    "planning_mechanism": "The planner alternates balanced expansions of start and goal trees with adaptive goal bias sampling and steering constrained by step size. It efficiently manages parent-child relationships and rewiring with an adaptive radius proportional to the tree size and space dimension, reducing redundant checks. It applies ellipsoidal informed sampling after an initial solution to concentrate search around promising corridors. Nearest neighbor queries are cached and updated incrementally for runtime gain. Collisions are strictly checked for nodes and edges. The search interrupts upon time expiration, ensuring the best path found is returned for robust operation.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        \n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            \n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 45.0\n        self.goal_sample_rate = 0.18\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        # Cache for nearest neighbor acceleration\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    \n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Use cached index if available for same tree object to speed nearest neighbor\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        else:\n            if len(self._nn_cache[key]) != len(tree):\n                self._nn_cache[key] = tree[:]\n        return min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n    \n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        # Filter cached to speed\n        key = id(tree)\n        if key not in self._nn_cache:\n            self._nn_cache[key] = tree[:]\n        result = []\n        for n in self._nn_cache[key]:\n            if self._dist(n.position, point) <= radius:\n                result.append(n)\n        return result\n    \n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n    \n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start,goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12  # prevent degenerate\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n    \n    def _propagate_cost_to_children(self, node: Node):\n        for c in node.children:\n            old_cost = c.cost\n            c.cost = node.cost + self._dist(node.position, c.position)\n            if abs(c.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_children(c)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            goal_bias = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal if expand_start else start, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_children(near)\n\n            # Try connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n                # Stop early on first solution to refine later\n                if found_solution:\n                    break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree from start root with best path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                n = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            # Ellipsoid parameters for informed sampling\n            c_min = self._dist(start, goal)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start, goal, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal, 0.0, ellipsoid)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_tree_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_tree_nodes) / n_tree_nodes) ** (1.0 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_children(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -13.83763,
    "time_improvement": 17.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 224.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025319766998291016,
            "num_nodes_avg": 124.3,
            "path_length_avg": 163.2394983196226,
            "smoothness_avg": 0.022534320283976204,
            "success_improvement": 0.0,
            "time_improvement": 2.09926619713116,
            "length_improvement": 10.525844275633734,
            "smoothness_improvement": 252.71104650394102,
            "objective_score": 8.208841657039294
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04371612071990967,
            "num_nodes_avg": 119.0,
            "path_length_avg": 261.4357946273634,
            "smoothness_avg": 0.011276384089395365,
            "success_improvement": 0.0,
            "time_improvement": 73.39657591656308,
            "length_improvement": 12.72520674127337,
            "smoothness_improvement": 190.14948467130657,
            "objective_score": 30.604844243089474
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.060172200202941895,
            "num_nodes_avg": 108.8,
            "path_length_avg": 129.2796635396884,
            "smoothness_avg": 0.025811603953994167,
            "success_improvement": 0.0,
            "time_improvement": -23.085240188387644,
            "length_improvement": 14.138603112980558,
            "smoothness_improvement": 228.32169708038452,
            "objective_score": 2.6991982966739645
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional informed RRT* planner with recursive cost propagation for rewiring, adaptive radius shrinking, ellipsoidal informed sampling after initial path discovery, and early termination on time limit. It maintains consistent parent-child relationships, efficient collision checking, and progressive best path updates to improve planning efficiency, path length, smoothness, and robustness within a 30-second limit.",
    "planning_mechanism": "A dual-tree growing approach expands start and goal trees alternately with goal-biased and informed sampling. Nodes are added with cost-aware parent selection and neighbors are rewired recursively propagating cost decreases to descendants. After the first connection, ellipsoidal informed sampling focuses refinement near the best path. The algorithm uses adaptive neighbor radius shrinking logarithmically and stops when no improvements or time ration is reached, always returning the best viable path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float,...]: point coordinates\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # cost from root\n        self.children: List['Node'] = []  # children nodes list\n        self.valid = True                 # validity marker\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 20.0  # adaptive neighbor radius scale, shrunk from parents\n        self.improve_tol = 1e-8\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, c_best=float(\"inf\"), c_min=float(\"inf\"), start=None):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12 or start is None:\n            # Uniform sampling with goal bias\n            if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Ellipsoidal informed sampling\n        center = tuple((s + goal[d]) * 0.5 for d, s in enumerate(start))\n        a1 = tuple(goal[d] - start[d] for d in range(dim))\n        c1_norm = math.sqrt(sum(x*x for x in a1))\n        if c1_norm < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n        while True:\n            # Sample point in unit ball\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * u for u in unit_dir]\n\n            # Scale to ellipsoid\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / c1_norm for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        result = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                dx = node.position[i] - point[i]\n                d_sq += dx*dx\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                result.append(node)\n        return result\n\n    def _update_descendants_costs(self, node: Node):\n        # Recursive cost update for all descendants after rewiring\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if child.cost + self.improve_tol < old_cost:\n                self._update_descendants_costs(child)\n\n    def _rewire(self, tree: List[Node], edges: List[Tuple[Node, Node]], new_node: Node, near_nodes: List[Node],\n                obstacles, is_3d):\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n            if cost_through_new + self.improve_tol < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    # Rewire\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    # Update descendants costs recursively\n                    self._update_descendants_costs(near_node)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        start_path = start_node.path_from_root()\n        goal_path = goal_node.path_from_root()\n        goal_path.reverse()\n        return start_path + goal_path[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > time_limit\n\n        iter_count = 0\n        # Phase 1: Bidirectional growth with rewiring until first path or timeout\n        while iter_count < self.max_iter:\n            if time_exceeded():\n                break\n            expand_start_tree = (iter_count % 2 == 0)\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            goal_sample_prob = self.goal_sample_rate\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     goal_sample_prob)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 12.0)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(tree_a, edges, new_node, near_nodes, obstacles, is_3d)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect other tree with new node\n                connect_node = Node(new_node.position, parent=nearest_other,\n                                   cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n            iter_count += 1\n\n        # Phase 2: Refinement with ellipsoidal informed sampling and rewiring if solution found\n        if found_solution and best_goal_node:\n            # Rebuild tree from best path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                curr_cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=curr_cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= 100:\n                    break\n\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos,\n                                         0.0, best_cost, c_min, start_pos)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 12.0)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                self._rewire(tree, edges, new_node, near_nodes, obstacles, is_3d)\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_goal_node = new_goal_node\n                        best_cost = new_goal_node.cost\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if no_improve_count > 150:\n                    break\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.55782,
    "time_improvement": 57.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 76.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01354355812072754,
            "num_nodes_avg": 123.0,
            "path_length_avg": 170.69238519620822,
            "smoothness_avg": 0.012605606756825084,
            "success_improvement": 0.0,
            "time_improvement": 47.63284044396917,
            "length_improvement": 6.440798880027129,
            "smoothness_improvement": 97.30511925751327,
            "objective_score": 18.640857057494596
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.032912039756774904,
            "num_nodes_avg": 159.5,
            "path_length_avg": 291.66160305722474,
            "smoothness_avg": 0.006421467222429217,
            "success_improvement": 0.0,
            "time_improvement": 79.9713941520512,
            "length_improvement": 2.634961885728556,
            "smoothness_improvement": 65.22897682899224,
            "objective_score": 25.898540261197457
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027144646644592284,
            "num_nodes_avg": 125.8,
            "path_length_avg": 149.40370060616124,
            "smoothness_avg": 0.013016890971651141,
            "success_improvement": 0.0,
            "time_improvement": 44.474269832081006,
            "length_improvement": 0.7731758970978289,
            "smoothness_improvement": 65.57389235245522,
            "objective_score": 14.134055949645274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
    "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -26.48735,
    "time_improvement": 58.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 228.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017215156555175783,
            "num_nodes_avg": 208.5,
            "path_length_avg": 160.40239983380974,
            "smoothness_avg": 0.02374652355073028,
            "success_improvement": 0.0,
            "time_improvement": 33.43633614808805,
            "length_improvement": 12.08090291241019,
            "smoothness_improvement": 271.6846599701681,
            "objective_score": 18.637865891723372
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03504271507263183,
            "num_nodes_avg": 467.1,
            "path_length_avg": 253.42542860882128,
            "smoothness_avg": 0.010719255016317384,
            "success_improvement": 0.0,
            "time_improvement": 78.67477272090856,
            "length_improvement": 15.399297483864519,
            "smoothness_improvement": 175.8141523371588,
            "objective_score": 33.72108106827707
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019155335426330567,
            "num_nodes_avg": 300.1,
            "path_length_avg": 131.29531716904052,
            "smoothness_avg": 0.02638587363121502,
            "success_improvement": 0.0,
            "time_improvement": 60.81680487189903,
            "length_improvement": 12.799901947476434,
            "smoothness_improvement": 235.62636498645543,
            "objective_score": 27.103114454987843
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that alternates growing two trees from start and goal using fixed step-size extensions and immediate connection attempts, incorporating goal bias sampling and early returns to improve efficiency. It maintains consistent parent-child relationships, performs collision checks before node/edge additions, and returns the best path found within a 30-second limit without complex rewiring or caching mechanisms. This design balances generality, efficiency, and path quality with modest implementation complexity.",
    "planning_mechanism": "A planner that samples points with goal bias, alternately extends each tree towards samples by fixed steps, attempts to connect trees after each extension, and stops upon connection or time limit, returning the found path or best effort so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(f_pos, t_pos, resolution=1.0):\n            dist = math.dist(f_pos, t_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[d] + (t_pos[d] - f_pos[d]) * (i / steps) for d in range(len(f_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling towards goal\n                p = goal_pos\n                if not is_in_obstacle(p):\n                    return p\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            # Alternate tree to extend each iteration\n            if i % 2 == 0:\n                tree_from, tree_to = tree_a, tree_b\n            else:\n                tree_from, tree_to = tree_b, tree_a\n\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n            new_node = Node(new_pos, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect other tree to new_node\n            nearest_node_to = nearest(tree_to, new_node.position)\n            dist_connect = math.dist(nearest_node_to.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_node_to.position, new_node.position):\n                # Connected trees\n                path_from = new_node.path_from_root()\n                path_to = nearest_node_to.path_from_root()\n                # Remove duplicate connection node in concatenation\n                best_path = path_from + path_to[-2::-1]\n                success = True\n                break\n\n            # Optional: try single-step extension for further connectivity (not required here for simplicity)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -3.52745,
    "time_improvement": 77.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.006187009811401367,
            "num_nodes_avg": 152.6,
            "path_length_avg": 194.45352613019662,
            "smoothness_avg": 0.01061254626627857,
            "success_improvement": -9.999999999999998,
            "time_improvement": 76.07747335816217,
            "length_improvement": -6.583058985264594,
            "smoothness_improvement": 66.10939458033307,
            "objective_score": -30.796046410808437
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.012421631813049316,
            "num_nodes_avg": 301.0,
            "path_length_avg": 306.98788233547384,
            "smoothness_avg": 0.006541117460421968,
            "success_improvement": 0.0,
            "time_improvement": 92.44082197850732,
            "length_improvement": -2.48139127984021,
            "smoothness_improvement": 68.30766363312871,
            "objective_score": 26.58495014381371
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01900057792663574,
            "num_nodes_avg": 389.1,
            "path_length_avg": 160.27081234775898,
            "smoothness_avg": 0.012893012831898648,
            "success_improvement": 0.0,
            "time_improvement": 61.13336906527485,
            "length_improvement": -6.444242285418285,
            "smoothness_improvement": 63.99817155853664,
            "objective_score": 14.793456206124167
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner that grows two trees from start and goal by fixed small steps with goal-biased sampling; it connects the trees when close enough and returns the first valid path found within a 30-second limit. The planner performs collision checks for nodes and edges before incorporation, maintains simple parent-child relations, and avoids complex rewiring or caching to ensure generality and efficiency.",
    "planning_mechanism": "The planner alternately extends each tree toward randomly sampled free points (biased toward the goal), uses fixed step steering for node additions, attempts immediate connection between trees when close, and stops upon successful connection or timeout, returning the path found or best effort so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 2.5, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n            tree_from, tree_to = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            rnd_point = sample_free()\n            nearest_node = nearest(tree_from, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_connect = math.dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                # Connected, assemble full path\n                path_from = new_node.path_from_root()\n                path_to = nearest_other.path_from_root()\n                # Remove duplicate node in connection\n                best_path = path_from + path_to[-2::-1]\n                success = True\n                break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 13.70354,
    "time_improvement": 21.0,
    "length_improvement": -5.0,
    "smoothness_improvement": -19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014434885978698731,
            "num_nodes_avg": 259.6,
            "path_length_avg": 190.58232863104269,
            "smoothness_avg": 0.005255766105779702,
            "success_improvement": 0.0,
            "time_improvement": 44.18645599026513,
            "length_improvement": -4.4611942929284245,
            "smoothness_improvement": -17.735847365776305,
            "objective_score": 10.490540984493602
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.051973581314086914,
            "num_nodes_avg": 717.9,
            "path_length_avg": 307.08996630707236,
            "smoothness_avg": 0.003259867049191445,
            "success_improvement": 0.0,
            "time_improvement": 68.37150227275464,
            "length_improvement": -2.5154698478839976,
            "smoothness_improvement": -16.12127283697495,
            "objective_score": 18.92156240891112
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.07285857200622559,
            "num_nodes_avg": 827.4,
            "path_length_avg": 164.88033577004333,
            "smoothness_avg": 0.006154764674063732,
            "success_improvement": -9.999999999999998,
            "time_improvement": -49.03584720059422,
            "length_improvement": -9.505668260581547,
            "smoothness_improvement": -21.711847643381027,
            "objective_score": -70.52271435474408
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "An optimized bidirectional RRT* planner with incremental nearest neighbor caching, adaptive rewiring radius, and efficient ellipsoidal informed sampling refinement, incorporating subtree cost update propagation, balanced goal-biased tree expansion, and early pruning strategies for faster convergence and smoother, shorter paths within a strict 30-second time limit.",
    "planning_mechanism": "The planner alternates growth of two trees from start and goal with adaptive radius rewiring and goal bias. Nearest neighbor queries use incremental caching to reduce computation. Upon initial solution discovery, it performs focused refinement via ellipsoidal informed sampling in a single tree. Rewiring propagates cost changes to descendants to maintain consistency, and collision checks prune expansions early. The best feasible path found within the time limit is returned.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 40.0  # Tuned parameter\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        \n        # Nearest neighbor cache keyed by tree id: stores nodes list snapshot\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob, ellipsoid=None):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        if ellipsoid is None:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        else:\n            center, c1, c2, a1, norm_a1 = ellipsoid\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0/dim)\n                ball_point = [r*x for x in unit_dir]\n                scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(min(max(0.0, point[d]), bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        nearest_node = min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        candidates = [n for n in self._nn_cache[key] if self._dist(n.position, point) <= radius]\n        return candidates\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoid_parameters(self, c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...], bounds):\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        return (center, c1, c2, a1, norm_a1)\n\n    def _propagate_cost(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = self.time_limit\n        \n        def time_exceeded():\n            return (time.monotonic() - start_time) > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            goal_bias = self.goal_sample_rate\n            \n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Adaptive radius with upper limit\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # Propagate cost to children recursively\n                    self._propagate_cost(near)\n\n            # Attempt to connect trees\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Create connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                    goal_node_for_path = conn_node\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if cur_cost + self.improve_tol < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success = True\n\n                if found_solution:\n                    break\n\n        # If solution found, start refinement via ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild single tree from start_root along best path nodes\n            # Clear old children\n            start_root.children.clear()\n            start_root.cost = 0.0\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            prev = start_root\n            for pos in best_path[1:]:\n                nd = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(nd)\n                tree.append(nd)\n                nodes.append(nd)\n                edges.append((prev, nd))\n                prev = nd\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_max_iter = self.max_iter // 2\n\n            for _ in range(refinement_max_iter):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                ellipsoid = self._ellipsoid_parameters(best_cost, c_min, start_pos, goal_pos, bounds)\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos, 0.0, ellipsoid)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                \n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_via_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost(near)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success else best_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -12.40664,
    "time_improvement": 11.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 197.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024726438522338866,
            "num_nodes_avg": 136.2,
            "path_length_avg": 158.9240097978004,
            "smoothness_avg": 0.02154214850608637,
            "success_improvement": 0.0,
            "time_improvement": 4.393414211438477,
            "length_improvement": 12.89123191773616,
            "smoothness_improvement": 237.18140364446492,
            "objective_score": 10.238670432295564
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.035642027854919434,
            "num_nodes_avg": 112.6,
            "path_length_avg": 250.04126451818865,
            "smoothness_avg": 0.011241461904313998,
            "success_improvement": 0.0,
            "time_improvement": 78.31006121761729,
            "length_improvement": 16.52902886508012,
            "smoothness_improvement": 189.2509116957298,
            "objective_score": 34.35669024281191
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07304487228393555,
            "num_nodes_avg": 103.4,
            "path_length_avg": 133.94841461811015,
            "smoothness_avg": 0.020864073099746132,
            "success_improvement": 0.0,
            "time_improvement": -49.416933721475225,
            "length_improvement": 11.037840948728759,
            "smoothness_improvement": 165.38946980308978,
            "objective_score": -7.375428198189863
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional informed RRT* planner with adaptive rewiring radius, recursive descendant cost updates, and efficient early termination. The planner grows two trees alternately with balanced goal biasing, attempts to connect the trees upon each extension, then refines the solution by single-tree ellipsoidal informed sampling. The rewiring with recursive cost propagation ensures low-cost and smoother paths, while the adaptive neighbor radius balances exploration with efficient rewiring. Early tracking of best solutions allows immediate return when time expires.",
    "planning_mechanism": "The planner initializes two trees from start and goal, expands them alternately by sampling points biased toward the opposite tree's root, and attempts to connect the trees if close enough without collision. Nodes are connected using an adaptive radius-based rewiring strategy with recursive cost updates to propagate cost improvements through descendants. Upon finding an initial feasible path, it switches to a single-tree informed RRT* refinement phase leveraging ellipsoidal sampling focused on the best solution, continually improving path length and smoothness until the 30-second limit is reached, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost):\n        if new_cost + 1e-10 >= self.cost:\n            return\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18\n        self.gamma_rrt_star = 35.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.max_radius_factor = 12.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n        while True:\n            dir_vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in dir_vec))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in dir_vec]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        results = []\n        for node in tree:\n            d_sq = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d_sq <= radius_sq:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Bidirectional expansion for initial solution\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start_tree = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes recursively\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.update_cost_recursively(cost_through_new)\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect newly added node to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Refinement phase with single-tree informed sampling\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            max_refine_iters = self.max_iter // 2\n\n            for _ in range(max_refine_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.8749,
    "time_improvement": 41.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 186.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017296576499938966,
            "num_nodes_avg": 74.4,
            "path_length_avg": 162.68551320198716,
            "smoothness_avg": 0.021340605901513897,
            "success_improvement": 0.0,
            "time_improvement": 33.12151996755042,
            "length_improvement": 10.829492297065672,
            "smoothness_improvement": 234.02682422613492,
            "objective_score": 17.604285489635206
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030746030807495116,
            "num_nodes_avg": 93.4,
            "path_length_avg": 268.1897281589756,
            "smoothness_avg": 0.009533105727792536,
            "success_improvement": 0.0,
            "time_improvement": 81.28951784869399,
            "length_improvement": 10.470549327223386,
            "smoothness_improvement": 145.29367679461498,
            "objective_score": 31.395653334915306
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04444429874420166,
            "num_nodes_avg": 74.9,
            "path_length_avg": 132.98651148189867,
            "smoothness_avg": 0.021897372819779524,
            "success_improvement": 0.0,
            "time_improvement": 9.0869676115473,
            "length_improvement": 11.676691210895223,
            "smoothness_improvement": 178.53296597166292,
            "objective_score": 10.624769839859638
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius, goal biasing and ellipsoidal informed sampling refinement. It maintains two growing trees rooted at start and goal, applies radius-based rewiring with recursive cost updates to optimize path cost and smoothness, and switches to single-tree informed optimization after connecting the trees. Efficient nearest neighbor search, collision checking, and bounded rewiring radius reduce computational overhead, while goal bias and informed sampling accelerate convergence toward shorter, smoother paths within a 30-second time limit.",
    "planning_mechanism": "A hybrid bidirectional RRT*/Informed RRT* planner that alternately grows and rewires two trees toward sampled points with goal bias, connects trees when close, then performs single-tree informed sampling-based refinement to optimize the path quality under a time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost):\n        cost_diff = new_cost - self.cost\n        if cost_diff >= -1e-10:\n            return\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.gamma_rrt_star = 35.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n\n        while True:\n            dir_vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in dir_vec]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r2 = radius * radius\n        results = []\n        for node in tree:\n            d2 = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d2 <= r2:\n                results.append(node)\n        return results\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                if found_solution:\n                    break\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos,\n                                                             bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -16.72258,
    "time_improvement": 36.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 172.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024419021606445313,
            "num_nodes_avg": 83.8,
            "path_length_avg": 170.2336470081887,
            "smoothness_avg": 0.019845060537671634,
            "success_improvement": 0.0,
            "time_improvement": 5.582064235406907,
            "length_improvement": 6.692240550052388,
            "smoothness_improvement": 210.61829165326583,
            "objective_score": 6.7430550589198335
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03257322311401367,
            "num_nodes_avg": 94.6,
            "path_length_avg": 273.85361773742414,
            "smoothness_avg": 0.009061342767288467,
            "success_improvement": 0.0,
            "time_improvement": 80.17758085584529,
            "length_improvement": 8.579779959914962,
            "smoothness_improvement": 133.15487602371954,
            "objective_score": 29.86691661282116
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03730697631835937,
            "num_nodes_avg": 74.2,
            "path_length_avg": 136.5465227850926,
            "smoothness_avg": 0.021452732906608766,
            "success_improvement": 0.0,
            "time_improvement": 23.68671703277276,
            "length_improvement": 9.312301212835159,
            "smoothness_improvement": 172.87717909603532,
            "objective_score": 13.557781733013098
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with goal biasing, adaptive neighbor radius, recursive cost propagation during rewiring, and ellipsoidal informed sampling post initial solution to efficiently find smooth, near-optimal paths within a 30-second limit. The planner alternately grows two trees from start and goal, using goal-biased sampling, steers with fixed step size, rewires neighbors with recursive descendant cost updates, attempts fast tree connections, and refines the found path with focused sampling to improve quality and planning time.",
    "planning_mechanism": "A bidirectional RRT*-inspired planner that combines goal bias sampling, adaptive rewiring radius based on node count and space dimension, recursive cost update propagation upon rewiring to maintain path consistency and smoothness, ellipsoidal informed sampling after finding an initial solution to speed convergence, and early termination once a satisfactory path is found or timer expires. It always verifies node and edge validity with obstacle collision checks and respects map bounds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Optional[Node]\n        self.cost = cost                # float\n        self.children = []              # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist=math.dist(start,end)\n        steps=max(1,int(dist/resolution))\n        for i in range(steps+1):\n            interp=tuple(start[d]+(end[d]-start[d])*(i/steps) for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist=math.dist(from_pos,to_pos)\n        if dist<=self.step_size:\n            return to_pos\n        ratio=self.step_size/dist\n        return tuple(from_pos[d]+(to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n    def _dist(self,p1,p2):\n        return math.dist(p1,p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random()<goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt=tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node=None\n        best_dist=float(\"inf\")\n        for node in tree:\n            d=self._dist(node.position,point)\n            if d<best_dist:\n                best_dist=d\n                best_node=node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point)<=radius]\n\n    def _recursive_update_cost(self, node):\n        # Update costs of descendants recursively after rewiring\n        for child in node.children:\n            old_cost=child.cost\n            child.cost=node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost)>1e-9:\n                self._recursive_update_cost(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start=start_node.path_from_root()\n        path_goal=goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start+path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim=len(bounds)\n        if c_best==float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt=tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center=tuple((s+g)*0.5 for s,g in zip(start,goal))\n        a1=tuple(g-s for s,g in zip(start,goal))\n        norm_a1=math.sqrt(sum(x*x for x in a1))\n        if norm_a1<1e-12:\n            while True:\n                pt=tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1=c_best*0.5\n        c2=math.sqrt(max(c_best*c_best - c_min*c_min,0))*0.5\n        while True:\n            rnd_dir=[random.gauss(0,1) for _ in range(dim)]\n            norm_dir=math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir<1e-12:\n                continue\n            unit_dir=[x/norm_dir for x in rnd_dir]\n            r=random.random()**(1.0/dim)\n            ball_point=[r*x for x in unit_dir]\n            scaled=[c1*ball_point[0]]+[c2*ball_point[i] for i in range(1,dim)]\n            dir_a1=[x/norm_a1 for x in a1]\n            point=[center[d]+dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1,dim):\n                point[i]+=scaled[i]\n            pt=tuple(max(0.0,min(bounds[d],point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds=map.size\n        start_pos=map.start\n        goal_pos=map.goal\n        obstacles=map.obstacles\n        is_3d=len(bounds)==3\n        dim=len(bounds)\n\n        time_start=time.monotonic()\n        time_limit=self.time_limit\n\n        start_root=Node(start_pos, cost=0.0)\n        goal_root=Node(goal_pos, cost=0.0)\n        tree_start=[start_root]\n        tree_goal=[goal_root]\n        nodes=[start_root, goal_root]\n        edges=[]\n\n        best_path=[]\n        best_cost=float(\"inf\")\n        best_goal_node=None\n        found_solution=False\n        success_state=False\n\n        def time_exceeded():\n            return (time.monotonic()-time_start)>time_limit\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start=(it%2==0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt=self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n            nearest_node=self._nearest(tree_a, sample_pt)\n            new_pos=self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes=len(tree_a)+1\n            radius=min(self.gamma_rrt_star*((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*12)\n            near_nodes=self._near(tree_a, new_pos, radius)\n\n            min_cost=nearest_node.cost+self._dist(nearest_node.position, new_pos)\n            best_parent=nearest_node\n            for near in near_nodes:\n                cost_candidate=near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost=cost_candidate\n                        best_parent=near\n\n            new_node=Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors with recursive cost update\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new=new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent=new_node\n                        old_cost=near.cost\n                        near.cost=cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._recursive_update_cost(near)\n\n            nearest_other=self._nearest(tree_b, new_node.position)\n            dist_connect=self._dist(nearest_other.position,new_node.position)\n            if dist_connect<=self.step_size and not self._is_edge_in_obstacle(nearest_other.position,new_node.position,obstacles,is_3d):\n                connect_node=Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path=self._build_path(new_node, connect_node)\n                    total_cost=new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path=self._build_path(connect_node, new_node)\n                    total_cost=connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost=total_cost\n                    best_path=path\n                    best_goal_node=connect_node if expand_start else new_node\n                    found_solution=True\n                    success_state=True\n            if found_solution:\n                break\n\n        # Refinement phase - single tree informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild tree on best path\n            tree=[start_root]\n            nodes=[start_root]\n            edges=[]\n            start_root.children=[]\n            start_root.cost=0.0\n            prev=start_root\n            for pos in best_path[1:]:\n                node=Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position,pos))\n                prev.add_child(node)\n                tree.append(node)\n                nodes.append(node)\n                edges.append((prev,node))\n                prev=node\n            best_goal_node=prev\n            best_cost=best_goal_node.cost\n\n            no_improve_count=0\n            max_no_improve=150\n            refinement_iters=self.max_iter//2\n            c_min=self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if time_exceeded() or no_improve_count>=max_no_improve:\n                    break\n                sample_pt=self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node=self._nearest(tree, sample_pt)\n                new_pos=self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count+=1\n                    continue\n\n                n_nodes=len(tree)+1\n                radius=min(self.gamma_rrt_star*((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size*12)\n                near_nodes=self._near(tree, new_pos, radius)\n\n                min_cost=nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent=nearest_node\n                for near in near_nodes:\n                    candidate=near.cost + self._dist(near.position,new_pos)\n                    if candidate < min_cost and not self._is_edge_in_obstacle(near.position,new_pos, obstacles, is_3d):\n                        min_cost=candidate\n                        best_parent=near\n\n                new_node=Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent,new_node))\n\n                rewired_any=False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_through_new=new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except Exception:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent=new_node\n                            near.cost=cost_through_new\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._recursive_update_cost(near)\n                            rewired_any=True\n\n                dist_goal=self._dist(new_node.position, goal_pos)\n                if dist_goal<=self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node=Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node,new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost=new_goal_node.cost\n                        best_goal_node=new_goal_node\n                        no_improve_count=0\n                        success_state=True\n                    else:\n                        no_improve_count+=1\n                else:\n                    no_improve_count+=1\n                if not rewired_any:\n                    no_improve_count+=1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path=best_path\n            success_state=found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges)",
    "objective": -19.64465,
    "time_improvement": 46.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 121.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01898040771484375,
            "num_nodes_avg": 134.9,
            "path_length_avg": 163.15899023874522,
            "smoothness_avg": 0.017217773258237645,
            "success_improvement": 0.0,
            "time_improvement": 26.61086323242007,
            "length_improvement": 10.569972030494814,
            "smoothness_improvement": 169.495540484481,
            "objective_score": 15.172719890445313
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031042718887329103,
            "num_nodes_avg": 131.5,
            "path_length_avg": 279.584590074453,
            "smoothness_avg": 0.0072039262042913514,
            "success_improvement": 0.0,
            "time_improvement": 81.10896846145778,
            "length_improvement": 6.666616436922297,
            "smoothness_improvement": 85.36221001472943,
            "objective_score": 28.759471450664357
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03335659503936768,
            "num_nodes_avg": 100.6,
            "path_length_avg": 138.1952422339011,
            "smoothness_avg": 0.016370635060858695,
            "success_improvement": 0.0,
            "time_improvement": 31.767419199562237,
            "length_improvement": 8.217300258520059,
            "smoothness_improvement": 108.23326961953683,
            "objective_score": 15.00177226307839
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive rewiring radius, recursive cost updates, balanced goal biasing, consistent edge management, early feasible path detection, and ellipsoidal informed sampling refinement for improved planning efficiency, path length, and smoothness while enforcing a strict 30-second time limit. The planner grows two trees alternately from start and goal, rewires neighbors with recursive cost propagation, connects trees upon proximity, then refines the solution in a single-tree informed optimization phase.",
    "planning_mechanism": "A bidirectional RRT* grows two trees with adaptive radius rewiring and consistent edge/parent updates. It alternates tree expansion with goal-biased sampling, attempts immediate tree connections, and upon locating a path, switches to a refinement stage using ellipsoidal informed sampling focused around the best path to optimize length and smoothness within a hard 30-second time budget. Recursive cost updates ensure subtree cost optimality, and adaptive radius limits neighbor search overhead, accelerating convergence and improving path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        # Only update if new cost is better with tolerance\n        if new_cost + 1e-12 >= self.cost:\n            return\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # Probability to sample goal for bias\n        self.time_limit = 30.0        # Hard time limit in seconds\n        self.gamma_rrt_star = 35.0    # Constant for adaptive radius\n        self.improve_tol = 1e-8       # Small tolerance for improvements\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        # Goal biased sampling\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            # No current solution, uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            # Start and goal are too close, just uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n        except:\n            c2 = 0.0\n\n        while True:\n            # Sample uniformly inside unit ball\n            dir_vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in dir_vec))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in dir_vec]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        results = []\n        for node in tree:\n            d_sq = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d_sq <= radius_sq:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove overlap duplication at connecting node\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Bidirectional search phase\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_sample)\n\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring with recursive update\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect other tree by adding a new connecting node\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n                # Break bidirectional phase on finding a solution\n                if found_solution:\n                    break\n            if found_solution:\n                break\n\n        # Refinement phase: single tree informed RRT* with ellipsoidal sampling\n        if found_solution and best_goal_node:\n            # Rebuild tree along best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_cnt = 0\n            max_no_improve = 100\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_cnt >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_cnt = 0\n                        success_state = True\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n\n                if not rewired:\n                    no_improve_cnt += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -14.34301,
    "time_improvement": 26.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 177.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018828344345092774,
            "num_nodes_avg": 79.3,
            "path_length_avg": 165.0579106365472,
            "smoothness_avg": 0.019990589386376895,
            "success_improvement": 0.0,
            "time_improvement": 27.198827390390502,
            "length_improvement": 9.529143670140272,
            "smoothness_improvement": 212.89613415645624,
            "objective_score": 14.941615089983593
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.033025574684143064,
            "num_nodes_avg": 96.9,
            "path_length_avg": 263.74852620358485,
            "smoothness_avg": 0.009748768883422049,
            "success_improvement": 0.0,
            "time_improvement": 79.9023025270095,
            "length_improvement": 11.953150372843211,
            "smoothness_improvement": 150.8428451248546,
            "objective_score": 31.896795207433048
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06375248432159424,
            "num_nodes_avg": 70.7,
            "path_length_avg": 139.32638824052592,
            "smoothness_avg": 0.02096978584217029,
            "success_improvement": 0.0,
            "time_improvement": -30.408890133058403,
            "length_improvement": 7.46604694030451,
            "smoothness_improvement": 166.7341280838221,
            "objective_score": -3.809368235315704
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighborhood radius, recursive cost updating, and a two-phase search that combines rapid initial path discovery with a dedicated informed refinement phase using ellipsoidal sampling. The planner enforces strict collision checking, balances exploration and exploitation with goal biasing, and terminates early with the best solution found within 30 seconds.",
    "planning_mechanism": "It grows two trees alternately from start and goal with adaptive radius rewiring, connecting when close enough to produce an initial feasible path. Once found, the planner switches to a single-tree ellipsoidal informed RRT* refinement phase to optimize path length and smoothness within the time limit. Recursive cost propagation and careful edge/parent management ensure cost-consistent and smooth paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        if new_cost + 1e-14 >= self.cost:\n            return\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for child in self.children:\n            child.update_cost_recursively(child.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*i/steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...], goal_bias: float) -> Tuple[float, ...]:\n        if random.random() < goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-14:\n            # No solution yet: uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-14:\n            # Start and goal too close, uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n        except:\n            c2 = 0.0\n\n        while True:\n            dir_vec = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in dir_vec))\n            if norm_dir < 1e-14:\n                continue\n            unit_dir = [x/norm_dir for x in dir_vec]\n            r = random.random()**(1.0/dim)\n            ball_point = [r*x for x in unit_dir]\n\n            scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x/norm_a1 for x in a1]\n\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius*radius\n        results = []\n        for node in tree:\n            d_sq = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n            if d_sq <= radius_sq:\n                results.append(node)\n        return results\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Bidirectional growth phase\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start_tree else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 10)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position,new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position,new_pos,obstacles,is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors with recursive cost propagation\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Add connecting node on other tree if not at exact location\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n                # Early break to start refinement phase\n                if found_solution:\n                    break\n            if found_solution:\n                break\n\n        # Refinement phase via single-tree informed RRT*\n        if found_solution and best_goal_node:\n            # Reset tree to only start node and path nodes from best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                c = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=c)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            max_no_improve = 120\n            no_improve_cnt = 0\n            post_opt_iters = self.max_iter // 2\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_cnt >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_cnt += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 10)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position,new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position,new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position,new_pos,obstacles,is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent,new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node_new = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node_new)\n                    tree.append(goal_node_new)\n                    nodes.append(goal_node_new)\n                    edges.append((new_node, goal_node_new))\n                    if goal_node_new.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node_new.cost\n                        best_goal_node = goal_node_new\n                        no_improve_cnt = 0\n                        success_state = True\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n\n                if not rewired_any:\n                    no_improve_cnt += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -11.51371,
    "time_improvement": 17.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 155.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03187241554260254,
            "num_nodes_avg": 117.3,
            "path_length_avg": 166.87970482899973,
            "smoothness_avg": 0.018994705109336533,
            "success_improvement": 0.0,
            "time_improvement": -23.237029388989274,
            "length_improvement": 8.530589405080702,
            "smoothness_improvement": 197.3083826234534,
            "objective_score": -0.8662132605310936
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.046278762817382815,
            "num_nodes_avg": 107.4,
            "path_length_avg": 270.1578867586253,
            "smoothness_avg": 0.008655529385985294,
            "success_improvement": 0.0,
            "time_improvement": 71.83708130975783,
            "length_improvement": 9.813521336356082,
            "smoothness_improvement": 122.71300542722501,
            "objective_score": 28.052802221877123
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04702279567718506,
            "num_nodes_avg": 84.0,
            "path_length_avg": 136.7956678787287,
            "smoothness_avg": 0.019224876036262474,
            "success_improvement": 0.0,
            "time_improvement": 3.8125233789801545,
            "length_improvement": 9.146830904656529,
            "smoothness_improvement": 144.53900414851907,
            "objective_score": 7.354550577230558
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive neighborhood rewiring with incremental informed path refinement. The algorithm alternates tree expansions from start and goal, uses adaptive radius for rewiring with efficient nearest and near searches, and upon initial path discovery switches to an incremental informed sampling refinement phase centered on the current best path. Recursive cost updates, consistent parent-child-edge management, goal bias sampling, and collision checks enforce path validity while improving path length, smoothness, and planning efficiency within a strict 30-second time limit.",
    "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal with adaptive rewiring radii and goal bias sampling, connecting them when feasible to form an initial solution. This switches to a single-tree incremental informed refinement phase, sampling inside an ellipsoidal subspace around the best path to improve path cost and smoothness. Parent-child edges are maintained carefully with recursive cost propagation upon rewiring. Early stopping is triggered on time limit or convergence, returning the best path found with success status.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursively(self, new_cost: float):\n        if new_cost + 1e-14 >= self.cost:\n            return\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursively(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 30.0\n        self.goal_sample_rate = 0.25\n        self.time_limit = 30.0\n        self.improve_tol = 1e-9\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds: Tuple[int, ...], obstacles, is_3d: bool):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_goal_bias(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal_pos: Tuple[float, ...], goal_bias: float):\n        if random.random() < goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-14:\n            # No solution yet: uniform sampling\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        vec = tuple(g - s for s, g in zip(start, goal))\n        norm_vec = math.sqrt(sum(x * x for x in vec))\n        if norm_vec < 1e-14:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n        a1 = tuple(x / norm_vec for x in vec)\n\n        c1 = c_best * 0.5\n        try:\n            c2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) * 0.5\n        except Exception:\n            c2 = 0.0\n\n        while True:\n            direction = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in direction))\n            if norm_dir < 1e-14:\n                continue\n            unit_dir = [x / norm_dir for x in direction]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * bp for bp in ball_point[1:]]\n            # Construct orthonormal basis with a1 as first axis\n            # Simple method: rotate vector in axis-aligned system\n            point = [center[d] + a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for n in tree:\n            dist_sq = sum((n.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if dist_sq <= radius_sq:\n                result.append(n)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out() -> bool:\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        max_rewire_radius_factor = 10.0\n        max_rewire_radius = self.step_size * max_rewire_radius_factor\n\n        # -------------------- Bidirectional phase --------------------\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n\n            sample = self._sample_goal_bias(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_n in near_nodes:\n                candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes with recursive cost updates\n            for near_n in near_nodes:\n                if near_n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.update_cost_recursively(cost_through_new)\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Connect trees by creating a connecting node on the other tree\n                    connect_node = Node(new_node.position,\n                                        parent=nearest_other,\n                                        cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        candidate_path = self._build_path(new_node, connect_node)\n                        candidate_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        candidate_path = self._build_path(connect_node, new_node)\n                        candidate_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n                    # Once initial path found, break to start refinement\n                    if found_solution:\n                        break\n            if found_solution:\n                break\n\n        # -------------------- Incremental informed refinement phase --------------------\n        if found_solution and best_goal_node:\n            # Reinitialize single-tree with the found path\n            tree = [Node(start_pos, cost=0.0)]\n            nodes = [tree[0]]\n            edges = []\n            tree[0].children = []\n\n            prev = tree[0]\n            for pos in best_path[1:]:\n                c = prev.cost + self._dist(prev.position, pos)\n                n = Node(pos, parent=prev, cost=c)\n                prev.add_child(n)\n                tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min,\n                                                              start_pos, goal_pos,\n                                                              bounds, obstacles, is_3d)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_rewire_radius)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_n in near_nodes:\n                    candidate_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                    if candidate_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                            min_cost = candidate_cost\n                            best_parent = near_n\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_n in near_nodes:\n                    if near_n is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                    if cost_through_new + self.improve_tol < near_n.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                            if near_n.parent:\n                                try:\n                                    edges.remove((near_n.parent, near_n))\n                                except ValueError:\n                                    pass\n                                near_n.parent.remove_child(near_n)\n                            near_n.parent = new_node\n                            near_n.update_cost_recursively(cost_through_new)\n                            new_node.add_child(near_n)\n                            edges.append((new_node, near_n))\n                            rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n\n                        if goal_node.cost + self.improve_tol < best_cost:\n                            best_cost = goal_node.cost\n                            best_goal_node = goal_node\n                            no_improve_count = 0\n                            success_state = True\n                        else:\n                            no_improve_count += 1\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            if best_goal_node:\n                extracted_path = best_goal_node.path_from_root()\n            else:\n                extracted_path = best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -15.78863,
    "time_improvement": 26.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 131.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025350546836853026,
            "num_nodes_avg": 80.7,
            "path_length_avg": 159.44212186387108,
            "smoothness_avg": 0.016914811536104846,
            "success_improvement": 0.0,
            "time_improvement": 1.9802536966702367,
            "length_improvement": 12.607246484311755,
            "smoothness_improvement": 164.75353164119315,
            "objective_score": 8.98219165779409
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04258110523223877,
            "num_nodes_avg": 101.5,
            "path_length_avg": 264.79743783191964,
            "smoothness_avg": 0.007870517390592788,
            "success_improvement": 0.0,
            "time_improvement": 74.08728904166492,
            "length_improvement": 11.602993480057835,
            "smoothness_improvement": 102.51408136449002,
            "objective_score": 29.700553207356624
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04729220867156982,
            "num_nodes_avg": 79.0,
            "path_length_avg": 132.80804150961566,
            "smoothness_avg": 0.01772934582986569,
            "success_improvement": 0.0,
            "time_improvement": 3.2614256459426256,
            "length_improvement": 11.795222468658766,
            "smoothness_improvement": 125.5159703117091,
            "objective_score": 8.683141026536592
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An adaptive bidirectional RRT* planner with dynamically adjusted rewiring radius, efficient nearest and near neighbor search pruning, recursive cost propagation, enhanced goal bias sampling, and a dedicated ellipsoidal informed refinement phase. It balances exploration and exploitation to achieve faster planning, shorter and smoother paths, and robust path quality within a fixed 30-second hard time limit by continuously updating the best solution found.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal using rewired RRT* steps with adaptive neighborhood radius shrinking with tree size and workspace dimension. It performs recursive cost updates during rewiring for path consistency, uses goal-biased and ellipsoidal sampling for focus on promising regions, connects the two trees when possible, and then refines the path by focusing sampling within an ellipsoidal subset around the current best path while respecting collision constraints, all while maintaining comprehensive edge and parent-child management and early termination on timeout.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18\n        self.gamma_rrt_star = 40.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        self.max_radius_factor = 12.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        result = []\n        radius_sq = radius * radius\n        for node in tree:\n            dx = tuple(node.position[d] - point[d] for d in range(len(point)))\n            dist_sq = sum(x * x for x in dx)\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        dim = len(bounds)\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node: Optional[Node] = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors recursively\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Try connecting other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Ellipsoidal informed refinement if solution found\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 13.18896,
    "time_improvement": -69.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 205.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02877333164215088,
            "num_nodes_avg": 244.8,
            "path_length_avg": 166.57128832419102,
            "smoothness_avg": 0.021862896602044993,
            "success_improvement": 0.0,
            "time_improvement": -11.254194476197506,
            "length_improvement": 8.699637378538624,
            "smoothness_improvement": 242.20180786185588,
            "objective_score": 3.0545331235732016
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.058768272399902344,
            "num_nodes_avg": 453.4,
            "path_length_avg": 260.2137995281383,
            "smoothness_avg": 0.010597598792491307,
            "success_improvement": 0.0,
            "time_improvement": 64.23659630454114,
            "length_improvement": 13.133143878573419,
            "smoothness_improvement": 172.68385007267767,
            "objective_score": 28.01428446886978
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1760326623916626,
            "num_nodes_avg": 517.4,
            "path_length_avg": 134.51897365502228,
            "smoothness_avg": 0.0234914678064303,
            "success_improvement": 0.0,
            "time_improvement": -260.08360103840465,
            "length_improvement": 10.658902803513454,
            "smoothness_improvement": 198.80973653800842,
            "objective_score": -70.63568994672329
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive Bidirectional RRT* planner with goal bias, dynamically shrinking rewiring radius, recursive subtree cost propagation, and informed ellipsoidal sampling after first solution. The planner grows two trees alternately, attempts immediate connections, rewires with consistent parent-child-edge updates, continuously tracks the best path, and enforces a 30-second time limit, improving planning speed, path length, and smoothness through focused sampling and adaptive rewiring.",
    "planning_mechanism": "The planner alternately expands start and goal trees by sampling with goal bias and later ellipsoidal informed sampling focused around the best path found. New nodes are added via fixed step steering and rewiring includes recursive cost updates to subtree nodes. Immediate connection attempts allow early detection of feasible paths, while adaptive rewiring radius shrinks logarithmically to balance exploration and refinement. The best path is incrementally tracked and returned either upon success or timeout.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_init = 0.15\n        self.rewire_radius_factor = 12.0  # radius = step_size * factor * (log(n)/n)^{1/d}\n        self.dimension = None\n        self.start_time = None\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        self.dimension = len(bounds)\n        is_3d = self.dimension == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro, to, resolution=1.0):\n            distance = dist(fro, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fro[d] + (to[d]-fro[d]) * (i / steps) for d in range(self.dimension))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(self.dimension))\n\n        def sample_free(goal_bias_rate, informed_sampling=False, best_cost=float('inf'), start=start_pos, goal=goal_pos):\n            if informed_sampling and best_cost < float('inf'):\n                # ellipsoidal informed sampling\n                c_best = best_cost\n                c_min = dist(start, goal)\n                if c_best < c_min:\n                    c_best = c_min + 1e-6  # avoid zero volume\n                # Define ellipsoid parameters\n                center = tuple((start[d] + goal[d])/2.0 for d in range(self.dimension))\n                a1 = tuple((goal[d] - start[d]) / c_min for d in range(self.dimension))\n                # Create orthonormal basis using Gram\u2013Schmidt (simple implementation for up to 3D)\n                # For now, only rotate sample sphere to align with vector start->goal\n                # Find rotation matrix U in SO(d) that aligns x-axis with a1\n                import numpy as np\n                # BUT imports not allowed. So do simplified rejection sampling inside bounding box between start/goal\n                # fallback to uniform sampling in bounding box around path plus margin proportional to step_size\n                margin = self.step_size * 2.0\n                low = [min(start[d], goal[d]) - margin for d in range(self.dimension)]\n                high = [max(start[d], goal[d]) + margin for d in range(self.dimension)]\n                for attempt in range(100):\n                    pt = tuple(random.uniform(low[d], high[d]) for d in range(self.dimension))\n                    if not is_in_obstacle(pt) and dist(start, pt) + dist(pt, goal) <= c_best:\n                        return pt\n                # fallback uniform\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(self.dimension))\n                    if not is_in_obstacle(pt):\n                        return pt\n            else:\n                if random.random() < goal_bias_rate:\n                    return goal_pos\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(self.dimension))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def update_subtree_costs(node):\n            # Recursively update cost of subtree nodes after rewiring\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if abs(child.cost - old_cost) > 1e-9:\n                    update_subtree_costs(child)\n\n        def reconnect(node, new_parent):\n            old_parent = node.parent\n            if old_parent is not None:\n                old_parent.remove_child(node)\n            node.parent = new_parent\n            new_parent.add_child(node)\n            node.cost = new_parent.cost + dist(new_parent.position, node.position)\n            update_subtree_costs(node)\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-12 < neighbor.cost:\n                    if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                        reconnect(neighbor, new_node)\n\n        def add_node(tree, new_node, parent):\n            new_node.parent = parent\n            new_node.cost = parent.cost + dist(parent.position, new_node.position)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((parent, new_node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        # Initialize trees\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        all_nodes = tree_start + tree_goal\n        all_edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        self.start_time = time.monotonic()\n\n        # Variables to allow informed sampling after first solution found\n        solution_found_at_iter = None\n\n        def rewiring_radius(iter_num):\n            # Adaptive rewiring radius shrink with iteration (log(n)/n)^{1/d}\n            n = max(len(all_nodes), 2)\n            r = self.step_size * self.rewire_radius_factor * (math.log(n) / n)**(1.0 / self.dimension)\n            r = min(r, self.step_size * self.rewire_radius_factor)\n            r = max(r, self.step_size * 1.5)\n            return r\n\n        # Alternate expansion between trees\n        tree_a, tree_b = tree_start, tree_goal\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - self.start_time\n            if elapsed > self.time_limit:\n                break\n\n            use_informed_sampling = (solution_found_at_iter is not None)\n            goal_bias = 0.15 if not use_informed_sampling else 0.05\n\n            sample = sample_free(goal_bias_rate=goal_bias,\n                                 informed_sampling=use_informed_sampling,\n                                 best_cost=best_cost,\n                                 start=start_pos,\n                                 goal=goal_pos)\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            add_node(tree_a, new_node, nearest_node)\n\n            radius = rewiring_radius(it)\n            rewire(tree_a, new_node, radius)\n\n            # Attempt connecting trees immediately\n            nearest_b = nearest(tree_b, new_node.position)\n            dist_ba = dist(nearest_b.position, new_node.position)\n            connected_node = None\n            if dist_ba <= self.step_size:\n                if not is_edge_in_obstacle(nearest_b.position, new_node.position):\n                    connected_node = Node(new_node.position)\n                    add_node(tree_b, connected_node, nearest_b)\n                    rewire(tree_b, connected_node, radius)\n\n            if connected_node:\n                candidate_path = extract_path(new_node, connected_node)\n                candidate_cost = new_node.cost + connected_node.cost\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success = True\n                    solution_found_at_iter = it\n                    # Keep searching for better path but stop earlier since we have a solution\n                    # Optionally, can break early for faster response\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If time expired without solution, return best found path so far even if empty\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )",
    "objective": -6.07426,
    "time_improvement": 19.0,
    "length_improvement": -0.0,
    "smoothness_improvement": 90.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010976266860961915,
            "num_nodes_avg": 171.1,
            "path_length_avg": 187.1964985195972,
            "smoothness_avg": 0.012557646506443008,
            "success_improvement": 0.0,
            "time_improvement": 57.55946015708544,
            "length_improvement": -2.6053671569337022,
            "smoothness_improvement": 96.55443719168314,
            "objective_score": 16.18738993892383
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02795257568359375,
            "num_nodes_avg": 362.4,
            "path_length_avg": 291.9107054098699,
            "smoothness_avg": 0.007349009851080579,
            "success_improvement": 0.0,
            "time_improvement": 82.98947361090214,
            "length_improvement": 2.55180435040194,
            "smoothness_improvement": 89.09531674614315,
            "objective_score": 26.87340127724252
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0891381025314331,
            "num_nodes_avg": 458.9,
            "path_length_avg": 151.98475624107408,
            "smoothness_avg": 0.01458393077211565,
            "success_improvement": 0.0,
            "time_improvement": -82.33643980135122,
            "length_improvement": -0.9410383589494509,
            "smoothness_improvement": 85.5065229475175,
            "objective_score": -24.838022341037448
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive bidirectional RRT* planner with recursive subtree cost propagation, logarithmically shrinking neighbor radius, dynamic goal bias, and ellipsoidal informed sampling refinement after initial connection. The planner maintains consistent parent-child and edge data structures, efficiently rewires with recursive cost updates, and returns the best path found under a fixed 30-second time limit, balancing fast initial connection, path quality, and smoothness improvements.",
    "planning_mechanism": "A bidirectional RRT* grows two trees alternately from start and goal by sampling with increasing goal bias, steering with adaptive step size, rewiring neighbors within a logarithmically shrinking radius, and propagating cost updates recursively to descendants. Once a first feasible path is established, the planner switches to a single-tree informed RRT* phase with ellipsoidal sampling around the current best path for focused refinement. Best paths are incrementally tracked and returned upon timeout or completion.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0             # Neighbor radius constant\n        self.max_radius_factor = 12.0           # Max radius factor for rewiring\n        self.improve_tol = 1e-7                 # Tolerance for cost improvement\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos,to_pos)\n        steps = max(1,int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos,to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size/dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self,p1,p2):\n        return math.dist(p1,p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]  # avoid duplicate node\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g-s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best/2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n\n        while True:\n            direction = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(d*d for d in direction))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [d / norm_dir for d in direction]\n            r = random.random()**(1.0/dim)\n            ball = [r * u for u in unit_dir]\n            scaled = [c1 * ball[0]] + [c2 * ball[i] for i in range(1, dim)]\n\n            # Rotation: align first dimension to a1 vector\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return time.monotonic() - start_time > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        goal_bias_base = 0.14\n        goal_bias_peak = 0.28\n        max_goal_bias_iters = min(1500, self.max_iter//3)\n\n        # Phase 1: Bidirectional growth until first connection\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            # Increase goal bias linearly up to peak during early iterations\n            goal_bias = goal_bias_base + (goal_bias_peak - goal_bias_base) * min(i,max_goal_bias_iters)/max_goal_bias_iters\n\n            expand_start = (i % 2 == 0)\n            tree_active, tree_other = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n\n            nearest_node = self._nearest(tree_active, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_active)+1\n            radius_max = self.step_size * self.max_radius_factor\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), radius_max)\n            near_nodes = self._near(tree_active, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                edge_free = not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if edge_free and cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_active.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                edge_free = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if edge_free and cost_through_new + self.improve_tol < near_node.cost:\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_other, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n                not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connecting_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connecting_node)\n                tree_other.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((nearest_other, connecting_node))\n\n                if expand_start:\n                    candidate_path = self._build_path(new_node, connecting_node)\n                    candidate_cost = new_node.cost + (connecting_node.cost - nearest_other.cost)\n                else:\n                    candidate_path = self._build_path(connecting_node, new_node)\n                    candidate_cost = connecting_node.cost + (new_node.cost - best_parent.cost)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    best_goal_node = connecting_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Single-tree ellipsoidal informed RRT* refinement for path improvement\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node,\n                                cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree)+1\n                radius_max = self.step_size * self.max_radius_factor\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), radius_max)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    edge_free = not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d)\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if edge_free and cost_candidate < min_cost:\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent,new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    edge_free = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if edge_free and cost_through_new + self.improve_tol < near_node.cost:\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and \\\n                   not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost+dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -7.98862,
    "time_improvement": 2.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 174.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.043700790405273436,
            "num_nodes_avg": 209.2,
            "path_length_avg": 160.86537438574896,
            "smoothness_avg": 0.020674960956354644,
            "success_improvement": 0.0,
            "time_improvement": -68.9723072384675,
            "length_improvement": 11.827139224191052,
            "smoothness_improvement": 223.60803536325867,
            "objective_score": -12.477368460209322
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04597725868225098,
            "num_nodes_avg": 428.1,
            "path_length_avg": 266.80584983895596,
            "smoothness_avg": 0.0090850813057772,
            "success_improvement": 0.0,
            "time_improvement": 72.02056150511216,
            "length_improvement": 10.93252774317479,
            "smoothness_improvement": 133.7656857172128,
            "objective_score": 28.834513526024583
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04730076789855957,
            "num_nodes_avg": 406.2,
            "path_length_avg": 135.98289359333677,
            "smoothness_avg": 0.0208105593199191,
            "success_improvement": 0.0,
            "time_improvement": 3.243917319733737,
            "length_improvement": 9.686636884861418,
            "smoothness_improvement": 164.7087784736663,
            "objective_score": 7.608701219205303
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius rewiring and goal biasing that alternates expansions between start and goal trees. It performs incremental rewiring using a logarithmically shrinking radius for better path cost and smoothness improvements and returns the best found path within a 30-second limit. It balances simplicity and performance while enforcing collision checks on nodes and edges.",
    "planning_mechanism": "The planner alternates between growing start and goal trees towards randomly sampled points biased towards the goal. After steering and collision checking, it rewires nearby nodes within an adaptive radius to optimize path costs. When connection between trees is found, it updates the best path and stops early or continues until time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Accumulated cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0  # Tuned for adaptive radius\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        result = []\n        r2 = radius * radius\n        # Avoid sqrt calls by comparing squared distances\n        for node in tree:\n            d2 = sum((node.position[i] - point[i])**2 for i in range(len(point)))\n            if d2 <= r2:\n                result.append(node)\n        return result\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timeout(): \n            return time.monotonic() - time_start > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if timeout():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cheaper cost via new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Try to connect other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build combined path\n                if expand_start:\n                    path = new_node.path_from_root() + connect_node.path_from_root()[::-1][1:]\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = connect_node.path_from_root() + new_node.path_from_root()[::-1][1:]\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success = True\n                # Early stop on first good path found to respect time limit\n                break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -18.20461,
    "time_improvement": 35.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 182.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01468193531036377,
            "num_nodes_avg": 130.0,
            "path_length_avg": 163.3747828996013,
            "smoothness_avg": 0.02155718503210289,
            "success_improvement": 0.0,
            "time_improvement": 43.23122165271581,
            "length_improvement": 10.451692653626054,
            "smoothness_improvement": 237.41675792896228,
            "objective_score": 20.42746587763519
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04524617195129395,
            "num_nodes_avg": 357.5,
            "path_length_avg": 263.42444460110494,
            "smoothness_avg": 0.009550229822082524,
            "success_improvement": 0.0,
            "time_improvement": 72.46546398102113,
            "length_improvement": 12.061338139922718,
            "smoothness_improvement": 145.73429207468294,
            "objective_score": 29.705113538633384
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05351955890655517,
            "num_nodes_avg": 346.8,
            "path_length_avg": 134.240990838281,
            "smoothness_avg": 0.020726678292430346,
            "success_improvement": 0.0,
            "time_improvement": -9.476930219809965,
            "length_improvement": 10.843525754273747,
            "smoothness_improvement": 163.64181799546276,
            "objective_score": 4.481245476598572
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT* algorithm that grows two trees from start and goal positions, alternately extending towards sampled points with goal biasing and rewiring neighbors within an adaptive radius to optimize path cost. It maintains edge and parent-child consistency during rewiring and updates the best path incrementally. The planner respects obstacles, avoids collisions, and returns the best path found within a 30-second time limit.",
    "planning_mechanism": "The planner samples points biased to the goal, extends the nearest tree node toward the sample within a fixed step, connects the two trees when close, rewires neighbors within an adaptive radius shrinking logarithmically with tree size for efficient optimization, and stops when a path is found or the time limit expires, returning the best path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, gamma=30.0, max_rewire_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(fro, to, resolution=1.0):\n            segment_len = dist(fro,to)\n            steps = max(1,int(segment_len/resolution))\n            for i in range(steps+1):\n                pt = tuple(fro[d]+(to[d]-fro[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(fr, to):\n            d = dist(fr,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[d] + (to[d]-fr[d])*ratio for d in range(dim))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def calc_rewire_radius(n):\n            if n <= 1:\n                return self.max_rewire_radius\n            r = self.gamma * (math.log(n)/n) ** (1/dim)\n            return min(r, self.max_rewire_radius)\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and not edge_collision(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            old_parent.children.remove(node)\n                            edges.remove((old_parent,node))\n                        except Exception:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.children.append(node)\n                    edges.append((new_node, node))\n                    propagate_cost(node)\n\n        def propagate_cost(node):\n            for child in node.children:\n                old_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-12 < old_cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def add_node(tree, new_pos, parent):\n            new_node = Node(new_pos)\n            new_node.parent = parent\n            new_node.cost = parent.cost + dist(parent.position, new_pos)\n            parent.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((parent,new_node))\n            return new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        start_time = time.monotonic()\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30.0:\n                break\n\n            s = sample_free()\n            nearest_node = nearest(tree_a, s)\n            new_pos = steer(nearest_node.position, s)\n\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = add_node(tree_a, new_pos, nearest_node)\n\n            radius = calc_rewire_radius(len(tree_a))\n            rewire(tree_a, new_node, radius)\n\n            nearest_in_other = nearest(tree_b, new_node.position)\n            if dist(nearest_in_other.position, new_node.position) <= self.step_size and \\\n                not edge_collision(nearest_in_other.position, new_node.position):\n\n                connect_node = add_node(tree_b, new_node.position, nearest_in_other)\n                rewire(tree_b, connect_node, calc_rewire_radius(len(tree_b)))\n\n                path = extract_path(new_node, connect_node)\n                cost = connect_node.cost + new_node.cost\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    success = True\n                    # Optional: could continue to refine, but stops here for simplicity\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": -19.88285,
    "time_improvement": 66.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 79.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00825669765472412,
            "num_nodes_avg": 139.3,
            "path_length_avg": 188.89057776614985,
            "smoothness_avg": 0.011325464264939508,
            "success_improvement": 0.0,
            "time_improvement": 68.07487370478262,
            "length_improvement": -3.533918836372714,
            "smoothness_improvement": 77.26810938558945,
            "objective_score": 18.688451356539105
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01704428195953369,
            "num_nodes_avg": 279.8,
            "path_length_avg": 295.73396372159243,
            "smoothness_avg": 0.006875470731970599,
            "success_improvement": 0.0,
            "time_improvement": 89.62771047155977,
            "length_improvement": 1.2754906795601362,
            "smoothness_improvement": 76.91081413500228,
            "objective_score": 28.038161619879023
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02847466468811035,
            "num_nodes_avg": 359.3,
            "path_length_avg": 150.59837646543104,
            "smoothness_avg": 0.014276742175179782,
            "success_improvement": 0.0,
            "time_improvement": 41.75365151017848,
            "length_improvement": -0.020270924278027277,
            "smoothness_improvement": 81.59910666879688,
            "objective_score": 12.921928431830711
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An adaptive bidirectional RRT* planner with efficient incremental rewiring, recursive cost propagation, and dynamic neighbor radius limiting. The planner balances tree expansions with goal bias, caches nearest neighbors to minimize redundant computation, and triggers ellipsoidal informed sampling refinement after an initial solution is found. It maintains consistent edge and parent-child relationships to improve path smoothness and quality, while enforcing early termination upon timeout to guarantee timely results.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal with adaptive rewiring neighborhoods that shrink logarithmically, uses goal-biased and obstacle-aware sampling, and connects trees when possible. Upon first solution, it refines paths by sampling within an ellipsoid based on current best cost, rewiring neighbors efficiently with recursive cost updating, and pruning unnecessary edges. It terminates when the time limit is reached, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # Indicates if node is free from obstacle\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            dist = sum((to_pos[d] - from_pos[d]) ** 2 for d in range(len(from_pos))) ** 0.5\n        except Exception:\n            dist = 0\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1))) ** 0.5\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point, cached=None):\n        best_node = None\n        best_dist = float(\"inf\")\n        if cached is not None:\n            nodes_to_check = cached\n        else:\n            nodes_to_check = tree\n        for node in nodes_to_check:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_cost_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                self._update_cost_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g)*0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        c2 = max((c_best * c_best - c_min * c_min), 0) ** 0.5 * 0.5\n        while True:\n            rnd_dir = []\n            for _ in range(dim):\n                rnd_dir.append(random.gauss(0, 1))\n            norm_dir = sum(x * x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        treestart = [Node(start_pos, cost=0.0)]\n        treegoal = [Node(goal_pos, cost=0.0)]\n\n        nodes = [treestart[0], treegoal[0]]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_over():\n            return time.monotonic() - time_start > self.time_limit\n\n        max_neighbor_radius = self.step_size * 12\n\n        for it in range(self.max_iter):\n            if time_over():\n                break\n            expand_start = (it % 2 == 0)\n            tree_from = treestart if expand_start else treegoal\n            tree_to = treegoal if expand_start else treestart\n            # Sample biased towards opposite goal\n            sample_goal = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_from, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_from) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n\n            near_nodes = self._near(tree_from, new_pos, radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_cost_recursive(near)\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_to.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Prepare single-tree refinement on start tree\n            refined_tree = [Node(start_pos, cost=0.0)]\n            nodes = [refined_tree[0]]\n            edges = []\n            refined_tree[0].children = []\n            refined_tree[0].cost = 0.0\n\n            prev = refined_tree[0]\n            for p in best_path[1:]:\n                n = Node(p, parent=prev, cost=prev.cost + self._dist(prev.position, p))\n                prev.add_child(n)\n                refined_tree.append(n)\n                nodes.append(n)\n                edges.append((prev, n))\n                prev = n\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            max_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(max_opt_iters):\n                if time_over() or no_improve_count >= 150:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest = self._nearest(refined_tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(refined_tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), max_neighbor_radius)\n                near_nodes = self._near(refined_tree, new_pos, radius)\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                refined_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._update_cost_recursive(near)\n                        rewired_any = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    refined_tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 40.15593,
    "time_improvement": -162.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 205.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.045547890663146975,
            "num_nodes_avg": 114.1,
            "path_length_avg": 162.35762146251975,
            "smoothness_avg": 0.021828592751507586,
            "success_improvement": 0.0,
            "time_improvement": -76.1142556878941,
            "length_improvement": 11.009214955244868,
            "smoothness_improvement": 241.6648781089417,
            "objective_score": -15.0204233426766
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11712124347686767,
            "num_nodes_avg": 116.2,
            "path_length_avg": 263.8098389248626,
            "smoothness_avg": 0.009960499450304543,
            "success_improvement": 0.0,
            "time_improvement": 28.725924027940174,
            "length_improvement": 11.93268242169186,
            "smoothness_improvement": 156.29082511410428,
            "objective_score": 16.55884078696769
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2629024744033813,
            "num_nodes_avg": 103.2,
            "path_length_avg": 129.88529366049312,
            "smoothness_avg": 0.024937401502235425,
            "success_improvement": 0.0,
            "time_improvement": -437.780139315556,
            "length_improvement": 13.736372423749357,
            "smoothness_improvement": 217.20190642092612,
            "objective_score": -122.00620880831256
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner that balances exploration by alternating tree expansions from start and goal, uses goal-biased uniform sampling, simple nearest neighbor search, and incremental extension without rewiring to ensure robust, efficient pathfinding within 30 seconds. The planner prioritizes collision-free growth, quick connection attempts between trees, and returns the best path found without expensive recursive cost updates or complex heuristics, enhancing generalization and runtime performance.",
    "planning_mechanism": "The planner alternates extending two trees from the start and goal states using fixed-step steering toward sampled points biased toward respective goals, checks collision-free edges, attempts connections after each extension, and tracks the best feasible path. Early termination happens on timeout or when a path is found, returning the best discovered path with status.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Accumulated path cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except Exception:\n            # fallback if math.dist unavailable\n            dist = sum((a - b) ** 2 for a, b in zip(from_pos, to_pos)) ** 0.5\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except Exception:\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= self.step_size:\n            return to_pos\n        ratio = self.step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal_pos, goal_sample_rate):\n        if random.random() < goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d, active_tree[-1].position if random.random() > self.goal_sample_rate else goal_pos, self.goal_sample_rate)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Attempt to connect the other tree\n            nearest_other = self._nearest(passive_tree, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other,\n                                        cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build full path\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n\n                    total_cost = new_node.cost + (connect_node.cost - (nearest_other.cost if nearest_other else 0))\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success = True\n                    break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -21.64102,
    "time_improvement": 82.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 65.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007103514671325683,
            "num_nodes_avg": 140.3,
            "path_length_avg": 198.33236209221457,
            "smoothness_avg": 0.010345963412573956,
            "success_improvement": 0.0,
            "time_improvement": 72.53374018216012,
            "length_improvement": -8.709110440135714,
            "smoothness_improvement": 61.93679402592351,
            "objective_score": 16.844339760696222
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018743348121643067,
            "num_nodes_avg": 351.4,
            "path_length_avg": 304.33814187363083,
            "smoothness_avg": 0.006605820781548803,
            "success_improvement": 0.0,
            "time_improvement": 88.59374458181357,
            "length_improvement": -1.5968316451266438,
            "smoothness_improvement": 69.97252668964065,
            "objective_score": 25.96988702091629
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.00717008113861084,
            "num_nodes_avg": 195.7,
            "path_length_avg": 160.12808205388438,
            "smoothness_avg": 0.012869879475299778,
            "success_improvement": 0.0,
            "time_improvement": 85.33324099601404,
            "length_improvement": -6.34944762031301,
            "smoothness_improvement": 63.70391697012578,
            "objective_score": 22.108823311467035
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that uses straightforward uniform sampling with goal bias, single-step steering, and alternating tree expansion without rewiring or complex heuristics to maintain robustness and efficiency within a 30-second time budget. The planner focuses on direct connection attempts between the start and goal trees, simple collision checking, and tracks the best feasible path found so far.",
    "planning_mechanism": "The planner builds two trees from start and goal by alternating extensions toward uniformly sampled points or the goal with fixed step sizes and uses basic nearest neighbor search. It attempts to connect the two trees whenever new nodes are added, stopping when a collision-free connection is found or the time limit is reached, returning the best path so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        dim = len(bounds)\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d, goal_pos)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                # Swap trees and continue\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = self._nearest(passive_tree, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_cost = nearest_other.cost + dist_to_other\n                if connect_cost + new_node.cost < best_cost:\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=connect_cost)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n\n                    total_cost = new_node.cost + (connect_cost - nearest_other.cost)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success = True\n                        break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -21.11177,
    "time_improvement": 79.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006083440780639648,
            "num_nodes_avg": 116.3,
            "path_length_avg": 194.87222368734706,
            "smoothness_avg": 0.01048766517655444,
            "success_improvement": 0.0,
            "time_improvement": 76.47793060216085,
            "length_improvement": -6.812553751026114,
            "smoothness_improvement": 64.15473434252364,
            "objective_score": 19.176620601745203
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013425517082214355,
            "num_nodes_avg": 279.8,
            "path_length_avg": 293.3033581902179,
            "smoothness_avg": 0.006805762741446886,
            "success_improvement": 0.0,
            "time_improvement": 91.82990808434403,
            "length_improvement": 2.08689676703407,
            "smoothness_improvement": 75.117177330191,
            "objective_score": 29.176696372174607
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014791512489318847,
            "num_nodes_avg": 301.9,
            "path_length_avg": 166.25773988273363,
            "smoothness_avg": 0.012756365093270638,
            "success_improvement": 0.0,
            "time_improvement": 69.74322259520213,
            "length_improvement": -10.420474487294904,
            "smoothness_improvement": 62.26002240947523,
            "objective_score": 14.981982198231073
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner leveraging adaptive radius rewiring, recursive cost updates with propagation, goal bias sampling, refined ellipsoidal informed sampling for post-solution optimization, and efficient nearest methods using spatial caching for accelerated neighbor queries within a 30-second time limit. The planner alternates between two trees rooted at start and goal, systematically rewires neighbors to improve path cost, connects trees with seamless parent-child relationships, and iteratively refines the best found solution by focused sampling within an ellipsoidal region around the current best path, yielding improved planning speed, path length, and smoothness.",
    "planning_mechanism": "The algorithm grows two trees from start and goal alternatingly, samples with goal bias, and extends by steering towards random samples. It maintains node costs and rewires neighbors in adaptive radius neighborhoods with recursive cost propagation to ensure cost consistency downstream. Upon initial path discovery, it switches to an ellipsoidal informed sampling phase focusing on refining the path. The best path is continuously updated and returned after timeout or completion.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float,...] coordinate\n        self.parent = parent                # Parent node\n        self.cost = cost                    # Cost from root\n        self.children = []                  # List of child nodes\n        self.valid = True                   # Validity flag for collision etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-9\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias):\n        if random.random() < goal_bias and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        # Incremental caching: linear but lightweight for moderate sized tree\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree, point, radius):\n        res = []\n        r2 = radius*radius\n        for node in tree:\n            d2 = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n            if d2 <= r2:\n                res.append(node)\n        return res\n\n    def _recursive_propagate_cost(self, node):\n        # Update costs of descendants if child's cost is not consistent with parent's + edge\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._recursive_propagate_cost(child)\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        # Remove duplicate parent node from concatenation\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            # No valid solution; uniform random\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r*x for x in unit_dir]\n            scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            # Rotate/scaling approximation - simplified\n            point = [center[d] + (dir_a1[d]*scaled[0]) for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return time.monotonic() - time_start > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        # Precompute min feasible cost heuristic\n        c_min = self._dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            # Adaptive goal bias sampling depending on phase\n            if found_solution:\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            else:\n                sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            # Validate node and edge free\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes_a = len(tree_a)+1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes_a) / n_nodes_a) ** (1/dim)), self.step_size*15.0)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Select best parent with minimal cost + obstacle free edge\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                if near == nearest_node:\n                    continue\n                dist_edge = self._dist(near.position, new_pos)\n                cost_candidate = near.cost + dist_edge\n                if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to potentially improve costs with recursive cost propagation\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                dist_edge = self._dist(new_node.position, near.position)\n                cost_through_new = new_node.cost + dist_edge\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try: edges.remove((near.parent, near))\n                        except ValueError: pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._recursive_propagate_cost(near)\n\n            # Attempt to connect with other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Compose path and cost\n                if expand_start_tree:\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    candidate_path = self._build_path(new_node, connect_node)\n                else:\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    candidate_path = self._build_path(connect_node, new_node)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success = True\n\n            # After initial solution, continue refining inside ellipse focused by ellipsoidal sampling and rewiring\n            if found_solution and it >= self.max_iter // 4:\n                # Refinement iterations capped within time limit\n                no_improve_count = 0\n                max_no_improve = 150\n                refinement_iters = self.max_iter // 2\n                # Prepare a merged tree along best path for refinement\n                # Only do once\n                break\n\n        # If initial path found, refine path with focused informed sampling and rewiring until timeout or no improvements\n        if found_solution and best_goal_node is not None:\n            # Rebuild a single tree tracking best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                nodes.append(new_node)\n                tree.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            goal_node = prev_node\n            best_cost = goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            for _ in range(self.max_iter // 2):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size*15.0)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    c_candidate = near.cost + self._dist(near.position, new_pos)\n                    if c_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = c_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    c_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if c_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = c_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._recursive_propagate_cost(near)\n                        rewired = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_candidate = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_candidate)\n                    tree.append(goal_candidate)\n                    nodes.append(goal_candidate)\n                    edges.append((new_node, goal_candidate))\n                    if goal_candidate.cost + self.improve_tol < best_cost:\n                        best_cost = goal_candidate.cost\n                        goal_node = goal_candidate\n                        no_improve_count = 0\n                        success = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = goal_node.path_from_root() if success else best_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges)",
    "objective": 188.52377,
    "time_improvement": -646.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 103.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.32238380908966063,
            "num_nodes_avg": 182.1,
            "path_length_avg": 168.70767952694467,
            "smoothness_avg": 0.013692062436416626,
            "success_improvement": 0.0,
            "time_improvement": -1146.5206128544562,
            "length_improvement": 7.528647507024367,
            "smoothness_improvement": 114.31050991939067,
            "objective_score": -338.86744280252526
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1749798536300659,
            "num_nodes_avg": 130.0,
            "path_length_avg": 273.96932417963677,
            "smoothness_avg": 0.007488954431424434,
            "success_improvement": 0.0,
            "time_improvement": -6.483905148022496,
            "length_improvement": 8.54115381907911,
            "smoothness_improvement": 92.69619159639747,
            "objective_score": 3.6430017050227046
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4328983545303345,
            "num_nodes_avg": 102.6,
            "path_length_avg": 138.53477899778443,
            "smoothness_avg": 0.01592170634543072,
            "success_improvement": 0.0,
            "time_improvement": -785.5152007873382,
            "length_improvement": 7.991796106952005,
            "smoothness_improvement": 102.52292949576388,
            "objective_score": -230.34686792455145
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A hybrid bidirectional RRT* planner utilizing an adaptive logarithmic rewiring radius combined with a dynamically tuned goal sampling probability and refined step size to improve planning efficiency, path smoothness, and path length within a strict 30-second time limit. The planner enforces collision-free sampling and connection, maintains consistent tree data structures, and integrates an ellipsoidal informed sampling phase post-initial connection for intensive path refinement.",
    "planning_mechanism": "The planning mechanism alternates tree expansion from start and goal with unbiased and goal-biased sampling, dynamically adjusts neighbor radius based on logarithmic scaling of tree size for efficient rewiring, and uses recursive cost propagation to maintain path consistency. Upon first feasible connection, the planner switches to refined informed sampling constrained by an ellipsoidal subset around the current best path to accelerate convergence. Early halting criteria and updated parameters reduce unnecessary computations while improving solution quality progressively.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Tuned goal sampling probability\n        self.gamma_rrt_star = 35.0    # Tuned neighborhood radius multiplier\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + self._dist(node.position, child.position)\n            if abs(child.cost - old_cost) > 1e-10:\n                self._propagate_cost_to_descendants(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return time.monotonic() - time_start > self.time_limit\n\n        # Initialize start and goal trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success_state = False\n        first_solution_found = False\n        best_goal_node = None\n\n        for iteration in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start_tree = (iteration % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._propagate_cost_to_descendants(near)\n                    rewired = True\n\n            # Try connecting the other tree to new_node\n            nearest_node_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_node_other, cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    success_state = True\n                    first_solution_found = True\n\n                if first_solution_found:\n                    break\n\n        # Refinement phase with ellipsoidal informed sampling if solution found\n        if first_solution_found and best_goal_node is not None:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_limit = 150\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= no_improve_limit:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n                        rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -17.29494,
    "time_improvement": 36.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 168.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021634602546691896,
            "num_nodes_avg": 125.8,
            "path_length_avg": 163.78093665886271,
            "smoothness_avg": 0.01948019302439895,
            "success_improvement": 0.0,
            "time_improvement": 16.348224492053536,
            "length_improvement": 10.229073342256713,
            "smoothness_improvement": 204.90732274806174,
            "objective_score": 12.066447966710399
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03286821842193603,
            "num_nodes_avg": 122.7,
            "path_length_avg": 267.7085610750306,
            "smoothness_avg": 0.00860277034683428,
            "success_improvement": 0.0,
            "time_improvement": 79.99806160413574,
            "length_improvement": 10.631176749470814,
            "smoothness_improvement": 121.3554773490695,
            "objective_score": 30.984901917668555
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04366216659545898,
            "num_nodes_avg": 111.5,
            "path_length_avg": 138.66500782069303,
            "smoothness_avg": 0.021764560896801552,
            "success_improvement": 0.0,
            "time_improvement": 10.686857977237223,
            "length_improvement": 7.905304323606263,
            "smoothness_improvement": 176.84360811453953,
            "objective_score": 8.833458027907621
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with adaptive rewiring radius, goal-biased sampling, and ellipsoidal informed sampling refinement phases. It ensures collision-free nodes and edges, performs non-recursive rewiring updates, and respects a hard 30-second time limit while returning the best found path. The planner balances exploration and exploitation with alternating tree expansions, early connection attempts, and a focused refinement phase to improve path quality and planning efficiency.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately with goal bias; the near nodes for rewiring are adaptively selected by a shrinking radius based on node count and dimension. Upon finding an initial path, ellipsoidal informed sampling refines the solution within the time limit. Costs are updated locally during rewiring without recursive descendant updates, trading some smoothness for better time efficiency and simpler structure.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos, goal_pos = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def time_exceeded(): return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try: edges.remove((near.parent, near))\n                        except ValueError: pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    goal_node_for_path = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    goal_node_for_path = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = goal_node_for_path\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Rebuild single tree along best path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -19.20603,
    "time_improvement": 45.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 148.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015767407417297364,
            "num_nodes_avg": 100.6,
            "path_length_avg": 169.32120135387655,
            "smoothness_avg": 0.018366459206857196,
            "success_improvement": 0.0,
            "time_improvement": 39.03416423909436,
            "length_improvement": 7.192366471807528,
            "smoothness_improvement": 187.47496999183883,
            "objective_score": 16.96304400477202
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022763156890869142,
            "num_nodes_avg": 122.7,
            "path_length_avg": 275.0023991679394,
            "smoothness_avg": 0.008564109003845116,
            "success_improvement": 0.0,
            "time_improvement": 86.14749190291712,
            "length_improvement": 8.196283652568875,
            "smoothness_improvement": 120.36069314731851,
            "objective_score": 31.363821228153054
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04381966590881348,
            "num_nodes_avg": 97.5,
            "path_length_avg": 136.78000808300936,
            "smoothness_avg": 0.01867137386321666,
            "success_improvement": 0.0,
            "time_improvement": 10.364685267109262,
            "length_improvement": 9.15723139533397,
            "smoothness_improvement": 137.4984973626569,
            "objective_score": 9.291236904146444
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with uniform rewiring radius, goal-biased sampling, and early path connection checking. It maintains consistent parent-child relations and incremental cost updates without recursive propagation. The planner alternates tree expansions from start and goal, uses fixed step steering, and respects a 30-second time limit, returning the best path found.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling free points biased toward the opposite tree's root. New nodes are connected via nearest neighbors, rewiring locally with a uniform radius for cost improvement. On each expansion, it attempts to connect the two trees to form a solution. The method uses simple collision checking and incremental updates avoiding recursion for efficient time use while balancing exploration and refinement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best, best_dist = node, d\n        return best\n\n    def _near(self, tree, point, radius):\n        res = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                res.append(node)\n        return res\n\n    def _build_path(self, start_node, goal_node):\n        path_from_start = start_node.path_from_root()\n        path_from_goal = goal_node.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position,\n                                    parent=nearest_other,\n                                    cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        goal_node_for_path = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n\n            if found_solution:\n                break\n\n        final_path = best_path if found_solution else []\n\n        return PlannerResult(success=found_solution,\n                             path=final_path,\n                             nodes=nodes,\n                             edges=edges)",
    "objective": -25.63427,
    "time_improvement": 53.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 293.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01984410285949707,
            "num_nodes_avg": 143.3,
            "path_length_avg": 171.67360458367028,
            "smoothness_avg": 0.022584930568577976,
            "success_improvement": 0.0,
            "time_improvement": 23.27132268888971,
            "length_improvement": 5.90297698534299,
            "smoothness_improvement": 253.5032073599508,
            "objective_score": 11.79069903467246
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025874114036560057,
            "num_nodes_avg": 243.0,
            "path_length_avg": 242.09986453995447,
            "smoothness_avg": 0.016588755758426728,
            "success_improvement": 0.0,
            "time_improvement": 84.25432043918015,
            "length_improvement": 19.180096758339072,
            "smoothness_improvement": 326.84063406213465,
            "objective_score": 38.41855735706817
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024422097206115722,
            "num_nodes_avg": 210.2,
            "path_length_avg": 125.00263383013859,
            "smoothness_avg": 0.031336834215711706,
            "success_improvement": 0.0,
            "time_improvement": 50.04338065783512,
            "length_improvement": 16.979202595794742,
            "smoothness_improvement": 298.6022181793566,
            "objective_score": 26.693546845724164
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional RRT* planner with goal biasing, adaptive logarithmic shrinking neighbor radius, and focused refinement using ellipsoidal informed sampling while applying efficient nearest neighbor caching and accelerations. It balances exploration and exploitation by alternating tree expansions, incrementally rewires nodes with recursive cost updates, maintains coherent parent-child-edge data, prunes infeasible samples early, and respects a hard 30-second time limit to return the best solution found.",
    "planning_mechanism": "The planner grows two RRT* trees (start and goal) alternately with goal-biased sampling, using adaptive neighbor radii for near searches and rewiring to improve paths. Upon first solution detection, it switches to single-tree refinement phase performing ellipsoidal informed sampling restricted to the admissible subset of configurations based on current best cost. Recursive cost updates during rewiring ensure path consistency. The algorithm enforces collision checks on nodes and edges, pruning invalid expansions promptly and returns the best path found within a strict time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        \"\"\"Update cost recursively to children after rewiring.\"\"\"\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0  # tuned gamma for rewiring radius\n        self.improve_tol = 1e-8\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist = 0\n        try:\n            dist = math.dist(start, end)\n        except:\n            # fallback for python <3.8\n            dist = ((start[0]-end[0])**2 + (start[1]-end[1])**2 + (start[2]-end[2])**2 if is_3d else (start[0]-end[0])**2+(start[1]-end[1])**2)**0.5\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d]-start[d]) * i/steps for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            dim = len(bounds)\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            # fallback uniform sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            # add components approx orthogonal\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _rewire(self, nodes, edges, near_nodes, new_node, obstacles, is_3d):\n        rewired_any = False\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n            if cost_through_new + self.improve_tol < near_node.cost and \\\n               not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                # Remove old edge\n                if near_node.parent:\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.parent.remove_child(near_node)\n                # Rewire\n                near_node.parent = new_node\n                near_node.update_cost_recursive(cost_through_new)\n                new_node.add_child(near_node)\n                edges.append((new_node, near_node))\n                rewired_any = True\n        return rewired_any\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        def timeout():\n            return time.monotonic() - time_start > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            if timeout():\n                break\n\n            expand_from_start = (iteration % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_from_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_from_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            nn_count = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(nn_count)/nn_count) ** (1/dim)), self.step_size * 20)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect other tree\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                path = self._build_path(new_node, connect_node) if expand_from_start else self._build_path(connect_node, new_node)\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost) if expand_from_start else connect_node.cost + (new_node.cost - best_parent.cost)\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_from_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase (informed RRT*)\n        if found_solution and best_goal_node:\n            # Rebuild single tree from start plus best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev, new_node))\n                prev = new_node\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if timeout() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                nn_count = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1/dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.88946,
    "time_improvement": 51.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 129.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019472384452819826,
            "num_nodes_avg": 114.5,
            "path_length_avg": 169.00137507247604,
            "smoothness_avg": 0.017421038343040283,
            "success_improvement": 0.0,
            "time_improvement": 24.708599137136318,
            "length_improvement": 7.36766832461489,
            "smoothness_improvement": 172.67708045883873,
            "objective_score": 12.696566138204021
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03758401870727539,
            "num_nodes_avg": 128.8,
            "path_length_avg": 267.0069168882448,
            "smoothness_avg": 0.00755848483484285,
            "success_improvement": 0.0,
            "time_improvement": 77.12826362531968,
            "length_improvement": 10.865405774728053,
            "smoothness_improvement": 94.48525895707861,
            "objective_score": 30.130148847218123
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02390244007110596,
            "num_nodes_avg": 104.4,
            "path_length_avg": 133.21945082328813,
            "smoothness_avg": 0.017241727448090122,
            "success_improvement": 0.0,
            "time_improvement": 51.106365276356,
            "length_improvement": 11.521983991723811,
            "smoothness_improvement": 119.31350048776885,
            "objective_score": 22.841667480379932
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An enhanced bidirectional RRT* planner with spatial hash based neighbor search acceleration, adaptive rewiring radius tied to local density, curvature-penalty steering for smoother connections, and iterative post-processing shortcut smoothing. The planner enforces collision checks on both nodes and edges, maintains consistent parent-child and cost updates with deferred batch rewiring for efficiency, and employs an informed sampling within an ellipsoidal subset around the best current path for focused refinement. It halts upon a 30-second deadline, returning the best feasible path found, improving planning speed, path length, smoothness, and robustness.",
    "planning_mechanism": "The algorithm grows two trees simultaneously from start and goal using alternate expansions with goal-biased random sampling within map bounds, using spatial hashing for efficient nearest and near neighbor lookups. Steering incorporates curvature penalties to prefer smoother transitions. When new nodes connect trees, a best path is updated. Local rewiring uses an adaptive radius scaled by local node density, applying batch cost updates to avoid repeated recursive calls. An ellipsoidal informed sampling refines the path within focused regions, and a post-processing shortcut smoothing iteratively reduces unnecessary path bends. The search terminates after 30 seconds or max iterations, promptly returning the best path discovered.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float,...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children = []            # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self.gamma_rrt_star = 35.0 # Reduced radius multiplier for efficiency and adaptivity\n        self.max_rewire_factor = 12.0\n        self.hash_cell_size = step_size * 3  # Cell size for spatial hash (~radius scale)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for (x,y,z,w,h,d) in obstacles:\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n        else:\n            for (x,y,w,h) in obstacles:\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        new_pos = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n        return new_pos\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _curvature_penalty(self, parent_pos, from_pos, to_pos):\n        # Penalize sharp turns by angle between vectors: parent->from and from->to\n        # Use dot product formula for angle\n        # If parent is None, no penalty\n        if parent_pos is None:\n            return 0.0\n        import math\n        vec1 = [from_pos[d] - parent_pos[d] for d in range(len(from_pos))]\n        vec2 = [to_pos[d] - from_pos[d] for d in range(len(from_pos))]\n        norm1 = math.sqrt(sum(x*x for x in vec1))\n        norm2 = math.sqrt(sum(x*x for x in vec2))\n        if norm1 < 1e-8 or norm2 < 1e-8:\n            return 0.0\n        dot = sum(vec1[d]*vec2[d] for d in range(len(vec1))) / (norm1*norm2)\n        dot = max(min(dot, 1.0), -1.0)\n        angle = math.acos(dot) # in radians\n        return angle # Larger angle means sharper turn -> higher penalty\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            dim = len(bounds)\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): \n                    return pt\n        dim = len(bounds)\n        center = tuple((start[d]+goal[d])/2 for d in range(dim))\n        a1 = tuple(goal[d] - start[d] for d in range(dim))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            return self._sample_free(bounds, obstacles, is_3d, goal)\n        c1 = c_best/2\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x/norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r*unit_dir[i] for i in range(dim)]\n            scaled = [c1*ball_point[0]] + [c2*ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            pt = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                pt[i] += scaled[i]\n            pt_clamped = tuple(max(0.0,min(bounds[d], pt[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt_clamped, obstacles, is_3d):\n                return pt_clamped\n\n    def _path_length(self, path):\n        length = 0.0\n        for i in range(1,len(path)):\n            length += self._dist(path[i-1], path[i])\n        return length\n\n    def _compute_hash_key(self, pos):\n        # Spatial hash key from position, cell size\n        key = tuple(int(p // self.hash_cell_size) for p in pos)\n        return key\n\n    def _hash_insert(self, hash_map, node):\n        key = self._compute_hash_key(node.position)\n        bucket = hash_map.setdefault(key, [])\n        bucket.append(node)\n\n    def _hash_near(self, hash_map, pos, radius):\n        # Return all nodes in buckets around pos that might lie with radius\n        cell_x = int(pos[0] // self.hash_cell_size)\n        cell_y = int(pos[1] // self.hash_cell_size)\n        dim = len(pos)\n        neighbors = []\n        ranges = [range(cell_x-1, cell_x+2), range(cell_y-1, cell_y+2)]\n        if dim == 3:\n            cell_z = int(pos[2] // self.hash_cell_size)\n            ranges.append(range(cell_z-1, cell_z+2))\n        # Recursive helper to collect nodes by scanning neighboring keys\n        def gather(idx=0, prefix=[]):\n            if idx == dim:\n                key = tuple(prefix)\n                candidates = hash_map.get(key, [])\n                neighbors.extend(candidates)\n                return\n            for v in ranges[idx]:\n                gather(idx+1, prefix+[v])\n        gather()\n        return neighbors\n\n    def _nearest(self, hash_map, pos):\n        # Find nearest neighbor in spatial hash map\n        search_radius = self.hash_cell_size\n        dim = len(pos)\n        best_node = None\n        best_dist = float('inf')\n        candidates = self._hash_near(hash_map, pos, search_radius)\n        for node in candidates:\n            d = self._dist(node.position, pos)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        # If no candidates found, fallback to coarse search (all nodes)\n        if best_node is None:\n            # fallback inefficient search\n            for bucket in hash_map.values():\n                for node in bucket:\n                    d = self._dist(node.position, pos)\n                    if d<best_dist:\n                        best_dist=d\n                        best_node=node\n        return best_node\n\n    def _near(self, hash_map, pos, radius):\n        candidates = self._hash_near(hash_map, pos, radius)\n        near_nodes = [node for node in candidates if self._dist(node.position, pos) <= radius]\n        return near_nodes\n\n    def _update_costs_batch(self, root):\n        # Breadth-first update of costs from root to descendants\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            for child in node.children:\n                cost_new = node.cost + self._dist(node.position, child.position)\n                if cost_new + self.improve_tol < child.cost:\n                    child.cost = cost_new\n                    child.parent = node\n                    queue.append(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_smooth(self, path, map_size, obstacles, is_3d, max_iter=20):\n        # Iteratively try shortcuts along the path to reduce bends and length.\n        if len(path) <= 2:\n            return path\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            # check shortcut collision free\n            p1 = path[i]\n            p2 = path[j]\n            if not self._is_edge_in_obstacle(p1,p2,obstacles,is_3d,resolution=0.5):\n                # replace intermediate nodes between i and j with direct edge\n                path = path[:i+1] + path[j:]\n        return path\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start_hash = {}\n        tree_goal_hash = {}\n        tree_start_nodes = []\n        tree_goal_nodes = []\n\n        self._hash_insert(tree_start_hash, start_root)\n        tree_start_nodes.append(start_root)\n        self._hash_insert(tree_goal_hash, goal_root)\n        tree_goal_nodes.append(goal_root)\n\n        edges = []\n\n        found_solution = False\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n\n        for iter_cnt in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start_tree = (iter_cnt%2 == 0)\n            tree_hash_a = tree_start_hash if expand_start_tree else tree_goal_hash\n            tree_nodes_a = tree_start_nodes if expand_start_tree else tree_goal_nodes\n            tree_hash_b = tree_goal_hash if expand_start_tree else tree_start_hash\n            tree_nodes_b = tree_goal_nodes if expand_start_tree else tree_start_nodes\n            sample_goal = goal_pos if expand_start_tree else start_pos\n\n            sample_pt = self._sample_free(bounds, obstacles, is_3d, sample_goal)\n\n            nearest_node = self._nearest(tree_hash_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            # curvature penalty steering - try to improve smoothness by adjusting step within small angle\n            curvature_penalty = self._curvature_penalty(nearest_node.parent.position if nearest_node.parent else None,\n                                                       nearest_node.position, new_pos)\n            if curvature_penalty > math.pi*0.90: # reject very sharp addition to keep smoothness\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius based on number nodes and dimension to balance complexity\n            n_nodes = len(tree_nodes_a) + 1\n            radius = self.gamma_rrt_star * ( (math.log(n_nodes)/n_nodes) ** (1/dim) )\n            radius = min(radius, self.step_size * self.max_rewire_factor)\n\n            near_nodes = self._near(tree_hash_a, new_pos, radius)\n\n            # Choose best parent from near_nodes\n            cost_min = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < cost_min:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        cost_min = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n\n            tree_nodes_a.append(new_node)\n            self._hash_insert(tree_hash_a, new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire nearby nodes including cost update\n            rewire_candidates = []\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                if new_cost + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        rewire_candidates.append((near, new_cost))\n\n            for (near_node, new_cost) in rewire_candidates:\n                if near_node.parent:\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.parent.remove_child(near_node)\n                near_node.parent = new_node\n                near_node.cost = new_cost\n                new_node.add_child(near_node)\n\n            if rewire_candidates:\n                # deferred batch cost propagation from rewire roots\n                for (near_node, _) in rewire_candidates:\n                    self._update_costs_batch(near_node)\n\n            # Attempt to connect to other tree\n            node_other = self._nearest(tree_hash_b, new_node.position)\n            dist_to_other = self._dist(node_other.position, new_node.position)\n            if dist_to_other <= self.step_size and not self._is_edge_in_obstacle(node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adding node in other tree at new_node position\n                connect_node = Node(new_node.position, parent=node_other, cost=node_other.cost + dist_to_other)\n                node_other.add_child(connect_node)\n                tree_nodes_b.append(connect_node)\n                self._hash_insert(tree_hash_b, connect_node)\n                edges.append((node_other, connect_node))\n\n                if expand_start_tree:\n                    candidate_path = self._build_path(new_node, connect_node)\n                    cost_candidate = new_node.cost + (connect_node.cost - node_other.cost)\n                    candidate_goal_node = connect_node\n                else:\n                    candidate_path = self._build_path(connect_node, new_node)\n                    cost_candidate = connect_node.cost + (new_node.cost - best_parent.cost)\n                    candidate_goal_node = new_node\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    best_goal_node = candidate_goal_node\n                    found_solution = True\n\n            if found_solution and timed_out():\n                break\n\n        # Refinement phase if solution found\n        if found_solution and best_goal_node is not None:\n            # Build single tree along best path to refine\n            tree = []\n            nodes = []\n            edges = []\n            start_node = Node(start_pos, cost=0.0)\n            tree.append(start_node)\n            nodes.append(start_node)\n            prev_node = start_node\n            for pos in best_path[1:]:\n                new_n = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_n)\n                tree.append(new_n)\n                nodes.append(new_n)\n                edges.append((prev_node, new_n))\n                prev_node = new_n\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = min(tree, key=lambda n:self._dist(n.position, sample_pt))\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                # Adaptive radius for near neighbors in refinement tree\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * self.max_rewire_factor)\n                near_nodes = [node for node in tree if self._dist(node.position, new_pos) <= radius]\n\n                cost_min = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n\n                for near in near_nodes:\n                    candi_cost = near.cost + self._dist(near.position, new_pos)\n                    if candi_cost < cost_min and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        cost_min = candi_cost\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired = True\n\n                if rewired:\n                    self._update_costs_batch(new_node)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        found_solution = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n            # Extract path and apply shortcut smoothing\n            extracted_path = best_goal_node.path_from_root() if found_solution else best_path\n            extracted_path = self._shortcut_smooth(extracted_path, bounds, obstacles, is_3d, max_iter=30)\n            success_state = found_solution\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        # Aggregate all explored nodes and edges from both trees if no refinement\n        if not found_solution:\n            nodes = tree_start_nodes + tree_goal_nodes\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 895.36564,
    "time_improvement": -2963.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 737.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.5153100490570068,
            "num_nodes_avg": 165.2,
            "path_length_avg": 155.18964247797948,
            "smoothness_avg": 0.025603519168018257,
            "success_improvement": -9.999999999999998,
            "time_improvement": -5759.057302997899,
            "length_improvement": 14.938097820566968,
            "smoothness_improvement": 300.75067391125083,
            "objective_score": -1767.250578837473
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0372485637664794,
            "num_nodes_avg": 207.7,
            "path_length_avg": 248.25007907342487,
            "smoothness_avg": 0.03101224961934612,
            "success_improvement": 0.0,
            "time_improvement": -531.2171109283305,
            "length_improvement": 17.126978122956675,
            "smoothness_improvement": 697.9675199262994,
            "objective_score": -145.59910880509364
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.3189474105834962,
            "num_nodes_avg": 196.0,
            "path_length_avg": 150.3762618591094,
            "smoothness_avg": 0.10327513724218629,
            "success_improvement": 0.0,
            "time_improvement": -2597.9727894275075,
            "length_improvement": 0.1272470212798339,
            "smoothness_improvement": 1213.6521227429294,
            "objective_score": -773.2472280017696
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner integrating adaptive neighbor radius with KD-tree based efficient nearest and near neighbor queries, recursive cost propagation on rewiring for improved path smoothness, and informed ellipsoidal sampling refinement. The planner alternates tree expansions with dynamic goal bias, prunes outdated nodes, and utilizes a hard 30-second time limit with early best-path return, yielding faster planning, smoother, and shorter paths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately using samples biased toward the goal. Instead of linear searches, it organizes nodes in KD-trees to accelerate nearest and near neighbor queries within an adaptively shrinking radius proportional to node count and dimensionality. New nodes are connected via the lowest-cost parent found within radius. Rewiring recursively propagates cost improvements downstream. Once an initial path is found, the planner switches to informed ellipsoidal sampling focused around the best path to refine and shorten it iteratively until timeout. The graph is maintained cleanly avoiding duplicates, and the best path is updated continuously, enabling early returns if time limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        self.near_resolution = 1.0  # For collision checking along edges\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = self.near_resolution\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicate middle node\n        return path_start + path_goal[1:]\n\n    # --- KD-Tree --- #\n    # Minimal KD-tree built here for nearest and radius queries efficiently.\n    # Uses recursive median split; balanced but rebuilds each iteration for simplicity.\n    def _build_kdtree(self, points, depth=0):\n        if not points:\n            return None\n        k = len(points[0][0])  # dimension\n        axis = depth % k\n        points.sort(key=lambda x: x[0][axis])\n        median = len(points) // 2\n        return {\n            'point': points[median][0],\n            'node': points[median][1],\n            'left': self._build_kdtree(points[:median], depth + 1),\n            'right': self._build_kdtree(points[median + 1:], depth + 1),\n            'axis': axis\n        }\n\n    def _kdtree_nearest(self, tree, target, best=None, best_dist=float('inf')):\n        if tree is None:\n            return best, best_dist\n        axis = tree['axis']\n        p = tree['point']\n        node = tree['node']\n        d = self._dist(p, target)\n        if d < best_dist:\n            best = node\n            best_dist = d\n        diff = target[axis] - p[axis]\n        close, away = (tree['left'], tree['right']) if diff <= 0 else (tree['right'], tree['left'])\n        best, best_dist = self._kdtree_nearest(close, target, best, best_dist)\n        if abs(diff) < best_dist:\n            best, best_dist = self._kdtree_nearest(away, target, best, best_dist)\n        return best, best_dist\n\n    def _kdtree_radius_search(self, tree, target, radius, results=None):\n        if results is None:\n            results = []\n        if tree is None:\n            return results\n        axis = tree['axis']\n        p = tree['point']\n        node = tree['node']\n        dist = self._dist(p, target)\n        if dist <= radius:\n            results.append(node)\n        diff = target[axis] - p[axis]\n        if diff <= 0:\n            self._kdtree_radius_search(tree['left'], target, radius, results)\n            if abs(diff) <= radius:\n                self._kdtree_radius_search(tree['right'], target, radius, results)\n        else:\n            self._kdtree_radius_search(tree['right'], target, radius, results)\n            if abs(diff) <= radius:\n                self._kdtree_radius_search(tree['left'], target, radius, results)\n        return results\n\n    def _update_cost_recursive(self, node):\n        for c in node.children:\n            new_cost = node.cost + self._dist(node.position, c.position)\n            if new_cost + self.improve_tol < c.cost:\n                c.cost = new_cost\n                c.parent = node\n                self._update_cost_recursive(c)\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 15  # max radius cap for few nodes\n            return min(self.gamma_rrt_star * ((math.log(n) / n) ** (1 / dim)), self.step_size * 15)\n\n        # Alternate expansions from start and goal\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Build KD-tree for tree_a\n            kd_points_a = [(n.position, n) for n in tree_a]\n            kd_tree_a = self._build_kdtree(kd_points_a)\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos if expand_start_tree else start_pos, obstacles, is_3d):\n                sample_pt = goal_pos if expand_start_tree else start_pos\n            else:\n                while True:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        break\n\n            # Nearest in tree_a\n            nearest_node, dist_near = self._kdtree_nearest(kd_tree_a, sample_pt)\n\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Near neighbors in tree_a\n            near_nodes = self._kdtree_radius_search(kd_tree_a, new_pos, radius)\n\n            # Choose best parent for new node\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes recursively updating cost\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._update_cost_recursive(near)\n\n            # Build KD-tree for other tree\n            kd_points_b = [(n.position, n) for n in tree_b]\n            kd_tree_b = self._build_kdtree(kd_points_b)\n\n            nearest_node_other, dist_other = self._kdtree_nearest(kd_tree_b, new_node.position)\n\n            dist_connect = self._dist(nearest_node_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                # Connect by adding new node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_node_other,\n                                   cost=nearest_node_other.cost + dist_connect)\n                nearest_node_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_node_other, connect_node))\n\n                if expand_start_tree:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase - ellipsoidal informed sampling and rewiring to improve best path until timeout or no improvements\n        if found_solution and best_goal_node:\n            # Reset graph to path nodes\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= 150:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                kd_points = [(n.position, n) for n in tree]\n                kd_tree = self._build_kdtree(kd_points)\n                nearest_node, _ = self._kdtree_nearest(kd_tree, sample_pt)\n\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                radius = adaptive_radius(len(tree) + 1)\n                near_nodes = self._kdtree_radius_search(kd_tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = cost_through_new\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_cost_recursive(near)\n                            rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 37.90872,
    "time_improvement": -145.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 123.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.045163941383361814,
            "num_nodes_avg": 100.6,
            "path_length_avg": 164.62893430824744,
            "smoothness_avg": 0.017271417072665895,
            "success_improvement": 0.0,
            "time_improvement": -74.62968767284929,
            "length_improvement": 9.764272393246294,
            "smoothness_improvement": 170.3351826696906,
            "objective_score": -15.678666952558556
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14463489055633544,
            "num_nodes_avg": 129.8,
            "path_length_avg": 274.0033430169038,
            "smoothness_avg": 0.007301242712191093,
            "success_improvement": 0.0,
            "time_improvement": 11.982507428220229,
            "length_improvement": 8.529797352021443,
            "smoothness_improvement": 87.86623385723719,
            "objective_score": 9.15196180896512
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2304293394088745,
            "num_nodes_avg": 104.6,
            "path_length_avg": 141.41855958401877,
            "smoothness_avg": 0.016683133296167486,
            "success_improvement": 0.0,
            "time_improvement": -371.3547201520834,
            "length_improvement": 6.076526352450099,
            "smoothness_improvement": 112.20822410644429,
            "objective_score": -107.19945911362274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive logarithmic rewiring radius, increased goal bias, caching of nearest neighbors for efficient queries, and integrated early best-path tracking. It alternates tree expansions between start and goal, performs rewiring using an adaptive radius to optimize path length and smoothness, and upon initial solution switches to an ellipsoidal informed sampling refinement phase that improves path quality. The planner aggressively prunes invalid samples and edges, manages consistent parent-child and edge relations, and respects a hard 30-second time limit, returning the best path found so far.",
    "planning_mechanism": "The planner initializes two trees from start and goal, growing them alternately toward goal-biased samples. It uses precomputed and cached distances to speed nearest and near neighbor searches, dynamically adapts the rewiring radius with logarithmic shrinking, and rewires nearby nodes to improve costs while maintaining consistent tree structure. When a first path is found, it switches to a single-tree ellipsoidal informed sampling for local refinement within the current best cost ellipsoid, continuously tracking the best path for early termination or timeout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.25  # Increased goal bias\n        self.gamma_rrt_star = 40.0    # Tuned parameter for rewiring radius\n        self.improve_tol = 1e-6       # Cost improvement tolerance\n        self.time_limit = 30.0        # Hard time limit in seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            if is_3d:\n                dist = ((from_pos[0]-to_pos[0])**2 + (from_pos[1]-to_pos[1])**2 + (from_pos[2]-to_pos[2])**2)**0.5\n            else:\n                dist = ((from_pos[0]-to_pos[0])**2 + (from_pos[1]-to_pos[1])**2)**0.5\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            if len(from_pos) == 3:\n                dist = ((from_pos[0]-to_pos[0])**2 + (from_pos[1]-to_pos[1])**2 + (from_pos[2]-to_pos[2])**2)**0.5\n            else:\n                dist = ((from_pos[0]-to_pos[0])**2 + (from_pos[1]-to_pos[1])**2)**0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except:\n            if len(p1) == 3:\n                return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)**0.5\n            else:\n                return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal, p_goal):\n        if random.random() < p_goal and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point, cache=None):\n        min_dist = float('inf')\n        nearest = None\n        if cache is not None:\n            if point in cache:\n                return cache[point]\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest = node\n        if cache is not None:\n            cache[point] = nearest\n        return nearest\n\n    def _near(self, tree, point, radius, cache=None):\n        result = []\n        if cache is not None and point in cache:\n            candidates = cache[point]\n            if candidates:\n                return [node for node in candidates if self._dist(node.position, point) <= radius]\n        for node in tree:\n            if self._dist(node.position, point) <= radius:\n                result.append(node)\n        if cache is not None:\n            cache[point] = result\n        return result\n\n    def _build_path(self, node_start, node_goal):\n        path1 = node_start.path_from_root()\n        path2 = node_goal.path_from_root()\n        path2.reverse()\n        return path1 + path2[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            dim = len(bounds)\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        dim = len(bounds)\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        def timeout():\n            return time.monotonic() - time_start > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Nearest neighbor cache: map of sample point to nearest node (per tree)\n        nn_cache_start = {}\n        nn_cache_goal = {}\n        near_cache_start = {}\n        near_cache_goal = {}\n\n        for it in range(self.max_iter):\n            if timeout():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            nn_cache_a = nn_cache_start if expand_start else nn_cache_goal\n            nn_cache_b = nn_cache_goal if expand_start else nn_cache_start\n            near_cache_a = near_cache_start if expand_start else near_cache_goal\n\n            sample_goal = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt, nn_cache_a)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n            near_nodes = self._near(tree_a, new_pos, radius, near_cache_a)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring near neighbors\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    # Rewire\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position, nn_cache_b)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            nn_cache_refine = {}\n            near_cache_refine = {}\n\n            for _ in range(refinement_iters):\n                if timeout() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt, nn_cache_refine)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 15)\n                near_nodes = self._near(tree, new_pos, radius, near_cache_refine)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_any = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and \\\n                       not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        rewired_any = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -9.94515,
    "time_improvement": 10.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 178.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02571101188659668,
            "num_nodes_avg": 102.1,
            "path_length_avg": 169.35118821154796,
            "smoothness_avg": 0.02044601534234147,
            "success_improvement": 0.0,
            "time_improvement": 0.5864891773295449,
            "length_improvement": 7.175930199945656,
            "smoothness_improvement": 220.02453934059426,
            "objective_score": 5.581627569869228
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.038828134536743164,
            "num_nodes_avg": 120.2,
            "path_length_avg": 263.31627496796744,
            "smoothness_avg": 0.009320515221018207,
            "success_improvement": 0.0,
            "time_improvement": 76.37115754007698,
            "length_improvement": 12.097448276954271,
            "smoothness_improvement": 139.8235699325587,
            "objective_score": 30.868934077858448
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0722747802734375,
            "num_nodes_avg": 98.8,
            "path_length_avg": 133.3485906694154,
            "smoothness_avg": 0.021629845872481745,
            "success_improvement": 0.0,
            "time_improvement": -47.84167205978388,
            "length_improvement": 11.436215454904737,
            "smoothness_improvement": 175.13004294882035,
            "objective_score": -6.615122130248221
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius rewiring, balanced goal bias sampling, and a focused refinement phase using ellipsoidal informed sampling for path improvement. The planner alternates expansions between start and goal trees, performs local rewiring to optimize paths, efficiently manages parent-child relationships and edges, and enforces a hard 30-second time limit returning the best found solution.",
    "planning_mechanism": "The planner grows two trees alternately, sampling with goal bias, steering towards samples with fixed step size, and connecting trees when possible. Adaptive near neighbor radius shrinks with node count providing efficient local rewiring to reduce cost. Upon first path discovery, the planner refines the solution using ellipsoidal informed sampling focused around the current best path, with rewiring and direct goal connections. The process continues until time runs out, returning the best viable path with its nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree along best path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        success_state = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -23.94126,
    "time_improvement": 61.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 149.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015314602851867675,
            "num_nodes_avg": 102.6,
            "path_length_avg": 174.31466392127092,
            "smoothness_avg": 0.018042815740374477,
            "success_improvement": 0.0,
            "time_improvement": 40.78496625981784,
            "length_improvement": 4.455370512140755,
            "smoothness_improvement": 182.40924693834805,
            "objective_score": 15.820758419921546
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02311997413635254,
            "num_nodes_avg": 124.2,
            "path_length_avg": 277.74141234820326,
            "smoothness_avg": 0.008272828990118159,
            "success_improvement": 0.0,
            "time_improvement": 85.93035094105784,
            "length_improvement": 7.281922214873708,
            "smoothness_improvement": 112.86584859361024,
            "objective_score": 30.712587854209623
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021300077438354492,
            "num_nodes_avg": 97.7,
            "path_length_avg": 131.4716872369412,
            "smoothness_avg": 0.019683669711549293,
            "success_improvement": 0.0,
            "time_improvement": 56.42962798952232,
            "length_improvement": 12.682765346216934,
            "smoothness_improvement": 150.37482583354094,
            "objective_score": 25.29042173375456
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive logarithmic rewiring radius, spatial hashing for efficient nearest/near neighbor searches, balanced goal-directed sampling, ellipsoidal informed sampling for focused refinement, and recursive cost propagation ensuring up-to-date cost consistency across tree subtrees. The algorithm alternates expansions from start and goal trees, attempts connection via collision-free edges, terminates early upon first solution, then refines the path with informed sampling until the hard 30-second deadline is reached. Efficient data structures and collision checks reduce planning time while adaptive rewiring and targeted sampling improve path length and smoothness.",
    "planning_mechanism": "The planner maintains two balanced trees grown alternately from start and goal, using a spatial hash grid to accelerate nearest and near neighbor searches. It adaptively shrinks the rewiring radius based on node count and dimensionality. Early connection attempts quickly find an initial path, followed by ellipsoidal informed sampling focused around the best path to refine and smooth it. Recursive cost updates ensure all descendants reflect cost improvements during rewiring. The entire process respects collision constraints and map boundaries, with a strict time limit enforcing immediate termination and returning the best solution found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...]\n        self.parent = parent                      # Optional[Node]\n        self.cost = cost                          # Cost from root\n        self.children: List[Node] = []           \n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2            # Goal bias probability\n        self.gamma_rrt_star = 35.0             # Adaptive rewiring parameter\n        self.improve_tol = 1e-7                 # Improvement tolerance\n        self.time_limit = 30.0                  # Hard time limit in seconds\n        self.grid_cell_size = self.step_size*2 # Spatial hash cell size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            # No valid path yet or numerical issues: uniform sampling\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        # Ellipsoidal informed sampling\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        sq_term = max(c_best*c_best - c_min*c_min, 0)\n        c2 = math.sqrt(sq_term) / 2.0\n        for _ in range(100):  # retry limit\n            # Sample random direction in unit ball\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            # Scale along ellipsoid axes\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback uniform if no valid sample found\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    # Spatial hashing grid for efficient NN and near neighbor search\n    def _grid_hash(self, pos: Tuple[float, ...]) -> Tuple[int, ...]:\n        return tuple(int(p // self.grid_cell_size) for p in pos)\n\n    def _insert_node_grid(self, grid: Dict[Tuple[int, ...], List[Node]], node: Node):\n        cell = self._grid_hash(node.position)\n        if cell not in grid:\n            grid[cell] = []\n        grid[cell].append(node)\n\n    def _nearest(self, grid: Dict[Tuple[int, ...], List[Node]], point: Tuple[float, ...], bounds: Tuple[int, ...]) -> Node:\n        dim = len(bounds)\n        cell = self._grid_hash(point)\n        radius_cells = 1\n\n        best_node = None\n        best_dist = float('inf')\n\n        def neighbors_in_grid(center_cell, radius):\n            # Generate neighbor cells in a cube of side (2*radius+1)\n            if dim == 2:\n                cx, cy = center_cell\n                for dx in range(-radius, radius+1):\n                    for dy in range(-radius, radius+1):\n                        yield (cx+dx, cy+dy)\n            else:\n                # dim==3\n                cx, cy, cz = center_cell\n                for dx in range(-radius, radius+1):\n                    for dy in range(-radius, radius+1):\n                        for dz in range(-radius, radius+1):\n                            yield (cx+dx, cy+dy, cz+dz)\n\n        while True:\n            found_any = False\n            for c in neighbors_in_grid(cell, radius_cells):\n                if c not in grid:\n                    continue\n                for node in grid[c]:\n                    d = self._dist(node.position, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                        found_any = True\n            if found_any or radius_cells > 5:\n                break\n            radius_cells += 1\n        return best_node\n\n    def _near(self, grid: Dict[Tuple[int, ...], List[Node]], point: Tuple[float, ...], radius: float, bounds: Tuple[int, ...]) -> List[Node]:\n        dim = len(bounds)\n        cell = self._grid_hash(point)\n        radius_cells = max(1, int(math.ceil(radius / self.grid_cell_size)))\n\n        result: List[Node] = []\n\n        def neighbors_in_grid(center_cell, radius_cell):\n            if dim == 2:\n                cx, cy = center_cell\n                for dx in range(-radius_cell, radius_cell+1):\n                    for dy in range(-radius_cell, radius_cell+1):\n                        yield (cx+dx, cy+dy)\n            else:\n                cx, cy, cz = center_cell\n                for dx in range(-radius_cell, radius_cell+1):\n                    for dy in range(-radius_cell, radius_cell+1):\n                        for dz in range(-radius_cell, radius_cell+1):\n                            yield (cx+dx, cy+dy, cz+dz)\n\n        radius_sq = radius*radius\n        for c in neighbors_in_grid(cell, radius_cells):\n            if c not in grid:\n                continue\n            for node in grid[c]:\n                # Fast squared dist check\n                d_sq = sum((node.position[d] - point[d])**2 for d in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(node)\n        return result\n\n    def _propagate_cost_to_descendants(self, node: Node):\n        stack = node.children[:]\n        while stack:\n            child = stack.pop()\n            old_cost = child.cost\n            child.cost = child.parent.cost + self._dist(child.parent.position, child.position)\n            if abs(child.cost - old_cost) > self.improve_tol:\n                stack.extend(child.children)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        # Spatial grids for fast NN and near searches\n        grid_start: Dict[Tuple[int,...], List[Node]] = {}\n        grid_goal: Dict[Tuple[int,...], List[Node]] = {}\n\n        self._insert_node_grid(grid_start, start_root)\n        self._insert_node_grid(grid_goal, goal_root)\n\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        best_goal_node: Optional[Node] = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start_tree = (it % 2 == 0)\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n            grid_a = grid_start if expand_start_tree else grid_goal\n            grid_b = grid_goal if expand_start_tree else grid_start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d,\n                                     goal_pos if expand_start_tree else start_pos,\n                                     self.goal_sample_rate)\n\n            nearest_node = self._nearest(grid_a, sample_pt, bounds)\n            if nearest_node is None:\n                continue\n\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size*10)\n\n            near_nodes = self._near(grid_a, new_pos, radius, bounds)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                if near == nearest_node:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._insert_node_grid(grid_a, new_node)\n\n            # Rewiring with recursive cost propagation\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire parent-child relations\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        self._propagate_cost_to_descendants(near)\n\n            # Attempt connection to other tree\n            nearest_node_other = self._nearest(grid_b, new_node.position, bounds)\n            if nearest_node_other is not None:\n                dist_connect = self._dist(nearest_node_other.position, new_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_node_other.position, new_node.position, obstacles, is_3d):\n                    # Connect by adopting new_node position in the other tree\n                    connect_node = Node(new_node.position, parent=nearest_node_other,\n                                       cost=nearest_node_other.cost + dist_connect)\n                    nearest_node_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_node_other, connect_node))\n                    self._insert_node_grid(grid_b, connect_node)\n\n                    if expand_start_tree:\n                        path = self._build_path(new_node, connect_node)\n                        # Total cost is sum of costs minus duplicated costs at connection offset\n                        total_cost = new_node.cost + (connect_node.cost - nearest_node_other.cost)\n                        goal_node_for_path = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n                        success_state = True\n\n                    if found_solution:\n                        break\n\n        # Refinement phase with ellipsoidal informed sampling until time or no improved\n        if found_solution and best_goal_node is not None:\n            # Setup single tree from best path for focused refinement\n            tree: List[Node] = []\n            nodes = []\n            edges = []\n            start_root = Node(start_pos, cost=0.0)\n            tree.append(start_root)\n            nodes.append(start_root)\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            # Build new spatial grid for refinement tree\n            grid_refine: Dict[Tuple[int,...], List[Node]] = {}\n            for nd in tree:\n                self._insert_node_grid(grid_refine, nd)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest_node = self._nearest(grid_refine, sample_pt, bounds)\n                if nearest_node is None:\n                    no_improve_count += 1\n                    continue\n\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size*10)\n                near_nodes = self._near(grid_refine, new_pos, radius, bounds)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    if near == nearest_node:\n                        continue\n                    cost_candidate = near.cost + self._dist(near.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._insert_node_grid(grid_refine, new_node)\n\n                rewired_any = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = cost_through_new\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._propagate_cost_to_descendants(near)\n                            rewired_any = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    self._insert_node_grid(grid_refine, new_goal_node)\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_any:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -20.91575,
    "time_improvement": 45.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 195.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0292022705078125,
            "num_nodes_avg": 117.3,
            "path_length_avg": 164.75887580031866,
            "smoothness_avg": 0.021306658943198525,
            "success_improvement": 0.0,
            "time_improvement": -12.912718020575978,
            "length_improvement": 9.693049402387349,
            "smoothness_improvement": 233.4954806114995,
            "objective_score": 3.1094916383171136
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02951326370239258,
            "num_nodes_avg": 115.0,
            "path_length_avg": 265.1981382626802,
            "smoothness_avg": 0.010225720937699322,
            "success_improvement": 0.0,
            "time_improvement": 82.03971767322274,
            "length_improvement": 11.469228142747562,
            "smoothness_improvement": 163.11516501608776,
            "objective_score": 32.3090280126958
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017005395889282227,
            "num_nodes_avg": 100.1,
            "path_length_avg": 133.4290649323335,
            "smoothness_avg": 0.022558084738005607,
            "success_improvement": 0.0,
            "time_improvement": 65.21461355124941,
            "length_improvement": 11.38276828124714,
            "smoothness_improvement": 186.93717280281788,
            "objective_score": 27.3287308981372
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive radius rewiring with recursive descendant cost updates and ellipsoidal informed sampling refinement to yield efficient planning, smooth and short paths within a 30-second time limit. The planner alternates expansions from start and goal, selects parents minimizing cost with local rewiring, attempts immediate tree connections upon node addition, and refines the path after initial connection via informed sampling to expedite convergence and improve quality.",
    "planning_mechanism": "A bidirectional planner grows two trees alternately using goal-biased sampling, steering towards samples within step size. Each new node is linked to the best parent within an adaptively computed radius, followed by recursive rewiring to update descendant costs ensuring cost-consistent paths. When trees connect within step size with collision-free edges, the combined path is extracted and refined by an ellipsoidal informed sampling phase, improving path length and smoothness. The algorithm enforces collision checks for nodes and edges, respects the map bounds and obstacles, and halts either on timeout or when the solution is stable after refinement.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 35.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        self.max_radius_factor = 12.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # If found initial solution, refine with ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild single tree along current best path\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            c_min = self._dist(start_pos, goal_pos)\n            refinement_iters = self.max_iter // 2\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -22.77122,
    "time_improvement": 55.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 166.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019782233238220214,
            "num_nodes_avg": 130.6,
            "path_length_avg": 165.98184559805898,
            "smoothness_avg": 0.020240880234202816,
            "success_improvement": 0.0,
            "time_improvement": 23.51054611158229,
            "length_improvement": 9.022720277049302,
            "smoothness_improvement": 216.81372944020723,
            "objective_score": 13.550864646905303
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03162829875946045,
            "num_nodes_avg": 123.4,
            "path_length_avg": 275.0235333192728,
            "smoothness_avg": 0.008234440384199935,
            "success_improvement": 0.0,
            "time_improvement": 80.75261411398841,
            "length_improvement": 8.189228464540967,
            "smoothness_improvement": 111.87808211313911,
            "objective_score": 29.6987117234868
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019553542137145996,
            "num_nodes_avg": 109.4,
            "path_length_avg": 134.96618081670107,
            "smoothness_avg": 0.021167948968517362,
            "success_improvement": 0.0,
            "time_improvement": 60.002253160643036,
            "length_improvement": 10.36188910044304,
            "smoothness_improvement": 169.25474842407638,
            "objective_score": 25.064083150579116
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner incorporating an efficient fixed-radius neighbor search, adaptive goal-biased sampling, non-recursive cost updates, and incremental smoothing via shortcutting during path extraction, designed to reduce planning time while improving path length and smoothness. It balances exploration and exploitation by alternating tree growth, attempts connection and local rewiring, limits neighbor radius to control complexity, and performs path shortcutting at the end to yield smoother, shorter routes within a strict 30-second deadline.",
    "planning_mechanism": "A bidirectional RRT* grows start and goal trees alternately using fixed step sizes with adaptive goal bias, applying fixed-radius near neighbor rewiring without costly recursive updates. The planner attempts direct tree connections each iteration for early success, dynamically adjusts rewiring radius based on tree size, and upon success, extracts the combined path and applies incremental shortcut smoothing to reduce jaggedness before returning the best path or timing out.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position        # Node position coordinates\n        self.parent = parent            # Parent node reference\n        self.cost = cost                # Cost from root to this node\n        self.children: List[\"Node\"] = []# Children nodes list\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2        # goal bias probability\n        self.fixed_radius = 8.0             # fixed neighbor radius for rewiring\n        self.time_limit = 30.0              # wall-time planning limit (seconds)\n        self.improve_tol = 1e-6             # tolerance for cost improvement\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n    \n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        # Goal biased sampling\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        near_nodes = []\n        r2 = radius*radius\n        for node in tree:\n            # Use squared dist for efficiency\n            d2 = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n            if d2 <= r2:\n                near_nodes.append(node)\n        return near_nodes\n    \n    def _rewire(self, new_node: Node, near_nodes: List[Node], obstacles, is_3d, edges: List[Tuple[Node, Node]]) -> None:\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            potential_cost = new_node.cost + self._dist(new_node.position, near_node.position)\n            if potential_cost + self.improve_tol < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        # Extract path from start root to start_node\n        path_start = start_node.path_from_root()\n        # Extract path from goal root to goal_node and reverse it (without duplicate connecting node)\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        idx = 0\n        while True:\n            next_idx = len(path) - 1\n            for i in range(len(path)-1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[i], obstacles, is_3d):\n                    next_idx = i\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n            if idx >= len(path)-1:\n                break\n        return shortened\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            if timed_out():\n                break\n            # Alternate tree selection\n            expand_start = (iteration % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Compute cost and add new node\n            edge_cost = self._dist(nearest_node.position, new_pos)\n            new_cost = nearest_node.cost + edge_cost\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Fixed-radius near neighbors for rewiring\n            radius = self.fixed_radius\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent among near nodes\n            min_cost = new_node.cost\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                dist_to_new = self._dist(near_node.position, new_pos)\n                tentative_cost = near_node.cost + dist_to_new\n                if tentative_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near_node\n            if best_parent is not nearest_node:\n                # Reparent to better parent\n                nearest_node.remove_child(new_node)\n                try:\n                    edges.remove((nearest_node, new_node))\n                except ValueError:\n                    pass\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node (local update, non-recursive)\n            self._rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n            # Try to connect to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connection found: build combined path\n                    path = self._build_path(new_node, nearest_other)\n                    cost = new_node.cost + nearest_other.cost + dist_connect\n                    if cost + self.improve_tol < best_cost:\n                        best_cost = cost\n                        best_path = path\n                        success_state = True\n                        break  # Early exit on first path found\n\n        # If found solution, apply shortcut smoothing\n        if success_state and best_path:\n            smoothed_path = self._shortcut_path(best_path, obstacles, is_3d)\n            extracted_path = smoothed_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 18.60949,
    "time_improvement": -14.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1558.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01885509490966797,
            "num_nodes_avg": 133.8,
            "path_length_avg": 158.92123842079863,
            "smoothness_avg": 0.05209440487915281,
            "success_improvement": -9.999999999999998,
            "time_improvement": 27.095394372948856,
            "length_improvement": 12.892750953386114,
            "smoothness_improvement": 715.3905611695618,
            "objective_score": -30.55877831023586
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.04803500175476074,
            "num_nodes_avg": 352.6,
            "path_length_avg": 229.7995705882629,
            "smoothness_avg": 0.09991163092293362,
            "success_improvement": -9.999999999999998,
            "time_improvement": 70.76832295532243,
            "length_improvement": 23.286288923744596,
            "smoothness_improvement": 2470.7982270860516,
            "objective_score": -2.443738623726249
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1176828145980835,
            "num_nodes_avg": 479.1,
            "path_length_avg": 120.55477912636016,
            "smoothness_avg": 0.12471630672721903,
            "success_improvement": 0.0,
            "time_improvement": -140.72607370176252,
            "length_improvement": 19.933255905963474,
            "smoothness_improvement": 1486.3822159700408,
            "objective_score": -22.82595748710046
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with an adaptive neighbor radius, kd-tree based nearest neighbor search for efficiency, non-recursive rewiring with robust edge management, goal bias, early termination upon first feasible path, and post-processing shortcut smoothing to improve path quality and smoothness within a 30-second time limit.",
    "planning_mechanism": "The planner iteratively grows two trees from start and goal, alternately sampling with goal bias, steering towards samples, and adding collision-free nodes. It employs a kd-tree based nearest and near neighbor search for fast queries. Rewiring is done locally without recursion, updating parents and costs consistently. When the two trees connect, a combined path is formed and smoothed by shortcutting. Planning stops on first solution or timeout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        # Parameters for adaptive radius calculation\n        self.gamma_rrt_star = 50.0  # constant for radius calculation\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    # Simple kd-tree implementation for nearest neighbor queries.\n    # Not balanced but efficient enough for moderate-sized trees.\n\n    class _KDTree:\n        def __init__(self, points):\n            self.points = points\n            self.dim = len(points[0].position) if points else 0\n\n        def _build_tree(self, points, depth=0):\n            if not points:\n                return None\n            axis = depth % self.dim\n            points.sort(key=lambda n: n.position[axis])\n            median = len(points) // 2\n            node = {\n                'node': points[median],\n                'left': self._build_tree(points[:median], depth + 1),\n                'right': self._build_tree(points[median + 1 :], depth + 1),\n                'axis': axis\n            }\n            return node\n\n        def build(self):\n            self.tree = self._build_tree(self.points)\n\n        def nearest(self, point):\n            best = [None, float(\"inf\")]\n\n            def recursive_search(node):\n                if node is None:\n                    return\n                axis = node['axis']\n                here = node['node']\n                dist = math.dist(here.position, point)\n                if dist < best[1]:\n                    best[0], best[1] = here, dist\n                diff = point[axis] - here.position[axis]\n                close_branch = node['left'] if diff < 0 else node['right']\n                far_branch = node['right'] if diff < 0 else node['left']\n                recursive_search(close_branch)\n                if abs(diff) < best[1]:\n                    recursive_search(far_branch)\n\n            recursive_search(self.tree)\n            return best[0]\n\n        def near(self, point, radius):\n            radius2 = radius * radius\n            result = []\n\n            def recursive_search(node):\n                if node is None:\n                    return\n                axis = node['axis']\n                here = node['node']\n                dist2 = sum((here.position[d] - point[d]) ** 2 for d in range(len(point)))\n                if dist2 <= radius2:\n                    result.append(here)\n                diff = point[axis] - here.position[axis]\n                if diff < 0:\n                    recursive_search(node['left'])\n                    if diff * diff <= radius2:\n                        recursive_search(node['right'])\n                else:\n                    recursive_search(node['right'])\n                    if diff * diff <= radius2:\n                        recursive_search(node['left'])\n\n            recursive_search(self.tree)\n            return result\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        idx = 0\n        while True:\n            next_idx = len(path) - 1\n            for i in range(len(path) - 1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[i], obstacles, is_3d):\n                    next_idx = i\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n            if idx >= len(path) - 1:\n                break\n        return shortened\n\n    def _rewire(self, new_node, near_nodes, obstacles, is_3d, edges):\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, near_node.position)\n            if new_cost + self.improve_tol < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    # Reparent\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timeout():\n            return time.monotonic() - start_time > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success = False\n\n        for iter_cnt in range(self.max_iter):\n            if timeout():\n                break\n\n            expand_start = (iter_cnt % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            # Build kd-tree for efficient NN queries\n            kdtree_a = self._KDTree(tree_a)\n            kdtree_a.build()\n            kdtree_b = self._KDTree(tree_b)\n            kdtree_b.build()\n\n            sample = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n            nearest_node = kdtree_a.nearest(sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            n_nodes = len(tree_a)\n            unit_ball_volume = 3.141592653589793 ** (dim/2) / math.gamma(dim/2 + 1)\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes+1)/ (n_nodes+1)) ** (1/dim)), self.step_size * 10)\n\n            near_nodes = kdtree_a.near(new_pos, radius)\n\n            # Choose best parent among near nodes\n            min_cost = new_node.cost\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node is nearest_node:\n                    continue\n                dist_to_node = self._dist(near_node.position, new_pos)\n                tentative_cost = near_node.cost + dist_to_node\n                if tentative_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near_node\n            if best_parent is not nearest_node:\n                nearest_node.remove_child(new_node)\n                try:\n                    edges.remove((nearest_node, new_node))\n                except ValueError:\n                    pass\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                edges.append((best_parent, new_node))\n\n            # Rewire around new_node\n            self._rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n            # Try to connect trees\n            nearest_other = kdtree_b.nearest(new_node.position)\n            dist_connect = self._dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    path = self._build_path(new_node, nearest_other)\n                    cost = new_node.cost + nearest_other.cost + dist_connect\n                    if cost + self.improve_tol < best_cost:\n                        best_cost = cost\n                        best_path = path\n                        success = True\n                        break\n\n        if success and best_path:\n            best_path = self._shortcut_path(best_path, obstacles, is_3d)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 88.25783,
    "time_improvement": -245.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1416.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.036643242835998534,
            "num_nodes_avg": 115.3,
            "path_length_avg": 155.70771479771585,
            "smoothness_avg": 0.043884785378513654,
            "success_improvement": -9.999999999999998,
            "time_improvement": -41.68378258785353,
            "length_improvement": 14.654134172738212,
            "smoothness_improvement": 586.8921885104749,
            "objective_score": -50.77819333016075
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.24772393703460693,
            "num_nodes_avg": 380.9,
            "path_length_avg": 231.77704605522473,
            "smoothness_avg": 0.09298382792135255,
            "success_improvement": 0.0,
            "time_improvement": -50.7522818590087,
            "length_improvement": 22.626150694397353,
            "smoothness_improvement": 2292.540865960562,
            "objective_score": 9.812710188738611
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.36312479972839357,
            "num_nodes_avg": 314.2,
            "path_length_avg": 120.00249065703944,
            "smoothness_avg": 0.11554993030670883,
            "success_improvement": -9.999999999999998,
            "time_improvement": -642.7899103271327,
            "length_improvement": 20.30005961013549,
            "smoothness_improvement": 1369.7865844926782,
            "objective_score": -223.8080044095951
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive bidirectional RRT* algorithm with dynamic neighborhood radius rewiring, goal biasing, and consistent edge management, designed to optimize planning efficiency, path quality, and smoothness within a strict 30-second time frame. The planner grows two trees alternately, samples points with goal bias, extends nodes by a tunable step size, rewires neighbors using a radius that shrinks logarithmically with node count for efficient local improvements, attempts tree connections upon proximity, and tracks the best solution for early termination.",
    "planning_mechanism": "The planner samples either the goal or random free points with a specified bias, then extends the active tree towards the sample. Using an adaptive radius shrinking based on tree size, it finds neighbors around new nodes and rewires locally if it can reduce costs without collision. Connections to the opposite tree are attempted immediately upon extension to quickly form feasible paths. Early stopping occurs as soon as a path is found or 30 seconds expire. Consistent parent-child and edge updates maintain tree coherency and path smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.15, rewire_factor=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # Factor for adaptive radius: rewire_radius = rewire_factor * (log(n)/n)^(1/dim)\n\n    def plan(self, map) -> 'PlannerResult':\n        from math import log\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro, to, resolution=0.5):\n            distance = dist(fro, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(fro[d] + (to[d]-fro[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def add_node(tree, new_node, parent):\n            new_node.parent = parent\n            new_node.cost = parent.cost + dist(parent.position, new_node.position)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n\n        def rewire(tree, new_node, radius):\n            nearby = near(tree, new_node.position, radius)\n            for node in nearby:\n                if node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, node.position)\n                if potential_cost + 1e-7 < node.cost:  # small epsilon to avoid float issues\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        old_parent = node.parent\n                        if old_parent:\n                            try:\n                                edges.remove((old_parent, node))\n                            except ValueError:\n                                pass\n                            old_parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = potential_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[-2::-1]\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes.extend(start_tree)\n        nodes.extend(goal_tree)\n\n        tree_a, tree_b = start_tree, goal_tree\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node = Node(new_pos)\n            add_node(tree_a, new_node, nearest_node)\n\n            n_nodes = len(tree_a)\n            if n_nodes > 1:\n                # Adaptive rewiring radius: proportional to rewire_factor * (log(n)/n)^(1/dim)\n                radius = self.rewire_factor * ((log(n_nodes) / n_nodes) ** (1 / dim))\n                radius = min(radius, self.step_size * 2.0)  # Clamp maximal radius to avoid huge neighbor sets\n                rewire(tree_a, new_node, radius)\n\n            # Try to connect opposite tree directly if within step_size\n            nearest_b = nearest(tree_b, new_node.position)\n            dist_to_b = dist(nearest_b.position, new_node.position)\n            if dist_to_b <= self.step_size and not is_edge_in_obstacle(nearest_b.position, new_node.position):\n                connect_node = Node(new_node.position)\n                add_node(tree_b, connect_node, nearest_b)\n                rewire(tree_b, connect_node, radius if n_nodes > 1 else self.step_size)\n                success = True\n                candidate_path = extract_path(new_node, connect_node)\n                candidate_cost = new_node.cost + connect_node.cost\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no success at end of planning, try to return best path if exists\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -15.14653,
    "time_improvement": 61.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 32.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012833118438720703,
            "num_nodes_avg": 183.8,
            "path_length_avg": 193.68089678791674,
            "smoothness_avg": 0.008403411802093095,
            "success_improvement": 0.0,
            "time_improvement": 50.379807515026364,
            "length_improvement": -6.1595685996655885,
            "smoothness_improvement": 31.531643003559353,
            "objective_score": 11.575859309726352
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03391921520233154,
            "num_nodes_avg": 411.4,
            "path_length_avg": 318.7039384928857,
            "smoothness_avg": 0.005062639510025743,
            "success_improvement": 0.0,
            "time_improvement": 79.3584780226389,
            "length_improvement": -6.392548053162665,
            "smoothness_improvement": 30.26536106480994,
            "objective_score": 20.123341380218122
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02357943058013916,
            "num_nodes_avg": 307.9,
            "path_length_avg": 155.46997151554538,
            "smoothness_avg": 0.01043579750825391,
            "success_improvement": 0.0,
            "time_improvement": 51.76709731947038,
            "length_improvement": -3.255752396136092,
            "smoothness_improvement": 32.74257401454416,
            "objective_score": 13.740390628232177
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT* planner using adaptive neighbor radius, recursive cost updates, and goal-biased sampling for efficient exploration and refined path quality within a 30-second limit. It alternates tree expansions while rewiring to improve path cost and applies early stopping upon finding a solution with limited refinement to balance runtime and path smoothness.",
    "planning_mechanism": "A bidirectional path planner growing start and goal trees alternately with goal biasing, employing adaptive near-neighbor rewiring with recursive cost propagation to ensure consistent cost updates. The planner performs collision checks on nodes and edges, attempts tree connections after each extension, and maintains best-path tracking with early termination. The design emphasizes simplicity, robust incremental refinement, and runtime-bounded execution to produce smooth, short paths efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # path cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15   # probability of sampling the goal\n        self.gamma_rrt_star = 20.0     # tuning parameter for near radius\n        self.time_limit = 30.0         # maximum allowed planning time in seconds\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timeout():\n            return time.monotonic() - start_time > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        for iter_num in range(self.max_iter):\n            if timeout():\n                break\n\n            # Alternate expanding start and goal trees\n            expand_start = (iter_num % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_target = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_target)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive radius for near neighbors\n            n = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n) / n) ** (1/dim)), self.step_size * 12)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + collision free edge\n            best_parent = nearest_node\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            for near in near_nodes:\n                candidate_cost = near.cost + self._dist(near.position, new_pos)\n                if candidate_cost + self.improve_tol < min_cost and \\\n                   not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to new_node if beneficial\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old parent-child edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    # Rewire\n                    near.parent = new_node\n                    near.update_cost_recursive(cost_through_new)\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try connect other tree to new_node\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n               not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other,\n                                   cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build full path\n                path = self._build_path(new_node, connect_node) if expand_start else self._build_path(connect_node, new_node)\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost) if expand_start else connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success = True\n                # Early stop on first valid connection\n                break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.79828,
    "time_improvement": 70.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 84.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0068387269973754885,
            "num_nodes_avg": 108.6,
            "path_length_avg": 177.55767600716456,
            "smoothness_avg": 0.012738296358941548,
            "success_improvement": 0.0,
            "time_improvement": 73.55756111951031,
            "length_improvement": 2.677824199047429,
            "smoothness_improvement": 99.38199967071878,
            "objective_score": 24.170872853635146
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021071314811706543,
            "num_nodes_avg": 294.8,
            "path_length_avg": 309.35035453873684,
            "smoothness_avg": 0.006604279338306424,
            "success_improvement": 0.0,
            "time_improvement": 87.17706158048615,
            "length_improvement": -3.2700525012814072,
            "smoothness_improvement": 69.93286424475754,
            "objective_score": 24.54075129460079
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024994325637817384,
            "num_nodes_avg": 287.6,
            "path_length_avg": 146.53006916468763,
            "smoothness_avg": 0.014345177552281832,
            "success_improvement": 0.0,
            "time_improvement": 48.87285882680558,
            "length_improvement": 2.6817050728999963,
            "smoothness_improvement": 82.46959961416087,
            "objective_score": 16.683228689852477
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner employing fixed-size rewiring radius and uniform random sampling with goal bias, alternating tree expansions for efficient path search and incremental improvement within a 30-second time limit. The planner updates path costs during rewiring and attempts connection after each new node insertion, returning the best feasible path found.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, each expansion samples points with a fixed goal bias, extends towards sampled points, and rewires nearby nodes to improve costs. Connection attempts between trees are made after each extension to detect solutions early. The search halts at timeout or after max iterations, returning the shortest path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    def update_cost_recursive(self, new_cost):\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + diff)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = step_size * 10\n        self.time_limit = 30.0\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d] - start[d]) * i / steps for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        start_time = time.monotonic()\n        def timeout():\n            return (time.monotonic() - start_time) > self.time_limit\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n        success = False\n        for i in range(self.max_iter):\n            if timeout():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_point = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n            nearest = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for node in near_nodes:\n                cost_candidate = node.cost + math.dist(node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    best_parent = node\n                    min_cost = cost_candidate\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, node.position)\n                if new_cost < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    # Rewire\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.update_cost_recursive(new_cost)\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n                path = new_node.path_from_root() if expand_start else connect_node.path_from_root()\n                other_path = connect_node.path_from_root() if expand_start else new_node.path_from_root()\n                other_path.reverse()\n                full_path = path + other_path[1:]\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost) if expand_start else connect_node.cost + (new_node.cost - best_parent.cost)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -17.96073,
    "time_improvement": 11.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 806.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03704488277435303,
            "num_nodes_avg": 106.1,
            "path_length_avg": 162.29479791024076,
            "smoothness_avg": 0.040998061084489654,
            "success_improvement": 0.0,
            "time_improvement": -43.23675283011911,
            "length_improvement": 11.04364953975187,
            "smoothness_improvement": 541.708684686862,
            "objective_score": -3.6362927017502993
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05155603885650635,
            "num_nodes_avg": 265.8,
            "path_length_avg": 229.77182972861425,
            "smoothness_avg": 0.04415501560611849,
            "success_improvement": 0.0,
            "time_improvement": 68.62559753301403,
            "length_improvement": 23.295549621171688,
            "smoothness_improvement": 1036.14035511766,
            "objective_score": 39.745710808195525
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04517831802368164,
            "num_nodes_avg": 262.8,
            "path_length_avg": 122.22274461411057,
            "smoothness_avg": 0.07392879965380451,
            "success_improvement": 0.0,
            "time_improvement": 7.585494522429914,
            "length_improvement": 18.82547264898104,
            "smoothness_improvement": 840.3688747400313,
            "objective_score": 17.772776319817755
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An efficient, bidirectional RRT* planner with fixed rewiring radius, moderate goal bias, and integrated early stopping for runtime reduction. It uses incremental caching for nearest neighbors, simplified rewiring procedures to reduce overhead, and balanced tree growth to quickly find and optimize paths under a 30s planning limit. The planner performs collision checks on nodes and edges strictly and refines the best solution found, returning a valid path with coherent parent-child and edge data.",
    "planning_mechanism": "The planner alternates expansions between forward and backward trees, sampling with a fixed goal bias and steering controlled by a step size. It uses cached nearest neighbor queries with a fixed radius for rewiring to reduce complexity. After a feasible path is found, an early stopping mechanism prevents unnecessary search, cutting planning time. The best path is extracted from tree roots through nodes, with all collision checks enforced.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, c):\n        self.children.append(c)\n        c.parent = self\n    def remove_child(self, c):\n        if c in self.children:\n            self.children.remove(c)\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.rewire_radius = 10.0\n        self.time_limit = 30.0\n        self._nn_cache = {}\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n    def _is_edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(len(fpos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n    def _nearest(self, tree, point):\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = tree[:]\n        best = None\n        best_dist = float('inf')\n        for n in self._nn_cache[key]:\n            d = self._dist(n.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n    def _near(self, tree, point, radius):\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = tree[:]\n        result = []\n        r2 = radius * radius\n        for n in self._nn_cache[key]:\n            # Use squared dist for speed\n            d = sum((n.position[d] - point[d])**2 for d in range(len(point)))\n            if d <= r2:\n                result.append(n)\n        return result\n    def _build_path(self, node_start, node_goal):\n        path1 = node_start.path_from_root()\n        path2 = node_goal.path_from_root()\n        path2.reverse()\n        return path1 + path2[1:]\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        success_state = False\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_goal = goal if expand_start else start\n            sample_pt = self._sample(bounds, obstacles, is_3d, target_goal, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n            # Rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n                path = self._build_path(new_node, connect_node) if expand_start else self._build_path(connect_node, new_node)\n                total_cost = new_node.cost + (connect_node.cost - nearest_b.cost if expand_start else connect_node.cost + new_node.cost - best_parent.cost)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    found_solution = True\n                    success_state = True\n                if found_solution:\n                    break\n        if found_solution:\n            extracted_path = best_path\n        else:\n            extracted_path = []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -20.74947,
    "time_improvement": 49.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 169.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017554497718811034,
            "num_nodes_avg": 136.0,
            "path_length_avg": 178.20880728583364,
            "smoothness_avg": 0.016431718717510355,
            "success_improvement": 0.0,
            "time_improvement": 32.124248681736056,
            "length_improvement": 2.320928827373525,
            "smoothness_improvement": 157.19207997734313,
            "objective_score": 11.815792300831648
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.032918119430541994,
            "num_nodes_avg": 297.9,
            "path_length_avg": 257.4924072035775,
            "smoothness_avg": 0.010996483450717673,
            "success_improvement": 0.0,
            "time_improvement": 79.96769436952587,
            "length_improvement": 14.041622967446694,
            "smoothness_improvement": 182.9474396338484,
            "objective_score": 33.33001928949502
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03185017108917236,
            "num_nodes_avg": 262.4,
            "path_length_avg": 135.98777728353446,
            "smoothness_avg": 0.021036089773387372,
            "success_improvement": 0.0,
            "time_improvement": 34.84888461232713,
            "length_improvement": 9.683393370368451,
            "smoothness_improvement": 167.57750919485628,
            "objective_score": 17.102588951893495
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An efficient bidirectional RRT* variant enhanced with a simple spatial grid for accelerated nearest neighbor queries and adaptive rewiring radius. It employs goal-biased sampling, collision-checked incremental expansion of two trees, and a non-recursive limited rewiring. The planner performs smooth rapid convergence by connecting trees on close nodes and refines the final path with a lightweight shortcut smoothing procedure before timeout. The algorithm ensures clear consistency in edges and nodes while respecting time constraints and map boundaries, focusing on balancing speed, path quality, and smoothness.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal with goal-biased sampling, steering incrementally with fixed step size. It maintains neighbors via a grid-based spatial index for faster nearest and near queries. Local rewiring uses an adaptive radius dependent on tree size and map density. When trees come within connecting distance and collision-free edge exists, path extraction occurs. Finally, a shortcut smoothing process iteratively attempts to bypass intermediate nodes if this reduces path length without collisions, improving smoothness. Time is monitored with hard cutoff to return the best solution.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=8000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self.grid_cell_size = 10.0  # cell size for spatial hashing (tuned for typical environment)\n        self.connect_dist_factor = 1.5  # multiplier on step size for tree connection threshold\n        self.gamma_rrt_star = 30.0  # rewiring radius factor\n        self.max_rewire_nodes = 40  # max neighbors to rewire to limit overhead\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= pos[0] <= x+w and y <= pos[1] <= y+h and z <= pos[2] <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= pos[0] <= x+w and y <= pos[1] <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(a, b)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(a[d] + (b[d]-a[d]) * (i / steps) for d in range(len(a)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio*(to_pos[d]-from_pos[d]) for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _grid_coords(self, pos):\n        return tuple(int(c // self.grid_cell_size) for c in pos)\n\n    def _insert_node_to_grid(self, grid: Dict[Tuple[int, ...], List[Node]], node: Node):\n        key = self._grid_coords(node.position)\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(node)\n\n    def _near_nodes(self, grid: Dict[Tuple[int, ...], List[Node]], pos: Tuple[float, ...], radius: float) -> List[Node]:\n        grid_pos = self._grid_coords(pos)\n        neighbors = []\n        radius_cells = int(math.ceil(radius / self.grid_cell_size))\n        dim = len(pos)\n        # iterate over neighboring grid cells\n        def neighbor_cells(dim_idx=0, prefix=()):\n            if dim_idx == dim:\n                yield prefix\n            else:\n                for delta in range(-radius_cells, radius_cells+1):\n                    yield from neighbor_cells(dim_idx+1, prefix+(grid_pos[dim_idx]+delta,))\n        for cell in neighbor_cells():\n            if cell in grid:\n                for node in grid[cell]:\n                    if self._dist(node.position, pos) <= radius:\n                        neighbors.append(node)\n        return neighbors\n\n    def _nearest_node(self, grid: Dict[Tuple[int, ...], List[Node]], pos: Tuple[float, ...]) -> Optional[Node]:\n        # Search expanding cells until find nearest candidate\n        radius = self.grid_cell_size\n        best_node = None\n        best_dist = float(\"inf\")\n        while True:\n            candidates = self._near_nodes(grid, pos, radius)\n            if candidates:\n                for node in candidates:\n                    d = self._dist(node.position, pos)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n            radius += self.grid_cell_size\n            if radius > sum(self.grid_cell_size*20 for _ in pos):  # arbitrary large limit\n                break\n        return best_node\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate node at connection\n        return path_start + path_goal[1:]\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_iterations=300):\n        if len(path) < 3:\n            return path\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut possible, remove intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        # Initialize trees with spatial grids for fast neighbor search\n        tree_start_nodes: List[Node] = [Node(start_pos, cost=0.0)]\n        tree_goal_nodes: List[Node] = [Node(goal_pos, cost=0.0)]\n\n        grid_start: Dict[Tuple[int, ...], List[Node]] = dict()\n        grid_goal: Dict[Tuple[int, ...], List[Node]] = dict()\n\n        self._insert_node_to_grid(grid_start, tree_start_nodes[0])\n        self._insert_node_to_grid(grid_goal, tree_goal_nodes[0])\n\n        edges: List[Tuple[Node, Node]] = []\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_connection: Tuple[Node, Node] = (None, None)\n        success = False\n\n        for iter_i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            # Alternate tree expansion\n            expand_start_tree = (iter_i % 2 == 0)\n            tree_nodes = tree_start_nodes if expand_start_tree else tree_goal_nodes\n            grid = grid_start if expand_start_tree else grid_goal\n            other_tree_nodes = tree_goal_nodes if expand_start_tree else tree_start_nodes\n            other_grid = grid_goal if expand_start_tree else grid_start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos)\n            nearest = self._nearest_node(grid, sample_pt)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius: gamma * (log n / n)^(1/d)\n            n_nodes = len(tree_nodes) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 20)\n            near_nodes = self._near_nodes(grid, new_pos, radius)\n            if len(near_nodes) > self.max_rewire_nodes:\n                near_nodes.sort(key=lambda node: self._dist(node.position, new_pos))\n                near_nodes = near_nodes[:self.max_rewire_nodes]\n\n            # Choose best parent\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._insert_node_to_grid(grid, new_node)\n\n            # Rewire neighbors (non-recursive)\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire near_node to new_node parent\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect trees\n            nearest_other = self._nearest_node(other_grid, new_node.position)\n            if nearest_other is not None:\n                dist_connect = self._dist(nearest_other.position, new_node.position)\n                connect_thresh = self.step_size * self.connect_dist_factor\n                if dist_connect <= connect_thresh and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Build combined path\n                    if expand_start_tree:\n                        path = self._build_path(new_node, nearest_other)\n                        total_cost = new_node.cost + (nearest_other.cost + dist_connect - nearest_other.cost)\n                    else:\n                        path = self._build_path(nearest_other, new_node)\n                        total_cost = nearest_other.cost + (new_node.cost + dist_connect - new_node.cost)\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_connection = (new_node, nearest_other)\n                        success = True\n                        # Continue search to improve within time limit\n\n            # Early cutoff heuristic: if sufficiently good path found, try continue for improvements but limited time\n            if success and (iter_i > self.max_iter//10):\n                # Optionally stop early or continue detailed (here continue to try better paths)\n                pass\n\n        if success:\n            # Perform lightweight shortcut smoothing on best path\n            smoothed_path = self._shortcut_smooth(best_path, obstacles, is_3d)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(\n            success=success,\n            path=smoothed_path,\n            nodes=tree_start_nodes + tree_goal_nodes,\n            edges=edges\n        )",
    "objective": 704.29238,
    "time_improvement": -2401.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1745.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1839951038360597,
            "num_nodes_avg": 4357.7,
            "path_length_avg": 161.83703068924754,
            "smoothness_avg": 0.04329122695221667,
            "success_improvement": 0.0,
            "time_improvement": -4478.003798075151,
            "length_improvement": 11.294559007364063,
            "smoothness_improvement": 577.6017102061743,
            "objective_score": -1333.7363954670961
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0182547092437744,
            "num_nodes_avg": 3727.1,
            "path_length_avg": 235.53322595690543,
            "smoothness_avg": 0.11719234498759516,
            "success_improvement": 0.0,
            "time_improvement": -519.6584099611493,
            "length_improvement": 21.3722297275725,
            "smoothness_improvement": 2915.443446765031,
            "objective_score": -128.49696791797615
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.1271689176559447,
            "num_nodes_avg": 4126.5,
            "path_length_avg": 144.66557944016165,
            "smoothness_avg": 0.14478577135563636,
            "success_improvement": 0.0,
            "time_improvement": -2205.6803057665793,
            "length_improvement": 3.9200103704702403,
            "smoothness_improvement": 1741.6643246697245,
            "objective_score": -650.643763884343
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid informed bidirectional RRT* planner that adaptively balances exploration and exploitation through goal-biased, ellipsoidal informed sampling. It employs efficient nearest neighbor lookups, incremental rewiring with recursive cost updates, and progressive path refinement while respecting a 30-second limit. The planner dynamically adjusts neighbor search radii, enforces strict collision checks on nodes and edges, and maintains coherent parent-child relationships to ensure path quality, smoothness, and planning efficiency.",
    "planning_mechanism": "The planner alternates expansions between start and goal trees with a goal sampling bias, performs adaptive radius rewiring to improve paths progressively, and upon first successful connection switches to an ellipsoidal informed sampling refinement phase to focus the search in the promising subset of the state space. Recursive cost propagation ensures cost consistency. Early exits and incremental best path updates optimize runtime and solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple of floats (2D or 3D)\n        self.parent = parent      # Parent Node or None\n        self.cost = cost          # Cost from root node\n        self.children = []        # List of child Nodes\n        self.valid = True         # For collision validity or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18\n        self.gamma_rrt_star = 30.0  # Tuned gamma for neighbor radius\n        self.improve_tol = 1e-8\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _rewire(self, nodes, edges, near_nodes, new_node, obstacles, is_3d):\n        rewired_any = False\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n            if cost_through_new + self.improve_tol < near_node.cost and \\\n                    not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                # Remove old edge\n                if near_node.parent:\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.parent.remove_child(near_node)\n                # Rewire\n                near_node.parent = new_node\n                new_node.add_child(near_node)\n                near_node.update_cost_recursive(cost_through_new)\n                edges.append((new_node, near_node))\n                rewired_any = True\n        return rewired_any\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def timeout():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            if timeout():\n                break\n\n            expand_from_start = (iteration % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_from_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_from_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            nn_count = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost < min_cost and \\\n                        not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n            # Try connecting the other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and \\\n                    not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build combined path based on expansion direction\n                if expand_from_start:\n                    path_candidate = self._build_path(new_node, connect_node)\n                    curr_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path_candidate = self._build_path(connect_node, new_node)\n                    curr_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if curr_cost + self.improve_tol < best_cost:\n                    best_cost = curr_cost\n                    best_path = path_candidate\n                    best_goal_node = connect_node if expand_from_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase: informed sampling focused on best path\n        if found_solution and best_goal_node:\n            # Reinitialize tree with best path from start_root\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev, cost=prev.cost + self._dist(prev.position, pos))\n                prev.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev, new_node))\n                prev = new_node\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if timeout() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                        self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                nn_count = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and \\\n                            not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and \\\n                        not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -21.04075,
    "time_improvement": 51.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 128.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019579219818115234,
            "num_nodes_avg": 118.3,
            "path_length_avg": 168.46227431288358,
            "smoothness_avg": 0.016697474018281526,
            "success_improvement": 0.0,
            "time_improvement": 24.295512371400125,
            "length_improvement": 7.663157993545718,
            "smoothness_improvement": 161.35172753128433,
            "objective_score": 12.69330714520389
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025733375549316408,
            "num_nodes_avg": 124.9,
            "path_length_avg": 270.6302429909855,
            "smoothness_avg": 0.007920940087339998,
            "success_improvement": 0.0,
            "time_improvement": 84.33996677740382,
            "length_improvement": 9.65583522997395,
            "smoothness_improvement": 103.81149366979623,
            "objective_score": 31.6145486395545
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02684805393218994,
            "num_nodes_avg": 106.2,
            "path_length_avg": 138.76630520512623,
            "smoothness_avg": 0.017095730601368507,
            "success_improvement": 0.0,
            "time_improvement": 45.08096503553117,
            "length_improvement": 7.838027424128834,
            "smoothness_improvement": 117.45643137383614,
            "objective_score": 18.81438812200583
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "'An improved bidirectional RRT planner with adaptive goal biasing and fixed-radius rewiring that balances exploration and exploitation while enforcing strict collision checks and incremental optimal path cost updates for faster convergence and smoother, shorter paths within a 30-second time limit.'",
    "planning_mechanism": "A bidirectional tree grows alternately from start and goal by sampling free points with adaptive biasing favoring the goal; new nodes are added via steering within step size, rewired locally within a fixed radius to minimize path cost, and connected efficiently with collision-checked edges. Early solution detection and incremental best path updates ensure fast, smooth, and robust planning without expensive global refinements.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # cumulative cost from root\n        self.children = []                  # list of child nodes\n        self.valid = True                   # validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.0, goal_sample_rate: float=0.15, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(len(p1)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback (rare)\n            return goal_pos\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, position):\n            radius = self.rewire_radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def add_node(tree, new_pos, obstacles, nodes, edges, bounds):\n            neighbors = near_nodes(tree, new_pos)\n            # Find best parent\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cost = nb.cost + dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                return None\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-8 < nb.cost:\n                        # Rewire parent-child relation\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n            return new_node\n\n        def try_connect(tree, target_node):\n            near = near_nodes(tree, target_node.position)\n            for candidate in near:\n                d = dist(candidate.position, target_node.position)\n                if d <= self.step_size:\n                    if not is_edge_in_obstacle(candidate.position, target_node.position):\n                        final_node = Node(target_node.position, cost=candidate.cost + d)\n                        candidate.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((candidate, final_node))\n                        return final_node\n            return None\n\n        active_tree, passive_tree = tree_start, tree_goal\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = add_node(active_tree, steer(nearest(active_tree, sample).position, sample), obstacles, nodes, edges, bounds)\n            if new_node is None:\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            connect_node = try_connect(passive_tree, new_node)\n            if connect_node is not None:\n                # Construct path\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                path_goal.reverse()\n                candidate_path = path_start + path_goal[1:]\n\n                candidate_cost = new_node.cost + (connect_node.cost - (connect_node.parent.cost if connect_node.parent else 0))\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success = True\n                    # Early stop on first valid path\n                    break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        # If timeout and path found, return the best found\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 61.65738,
    "time_improvement": -177.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 156.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04252622127532959,
            "num_nodes_avg": 122.4,
            "path_length_avg": 167.10013285423705,
            "smoothness_avg": 0.015053750182804023,
            "success_improvement": -9.999999999999998,
            "time_improvement": -64.43074965891073,
            "length_improvement": 8.409769311542552,
            "smoothness_improvement": 135.6238801026224,
            "objective_score": -63.60524391023458
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.15486199855804444,
            "num_nodes_avg": 403.1,
            "path_length_avg": 253.69579618670372,
            "smoothness_avg": 0.010412302697201335,
            "success_improvement": 0.0,
            "time_improvement": 5.758805808861677,
            "length_improvement": 15.309041004268122,
            "smoothness_improvement": 167.91604807748385,
            "objective_score": 11.752646585606797
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.280318546295166,
            "num_nodes_avg": 398.0,
            "path_length_avg": 130.30186524082626,
            "smoothness_avg": 0.020853844271882326,
            "success_improvement": 0.0,
            "time_improvement": -473.40558403435733,
            "length_improvement": 13.459705415099107,
            "smoothness_improvement": 165.25935986767573,
            "objective_score": -133.11955516190937
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "An advanced bidirectional RRT* planner integrating adaptive rewiring radius, ellipsoidal informed sampling for focused refinement, recursive cost propagation, and balanced goal biasing for improved planning efficiency, path optimality, and smoothness within a strict 30-second runtime. The planner grows start and goal trees alternately, rewires nodes intelligently with efficient collision checks, and refines the best path using informed samples, returning the best-found solution even if interrupted by the time limit.",
    "planning_mechanism": "The algorithm alternates incremental expansions of two RRT* trees from start and goal positions using adaptive radius neighbor search for efficient rewiring. Upon discovering a feasible path, it switches to a refinement phase employing ellipsoidal informed sampling restricted to the subspace containing better solutions. Recursive cost updates during rewiring maintain path cost consistency, and balanced goal-biased sampling accelerates convergence. The strict 30-second time limit ensures timely termination with retrieval of the best computed path, improving overall planning speed, path length, and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-8\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(start, end)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d] - start[d]) * i / steps for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        dim = len(bounds)\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        c1 = c_best / 2.0\n        temp = c_best * c_best - c_min * c_min\n        c2 = math.sqrt(temp) / 2.0 if temp > 0 else 0.0\n\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _rewire(self, nodes, edges, near_nodes, new_node, obstacles, is_3d):\n        rewired_any = False\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n            if cost_through_new + self.improve_tol < near_node.cost and not \\\n               self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                # Remove old edge\n                if near_node.parent:\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.parent.remove_child(near_node)\n                # Rewire\n                near_node.parent = new_node\n                near_node.update_cost_recursive(cost_through_new)\n                new_node.add_child(near_node)\n                edges.append((new_node, near_node))\n                rewired_any = True\n        return rewired_any\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iteration % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            nn_count = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 25)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path_goal.reverse()\n                    path_full = path + path_goal[1:]\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                    path_b.reverse()\n                    path_full = path_a + path_b[1:]\n\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost) if expand_start else connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path_full\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # Refinement phase\n        if found_solution and best_goal_node:\n            # Reset tree to best path to enable refinement growth\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                dist_edge = self._dist(prev.position, pos)\n                new_node = Node(pos, parent=prev, cost=prev.cost + dist_edge)\n                prev.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev, new_node))\n                prev = new_node\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                nn_count = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 25)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.70323,
    "time_improvement": 47.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 122.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021251106262207033,
            "num_nodes_avg": 133.6,
            "path_length_avg": 166.7387418803157,
            "smoothness_avg": 0.016297275756651106,
            "success_improvement": 0.0,
            "time_improvement": 17.831040967587295,
            "length_improvement": 8.607853430955286,
            "smoothness_improvement": 155.0877556923336,
            "objective_score": 11.289463127311029
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03271768093109131,
            "num_nodes_avg": 135.8,
            "path_length_avg": 271.82778369091403,
            "smoothness_avg": 0.007341797913278714,
            "success_improvement": 0.0,
            "time_improvement": 80.08967112125318,
            "length_improvement": 9.25606167503996,
            "smoothness_improvement": 88.90974839195232,
            "objective_score": 30.02508708335969
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02826693058013916,
            "num_nodes_avg": 101.2,
            "path_length_avg": 139.18019224500392,
            "smoothness_avg": 0.017353678465557278,
            "success_improvement": 0.0,
            "time_improvement": 42.17858200114804,
            "length_improvement": 7.563143359425009,
            "smoothness_improvement": 120.73750916658652,
            "objective_score": 17.79514816183235
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A refined bidirectional RRT* planner that utilizes adaptive neighbor radius scaling, balanced bidirectional expansion, goal bias sampling, and an efficient rewiring process with recursive cost updates. The planner incorporates early solution detection with ellipsoidal informed sampling in a dedicated refinement phase to improve path optimality and smoothness. A strict 30-second wall-clock time limit is enforced to guarantee timely results, returning the best path found so far.",
    "planning_mechanism": "The planner grows two trees\u2014start and goal\u2014in an alternating fashion, sampling with goal bias and using adaptive radius for near neighbor search and rewiring. Upon first feasible connection, the planner switches to an ellipsoidal informed sampling refinement phase to efficiently optimize the path, recursively updating costs downward from rewirings. Time checks ensure the algorithm halts at 30 seconds, returning the best solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 20.0  # adaptive radius scaling factor, refined to balance rewiring effort\n        self.improve_tol = 1e-9     # stricter improvement tolerance\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=0.8):\n        dist = 0.0\n        dims = len(start)\n        dist = 0\n        dist = 0\n        from math import dist as math_dist\n        dist = math_dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d] - start[d]) * i / steps for d in range(dims))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        s = 0\n        for i in range(len(p1)):\n            s += (p1[i] - p2[i]) ** 2\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _nearest(self, tree, point):\n        min_dist = float(\"inf\")\n        nearest = None\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest = node\n        return nearest\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        c1 = c_best * 0.5\n        temp = c_best * c_best - c_min * c_min\n        c2 = (temp ** 0.5) * 0.5 if temp > 0 else 0.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = sum(x*x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n\n            pt_coords = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                pt_coords[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], pt_coords[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _rewire(self, nodes, edges, near_nodes, new_node, obstacles, is_3d):\n        rewired = False\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, near_node.position)\n            if new_cost + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                # Remove old edge\n                if near_node.parent:\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.parent.remove_child(near_node)\n                # Rewire\n                near_node.parent = new_node\n                near_node.update_cost_recursive(new_cost)\n                new_node.add_child(near_node)\n                edges.append((new_node, near_node))\n                rewired = True\n        return rewired\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            nn_count = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node is nearest_node:\n                    continue\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path_first = new_node.path_from_root()\n                    path_second = connect_node.path_from_root()\n                    path_second.reverse()\n                    candidate_path = path_first + path_second[1:]\n                    total_cost_candidate = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path_first = connect_node.path_from_root()\n                    path_second = new_node.path_from_root()\n                    path_second.reverse()\n                    candidate_path = path_first + path_second[1:]\n                    total_cost_candidate = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost_candidate + self.improve_tol < best_cost:\n                    best_cost = total_cost_candidate\n                    best_path = candidate_path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                # Stop immediate expansion & enter refinement phase\n                break\n\n        if found_solution and best_goal_node:\n            # Begin refinement with ellipsoidal informed sampling using existing path as backbone\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                dist_edge = self._dist(prev.position, pos)\n                new_node = Node(pos, parent=prev, cost=prev.cost + dist_edge)\n                prev.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev, new_node))\n                prev = new_node\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                nn_count = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 44.74599,
    "time_improvement": 10.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 75.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.02707228660583496,
            "num_nodes_avg": 117.3,
            "path_length_avg": 174.04032148707506,
            "smoothness_avg": 0.012304532726861963,
            "success_improvement": -19.999999999999996,
            "time_improvement": -4.676979239647474,
            "length_improvement": 4.605741947557567,
            "smoothness_improvement": 92.59265689587005,
            "objective_score": -98.17668531888035
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06589953899383545,
            "num_nodes_avg": 138.2,
            "path_length_avg": 298.1592365331991,
            "smoothness_avg": 0.006206506556954457,
            "success_improvement": 0.0,
            "time_improvement": 59.896867473935025,
            "length_improvement": 0.4658648074385433,
            "smoothness_improvement": 59.69788407641761,
            "objective_score": 18.54706854702572
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.06056468486785889,
            "num_nodes_avg": 112.7,
            "path_length_avg": 145.0454292878841,
            "smoothness_avg": 0.013481888979700532,
            "success_improvement": -9.999999999999998,
            "time_improvement": -23.888087169030467,
            "length_improvement": 3.667732188119007,
            "smoothness_improvement": 71.4886326922608,
            "objective_score": -54.60834367437643
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, recursive cost updates, goal-biased bidirectional sampling, and ellipsoidal informed sampling refinement. The planner alternates tree expansions, connects trees efficiently, and refines the path within a 30-second wall-clock time limit, ensuring faster convergence, improved path length, and smoother trajectories.",
    "planning_mechanism": "The planner grows start and goal trees in alternation, employing adaptive radius neighbor searches and rewiring with recursive cost propagation. Upon connecting the trees, the algorithm switches to an ellipsoidal informed sampling refinement phase to optimize the path under the 30-second time restriction, dynamically updating the best path and terminating early if time expires.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, new_cost: float):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 18.0  # Slightly reduced to balance rewiring cost and connectivity\n        self.improve_tol = 1e-9\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _sample_uniform(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        return self._sample_uniform(bounds, obstacles, is_3d)\n\n    def _nearest(self, tree, point):\n        min_dist = float(\"inf\")\n        nearest = None\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                nearest = node\n        return nearest\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        near_nodes = []\n        for node in tree:\n            dx = tuple(node.position[d] - point[d] for d in range(len(point)))\n            dist_sq = sum(x*x for x in dx)\n            if dist_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            return self._sample_uniform(bounds, obstacles, is_3d)\n\n        c1 = c_best * 0.5\n        temp = c_best*c_best - c_min*c_min\n        c2 = (math.sqrt(temp) * 0.5) if temp > 0 else 0.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x/norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n\n            pt_coords = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                pt_coords[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[d], pt_coords[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _rewire(self, nodes, edges, near_nodes, new_node, obstacles, is_3d):\n        rewired = False\n        for near_node in near_nodes:\n            if near_node is new_node.parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, near_node.position)\n            if new_cost + self.improve_tol < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    # Rewire with recursive cost update\n                    near_node.parent = new_node\n                    near_node.update_cost_recursive(new_cost)\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    rewired = True\n        return rewired\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            nn_count = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 10)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node is nearest_node:\n                    continue\n                candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path_first = new_node.path_from_root()\n                    path_second = connect_node.path_from_root()\n                    path_second.reverse()\n                    candidate_path = path_first + path_second[1:]\n                    total_cost_candidate = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path_first = connect_node.path_from_root()\n                    path_second = new_node.path_from_root()\n                    path_second.reverse()\n                    candidate_path = path_first + path_second[1:]\n                    total_cost_candidate = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost_candidate + self.improve_tol < best_cost:\n                    best_cost = total_cost_candidate\n                    best_path = candidate_path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Refinement phase\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev = start_root\n            for pos in best_path[1:]:\n                dist_edge = self._dist(prev.position, pos)\n                new_node = Node(pos, parent=prev, cost=prev.cost + dist_edge)\n                prev.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev, new_node))\n                prev = new_node\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            refinement_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                nn_count = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(nn_count) / nn_count) ** (1 / dim)), self.step_size * 10)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = self._rewire(nodes, edges, near_nodes, new_node, obstacles, is_3d)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 12.05072,
    "time_improvement": 15.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 62.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023263025283813476,
            "num_nodes_avg": 130.1,
            "path_length_avg": 184.83012165338417,
            "smoothness_avg": 0.010758067635320839,
            "success_improvement": 0.0,
            "time_improvement": 10.05180869501088,
            "length_improvement": -1.3083184989213028,
            "smoothness_improvement": 68.38712001055528,
            "objective_score": 2.5724871092032586
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03916864395141602,
            "num_nodes_avg": 140.1,
            "path_length_avg": 296.10787092412704,
            "smoothness_avg": 0.006245718750987474,
            "success_improvement": 0.0,
            "time_improvement": 76.16394070075623,
            "length_improvement": 1.1506696930319913,
            "smoothness_improvement": 60.7068420722889,
            "objective_score": 23.843118236407506
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.06833128929138184,
            "num_nodes_avg": 108.6,
            "path_length_avg": 152.87265306037233,
            "smoothness_avg": 0.012314386865569838,
            "success_improvement": -9.999999999999998,
            "time_improvement": -39.7750643394411,
            "length_improvement": -1.5307371492242638,
            "smoothness_improvement": 56.638091976560304,
            "objective_score": -62.56777113148408
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified adaptive bidirectional RRT* planner that balances efficiency and path quality by using uniform fixed-radius rewiring without recursive cost propagation, alternating tree expansion with goal biasing, early termination upon solution discovery, consistent edge and parent-child management, and efficient collision checking to ensure robust, smooth, and near-optimal paths within a 30-second time limit.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately by sampling with goal bias, extends nodes with fixed step size towards samples, rewires neighbors within a fixed radius based on current tree size without recursive updates, attempts connecting trees immediately upon proximity, tracks and returns the best path found so far, and stops early when the time limit is exceeded or a solution is found, thus reducing overhead while maintaining path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []        # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15         # probability to sample goal\n        self.rewire_radius_factor = 3.0      # fixed radius factor, tuned for performance/smoothness\n        self.time_limit = 30.0               # seconds hard limit\n        self.radius_max_multiplier = 10.0    # max radius multiplier for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Calculate radius for neighbor search (fixed, no recursive updates)\n            n_nodes = len(tree_a) + 1\n            radius = min(self.rewire_radius_factor * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.radius_max_multiplier)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors locally without recursion\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    old_parent = near_node.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near_node))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                path = self._build_path(new_node, connect_node)\n                total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success_state = True\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.29022,
    "time_improvement": 73.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007032942771911621,
            "num_nodes_avg": 132.2,
            "path_length_avg": 194.05003531743768,
            "smoothness_avg": 0.010639410791833328,
            "success_improvement": 0.0,
            "time_improvement": 72.80661160072273,
            "length_improvement": -6.361899277070333,
            "smoothness_improvement": 66.529882742516,
            "objective_score": 18.357493327687198
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.016536879539489745,
            "num_nodes_avg": 266.0,
            "path_length_avg": 307.38978928482237,
            "smoothness_avg": 0.006597505067211436,
            "success_improvement": 0.0,
            "time_improvement": 89.93648996843868,
            "length_improvement": -2.6155593877828665,
            "smoothness_improvement": 69.75855737017326,
            "objective_score": 25.760404144712748
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020846033096313478,
            "num_nodes_avg": 288.8,
            "path_length_avg": 160.03405130963824,
            "smoothness_avg": 0.012852771092420385,
            "success_improvement": 0.0,
            "time_improvement": 57.35839836367865,
            "length_improvement": -6.2869968772476,
            "smoothness_improvement": 63.48629960270936,
            "objective_score": 13.75275288076858
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, general bidirectional RRT planner that grows two trees alternately from start and goal using goal-biased sampling and fixed step size extensions. The algorithm performs straightforward nearest-neighbor selection and incremental tree growth without rewiring or recursion. It performs consistent collision checks on nodes and edges and attempts connection between trees after each new node addition. Early termination occurs upon the first found path or when a 30-second time limit is exceeded, returning the best feasible path found. This simplicity promotes robust generalization across various environments.",
    "planning_mechanism": "The planner samples points mostly randomly with some goal bias, extends the nearest node in one tree towards sampled points, attempts to connect to the other tree, and swaps roles each iteration. It uses simple distance-based nearest neighbor searches, basic collision checks on nodes and edges, and builds parent-child relations incrementally without rewiring. The best path found is tracked and returned, enabling simplicity and consistent performance within a set time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Alternate trees each iteration\n        active_tree, passive_tree = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Attempt to connect to passive tree\n            nearest_in_passive = nearest(passive_tree, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_passive.position)\n            if connect_dist <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_in_passive.position):\n                    # Connect trees\n                    connect_node = Node(nearest_in_passive.position, parent=new_node,\n                                        cost=new_node.cost + connect_dist)\n                    new_node.add_child(connect_node)\n                    active_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    # Extract path\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_in_passive.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]  # avoid duplicate node\n\n                    total_cost = connect_node.cost + (nearest_in_passive.cost - (nearest_in_passive.parent.cost if nearest_in_passive.parent else 0))\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success = True\n                    break  # stop after first connection\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -23.15293,
    "time_improvement": 83.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 68.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006335854530334473,
            "num_nodes_avg": 130.7,
            "path_length_avg": 187.36865867310507,
            "smoothness_avg": 0.010810852508436667,
            "success_improvement": 0.0,
            "time_improvement": 75.50195434934916,
            "length_improvement": -2.699730865123569,
            "smoothness_improvement": 69.2133178990046,
            "objective_score": 21.37681437522563
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013036704063415528,
            "num_nodes_avg": 273.9,
            "path_length_avg": 295.7181795551451,
            "smoothness_avg": 0.006810485609315557,
            "success_improvement": 0.0,
            "time_improvement": 92.06652005855231,
            "length_improvement": 1.2807598886422866,
            "smoothness_improvement": 75.23870012219615,
            "objective_score": 28.764605451362048
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009097981452941894,
            "num_nodes_avg": 226.5,
            "path_length_avg": 164.1122592210695,
            "smoothness_avg": 0.012544295097881214,
            "success_improvement": 0.0,
            "time_improvement": 81.3896246341662,
            "length_improvement": -8.995548388628077,
            "smoothness_improvement": 59.562507721500545,
            "objective_score": 19.317370895680515
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A novel unidirectional RRT*-based planner with adaptive local sampling density, a spatial grid acceleration structure for near-neighbor queries, and incremental lazy collision checking to minimize expensive obstacle checks. This planner integrates goal biasing and dynamic radius rewiring based on number of nodes for efficient path optimization. It applies incremental cost updates on rewiring and early termination with best path tracking, guaranteeing a smooth, short, and feasible path within a 30-second limit.",
    "planning_mechanism": "The planner grows a single RRT* tree from start towards the goal, sampling biased near the goal. To speed nearest and near neighbor queries, it organizes nodes in a spatial grid hashing structure keyed by node position. Edge collision checks are performed lazily\u2014only when needed for rewiring or path extraction\u2014to reduce calls. The rewiring radius shrinks logarithmically with tree size, focusing rewiring locally. The planner performs incremental cost updates on rewiring to ensure consistent cost tracking across descendants. Search terminates either upon a path connecting near the goal free of collisions or if time limit is reached, returning the best found path so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For future collision status or pruning if needed\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_cost_recursive(self, new_cost):\n        diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + diff)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-7\n        self.grid_cell_size = None  # To be set after bounds known\n        self.grid = {}\n        self.dimension = 0\n        self.bounds = ()\n        self.is_3d = False\n\n    # --- Spatial hash grid helpers ---\n    def _grid_key(self, pos):\n        return tuple(int(p / self.grid_cell_size) for p in pos)\n\n    def _grid_insert(self, node):\n        key = self._grid_key(node.position)\n        if key not in self.grid:\n            self.grid[key] = []\n        self.grid[key].append(node)\n\n    def _grid_near_nodes(self, pos, radius):\n        key_center = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell_size) + 1\n        candidates = []\n        for dx in range(-r_cells, r_cells + 1):\n            for dy in range(-r_cells, r_cells + 1):\n                if self.is_3d:\n                    for dz in range(-r_cells, r_cells + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        candidates.extend(self.grid.get(k, []))\n                else:\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    candidates.extend(self.grid.get(k, []))\n        # Filter candidates by exact distance <= radius\n        radius_sq = radius * radius\n        result = [n for n in candidates if self._dist_sq(n.position, pos) <= radius_sq]\n        return result\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        self.bounds = map.size\n        self.is_3d = len(self.bounds) == 3\n        self.dimension = len(self.bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        self.grid_cell_size = self.step_size * 1.5  # Slightly larger cells than step_size for coverage\n        self.grid = {}\n\n        # Core data structures\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n\n        time_start = time.monotonic()\n        def timeout():\n            return time.monotonic() - time_start > self.time_limit\n\n        # Initialize tree root\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        self._grid_insert(root)\n\n        def in_bounds(p):\n            for i in range(self.dimension):\n                if not (0 <= p[i] <= self.bounds[i]):\n                    return False\n            return True\n\n        def is_free_point(p):\n            for obs in obstacles:\n                if self.is_3d:\n                    x,y,z,w,h,d=obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return False\n                else:\n                    x,y,w,h=obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return False\n            return True\n\n        def is_free_edge(a,b, resolution=1.0):\n            dist = self._distance(a,b)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * (i/steps) for d in range(self.dimension))\n                if not in_bounds(interp) or not is_free_point(interp):\n                    return False\n            return True\n\n        def steer(from_p, to_p):\n            dist = self._distance(from_p,to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(self.dimension))\n\n        def distance(a, b):\n            return math.dist(a,b)\n\n        # Use squared distance for faster radius checks\n        def dist_sq(a,b):\n            s = 0\n            for i in range(self.dimension):\n                diff = a[i]-b[i]\n                s += diff*diff\n            return s\n\n        self._distance = distance\n        self._dist_sq = dist_sq\n\n        def nearest_node(pos):\n            # Use grid neighbors with large radius to find nearest but fallback on all if empty\n            search_radius = self.step_size * 5.0\n            near_candidates = self._grid_near_nodes(pos, search_radius)\n            if not near_candidates:\n                # Grid empty cells maybe because few nodes, fallback linear\n                near_candidates = nodes\n            min_node = None\n            min_dist = float(\"inf\")\n            for n in near_candidates:\n                d = dist_sq(n.position, pos)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = n\n            return min_node\n\n        def near_nodes(pos, radius):\n            return self._grid_near_nodes(pos, radius)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if is_free_point(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                pt = tuple(random.uniform(0, self.bounds[i]) for i in range(self.dimension))\n                if is_free_point(pt):\n                    return pt\n            return goal_pos  # fallback\n\n        # Adaptive radius from RRT* theory: gamma * (log(n)/n)^(1/d)\n        def rewiring_radius(n):\n            if n <= 1:\n                return self.step_size * 20\n            val = self.gamma_rrt_star * ((math.log(n)/n)**(1/self.dimension))\n            return min(val, self.step_size*20)\n\n        def update_costs_recursive(node, new_cost):\n            node.cost = new_cost\n            stack = list(node.children)\n            while stack:\n                c = stack.pop()\n                c.cost = c.parent.cost + distance(c.parent.position, c.position)\n                stack.extend(c.children)\n\n        def rewire(new_node, near_nodes_list):\n            rewired_any = False\n            for near_n in near_nodes_list:\n                if near_n == new_node.parent:\n                    continue\n                c_through_new = new_node.cost + distance(new_node.position, near_n.position)\n                if c_through_new + self.improve_tol < near_n.cost:\n                    if is_free_edge(new_node.position, near_n.position):\n                        # remove old edge\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        # rewire near_n\n                        near_n.parent = new_node\n                        update_costs_recursive(near_n, c_through_new)\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n                        rewired_any = True\n            return rewired_any\n\n        # Track best node near goal within step_size\n        def closest_goal_node():\n            radius_goal = self.step_size\n            near_goal_nodes = near_nodes(goal_pos, radius_goal)\n            near_goal_nodes = [n for n in near_goal_nodes if is_free_edge(n.position, goal_pos)]\n            if not near_goal_nodes:\n                return None\n            min_n = None\n            min_cost = float(\"inf\")\n            for n in near_goal_nodes:\n                total_cost = n.cost + distance(n.position, goal_pos)\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    min_n = n\n            return min_n, min_cost if min_n else (None, float(\"inf\"))\n\n        for iter in range(self.max_iter):\n            if timeout():\n                break\n            q_rand = sample_free()\n            q_near = nearest_node(q_rand)\n            q_new_pos = steer(q_near.position, q_rand)\n            if not in_bounds(q_new_pos) or not is_free_point(q_new_pos):\n                continue\n            if not is_free_edge(q_near.position, q_new_pos):\n                continue\n\n            # Find near nodes for rewiring\n            n_nodes = len(nodes) + 1\n            radius = rewiring_radius(n_nodes)\n            near_nodes_list = near_nodes(q_new_pos, radius)\n\n            # Choose best parent from near nodes\n            min_cost_candidate = q_near.cost + distance(q_near.position, q_new_pos)\n            best_parent = q_near\n            for near_candidate in near_nodes_list:\n                cost_candidate = near_candidate.cost + distance(near_candidate.position, q_new_pos)\n                if cost_candidate + self.improve_tol < min_cost_candidate:\n                    # Check edge collision lazily\n                    if is_free_edge(near_candidate.position, q_new_pos):\n                        min_cost_candidate = cost_candidate\n                        best_parent = near_candidate\n\n            new_node = Node(q_new_pos, parent=best_parent, cost=min_cost_candidate)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(new_node)\n\n            # Rewire near nodes with new_node\n            rewire(new_node, near_nodes_list)\n\n            # Check if new_node can connect directly to goal within step_size\n            dist_to_goal = distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success_state = True\n\n                # Track best solution\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    best_path = goal_node.path_from_root()\n                    break  # early stop on first solution found\n\n        # If no goal node found but nodes exist, find closest and best partial path\n        if not success_state and nodes:\n            close_node, close_cost = closest_goal_node() or (None, float(\"inf\"))\n            if close_node:\n                best_path = close_node.path_from_root()\n                success_state = True\n                best_goal_node = close_node\n\n        if not best_path:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 30.95675,
    "time_improvement": -120.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 43.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05181355476379394,
            "num_nodes_avg": 367.6,
            "path_length_avg": 169.69787048355005,
            "smoothness_avg": 0.009793221076205939,
            "success_improvement": 0.0,
            "time_improvement": -100.34090490062317,
            "length_improvement": 6.9859081531291665,
            "smoothness_improvement": 53.28517616256917,
            "objective_score": -25.644300697496604
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.24113867282867432,
            "num_nodes_avg": 1477.4,
            "path_length_avg": 280.08138883825075,
            "smoothness_avg": 0.004661134733256229,
            "success_improvement": 0.0,
            "time_improvement": -46.744822517079584,
            "length_improvement": 6.500770710007051,
            "smoothness_improvement": 19.93435396632888,
            "objective_score": -10.023312559288
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15323870182037352,
            "num_nodes_avg": 637.4,
            "path_length_avg": 134.1003277687884,
            "smoothness_avg": 0.012145135362433774,
            "success_improvement": 0.0,
            "time_improvement": -213.45741648308936,
            "length_improvement": 10.936947467375152,
            "smoothness_improvement": 54.48522534951601,
            "objective_score": -57.20263033775413
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An efficient unidirectional adaptive RRT* variant with a dynamic sampling bias toward the goal, KD-tree acceleration for nearest and near neighbor searches, and incremental cost updating after rewiring to ensure consistent paths. The method features adaptive shrinking neighbor radius for rewiring, lazy collision checking, early path caching and returns the best found path within a 30-second limit.",
    "planning_mechanism": "A single tree is grown from start toward goal, sampling mainly near the goal to accelerate convergence. A KD-tree spatial index (using a grid-based hash for this implementation) speeds up nearest and radius-based neighbor searches, allowing efficient rewiring within an adaptively shrinking radius. Incremental cost updates upon rewiring maintain consistent subtree costs. Collision checks are performed lazily only as needed. The search ends early when the goal is connected or time expires, returning the best available path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # tuple of float (2D or 3D)\n        self.parent = parent            # parent Node or None\n        self.cost = cost                # cost from root to this node\n        self.children = []              # list of child nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_cost_recursive(self, cost):\n        self.cost = cost\n        for c in self.children:\n            c.update_cost_recursive(cost + math.dist(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.2, gamma_rrtstar=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal (goal bias)\n        self.gamma_rrtstar = gamma_rrtstar  # rewiring radius factor (typically ~30 for 2D)\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        # Root node\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Spatial grid index parameters for neighbor queries\n        dim = len(bounds)\n        cell_size = self.step_size * 2\n        grid = {}  # dict: cell_idx tuple -> list of nodes\n\n        def grid_index(point):\n            return tuple(int(p // cell_size) for p in point)\n\n        def add_to_grid(node):\n            idx = grid_index(node.position)\n            if idx not in grid:\n                grid[idx] = []\n            grid[idx].append(node)\n\n        def near_nodes(position, radius):\n            \"\"\"Return nodes in grid cells overlapping radius ball around position.\"\"\"\n            center_idx = grid_index(position)\n            neighbors = []\n            r_cells = int(math.ceil(radius / cell_size))\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    zi_range = [0]\n                    if is_3d:\n                        zi_range = range(-r_cells, r_cells + 1)\n                    for dz in zi_range:\n                        cell = (center_idx[0]+dx, center_idx[1]+dy)\n                        if is_3d:\n                            cell = (center_idx[0]+dx, center_idx[1]+dy, center_idx[2]+dz)\n                        if cell in grid:\n                            for n in grid[cell]:\n                                if math.dist(n.position, position) <= radius:\n                                    neighbors.append(n)\n            return neighbors\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def reconstruct_path(node):\n            path = []\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        add_to_grid(root)\n\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Dynamic rewiring radius as per RRT* theory\n            n_nodes = len(nodes) + 1\n            unit_ball_volume = math.pi if dim == 2 else 4.0/3.0*math.pi  # approximate volume unit ball\n            radius = min(self.gamma_rrtstar * (math.log(n_nodes) / n_nodes)**(1/dim), self.step_size*15.0)\n            # find near neighbors for rewiring\n            near = near_nodes(new_pos, radius)\n\n            # Choose best parent among near nodes + nearest_node\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in near:\n                c = n.cost + math.dist(n.position, new_pos)\n                if c < min_cost and not is_edge_in_obstacle(n.position, new_pos):\n                    min_cost = c\n                    min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n            add_to_grid(new_node)\n\n            # Rewiring step for near nodes\n            for n in near:\n                if n is new_node or n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost and not is_edge_in_obstacle(new_node.position, n.position):\n                    # Rewire n's parent to new_node\n                    if n.parent is not None:\n                        try:\n                            n.parent.children.remove(n)\n                            edges.remove((n.parent, n))\n                        except:\n                            pass\n                    n.parent = new_node\n                    new_node.children.append(n)\n                    prev_cost = n.cost\n                    n.update_cost_recursive(new_cost)\n\n                    edges.append((new_node, n))\n\n            # Check if new_node close to goal and path reachable\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, new_node, new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    path_candidate = reconstruct_path(goal_node)\n                    cost_candidate = goal_node.cost\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        best_path = path_candidate\n                        success = True\n                    # Early stopping on first practical solution\n                    break\n\n        # If timed out or finished, and no path found\n        if not success:\n            # Try to find best node close to goal and reconstruct path\n            close_nodes = [n for n in nodes if math.dist(n.position, goal_pos) <= self.step_size*2 and not is_edge_in_obstacle(n.position, goal_pos)]\n            if close_nodes:\n                best_candidate = min(close_nodes, key=lambda n: n.cost + math.dist(n.position, goal_pos))\n                goal_node = Node(goal_pos, best_candidate, best_candidate.cost + math.dist(best_candidate.position, goal_pos))\n                path_candidate = reconstruct_path(goal_node)\n                best_path = path_candidate\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -4.06791,
    "time_improvement": -1.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 68.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020831871032714843,
            "num_nodes_avg": 277.9,
            "path_length_avg": 171.2196194221432,
            "smoothness_avg": 0.011685888636577088,
            "success_improvement": 0.0,
            "time_improvement": 19.45204469191342,
            "length_improvement": 6.151813446231218,
            "smoothness_improvement": 82.90953347576773,
            "objective_score": 9.941249142691596
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.13673231601715088,
            "num_nodes_avg": 1182.1,
            "path_length_avg": 283.03020379871884,
            "smoothness_avg": 0.005623670629049493,
            "success_improvement": 0.0,
            "time_improvement": 16.791615335206817,
            "length_improvement": 5.516371399270292,
            "smoothness_improvement": 44.70109585167245,
            "objective_score": 8.57081291938258
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06740128993988037,
            "num_nodes_avg": 737.9,
            "path_length_avg": 138.85464737636946,
            "smoothness_avg": 0.01392877328333567,
            "success_improvement": 0.0,
            "time_improvement": -37.87270422682208,
            "length_improvement": 7.779354760391222,
            "smoothness_improvement": 77.17296804893165,
            "objective_score": -6.308333571567233
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional sampling-based planner that integrates efficient nearest and near neighbor searches with adaptive radius rewiring, recursive cost updates, informed ellipsoidal sampling for focused refinement, and consistent collision checking. The algorithm balances exploration and exploitation via goal bias and ellipsoidal sampling, iteratively grows two trees with rewiring to optimize path cost and smoothness, and maintains best path tracking to return the shortest collision-free path within a 30-second limit. This approach improves planning speed, path quality, and smoothness while ensuring robustness.",
    "planning_mechanism": "The planner starts growing two trees from start and goal positions, alternately sampling points with goal bias and informed ellipsoidal sampling after initial solution discovery. It extends trees using fixed step size towards samples, finds neighbors within an adaptive radius to choose the best parent and performs rewiring with recursive cost propagation to maintain optimal paths. When trees connect, it reconstructs the path and continues refining until time runs out or no significant improvements occur, returning the best found path with nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self, cost_diff):\n        self.cost += cost_diff\n        for child in self.children:\n            child.update_cost_recursive(cost_diff)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        d = math.dist(from_pos, to_pos)\n        if d <= self.step_size:\n            return to_pos\n        ratio = self.step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            # Use informed sampling after first solution, else goal bias sampling\n            if found_solution:\n                sample_pt = self._ellipsoidal_informed_sample(\n                    best_cost, self._dist(start_pos, goal_pos),\n                    start_pos, goal_pos,\n                    bounds, obstacles, is_3d\n                )\n            else:\n                if random.random() < self.goal_sample_rate and not self._is_in_obstacle(sample_goal, obstacles, is_3d):\n                    sample_pt = sample_goal\n                else:\n                    while True:\n                        sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                            break\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(\n                self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                self.step_size * 12\n            )\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    # Check edge collision before considering near as parent\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired_any = False\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        cost_diff = cost_through_new - near.cost\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        near.update_cost_recursive(cost_diff)\n                        rewired_any = True\n\n            # Attempt connection between trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by creating a new node on the other tree at new_node's position\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    # Build path from start tree's new_node to connect_node on goal tree\n                    path = new_node.path_from_root() + nearest_other.path_from_root()[::-1][1:]\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    path_cost = total_cost\n                else:\n                    # Build path from goal tree's new_node to connect_node on start tree\n                    path = nearest_other.path_from_root() + new_node.path_from_root()[::-1][1:]\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    path_cost = total_cost\n\n                if path_cost + self.improve_tol < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            # If found a solution, optionally refine (continue rewiring and sampling in informed space)\n            if found_solution:\n                # Continue refinement with focused informed samples and rewiring\n                no_improve_count = 0\n                max_no_improve = 100\n                while not time_exceeded() and no_improve_count < max_no_improve:\n                    sample_pt = self._ellipsoidal_informed_sample(\n                        best_cost, self._dist(start_pos, goal_pos),\n                        start_pos, goal_pos,\n                        bounds, obstacles, is_3d\n                    )\n                    nearest_node = self._nearest(tree_start, sample_pt)\n                    new_pos = self._steer(nearest_node.position, sample_pt)\n\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        no_improve_count += 1\n                        continue\n                    if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                        no_improve_count += 1\n                        continue\n\n                    n_nodes = len(tree_start) + 1\n                    radius = min(\n                        self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)),\n                        self.step_size * 12\n                    )\n                    near_nodes = self._near(tree_start, new_pos, radius)\n\n                    min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                    best_parent = nearest_node\n                    for near in near_nodes:\n                        cost_candidate = near.cost + self._dist(near.position, new_pos)\n                        if cost_candidate + self.improve_tol < min_cost:\n                            if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                                min_cost = cost_candidate\n                                best_parent = near\n\n                    new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                    best_parent.add_child(new_node)\n                    tree_start.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((best_parent, new_node))\n\n                    rewired_any = False\n                    for near in near_nodes:\n                        if near is best_parent:\n                            continue\n                        cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                        if cost_through_new + self.improve_tol < near.cost:\n                            if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                                if near.parent:\n                                    try:\n                                        edges.remove((near.parent, near))\n                                    except ValueError:\n                                        pass\n                                    near.parent.remove_child(near)\n                                near.parent = new_node\n                                cost_diff = cost_through_new - near.cost\n                                near.cost = cost_through_new\n                                new_node.add_child(near)\n                                edges.append((new_node, near))\n                                near.update_cost_recursive(cost_diff)\n                                rewired_any = True\n\n                    dist_goal = self._dist(new_node.position, goal_pos)\n                    if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                        new_node.add_child(new_goal_node)\n                        tree_start.append(new_goal_node)\n                        nodes.append(new_goal_node)\n                        edges.append((new_node, new_goal_node))\n                        if new_goal_node.cost + self.improve_tol < best_cost:\n                            best_cost = new_goal_node.cost\n                            best_goal_node = new_goal_node\n                            best_path = new_goal_node.path_from_root()\n                            no_improve_count = 0\n                        else:\n                            no_improve_count += 1\n                    else:\n                        no_improve_count += 1\n\n                    if not rewired_any:\n                        no_improve_count += 1\n\n                break  # break outer for-loop after refinement phase completes or time expires\n\n        if not found_solution:\n            extracted_path = []\n            success_state = False\n        else:\n            extracted_path = best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 41.1196,
    "time_improvement": 46.0,
    "length_improvement": 4.0,
    "smoothness_improvement": 1839.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.023108434677124024,
            "num_nodes_avg": 193.6,
            "path_length_avg": 178.49714240928753,
            "smoothness_avg": 0.017702366205891915,
            "success_improvement": -9.999999999999998,
            "time_improvement": 10.649544599727125,
            "length_improvement": 2.162887777246035,
            "smoothness_improvement": 177.08047242569899,
            "objective_score": -44.62200159160574
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.030220603942871092,
            "num_nodes_avg": 244.9,
            "path_length_avg": 286.2162993209141,
            "smoothness_avg": 0.20623256110004345,
            "success_improvement": -19.999999999999996,
            "time_improvement": 81.60926611258917,
            "length_improvement": 4.452761007286718,
            "smoothness_improvement": 5206.512340413712,
            "objective_score": -46.813001859782645
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.027198266983032227,
            "num_nodes_avg": 275.3,
            "path_length_avg": 140.294779146738,
            "smoothness_avg": 0.018445061988287055,
            "success_improvement": -9.999999999999998,
            "time_improvement": 44.36458675229326,
            "length_improvement": 6.822887810218055,
            "smoothness_improvement": 134.61982701815734,
            "objective_score": -31.923792153090396
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "An improved bidirectional RRT* planner that incorporates adaptive neighbor radius shrinking, recursive descendant cost propagation during rewiring, ellipsoidal informed sampling after initial connection, and consistent parent-child and edge updates. It alternates expanding trees towards goal-biased samples, immediately attempts connections, and performs a dedicated refinement phase focused on the best path, integrating early termination upon time limit or convergence for improved planning time, path length, and smoothness.",
    "planning_mechanism": "A bidirectional approach grows two trees from start and goal alternately, sampling points with goal bias and steering by a fixed step size. New nodes are added after collision checks, rewiring neighbors within an adaptive radius with recursive cost propagation ensures cost consistency and smooth paths. After connecting the trees to form an initial feasible path, a single-tree ellipsoidal informed RRT* refinement phase focuses sampling around best path to incrementally optimize the solution while respecting a strict 30-second limit. Early termination returns the best found path, ensuring efficiency and path quality trade-offs.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        curr = self\n        while curr is not None:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18\n        self.gamma_rrt_star = 40.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        self.max_radius_factor = 12.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement with single-tree ellipsoidal informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired_flag = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired_flag = True\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired_flag:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -21.65631,
    "time_improvement": 48.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 216.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01897265911102295,
            "num_nodes_avg": 214.9,
            "path_length_avg": 173.2844153920329,
            "smoothness_avg": 0.0216733486766184,
            "success_improvement": 0.0,
            "time_improvement": 26.640823776687927,
            "length_improvement": 5.020066056348759,
            "smoothness_improvement": 239.23497121902156,
            "objective_score": 12.20046162291074
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028537869453430176,
            "num_nodes_avg": 401.1,
            "path_length_avg": 261.2893324906373,
            "smoothness_avg": 0.010723949701935617,
            "success_improvement": 0.0,
            "time_improvement": 82.63329337084573,
            "length_improvement": 12.774100018191398,
            "smoothness_improvement": 175.9349499795613,
            "objective_score": 33.334122772066365
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03140802383422851,
            "num_nodes_avg": 402.9,
            "path_length_avg": 131.62813763361018,
            "smoothness_avg": 0.02611706879070861,
            "success_improvement": 0.0,
            "time_improvement": 35.75331890075022,
            "length_improvement": 12.578858442116712,
            "smoothness_improvement": 232.20718725632335,
            "objective_score": 19.434346671776712
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with fixed-radius rewiring, goal-biased sampling, and incremental path cost updating, designed for efficient exploration and rapid convergence to short, smooth paths. It alternates expansions from start and goal trees, connects trees with collision-free edges, and maintains best path tracking with early stopping under a 30-second time limit. Edge and node collision checks, consistent tree updates, and pruning ensure high path quality and robustness.",
    "planning_mechanism": "The planner samples with goal bias, extends trees via fixed step size steer functions, uses a fixed-radius neighborhood for parent selection and rewiring to optimize path costs, alternates between start and goal expansions, attempts immediate connections, keeps track of best path found, and stops early either on timeout or solution stabilization, thus improving planning time, path length, and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Goal bias probability\n        self.fixed_radius = 15.0       # Fixed rewiring/neighbor radius\n        self.time_limit = 30.0         # Hard time limit in seconds\n        self.improve_tol = 1e-9        # Small tolerance for cost comparison\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths exist through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution:\n                # Early stop on improvement for efficiency\n                break\n\n        extracted_path = best_path if found_solution else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicated connection node position to avoid double count\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.79261,
    "time_improvement": 64.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 286.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014900636672973634,
            "num_nodes_avg": 124.9,
            "path_length_avg": 159.47130040463088,
            "smoothness_avg": 0.02276354128553975,
            "success_improvement": 0.0,
            "time_improvement": 42.38559681404182,
            "length_improvement": 12.591253263757743,
            "smoothness_improvement": 256.29885293978236,
            "objective_score": 21.5519252671661
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03198549747467041,
            "num_nodes_avg": 320.0,
            "path_length_avg": 240.61799786727897,
            "smoothness_avg": 0.01613382883159849,
            "success_improvement": 0.0,
            "time_improvement": 80.53524100891183,
            "length_improvement": 19.674786506845358,
            "smoothness_improvement": 315.1350365642233,
            "objective_score": 37.541119389601874
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015687036514282226,
            "num_nodes_avg": 203.9,
            "path_length_avg": 129.30542997382435,
            "smoothness_avg": 0.03047932298139177,
            "success_improvement": 0.0,
            "time_improvement": 67.91138348452755,
            "length_improvement": 14.121490274293217,
            "smoothness_improvement": 287.69473857370235,
            "objective_score": 30.284782902802707
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that grows two trees alternately from start and goal without rewiring, using goal-biased sampling and fixed step extensions. The planner performs consistent node and edge collision checks, employs linear nearest neighbor searches, and immediately attempts to connect trees after each extension. It terminates upon the first solution or a hard 30-second limit, returning the best found path. This simple design improves generalization and robustness by avoiding costly rewiring and neighbor radius tuning while preserving path quality and planning efficiency.",
    "planning_mechanism": "The planner samples random points with goal bias, extends the nearest node in the active tree toward the sample by a fixed step size if collision free, then tries to connect to the other tree within step distance. Trees alternate growth each iteration. The first successful connection merges two trees and extracts a path back to the start and goal. Early stopping with best path tracking and consistent collision checks keep planning efficient and robust across 2D/3D environments.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1, p2):\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[j] + (to_pos[j] - from_pos[j]) * (i / steps) for j in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not is_in_obstacle(point):\n                    return point\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        import time\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree, passive_tree = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_in_passive = nearest(passive_tree, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_passive.position)\n            if connect_dist <= self.step_size and not is_edge_in_obstacle(new_node.position, nearest_in_passive.position):\n                connect_node = Node(nearest_in_passive.position, parent=new_node,\n                                    cost=new_node.cost + connect_dist)\n                new_node.add_child(connect_node)\n                active_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                path_start = connect_node.path_from_root()\n                path_goal = nearest_in_passive.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n\n                total_cost = connect_node.cost + (nearest_in_passive.cost - (nearest_in_passive.parent.cost if nearest_in_passive.parent else 0))\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -4.64163,
    "time_improvement": 26.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 63.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012271285057067871,
            "num_nodes_avg": 125.6,
            "path_length_avg": 197.44463925531446,
            "smoothness_avg": 0.010282138143930279,
            "success_improvement": 0.0,
            "time_improvement": 52.5521774401711,
            "length_improvement": -8.222535486362233,
            "smoothness_improvement": 60.937789972860756,
            "objective_score": 11.136820890098292
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05787203311920166,
            "num_nodes_avg": 340.1,
            "path_length_avg": 308.8312962358399,
            "smoothness_avg": 0.006407108096274612,
            "success_improvement": 0.0,
            "time_improvement": 64.78200228457943,
            "length_improvement": -3.096775899509541,
            "smoothness_improvement": 64.85950617057375,
            "objective_score": 17.900832676520974
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06875224113464355,
            "num_nodes_avg": 356.0,
            "path_length_avg": 158.70207011466817,
            "smoothness_avg": 0.012884981005066309,
            "success_improvement": 0.0,
            "time_improvement": -40.636142354884505,
            "length_improvement": -5.402358389677112,
            "smoothness_improvement": 63.896007314077075,
            "objective_score": -15.112777703701234
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT algorithm with uniform fixed step growth and goal-biased sampling, which alternates growing start and goal trees. It performs straightforward nearest-node search without rewiring or complex neighbor radius tuning. Connections between trees are made when nodes are within step distance and collision-free. The planner terminates upon the first successful connection or after a 30-second time limit, returning the best path found.",
    "planning_mechanism": "The algorithm samples random free points with goal bias, grows one tree each iteration by extending its nearest node toward the sample by a fixed step, checks collisions for nodes and edges, and tries to connect the newly added node to the opposite tree. The growth alternates between start and goal trees until a feasible path joins them or the time limit expires.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # float\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i / steps for d in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            rnd_point = sample_free()\n            nearest_node = nearest(active_tree, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            active_tree.append(new_node)\n\n            nearest_in_passive = nearest(passive_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_in_passive.position)\n\n            if dist_connect <= self.step_size and not edge_in_obstacle(new_pos, nearest_in_passive.position):\n                connect_cost = new_node.cost + dist_connect\n                connect_node = Node(nearest_in_passive.position, parent=new_node, cost=connect_cost)\n                new_node.add_child(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n                active_tree.append(connect_node)\n\n                path_start = connect_node.path_from_root()\n                path_goal = nearest_in_passive.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -23.17208,
    "time_improvement": 79.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 71.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0068721771240234375,
            "num_nodes_avg": 135.3,
            "path_length_avg": 188.07230175950542,
            "smoothness_avg": 0.010839288894135057,
            "success_improvement": 0.0,
            "time_improvement": 73.42822375456322,
            "length_improvement": -3.085408790717821,
            "smoothness_improvement": 69.65840908578429,
            "objective_score": 20.525513897367194
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013908791542053222,
            "num_nodes_avg": 303.5,
            "path_length_avg": 297.988918180301,
            "smoothness_avg": 0.006692869599022928,
            "success_improvement": 0.0,
            "time_improvement": 91.5358116459578,
            "length_improvement": 0.522721975977883,
            "smoothness_improvement": 72.2123554619788,
            "objective_score": 28.135438456683964
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01370546817779541,
            "num_nodes_avg": 297.3,
            "path_length_avg": 153.3082196080233,
            "smoothness_avg": 0.01348836234332646,
            "success_improvement": 0.0,
            "time_improvement": 71.96478046558492,
            "length_improvement": -1.8200197107238791,
            "smoothness_improvement": 71.57097339976859,
            "objective_score": 20.85527718023999
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner with fixed step size and unbiased random sampling that grows two trees alternately from start and goal without goal bias or rewiring. The planner uses straightforward linear nearest neighbor search, edge and node collision checks with fixed resolution, and attempts tree connection whenever new nodes are close enough. It terminates upon the first connection or after a 30-second timeout, returning the path found.",
    "planning_mechanism": "The planner alternately grows start and goal trees by uniformly sampling free states without goal bias, extending nearest nodes by a fixed step, and checking node and edge collisions. Upon each extension, it attempts to connect the newly added node to the opposite tree if within step size, merging paths when successful. The process repeats until a path is found or time expires.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = math.dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        best_path = []\n        success = False\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            rnd_point = sample_free()\n            nearest_node = nearest(active_tree, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_in_passive = nearest(passive_tree, new_pos)\n            dist_connect = math.dist(new_pos, nearest_in_passive.position)\n\n            if dist_connect <= self.step_size and not edge_in_obstacle(new_pos, nearest_in_passive.position):\n                connect_cost = new_node.cost + dist_connect\n                connect_node = Node(nearest_in_passive.position, parent=new_node, cost=connect_cost)\n                new_node.add_child(connect_node)\n                active_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                path_start = connect_node.path_from_root()\n                path_goal = nearest_in_passive.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -23.45641,
    "time_improvement": 81.0,
    "length_improvement": -2.0,
    "smoothness_improvement": 69.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008159184455871582,
            "num_nodes_avg": 160.3,
            "path_length_avg": 185.4314620002835,
            "smoothness_avg": 0.010785415437332243,
            "success_improvement": 0.0,
            "time_improvement": 68.45191563110734,
            "length_improvement": -1.637922671904396,
            "smoothness_improvement": 68.81517249873633,
            "objective_score": 19.896896948683246
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009363079071044922,
            "num_nodes_avg": 279.5,
            "path_length_avg": 310.9313421212245,
            "smoothness_avg": 0.0065849312150528996,
            "success_improvement": 0.0,
            "time_improvement": 94.30210276777103,
            "length_improvement": -3.797831662520182,
            "smoothness_improvement": 69.43502309755448,
            "objective_score": 26.359106948306973
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009993338584899902,
            "num_nodes_avg": 256.3,
            "path_length_avg": 150.83101605197797,
            "smoothness_avg": 0.01337512549586337,
            "success_improvement": 0.0,
            "time_improvement": 79.55812691146785,
            "length_improvement": -0.17477906055582124,
            "smoothness_improvement": 70.13060905831273,
            "objective_score": 24.113223682398424
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional RRT* planner employing goal bias sampling, adaptive neighbor radius, and an incremental rewiring strategy with non-recursive cost updates for efficient planning. The planner starts with bidirectional tree growth and switches to single-tree informed sampling around the current best path for faster convergence and path improvement. Collision checks are performed at all stages, and a strict 30-second timeout ensures timely termination with the best found solution. It balances exploration and exploitation to minimize planning time while improving path length and smoothness.",
    "planning_mechanism": "The planner alternates expansions from start and goal trees using goal-biased sampling, employs an adaptive radius for neighbor search to limit rewiring overhead, keeps track of the best path found to switch to an informed sampling refinement phase that samples within an ellipsoid around the best path, all while maintaining consistent, non-recursive path cost updates and performing comprehensive collision checks, stopping immediately on timeout or upon solution refinement convergence.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 50.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r_sq = radius * radius\n        for node in tree:\n            # compare squared distance for speed\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        def timeout():\n            return time.monotonic() - time_start >= time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # === Bidirectional Phase ===\n        for it in range(self.max_iter):\n            if timeout():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            sample = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors (non-recursive)\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            nearest_opposite = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_opposite.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_opposite.position, new_node.position, obstacles, is_3d):\n                # Connect trees by linking new node with nearest opposite\n                connect_node = Node(new_node.position, parent=nearest_opposite, cost=nearest_opposite.cost + dist_connect)\n                nearest_opposite.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_opposite, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_opposite.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        # === Single-Tree Refinement Phase ===\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Build tree from best path for refinement\n        tree = [start_root]\n        start_root.children = []\n        start_root.cost = 0.0\n        nodes = [start_root]\n        edges = []\n\n        prev_node = start_root\n        for p in best_path[1:]:\n            n = Node(p, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, p))\n            prev_node.add_child(n)\n            tree.append(n)\n            nodes.append(n)\n            edges.append((prev_node, n))\n            prev_node = n\n        best_goal_node = prev_node\n        best_cost = best_goal_node.cost\n\n        no_improve_count = 0\n        max_no_improve = 150\n        refinement_iters = self.max_iter // 2\n        c_min = self._dist(start_pos, goal_pos)\n\n        for _ in range(refinement_iters):\n            if timeout() or no_improve_count >= max_no_improve:\n                break\n            sample = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            n_nodes = len(tree) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    rewired = True\n\n            # Check connecting new node directly to goal\n            dist_goal = self._dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                    success_state = True\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n        final_path = best_goal_node.path_from_root() if success_state else best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -12.53849,
    "time_improvement": 7.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 296.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030045223236083985,
            "num_nodes_avg": 95.4,
            "path_length_avg": 160.81581401172727,
            "smoothness_avg": 0.025708202112380618,
            "success_improvement": 0.0,
            "time_improvement": -16.17205649175855,
            "length_improvement": 11.854304050526727,
            "smoothness_improvement": 302.3891893131739,
            "objective_score": 3.7729114293543407
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.052814698219299315,
            "num_nodes_avg": 108.9,
            "path_length_avg": 250.64860418056378,
            "smoothness_avg": 0.01342185084909307,
            "success_improvement": 0.0,
            "time_improvement": 67.85964098761269,
            "length_improvement": 16.326281404476397,
            "smoothness_improvement": 245.35388971557333,
            "objective_score": 31.38043058754751
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06383750438690186,
            "num_nodes_avg": 90.5,
            "path_length_avg": 125.65242145575378,
            "smoothness_avg": 0.0347233803394253,
            "success_improvement": 0.0,
            "time_improvement": -30.582802922086017,
            "length_improvement": 16.54764459442284,
            "smoothness_improvement": 341.67883490416074,
            "objective_score": 2.4621400545487035
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A refined bidirectional RRT* variant using adaptive fixed-radius rewiring, efficient incremental cost propagation with recursive updates, balanced goal-biased sampling, and early termination upon stable best path discovery within a 30-second limit. The planner ensures coherent parent-child-edge structures and collision checking, improving planning time, path length, and smoothness.",
    "planning_mechanism": "A bidirectional approach grows two trees from start and goal, sampling points biased toward the opposite tree\u2019s root. New nodes steer at fixed step size and connect to the best nearby parent within an adaptive fixed radius. A recursive rewiring propagates cost improvements downstream efficiently. The planner attempts to connect the two trees each iteration, updates the best path found, and stops early if no improvement occurs within a set threshold. This combination accelerates convergence, enhances path quality, and reduces planning time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.fixed_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.max_no_improve_iters = 100\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_prob):\n        if random.random() < goal_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best, best_dist = node, d\n        return best\n\n    def _near(self, tree, point, radius):\n        r2 = radius * radius\n        near_nodes = []\n        for node in tree:\n            d2 = sum((a - b) ** 2 for a,b in zip(node.position, point))\n            if d2 <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _recursive_update_cost(self, node):\n        # Recursively update costs of children nodes if their cost can be improved\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for child in cur.children:\n                new_cost = cur.cost + self._dist(cur.position, child.position)\n                if new_cost + self.improve_tol < child.cost:\n                    child.cost = new_cost\n                    child.parent = cur\n                    stack.append(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def timeout():\n            return (time.monotonic() - time_start) >= self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_count in range(self.max_iter):\n            if timeout():\n                break\n\n            # Alternate tree expansions\n            expand_start = (iter_count % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_pos = goal_pos if expand_start else start_pos\n\n            sample = self._sample(bounds, obstacles, is_3d, target_pos, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_n in near_nodes:\n                tentative_cost = near_n.cost + self._dist(near_n.position, new_pos)\n                if tentative_cost + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = near_n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive downstream cost update\n            for near_n in near_nodes:\n                if near_n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = cost_through_new\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n                        # Recursively update costs downstream\n                        self._recursive_update_cost(near_n)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(new_node.position, nearest_other.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position,\n                                        parent=nearest_other,\n                                        cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve_iters:\n                break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 81.87426,
    "time_improvement": -309.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 274.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0980675220489502,
            "num_nodes_avg": 557.6,
            "path_length_avg": 154.82742708156258,
            "smoothness_avg": 0.022198131323300972,
            "success_improvement": 0.0,
            "time_improvement": -279.1852575684944,
            "length_improvement": 15.136633819013326,
            "smoothness_improvement": 247.44895922336076,
            "objective_score": -73.43635218302353
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1806812047958374,
            "num_nodes_avg": 845.2,
            "path_length_avg": 235.843127166259,
            "smoothness_avg": 0.01623263492538422,
            "success_improvement": 0.0,
            "time_improvement": -9.953459637621547,
            "length_improvement": 21.268775783878553,
            "smoothness_improvement": 317.67738852448286,
            "objective_score": 11.36361452166308
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.36087963581085203,
            "num_nodes_avg": 826.1,
            "path_length_avg": 133.9611821741662,
            "smoothness_avg": 0.02816904655326926,
            "success_improvement": 0.0,
            "time_improvement": -638.1973154224944,
            "length_improvement": 11.029361345922018,
            "smoothness_improvement": 258.30819293485155,
            "objective_score": -183.55003685452084
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved bidirectional incremental sampling-based planner with adaptive rewiring and dynamic step size that balances exploration and exploitation. It uses goal-biased sampling, efficient nearest neighbor caching, adaptive rewiring radius to reduce computational overhead, and incremental path refinement with recursive cost propagation to maintain updated node costs. The planner aggressively attempts tree connections and rewiring within a bounded neighborhood, while enforcing collision-free node and edge additions and terminating within 30 seconds, returning the best path found so far.",
    "planning_mechanism": "The planner alternates tree growth from start and goal by sampling mostly free states with goal bias to improve convergence. Each new node is added only after successful collision checks. The adaptive rewiring uses a shrinking neighborhood radius based on node density, limiting expensive computations. Rewiring improves path smoothness and length by considering lower-cost parent connections and recursively updating descendant costs. Direct tree connections are attempted whenever possible. The planner terminates when a valid path is found or after the 30-second limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n            child.parent = None\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_recursive(self):\n        for child in self.children:\n            d = math.dist(self.position, child.position)\n            possible_cost = self.cost + d\n            if possible_cost < child.cost:\n                child.cost = possible_cost\n                child.update_cost_recursive()\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=4.0, goal_sample_rate=0.15, gamma_rrt_star=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(fpos, tpos, res=0.5):\n            dist = math.dist(fpos, tpos)\n            steps = max(1, int(dist / res))\n            for i in range(steps+1):\n                interp = tuple(fpos[d] + (tpos[d]-fpos[d]) * (i/steps) for d in range(len(fpos)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(tree_nodes):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            n = len(tree_nodes)\n            if n==0:\n                return tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n            vol = 1.0\n            for v in bounds:\n                vol *= v\n            radius = min(self.gamma_rrt_star * ((math.log(n+1)/(n+1))**(1/(len(bounds)))), self.step_size*12.0)\n            # Sampling biased toward current best path ellipse can be too complex here, so uniform\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            best, best_dist = None, float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best, best_dist\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius*radius\n            for node in tree:\n                d2 = sum((node.position[d]-point[d])**2 for d in range(len(point)))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def try_connect_nodes(n1, n2):\n            if edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free(active_tree)\n            nearest_node, _ = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            # Choose best parent among near nodes\n            # radius depends on gamma and number of nodes in tree\n            r = min(self.gamma_rrt_star * ((math.log(len(active_tree)+1)/(len(active_tree)+1))**(1/len(bounds))), self.step_size*12.0)\n            near_nodes = near(active_tree, new_pos, r)\n\n            best_parent = nearest_node\n            best_cost_parent = new_cost\n            for near_node in near_nodes:\n                potential_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                if potential_cost < best_cost_parent and not edge_in_obstacle(near_node.position, new_pos):\n                    best_parent = near_node\n                    best_cost_parent = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = best_cost_parent\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if better cost found through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                dist_to_new = math.dist(new_node.position, near_node.position)\n                potential_cost = new_node.cost + dist_to_new\n                if potential_cost + 1e-10 < near_node.cost and not edge_in_obstacle(new_node.position, near_node.position):\n                    # Rewire\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.children.append(near_node)\n                    near_node.update_cost_recursive()\n                    # Update edges list accordingly\n                    # Remove old edge and add new edge\n                    # Edges is a list, remove and add carefully\n                    try:\n                        edges.remove((near_node.parent, near_node))  # The parent was updated already so safe\n                    except Exception:\n                        pass\n                    edges.append((new_node, near_node))\n\n            # Try to connect to passive tree\n            nearest_passive, dist_passive = nearest(passive_tree, new_node.position)\n            if dist_passive <= self.step_size and not edge_in_obstacle(new_node.position, nearest_passive.position):\n                # Connect trees\n                connect_cost = new_node.cost + dist_passive + nearest_passive.cost\n                # Build path\n                # Path from start tree root to new_node\n                if active_tree is tree_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_passive.path_from_root()\n                    path_goal.reverse()\n                else:\n                    path_start = nearest_passive.path_from_root()\n                    path_goal = new_node.path_from_root()\n                    path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n                # Update best path if better\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        if not success and best_path:\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 7.94255,
    "time_improvement": 24.0,
    "length_improvement": 2.0,
    "smoothness_improvement": 60.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.016480660438537596,
            "num_nodes_avg": 186.9,
            "path_length_avg": 179.25862821234745,
            "smoothness_avg": 0.011278510432977814,
            "success_improvement": -9.999999999999998,
            "time_improvement": 36.27631918581069,
            "length_improvement": 1.745505342074176,
            "smoothness_improvement": 76.53317995351088,
            "objective_score": -37.68713513924473
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04606809616088867,
            "num_nodes_avg": 397.5,
            "path_length_avg": 289.1228835399454,
            "smoothness_avg": 0.005827406480677625,
            "success_improvement": 0.0,
            "time_improvement": 71.96528240149837,
            "length_improvement": 3.48245953358606,
            "smoothness_improvement": 49.943366059066726,
            "objective_score": 23.928777270896482
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06721310615539551,
            "num_nodes_avg": 430.2,
            "path_length_avg": 148.2832177221978,
            "smoothness_avg": 0.012054053353790499,
            "success_improvement": 0.0,
            "time_improvement": -37.48776489878092,
            "length_improvement": 1.5173472769650225,
            "smoothness_improvement": 53.326668922548095,
            "objective_score": -10.06928775884252
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified unidirectional RRT* planner with adaptive rewiring radius, efficient grid-based nearest neighbor queries, goal biasing, non-recursive incremental cost propagation, and early termination upon solution or time limit. It avoids recursive rewiring overhead and redundant node creation, improving planning speed, path quality, and smoothness.",
    "planning_mechanism": "The planner incrementally expands a single tree from start toward goal, sampling with goal bias. It maintains nodes in a spatial grid for efficient neighbor queries, performs local rewiring with adaptive radius, updates costs incrementally without recursion, and tracks the best path found. It terminates early if a collision-free path to the goal is found or the 30-second limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-7\n        self.grid = {}\n        self.grid_cell_size = None\n        self.dim = 0\n        self.bounds = ()\n        self.is_3d = False\n\n    def _grid_key(self, pos):\n        return tuple(int(p / self.grid_cell_size) for p in pos)\n\n    def _grid_insert(self, node):\n        key = self._grid_key(node.position)\n        self.grid.setdefault(key, []).append(node)\n\n    def _grid_near_nodes(self, pos, radius):\n        key_c = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell_size) + 1\n        candidates = []\n        rng = range(-r_cells, r_cells + 1)\n        if self.is_3d:\n            for dx in rng:\n                for dy in rng:\n                    for dz in rng:\n                        k = (key_c[0] + dx, key_c[1] + dy, key_c[2] + dz)\n                        candidates.extend(self.grid.get(k, []))\n        else:\n            for dx in rng:\n                for dy in rng:\n                    k = (key_c[0] + dx, key_c[1] + dy)\n                    candidates.extend(self.grid.get(k, []))\n        radius_sq = radius * radius\n        return [n for n in candidates if self._dist_sq(n.position, pos) <= radius_sq]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(a,b)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(len(a)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _dist_sq(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            diff = a[i] - b[i]\n            s += diff*diff\n        return s\n\n    def _steer(self, from_p, to_p):\n        dist = self._distance(from_p, to_p)\n        if dist <= self.step_size:\n            return to_p\n        ratio = self.step_size / dist\n        return tuple(from_p[d] + ratio*(to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        for _ in range(100):\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(self.dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return goal\n\n    def _rewiring_radius(self, n):\n        if n <= 1:\n            return self.step_size * 15\n        val = self.gamma_rrt_star * ((math.log(n) / n) ** (1/self.dim))\n        return min(val, self.step_size * 15)\n\n    def _update_costs_nonrecursive(self, node):\n        stack = list(node.children)\n        while stack:\n            c = stack.pop()\n            c.cost = c.parent.cost + self._distance(c.parent.position, c.position)\n            stack.extend(c.children)\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, time, random\n\n        self.bounds = map.size\n        self.is_3d = len(self.bounds) == 3\n        self.dim = len(self.bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        self.grid_cell_size = self.step_size * 1.5\n        self.grid.clear()\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n\n        time_start = time.monotonic()\n        def timeout():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        self._grid_insert(root)\n\n        for _ in range(self.max_iter):\n            if timeout():\n                break\n\n            q_rand = self._sample_free(self.bounds, obstacles, self.is_3d, goal_pos)\n            q_near = None\n            # Nearest with grid\n            search_radius = self.step_size * 5.0\n            candidates = self._grid_near_nodes(q_rand, search_radius)\n            if candidates:\n                q_near = min(candidates, key=lambda n: self._dist_sq(n.position, q_rand))\n            else:\n                q_near = min(nodes, key=lambda n: self._dist_sq(n.position, q_rand))\n\n            q_new_pos = self._steer(q_near.position, q_rand)\n            if not self._in_bounds(q_new_pos) or self._is_in_obstacle(q_new_pos, obstacles, self.is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, self.is_3d):\n                continue\n\n            n_nodes = len(nodes) + 1\n            radius = self._rewiring_radius(n_nodes)\n            near_nodes_list = self._grid_near_nodes(q_new_pos, radius)\n\n            min_cost_candidate = q_near.cost + self._distance(q_near.position, q_new_pos)\n            best_parent = q_near\n            for near_n in near_nodes_list:\n                if near_n == q_near:\n                    continue\n                cost_candidate = near_n.cost + self._distance(near_n.position, q_new_pos)\n                if cost_candidate + self.improve_tol < min_cost_candidate:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new_pos, obstacles, self.is_3d):\n                        min_cost_candidate = cost_candidate\n                        best_parent = near_n\n\n            new_node = Node(q_new_pos, parent=best_parent, cost=min_cost_candidate)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(new_node)\n\n            rewired = False\n            for near_n in near_nodes_list:\n                if near_n == best_parent:\n                    continue\n                c_through_new = new_node.cost + self._distance(new_node.position, near_n.position)\n                if c_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, self.is_3d):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = c_through_new\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n                        self._update_costs_nonrecursive(near_n)\n                        rewired = True\n\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, self.is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    best_path = goal_node.path_from_root()\n                    success_state = True\n                    break\n\n        if not success_state and nodes:\n            radius_goal = self.step_size\n            near_goal = self._grid_near_nodes(goal_pos, radius_goal)\n            near_goal = [n for n in near_goal if not self._is_edge_in_obstacle(n.position, goal_pos, obstacles, self.is_3d)]\n            if near_goal:\n                best_goal_node = min(near_goal, key=lambda n: n.cost + self._distance(n.position, goal_pos))\n                best_path = best_goal_node.path_from_root()\n                success_state = True\n\n        if not best_path:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 28.08554,
    "time_improvement": -112.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 75.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.042309355735778806,
            "num_nodes_avg": 323.8,
            "path_length_avg": 167.74497839317206,
            "smoothness_avg": 0.012514672968489415,
            "success_improvement": 0.0,
            "time_improvement": -63.592223164570946,
            "length_improvement": 8.05631925342081,
            "smoothness_improvement": 95.88180800417813,
            "objective_score": -13.76446635729791
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.19717645645141602,
            "num_nodes_avg": 1191.5,
            "path_length_avg": 281.0796179983598,
            "smoothness_avg": 0.005614695508981278,
            "success_improvement": 0.0,
            "time_improvement": -19.99163704059765,
            "length_improvement": 6.1675330839293805,
            "smoothness_improvement": 44.4701595477996,
            "objective_score": -2.074620464082668
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.17179291248321532,
            "num_nodes_avg": 612.6,
            "path_length_avg": 134.03304664898116,
            "smoothness_avg": 0.014415038102101924,
            "success_improvement": 0.0,
            "time_improvement": -251.4109808905642,
            "length_improvement": 10.981632383568476,
            "smoothness_improvement": 83.35822065130304,
            "objective_score": -68.41752373377166
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined unidirectional RRT* planner leveraging adaptive neighbor radius and simple linear searches for neighbor queries, combined with goal-biased sampling and non-recursive cost updating. It ensures collision-free node and edge additions, maintains coherent parent-child relationships, and returns the best found path within a strict 30-second time limit, prioritizing planning efficiency and path quality.",
    "planning_mechanism": "The planner incrementally grows a single tree from start to goal by sampling random free points biased toward the goal, steering toward them within a step size, and rewiring nearby nodes within an adaptively computed radius. It efficiently checks collisions and updates path costs non-recursively to maintain coherence. The process terminates early if a satisfactory goal node is connected or the time limit is reached, ensuring a viable path or best effort within time constraints.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 20.0  # tuning parameter for neighbor radius\n        self.improve_tol = 1e-6\n\n    def _distance(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _dist_sq(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return sum((x - y) ** 2 for x, y in zip(a, b))\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float = 1.0) -> bool:\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _rewiring_radius(self, n_nodes: int, dim: int) -> float:\n        if n_nodes <= 1:\n            return self.step_size * 10.0\n        val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n        return min(val, self.step_size * 10.0)\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d: bool, goal: Tuple[float, ...]) -> Tuple[float, ...]:\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        for _ in range(100):\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return goal\n\n    def _update_costs_nonrecursive(self, node: Node):\n        stack = list(node.children)\n        while stack:\n            c = stack.pop()\n            c.cost = c.parent.cost + self._distance(c.parent.position, c.position)\n            stack.extend(c.children)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        success_state = False\n\n        time_start = time.monotonic()\n        def timeout():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        for iteration in range(self.max_iter):\n            if timeout():\n                break\n\n            q_rand = self._sample_free(bounds, obstacles, is_3d, goal_pos)\n\n            # Nearest node linear search (simplified)\n            q_near = min(nodes, key=lambda n: self._dist_sq(n.position, q_rand))\n            q_new_pos = self._steer(q_near.position, q_rand)\n            if not self._in_bounds(q_new_pos, bounds):\n                continue\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(nodes) + 1\n            radius = self._rewiring_radius(n_nodes, dim)\n            near_nodes = [node for node in nodes if self._distance(node.position, q_new_pos) <= radius]\n\n            # Choose best parent\n            min_cost = q_near.cost + self._distance(q_near.position, q_new_pos)\n            best_parent = q_near\n            for near in near_nodes:\n                if near == q_near:\n                    continue\n                cost_here = near.cost + self._distance(near.position, q_new_pos)\n                if cost_here + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near.position, q_new_pos, obstacles, is_3d):\n                    min_cost = cost_here\n                    best_parent = near\n\n            new_node = Node(q_new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._distance(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_costs_nonrecursive(near)\n\n            # Check if goal reached\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    best_path = goal_node.path_from_root()\n                    success_state = True\n                    break\n\n        # If no exact goal node, try closest existing node connected to goal\n        if not success_state and nodes:\n            candidates = [node for node in nodes if self._distance(node.position, goal_pos) <= self.step_size and not self._is_edge_in_obstacle(node.position, goal_pos, obstacles, is_3d)]\n            if candidates:\n                best_goal_node = min(candidates, key=lambda n: n.cost + self._distance(n.position, goal_pos))\n                best_path = best_goal_node.path_from_root()\n                success_state = True\n\n        if not best_path:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 220.53708,
    "time_improvement": -736.0,
    "length_improvement": 0.0,
    "smoothness_improvement": 40.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07105007171630859,
            "num_nodes_avg": 330.6,
            "path_length_avg": 183.88320539589304,
            "smoothness_avg": 0.00927390420570243,
            "success_improvement": 0.0,
            "time_improvement": -174.72030679597327,
            "length_improvement": -0.7892986933421128,
            "smoothness_improvement": 45.15673942455526,
            "objective_score": -52.66388755767447
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.1936110973358154,
            "num_nodes_avg": 1207.5,
            "path_length_avg": 310.55750533258515,
            "smoothness_avg": 0.004971664172908165,
            "success_improvement": 0.0,
            "time_improvement": -626.371454973574,
            "length_improvement": -3.673034182177035,
            "smoothness_improvement": 27.92450011388795,
            "objective_score": -189.97563450080898
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7371738910675049,
            "num_nodes_avg": 635.5,
            "path_length_avg": 142.6227094580021,
            "smoothness_avg": 0.011635620922893298,
            "success_improvement": 0.0,
            "time_improvement": -1407.9260046438521,
            "length_improvement": 5.276787341605616,
            "smoothness_improvement": 48.004239287005,
            "objective_score": -418.97170779175724
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner that uses fixed radius rewiring with consistent parent-child relationship updates, goal-biased sampling, and early stopping upon finding a solution to balance exploration and planning efficiency. The algorithm avoids recursive cost propagation by incremental cost updates during rewiring and maintains a time limit for robust real-time performance.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points biased toward their opposite root, extends toward samples with fixed step size, locally rewires neighbors within a constant radius to improve path cost, and attempts connection of the two trees. Collision checks ensure feasibility of nodes and edges. Upon connecting trees, the planner extracts the path and terminates early, returning the best path found within the time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success_state = found_solution\n        extracted_path = best_path if found_solution else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -23.64699,
    "time_improvement": 42.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 312.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012988829612731933,
            "num_nodes_avg": 105.7,
            "path_length_avg": 158.0716475211238,
            "smoothness_avg": 0.02391556040922841,
            "success_improvement": 0.0,
            "time_improvement": 49.77773885467754,
            "length_improvement": 13.35842518812721,
            "smoothness_improvement": 274.3304538750773,
            "objective_score": 24.32002903865497
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02958998680114746,
            "num_nodes_avg": 266.1,
            "path_length_avg": 243.47383404946873,
            "smoothness_avg": 0.017303870387007696,
            "success_improvement": 0.0,
            "time_improvement": 81.99302786864814,
            "length_improvement": 18.72142618854365,
            "smoothness_improvement": 345.24104853177045,
            "objective_score": 37.55696931637948
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05162415504455566,
            "num_nodes_avg": 288.1,
            "path_length_avg": 127.56547078962936,
            "smoothness_avg": 0.03266774598713309,
            "success_improvement": 0.0,
            "time_improvement": -5.599786973902844,
            "length_improvement": 15.27708831648271,
            "smoothness_improvement": 315.53131767414845,
            "objective_score": 9.063973486089514
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive neighbor radius rewiring, goal-biased and informed sampling with ellipsoidal focus after initial solution, incremental cost updates without recursion, and early stopping based on solution stabilization. The planner grows two trees from start and goal, alternately sampling with increasing bias and refined informed samples, steering by fixed step size, rewiring nearby nodes with adaptive radius that shrinks logarithmically, while maintaining and updating the best found path throughout a hard 30-second time limit constraint to ensure efficiency, robustness, smoothness, and shortened path length.",
    "planning_mechanism": "The planner alternates expansion between start and goal trees using a mixture of goal-biased random and ellipsoidal informed sampling after a first solution, grows new nodes via steering with fixed steps, performs rewiring with an adaptive neighbor search radius reducing over iterations to improve path quality, manages edges and parent-child relations consistently while avoiding recursive cost propagation overhead, attempts to connect trees directly when close, and tracks best solutions to enable early termination or full 30-second search cutoff, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # For possible future pruning\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10    # Initial goal bias probability\n        self.time_limit = 30.0          # Hard time limit in seconds\n        self.improve_tol = 1e-9         # Cost improvement tolerance for rewiring/connect\n        self.max_radius = 20.0          # Max neighbor radius for rewiring\n        self.min_radius = 5.0           # Min neighbor radius (adaptive)\n        self.log_const = 50             # Logarithmic base for radius shrinking\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def elapsed():\n            return (time.monotonic() - time_start)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def dist(p1: Tuple[float,...], p2: Tuple[float,...]) -> float:\n            return math.dist(p1, p2)\n\n        def steer(from_pos: Tuple[float,...], to_pos: Tuple[float,...]) -> Tuple[float,...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos: Tuple[float,...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float,...], to_pos: Tuple[float,...], resolution=1.0) -> bool:\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(iteration: int) -> Tuple[float,...]:\n            # After initial solution found, sample with ellipsoidal informed sampling\n            if found_solution:\n                c_best = best_cost\n                c_min = dist(start_pos, goal_pos)\n                if c_best < float('inf') and c_best > c_min:\n                    # Build prolate hyperspheroid in n-D for informed sampling\n                    center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n                    vec_start_goal = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n                    length = c_best / 2\n                    # Unit vector from start to goal\n                    norm = math.sqrt(sum(x*x for x in vec_start_goal))\n                    if norm < 1e-6:\n                        norm_vec = tuple(1.0 if i == 0 else 0.0 for i in range(dim))\n                    else:\n                        norm_vec = tuple(x/norm for x in vec_start_goal)\n                    while True:\n                        # Ellipsoidal uniform sampling trick\n                        # Sample point in unit n-ball\n                        while True:\n                            # Sample in cube [-1,1]^dim\n                            coords = [random.uniform(-1,1) for _ in range(dim)]\n                            norm_coords = math.sqrt(sum(c*c for c in coords))\n                            if norm_coords <= 1:\n                                break\n                        # Scale axes: semi-major axis length length, semi-minor axes sqrt(length^2 - (c_min/2)^2)\n                        if dim >= 2:\n                            minor_axis = math.sqrt(length*length - (c_min*0.5)**2)\n                        else:\n                            minor_axis = length\n                        # Build coords scaled accordingly (first axis for start-goal)\n                        x = coords[0] * length\n                        others = coords[1:]\n                        others_scaled = [c * minor_axis for c in others]\n                        # Rotate sample back to global frame\n                        # For 2D or 3D, build a rotation matrix to align x-axis to norm_vec\n                        # [norm_vec, perpendicular basis] to convert sample coords\n                        # Build orthonormal basis\n                        # If dim==2:\n                        #   basis = [norm_vec, perpendicular(norm_vec)]\n                        # If dim==3:\n                        #   Gram-Schmidt basis including norm_vec\n                        # For higher dims, approximate with norm_vec + arbitrary basis\n                        # For efficiency, here do a simple approach:\n                        # proj_vec = norm_vec repeated to dims; sample_vec rotated by dot product approach\n                        # Instead, approximate by:\n                        # Return center + x*norm_vec + sum_i others_scaled[i]*unit vectors orthogonal to norm_vec\n                        # To generate orthonormal basis orthogonal to norm_vec:\n                        ortho_basis = self._generate_orthonormal_basis(norm_vec)\n                        sample_vec = [center[i] + x*norm_vec[i] for i in range(dim)]\n                        for i, bvec in enumerate(ortho_basis):\n                            sample_vec = [sample_vec[j] + others_scaled[i]*bvec[j] for j in range(dim)]\n                        sample_pt = tuple(sample_vec)\n                        if not is_in_obstacle(sample_pt):\n                            # Clamp to bounds\n                            clamped = tuple(max(0,min(sample_pt[i],bounds[i])) for i in range(dim))\n                            if not is_in_obstacle(clamped):\n                                return clamped\n                # Fall back to uniform if ellipsoid invalid\n            # Goal biasing: increase goal bias over iterations (up to 20%)\n            prob = min(self.goal_sample_rate + iteration*0.0005, 0.20)\n            if random.random() < prob and not is_in_obstacle(goal_pos):\n                return goal_pos\n            # Uniform random sample\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def radius_rewiring(iter: int) -> float:\n            # Adaptive radius shrinks logarithmically with iteration count to min radius\n            return max(self.min_radius, min(self.max_radius, self.max_radius * math.log(iter + 2) / self.log_const))\n\n        def nearest(tree: List[Node], point: Tuple[float,...]) -> Node:\n            best_node = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float,...], radius: float) -> List[Node]:\n            result = []\n            radius_sq = radius*radius\n            for n in tree:\n                d_sq = sum( (n.position[i]-point[i])**2 for i in range(dim) )\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        # Orthonormal basis generator for unit vector norm_vec (in R^dim)\n        # Returns (dim-1) basis vectors orthogonal to norm_vec\n        # Uses Gram-Schmidt or Householder reflection for numerical stability\n        def generate_orthonormal_basis(vec: Tuple[float,...]) -> List[List[float]]:\n            n = len(vec)\n            # Start with identity matrix rows and orthogonalize against vec\n            basis = []\n            for i in range(n):\n                # Start with standard basis vector e_i\n                e = [0.0]*n\n                e[i] = 1.0\n                # Gram-Schmidt ortho against vec\n                dot = sum(e[j]*vec[j] for j in range(n))\n                proj = [dot*vec[j] for j in range(n)]\n                w = [e[j] - proj[j] for j in range(n)]\n                norm_w = math.sqrt(sum(c*c for c in w))\n                if norm_w > 1e-9:\n                    basis.append([c/norm_w for c in w])\n                if len(basis) >= n-1:\n                    break\n            # If basis less than n-1 (rare), fill up by simple arbitrary vecs\n            while len(basis) < n-1:\n                # Add some orthogonal vector, e.g. cyclic shift\n                candidate = [0.0]*n\n                candidate[(len(basis))%n] = 1.0\n                # Orthogonalize to vec and existing basis\n                w = candidate\n                # Ortho to vec\n                dot = sum(w[j]*vec[j] for j in range(n))\n                w = [w[j] - dot*vec[j] for j in range(n)]\n                # Ortho to each existing basis\n                for bvec in basis:\n                    d = sum(w[j]*bvec[j] for j in range(n))\n                    w = [w[j] - d*bvec[j] for j in range(n)]\n                norm_w = math.sqrt(sum(c*c for c in w))\n                if norm_w > 1e-9:\n                    basis.append([c/norm_w for c in w])\n            return basis\n\n        self._generate_orthonormal_basis = generate_orthonormal_basis\n\n        itr = 0\n        # Track iterations without improvement for early stopping\n        no_improve_iters = 0\n        max_no_improve = 200\n\n        while itr < self.max_iter:\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = sample_free(itr)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos):\n                itr += 1\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                itr += 1\n                continue\n\n            radius = radius_rewiring(itr)\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node (non-recursive)\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Update tree edges and parents carefully (no recursion)\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt direct connection between two trees\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build full path based on expansion direction\n                    def build_combined_path(n_start: Node, n_goal: Node) -> List[Tuple[float,...]]:\n                        path_from_start = n_start.path_from_root()\n                        path_from_goal = n_goal.path_from_root()\n                        path_from_goal.reverse()\n                        return path_from_start + path_from_goal[1:]\n\n                    if expand_start:\n                        path = build_combined_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = build_combined_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n                        no_improve_iters = 0\n                    else:\n                        no_improve_iters += 1\n                else:\n                    no_improve_iters += 1\n            else:\n                no_improve_iters += 1\n\n            # Early stop if solution stable for many iterations\n            if found_solution and no_improve_iters > max_no_improve:\n                break\n\n            itr += 1\n\n        return PlannerResult(success=success_state, path=best_path if found_solution else [], nodes=nodes, edges=edges)",
    "objective": 278.95213,
    "time_improvement": -930.0,
    "length_improvement": -0.0,
    "smoothness_improvement": 38.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.46381244659423826,
            "num_nodes_avg": 1503.6,
            "path_length_avg": 185.5761044654251,
            "smoothness_avg": 0.008602825723576096,
            "success_improvement": 0.0,
            "time_improvement": -1693.3647995870053,
            "length_improvement": -1.7172034990550398,
            "smoothness_improvement": 34.65290390902979,
            "objective_score": -508.8664974559894
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3392354488372803,
            "num_nodes_avg": 854.7,
            "path_length_avg": 302.4934595883308,
            "smoothness_avg": 0.005443422735095128,
            "success_improvement": 0.0,
            "time_improvement": -106.44156802877185,
            "length_improvement": -0.9810236020579044,
            "smoothness_improvement": 40.063187712916275,
            "objective_score": -32.32076863130172
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.533601975440979,
            "num_nodes_avg": 1019.1,
            "path_length_avg": 146.5842120888997,
            "smoothness_avg": 0.010947869676709774,
            "success_improvement": 0.0,
            "time_improvement": -991.5094859526164,
            "length_improvement": 2.645745920647334,
            "smoothness_improvement": 39.256094200067,
            "objective_score": -295.6691177623962
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT* planner employing fixed-radius neighbor rewiring, goal-biased sampling, early termination on first solution discovery, and incremental cost updates without recursive propagation. It balances simplicity and efficiency by alternating tree expansions, efficiently searching neighbors within a constant radius, ensuring collision-free connections, and promptly returning the best path found within a hard time limit.",
    "planning_mechanism": "The planner grows two trees from start and goal with goal bias sampling, extends towards sampled points in fixed steps, rewires neighbors within a fixed radius by incremental cost comparison and updates parents, attempts to connect the trees upon proximity, and stops early once a solution is found or time limit is exceeded.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start else start_pos\n\n            sample = self._sample(bounds, obstacles, is_3d, target_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success_state = found_solution\n        extracted_path = best_path if found_solution else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -12.4748,
    "time_improvement": 6.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 286.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01651873588562012,
            "num_nodes_avg": 129.1,
            "path_length_avg": 163.696358168807,
            "smoothness_avg": 0.022814818291193716,
            "success_improvement": 0.0,
            "time_improvement": 36.129097680592935,
            "length_improvement": 10.275432152888191,
            "smoothness_improvement": 257.1014494280669,
            "objective_score": 18.289495843051128
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.039663839340209964,
            "num_nodes_avg": 320.7,
            "path_length_avg": 238.93700042108193,
            "smoothness_avg": 0.0164025145196386,
            "success_improvement": 0.0,
            "time_improvement": 75.86258978683014,
            "length_improvement": 20.235951839214646,
            "smoothness_improvement": 322.048512843974,
            "objective_score": 36.510590603797695
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09480364322662353,
            "num_nodes_avg": 406.5,
            "path_length_avg": 126.96902650618938,
            "smoothness_avg": 0.029844050747926298,
            "success_improvement": 0.0,
            "time_improvement": -93.92558619973246,
            "length_improvement": 15.673218209918826,
            "smoothness_improvement": 279.61412265494016,
            "objective_score": -17.375674320693744
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved bidirectional RRT* planner integrating adaptive neighbor radius, goal bias sampling, and ellipsoidal informed sampling for refinement. It employs efficient nearest and near neighbor searches with early termination on timeout or first feasible path, consistent parent-child and edge management, and incrementally rewired trees to balance fast planning time and high-quality smooth paths. The planner uses non-recursive rewiring updates and limits rewiring radius dynamically for computational efficiency while maintaining robust collision checks both for nodes and edges.",
    "planning_mechanism": "The planner builds two trees rooted at start and goal, expanding them alternately using goal-biased sampling to direct growth. It connects trees when nodes come close, keeps track of best paths, and upon first path discovery, switches to a single-tree refinement phase using ellipsoidal sampling to focus growth around the best path. Throughout, it performs adaptive-radius rewiring and non-recursive cost updates to reduce overhead. It enforces a strict 30-second timeout, returning the best found path with consistent edge and parent-child relationships for smooth, short, and computationally efficient planning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For potential extensions, unused here\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 35.0  # Tuned coefficient for neighbor radius\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0  # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        dim = len(bounds)\n        for _ in range(100):\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return goal  # fallback to goal if sampling fails repeatedly\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        near_nodes = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        # If no solution found or c_best worse than min, sample uniformly\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            dim_range = [ (0, bounds[d]) for d in range(dim) ]\n            for _ in range(100):\n                pt = tuple(random.uniform(low, high) for (low, high) in dim_range)\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return start  # fallback\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            return self._sample(bounds, obstacles, is_3d, goal, 0.0)\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n\n        def sample_unit_ball():\n            while True:\n                dir_gauss = [random.gauss(0, 1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x * x for x in dir_gauss))\n                if norm_dir > 1e-12:\n                    unit_dir = [x / norm_dir for x in dir_gauss]\n                    r = random.random() ** (1.0 / dim)  # radius for uniform in ball\n                    point = [r * x for x in unit_dir]\n                    return point\n        for _ in range(100):\n            ball_pt = sample_unit_ball()\n            scaled = [c1 * ball_pt[0]] + [c2 * ball_pt[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            # Compose transformation assuming rotation aligning first axis to a1 direction:\n            pt_coords = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                # We approximate an orthogonal basis with identity in other axes (no rotation for simplicity)\n                pt_coords[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], pt_coords[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return start  # fallback\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        t_start = time.monotonic()\n        time_limit = self.time_limit\n\n        def timeout():\n            return (time.monotonic() - t_start) >= time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n\n        # Bidirectional growing phase\n        for it in range(self.max_iter):\n            if timeout():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size*15)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Non-recursive rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Try to connect to opposite tree\n            nearest_opp = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_opp.position, new_node.position)\n\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_opp.position, new_node.position, obstacles, is_3d):\n                # Connect trees by linking new node to nearest opposite node directly\n                connect_node = Node(new_node.position, parent=nearest_opp, cost=nearest_opp.cost + dist_connect)\n                nearest_opp.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_opp, connect_node))\n\n                if expand_start:\n                    candidate_path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_opp.cost)\n                else:\n                    candidate_path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n\n                # Early termination upon first feasible path found for efficiency\n                if found_solution:\n                    break\n\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Refinement phase with informed sampling around best path\n        # Build new tree from best path\n        root = Node(start_pos, cost=0.0)\n        root.children.clear()\n        refinement_tree = [root]\n        root_cost_map = {root.position: 0.0}\n        nodes = [root]\n        edges = []\n\n        prev_node = root\n        for pos in best_path[1:]:\n            d = self._dist(prev_node.position, pos)\n            n = Node(pos, parent=prev_node, cost=prev_node.cost + d)\n            prev_node.add_child(n)\n            refinement_tree.append(n)\n            nodes.append(n)\n            edges.append((prev_node, n))\n            prev_node = n\n        best_goal_node = prev_node\n        best_cost = best_goal_node.cost\n\n        no_improve_iter = 0\n        max_no_improve = 150\n        max_refine_iter = self.max_iter // 2\n        c_min = self._dist(start_pos, goal_pos)\n\n        for _ in range(max_refine_iter):\n            if timeout() or no_improve_iter >= max_no_improve:\n                break\n\n            sample = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n            nearest = self._nearest(refinement_tree, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_iter += 1\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                no_improve_iter += 1\n                continue\n\n            n_nodes = len(refinement_tree) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 15)\n            near_nodes = self._near(refinement_tree, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                c = near_node.cost + self._dist(near_node.position, new_pos)\n                if c + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_thru_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_thru_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_thru_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    rewired = True\n\n            dist_goal = self._dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                new_node.add_child(goal_node)\n                refinement_tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    no_improve_iter = 0\n                    found_solution = True\n                else:\n                    no_improve_iter += 1\n            else:\n                no_improve_iter += 1\n\n            if not rewired:\n                no_improve_iter += 1\n\n        if found_solution:\n            final_path = best_goal_node.path_from_root()\n        else:\n            final_path = best_path\n\n        return PlannerResult(\n            success=found_solution,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -22.72872,
    "time_improvement": 55.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 182.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017363715171813964,
            "num_nodes_avg": 104.5,
            "path_length_avg": 167.77032899914258,
            "smoothness_avg": 0.020395696518840833,
            "success_improvement": 0.0,
            "time_improvement": 32.861923374755705,
            "length_improvement": 8.042424184582313,
            "smoothness_improvement": 219.23694048373514,
            "objective_score": 15.780216225594774
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03564341068267822,
            "num_nodes_avg": 116.8,
            "path_length_avg": 259.51140395857516,
            "smoothness_avg": 0.009980746128695374,
            "success_improvement": 0.0,
            "time_improvement": 78.30921969845465,
            "length_improvement": 13.367623737029078,
            "smoothness_improvement": 156.81178673219335,
            "objective_score": 32.29739908541481
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02279052734375,
            "num_nodes_avg": 94.9,
            "path_length_avg": 142.44462665595103,
            "smoothness_avg": 0.021340518905048803,
            "success_improvement": 0.0,
            "time_improvement": 53.380838283052576,
            "length_improvement": 5.395061459336175,
            "smoothness_improvement": 171.4498252789686,
            "objective_score": 20.108537486912322
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* inspired planner that combines efficient fixed-radius rewiring, balanced tree expansion with goal-biased sampling, early solution tracking, and incremental cost propagation to improve planning time, path smoothness, path length, and robustness. It adaptively rewires nodes in fixed-radius neighborhoods to optimize paths and propagates cost changes efficiently while respecting a strict time limit. The planner maintains coherent parent-child and edge relations, aggressively prunes redundant nodes, and incrementally updates the best path found, terminating early upon timeout or solution discovery.",
    "planning_mechanism": "The algorithm grows two trees alternately from start and goal using goal-biased sampling and fixed step size steering. After inserting a new node, it rewires neighboring nodes within a fixed radius to reduce costs and improve smoothness. It attempts to connect the opposite tree with shortcut edges, and on success, assembles a cost-optimized path. The planner incrementally updates costs to maintain tree consistency, continually tracks the best path's cost, and respects a 30-second wall-clock timeout, returning the best feasible path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Cost from root\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.0, radius: float=8.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius              # Fixed radius for neighbor search for rewiring\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree: List[Node] = []\n        goal_tree: List[Node] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        start_tree.append(start_root)\n        goal_tree.append(goal_root)\n        nodes.extend([start_root, goal_root])\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]):\n            best = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree_nodes: List[Node], point: Tuple[float, ...], radius: float):\n            result = []\n            for node in tree_nodes:\n                if dist(node.position, point) <= radius:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def cost_to_node(node: Node):\n            return node.cost\n\n        def update_costs_recursive(node: Node):\n            \"\"\" Recursively update costs for children after rewiring \"\"\"\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    old_cost = c.cost\n                    c.cost = curr.cost + dist(curr.position, c.position)\n                    if abs(c.cost - old_cost) > 1e-8:\n                        stack.append(c)\n\n        def try_connect(tgt_tree: List[Node], new_node: Node) -> Tuple[bool, Node]:\n            # Attempt to connect new_node to tgt_tree within step_size without collision\n            nearest_node = nearest(tgt_tree, new_node.position)\n            d = dist(nearest_node.position, new_node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(new_node.position, nearest_node.position):\n                # Choose better parent if any for connecting node in tgt_tree, else create new connecting node\n                if nearest_node.parent is None:\n                    # root node, just connect directly\n                    connect_node = nearest_node\n                    return True, connect_node\n                else:\n                    # Connect via new node if better cost\n                    # Create virtual edge connection without rewiring tgt_tree to keep it consistent\n                    intersecting_node = None\n                    # Check if direct connecting is feasible without adding node to target tree\n                    return True, nearest_node\n            # Otherwise try to extend tgt_tree towards new_node by one step and add node\n            new_pos = steer(nearest_node.position, new_node.position)\n            if is_in_obstacle(new_pos):\n                return False, None\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                return False, None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            connect_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(connect_node)\n            tgt_tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((nearest_node, connect_node))\n            # Check if can connect further directly\n            if dist(connect_node.position, new_node.position) <= self.step_size and not is_edge_in_obstacle(connect_node.position, new_node.position):\n                final_node = Node(new_node.position, connect_node, connect_node.cost + dist(connect_node.position, new_node.position))\n                connect_node.add_child(final_node)\n                tgt_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((connect_node, final_node))\n                return True, final_node\n            return False, None\n\n        def rewire(tree_nodes: List[Node], new_node: Node):\n            neighbors = near(tree_nodes, new_node.position, self.radius)\n            # Choose parent from neighbors with minimal cost+distance\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                if is_edge_in_obstacle(neighbor.position, new_node.position):\n                    continue\n                c = neighbor.cost + dist(neighbor.position, new_node.position)\n                if c < min_cost:\n                    min_cost = c\n                    min_parent = neighbor\n            if min_parent is not new_node.parent:\n                # Update parent-child relationship\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                    if (new_node.parent, new_node) in edges:\n                        edges.remove((new_node.parent, new_node))\n                min_parent.add_child(new_node)\n                new_node.cost = min_cost\n                edges.append((min_parent, new_node))\n                # Propagate cost changes\n                update_costs_recursive(new_node)\n\n            # Try rewiring neighbors to new_node if it improves cost\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if is_edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire neighbor\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    edges.append((new_node, neighbor))\n                    update_costs_recursive(neighbor)\n\n        def assemble_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Alternate growth starting with start tree\n        tree_active, tree_other = start_tree, goal_tree\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Timeout, return best known path\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_active, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos):\n                tree_active, tree_other = tree_other, tree_active\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_active, tree_other = tree_other, tree_active\n                continue\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_active.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire new_node and neighbors\n            rewire(tree_active, new_node)\n\n            # Attempt to connect other tree to new_node\n            connected, conn_node = try_connect(tree_other, new_node)\n            if connected:\n                # Construct path and update best if better\n                path = assemble_path(new_node, conn_node)\n                total_cost = new_node.cost + conn_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success = True\n                    # Early terminate on good solution\n                    break\n\n            tree_active, tree_other = tree_other, tree_active\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 69.32346,
    "time_improvement": -194.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 110.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.08348755836486817,
            "num_nodes_avg": 194.7,
            "path_length_avg": 174.94775865035345,
            "smoothness_avg": 0.01272189071004332,
            "success_improvement": -9.999999999999998,
            "time_improvement": -222.81075998377526,
            "length_improvement": 4.10836125910266,
            "smoothness_improvement": 99.12521564002473,
            "objective_score": -113.88258516147086
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1720412015914917,
            "num_nodes_avg": 474.1,
            "path_length_avg": 269.7204185912409,
            "smoothness_avg": 0.00826299002127142,
            "success_improvement": 0.0,
            "time_improvement": -4.695589873738759,
            "length_improvement": 9.95956080245202,
            "smoothness_improvement": 112.61268483846085,
            "objective_score": 5.130122943541888
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.22186975479125975,
            "num_nodes_avg": 380.5,
            "path_length_avg": 134.6500036030362,
            "smoothness_avg": 0.017180005608584376,
            "success_improvement": 0.0,
            "time_improvement": -353.8456623975287,
            "length_improvement": 10.571878951018244,
            "smoothness_improvement": 118.52840324508804,
            "objective_score": -99.21792933242223
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* algorithm integrating goal-biased sampling, fixed step-size steering, and efficient fixed-radius rewiring for local cost and smoothness optimization. It grows two trees alternately from start and goal, rewiring neighbors only in a bounded radius to reduce overhead, immediately tracks and updates the best solution upon connecting the trees, and enforces a 30-second hard timeout. The algorithm maintains coherent parent-child relationships and prevents costly recursive cost propagation by local rewiring only. Efficient collision checks and careful pruning ensure robust path quality improvements for path length, smoothness, and planning time.",
    "planning_mechanism": "A bidirectional planner grows start and goal trees alternately by sampling random free points with goal bias. Each iteration extends the active tree by steering a fixed step size towards the sample, adding collision-free nodes. After node insertion, neighbors within a dynamically computed radius are rewired locally if better paths are found, improving smoothness and cost. The planner attempts to connect the newly added node to the opposite tree within step size with collision-free edges. Upon successful connection, it immediately extracts the combined path with updated costs. The process repeats until a path is found or the 30-second time limit is reached, returning the best path so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=60.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Best solution tracking\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, position):\n            n = max(1,len(tree))\n            unit_ball_volume = 3.14159  # Approximate volume for 2D ball radius calc\n            # Adaptive radius form per RRT* theory capped by gamma\n            radius = min(self.gamma * ((math.log(n) / n) ** (1/dim)), self.gamma)\n            # Also cap minimum radius for connectivity\n            radius = max(radius, self.step_size*1.5)\n            neighbors = []\n            for node in tree:\n                if dist(node.position, position) <= radius:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(dim))\n\n        def add_node(tree, new_pos, parent, nodes_ref, edges_ref):\n            cost = parent.cost + dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_ref.append(new_node)\n            edges_ref.append((parent, new_node))\n            return new_node\n\n        def rewire(new_node, neighbors, nodes_ref, edges_ref):\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost:\n                    # Check edge collision before rewiring\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges_ref.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            if nbr in nbr.parent.children:\n                                nbr.parent.children.remove(nbr)\n                        # Rewire neighbor to new_node\n                        new_node.add_child(nbr)\n                        nbr.cost = new_cost\n\n        def try_connect(node_new, other_tree):\n            # Try connect node_new to nearest node in other_tree within step_size\n            nearest_other = nearest(other_tree, node_new.position)\n            if dist(node_new.position, nearest_other.position) <= self.step_size:\n                if not edge_in_obstacle(node_new.position, nearest_other.position):\n                    cost_connect = node_new.cost + dist(node_new.position, nearest_other.position)\n                    connect_node = Node(nearest_other.position, parent=None, cost=cost_connect)\n                    node_new.add_child(connect_node)\n                    other_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((node_new, connect_node))\n                    return connect_node, nearest_other\n            return None, None\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            rnd = sample_free()\n            nearest_node = nearest(active_tree, rnd)\n            new_pos = steer(nearest_node.position, rnd)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_node = add_node(active_tree, new_pos, nearest_node, nodes, edges)\n\n            neighbors = near_nodes(active_tree, new_pos)\n            rewire(new_node, neighbors, nodes, edges)\n\n            con_node, con_other = try_connect(new_node, passive_tree)\n            if con_node is not None:\n                # Found connection: extract combined path\n                path_start = con_node.path_from_root()\n                path_goal = con_other.path_from_root()\n                path_goal.reverse()\n                # Remove duplicate connection point to avoid double inclusion\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                full_path = path_start + path_goal\n\n                total_cost = con_node.cost + con_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            # Swap active/passive trees for next iteration\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -22.37404,
    "time_improvement": 66.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 119.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008773112297058105,
            "num_nodes_avg": 108.8,
            "path_length_avg": 177.98287689223014,
            "smoothness_avg": 0.014605352963532641,
            "success_improvement": 0.0,
            "time_improvement": 66.07811866219255,
            "length_improvement": 2.444764856203794,
            "smoothness_improvement": 128.60548991087884,
            "objective_score": 21.933321961934436
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019752001762390135,
            "num_nodes_avg": 318.1,
            "path_length_avg": 283.22770551502424,
            "smoothness_avg": 0.00865571585370976,
            "success_improvement": 0.0,
            "time_improvement": 87.97992889743433,
            "length_improvement": 5.450439641595847,
            "smoothness_improvement": 122.7178033760828,
            "objective_score": 30.27783147106822
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026772308349609374,
            "num_nodes_avg": 335.4,
            "path_length_avg": 148.51560918518618,
            "smoothness_avg": 0.016075232544732046,
            "success_improvement": 0.0,
            "time_improvement": 45.23590640702322,
            "length_improvement": 1.3630039325404428,
            "smoothness_improvement": 104.47577141875148,
            "objective_score": 14.910953138724988
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An adaptive bidirectional RRT* planner with fixed-radius neighbor rewiring, goal-biased incremental tree extension, efficient collision checking, recursive cost propagation on rewiring, and early stopping upon improving solution. It balances exploration and exploitation with ellipsoidal informed sampling refinement phase limited by wall-clock time, improving planning speed, path smoothness, and path length.",
    "planning_mechanism": "A planner that grows start and goal trees alternately by steering toward goal-biased samples with fixed step sizes. Uses a fixed neighbor radius for local rewiring with recursive cost updates, prunes expansion after first good solution to save time, and incorporates an ellipsoidal informed sampling phase to improve path quality within a time budget. Paths are constructed by linking trees when close, maintaining consistent parent-child and edges relations for smoothness and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position              # Tuple[float,...]\n        self.parent = parent                  # Node or None\n        self.cost = cost                      # Cost from root\n        self.children = []                    # List of child Nodes\n        self.valid = True                     # For future validation if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_propagate(self, new_cost):\n        if new_cost + 1e-9 < self.cost:\n            cost_diff = self.cost - new_cost\n            self.cost = new_cost\n            for child in self.children:\n                child.update_cost_and_propagate(child.cost - cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2          # Higher goal bias for faster convergence\n        self.neighbor_radius = 15.0          # Fixed radius for neighbor searches\n        self.time_limit = 30.0               # Hard wall clock time limit in seconds\n        self.improve_tol = 1e-6              # Tolerance for cost improvement\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_rate):\n        # With goal bias probability return the goal if free\n        if random.random() < goal_bias_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        neighbors = []\n        radius_sq = radius * radius\n        for node in tree:\n            dx = node.position\n            dist_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if dist_sq <= radius_sq:\n                neighbors.append(node)\n        return neighbors\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            # Degenerate start=goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n        active_root = start_root\n        passive_root = goal_root\n        count_no_improve = 0\n        max_no_improve = 100\n\n        # --- Main expansion loop ---\n        for iter_count in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            # Sample a point with goal bias towards the opposite tree root\n            goal_sample_pt = passive_root.position\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample_pt, self.goal_sample_rate)\n\n            nearest_node = self._nearest(active_tree, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                # Fail, skip this iteration\n                active_tree, passive_tree = passive_tree, active_tree\n                active_root, passive_root = passive_root, active_root\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                active_root, passive_root = passive_root, active_root\n                continue\n\n            # Find neighbors within fixed radius to perform rewiring\n            near_nodes = self._near(active_tree, new_pos, self.neighbor_radius)\n\n            # Choose parent that minimizes cost + edge cost and is collision free\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new node lowers cost\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        # Reparent and update cost with propagation\n                        near.parent = new_node\n                        near.update_cost_and_propagate(cost_through_new)\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try to connect the new node to the other tree\n            nearest_other = self._nearest(passive_tree, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other,\n                                       cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Construct path based on which tree is active to maintain start->goal order\n                    if active_tree is tree_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if active_tree is tree_start else new_node\n                        found_solution = True\n                        success_state = True\n                        # Early stop upon improving solution\n                        break\n\n            # Swap trees for next iteration (balanced growth)\n            active_tree, passive_tree = passive_tree, active_tree\n            active_root, passive_root = passive_root, active_root\n\n        # If found a solution, refine it using informed sampling until time expires or no improvements\n        if found_solution and best_goal_node:\n            # Rebuild minimal tree along best path for refinement\n            tree = [Node(best_path[0], cost=0.0)]\n            nodes = [tree[0]]\n            edges = []\n            prev_node = tree[0]\n            for pos in best_path[1:]:\n                n_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            c_min = self._dist(start_pos, goal_pos)\n            no_improve_count = 0\n            max_no_improve_refinement = 150\n            max_refine_iters = self.max_iter // 2\n\n            for _ in range(max_refine_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve_refinement:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                near_nodes = self._near(tree, new_pos, self.neighbor_radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = cost_cand\n                            best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            # Remove old edge\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.update_cost_and_propagate(cost_through_new)\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        success_state = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -9.92114,
    "time_improvement": -8.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 312.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.053250885009765624,
            "num_nodes_avg": 216.0,
            "path_length_avg": 156.7343393482701,
            "smoothness_avg": 0.0237005625401021,
            "success_improvement": 0.0,
            "time_improvement": -105.89844758287548,
            "length_improvement": 14.091424988672385,
            "smoothness_improvement": 270.9652703479051,
            "objective_score": -21.959852929919688
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03792276382446289,
            "num_nodes_avg": 103.0,
            "path_length_avg": 236.72289207762455,
            "smoothness_avg": 0.016521403365232567,
            "success_improvement": 0.0,
            "time_improvement": 76.92212044837883,
            "length_improvement": 20.975084933835806,
            "smoothness_improvement": 325.10760847328095,
            "objective_score": 37.287225137181544
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04678840637207031,
            "num_nodes_avg": 96.3,
            "path_length_avg": 121.8450612467233,
            "smoothness_avg": 0.03463312013167409,
            "success_improvement": 0.0,
            "time_improvement": 4.291978406722807,
            "length_improvement": 19.07631195825035,
            "smoothness_improvement": 340.5307317238809,
            "objective_score": 14.436034355586456
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A straightforward, simplified bidirectional RRT planner with uniform random sampling (no goal bias), fixed step extensions, and quick tree connection attempts without rewiring or post-processing. The planner alternates growing trees from start and goal positions by selecting nearest neighbors, extending towards random samples within bounds, and checking collisions on nodes and edges. It terminates early when a valid path is found or when the 30-second time limit is reached, returning the best path found so far. The lack of goal bias and rewiring simplifies the algorithm, enhancing general applicability and generalization.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling uniformly inside the map bounds, extending nearest nodes towards sampled points by a fixed step distance if collision-free. After each new node insertion, it attempts to connect the other tree within a fixed step size, stopping at the first valid path detected. Both node and edge collisions are checked strictly. The process continues with simple nearest neighbor searches and no rewiring, maintaining consistent parents and children relations until time expires or a path is found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[dim] + (to_pos[dim] - from_pos[dim]) * (i / steps) for dim in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n        active_tree, passive_tree = start_tree, goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_in_passive = nearest(passive_tree, new_node.position)\n            connect_dist = dist(new_node.position, nearest_in_passive.position)\n            if connect_dist <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_in_passive.position):\n                    connect_node = Node(nearest_in_passive.position, parent=new_node,\n                                        cost=new_node.cost + connect_dist)\n                    new_node.add_child(connect_node)\n                    active_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = nearest_in_passive.path_from_root()\n                    path_from_goal.reverse()\n                    full_path = path_from_start + path_from_goal[1:]  # avoid duplication\n\n                    total_cost = connect_node.cost + (nearest_in_passive.cost - (nearest_in_passive.parent.cost if nearest_in_passive.parent else 0))\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success = True\n                    break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -19.54446,
    "time_improvement": 74.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00674283504486084,
            "num_nodes_avg": 132.0,
            "path_length_avg": 198.9188261720614,
            "smoothness_avg": 0.010396100638418214,
            "success_improvement": 0.0,
            "time_improvement": 73.92833437811129,
            "length_improvement": -9.030560695417796,
            "smoothness_improvement": 62.72155048511468,
            "objective_score": 17.07377164860828
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.010281968116760253,
            "num_nodes_avg": 249.7,
            "path_length_avg": 302.17431176315097,
            "smoothness_avg": 0.006705338544585128,
            "success_improvement": 0.0,
            "time_improvement": 93.74291328420699,
            "length_improvement": -0.874482871852076,
            "smoothness_improvement": 72.53319041231268,
            "objective_score": 27.960850214212414
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022248506546020508,
            "num_nodes_avg": 339.4,
            "path_length_avg": 158.25520540150146,
            "smoothness_avg": 0.012817957362546243,
            "success_improvement": 0.0,
            "time_improvement": 54.489568890386664,
            "length_improvement": -5.10557212460277,
            "smoothness_improvement": 63.043471528392516,
            "objective_score": 13.598744749996298
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner with uniform random sampling, fixed step size extensions, alternating tree growth without rewiring or goal bias, and early termination upon first valid path found. The planner strictly checks node and edge collisions, uses straightforward nearest neighbor search, and returns the best found path within a 30-second time limit, enhancing generality and robustness by avoiding complex post-processing or heuristics.",
    "planning_mechanism": "The planner alternates expanding two trees from start and goal states by sampling random collision-free points within map bounds, steering nearest nodes toward samples by a fixed step size if collision-free, attempting to connect newly added nodes to the opposite tree within one step size, and terminates early upon first feasible connection, returning the combined path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_passive = self._nearest(passive_tree, new_pos)\n            connect_dist = math.dist(new_pos, nearest_passive.position)\n            if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_pos, nearest_passive.position, obstacles, is_3d):\n                connect_node = Node(nearest_passive.position, parent=new_node, cost=new_cost + connect_dist)\n                new_node.add_child(connect_node)\n                active_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                path_start = connect_node.path_from_root()\n                path_goal = nearest_passive.path_from_root()\n                path_goal.reverse()\n\n                full_path = path_start + path_goal[1:]\n                best_path = full_path\n                success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -20.14365,
    "time_improvement": 81.0,
    "length_improvement": -7.0,
    "smoothness_improvement": 64.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006634378433227539,
            "num_nodes_avg": 129.9,
            "path_length_avg": 194.97992325680679,
            "smoothness_avg": 0.010621364010726952,
            "success_improvement": 0.0,
            "time_improvement": 74.34768981157121,
            "length_improvement": -6.8715855916558795,
            "smoothness_improvement": 66.24741142898878,
            "objective_score": 18.512592645622778
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.00924525260925293,
            "num_nodes_avg": 270.5,
            "path_length_avg": 306.0760682419546,
            "smoothness_avg": 0.006533325398666261,
            "success_improvement": 0.0,
            "time_improvement": 94.37380600400708,
            "length_improvement": -2.1770014903100052,
            "smoothness_improvement": 68.10716827175915,
            "objective_score": 27.34647674837492
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013268494606018066,
            "num_nodes_avg": 289.6,
            "path_length_avg": 169.5608781789037,
            "smoothness_avg": 0.012309068691238188,
            "success_improvement": 0.0,
            "time_improvement": 72.85863172674526,
            "length_improvement": -12.614261665067863,
            "smoothness_improvement": 56.570445191608506,
            "objective_score": 14.5718847449409
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner using uniform random sampling within bounds, fixed-step extensions, and alternating tree growth without rewiring or goal bias; it performs essential collision checks on nodes and edges, utilizes straightforward nearest neighbor selection, and terminates early upon finding a valid path or after 30 seconds, thus promoting simplicity and generalization.",
    "planning_mechanism": "The planner builds two trees from start and goal positions by iteratively sampling collision-free points, extending nearest nodes toward these samples by a fixed step size while verifying collision-free status, then attempts to connect the new node to the opposite tree within one step size, swapping active trees after every iteration and returning the combined path once a connection is established or time expires.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_passive = self._nearest(passive_tree, new_pos)\n            dist_to_passive = math.dist(new_pos, nearest_passive.position)\n            if dist_to_passive <= self.step_size and not self._is_edge_in_obstacle(new_pos, nearest_passive.position, obstacles, is_3d):\n                connect_node = Node(nearest_passive.position, parent=new_node, cost=new_cost + dist_to_passive)\n                new_node.add_child(connect_node)\n                active_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                path_from_start = connect_node.path_from_root()\n                path_from_goal = nearest_passive.path_from_root()\n                path_from_goal.reverse()\n\n                best_path = path_from_start + path_from_goal[1:]\n                success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -23.33613,
    "time_improvement": 83.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 69.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0051754236221313475,
            "num_nodes_avg": 105.5,
            "path_length_avg": 187.27183808818094,
            "smoothness_avg": 0.01097889290378436,
            "success_improvement": 0.0,
            "time_improvement": 79.98884545890334,
            "length_improvement": -2.6466619683063053,
            "smoothness_improvement": 71.843514991755,
            "objective_score": 22.767874031645995
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.010926079750061036,
            "num_nodes_avg": 273.9,
            "path_length_avg": 297.98350841429124,
            "smoothness_avg": 0.006766176955668358,
            "success_improvement": 0.0,
            "time_improvement": 93.35093946183687,
            "length_improvement": 0.524527911583432,
            "smoothness_improvement": 74.09860654962048,
            "objective_score": 28.69049161824922
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.012542939186096192,
            "num_nodes_avg": 299.5,
            "path_length_avg": 160.74171945423825,
            "smoothness_avg": 0.012600547468599985,
            "success_improvement": 0.0,
            "time_improvement": 74.3427915684973,
            "length_improvement": -6.756996363355084,
            "smoothness_improvement": 60.278033724925216,
            "objective_score": 18.550029821160763
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An adaptive bidirectional RRT* planner with incremental rewiring using a balanced, radius-limited neighborhood, goal bias sampling, efficient nearest neighbor heuristic, and post-processing shortcut smoothing. The planner alternates expansions between start and goal trees, dynamically adjusts neighbor radius based on tree size and dimension to efficiently improve path quality with minimal rewiring overhead, and returns the best path found within a 30-second hard time limit.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, sampling points with a goal bias and steering toward them within a fixed step size. For each new node, it selects the lowest-cost parent within a computed neighbor radius, rewires neighbors to improve costs, and attempts to connect the two trees. The best path found so far is tracked incrementally. After the time limit or solution, a shortcut smoothing procedure attempts to shorten and smooth the path before returning. Collision checks for nodes and edges ensure validity at all stages.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        current = self\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Probability to sample goal for biasing\n        self.time_limit = 30.0         # seconds\n        self.gamma_rrt_star = 30.0     # Tuned rewiring radius factor\n        self.improve_tol = 1e-5        # Tolerance for considering improvement\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        near_nodes = []\n        r2 = radius * radius\n        for node in tree:\n            d2 = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d2 <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _update_costs_recursive(self, node: Node, obstacles, is_3d):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                # Check edge validity before updating\n                if not self._is_edge_in_obstacle(node.position, child.position, obstacles, is_3d):\n                    child.cost = new_cost\n                    child.parent = node\n                    self._update_costs_recursive(child, obstacles, is_3d)\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_attempts=100) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut possible, remove intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        success = False\n\n        # The trees alternate expansion\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n            # Alternate trees\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos)\n\n            near_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(near_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            if n_nodes > 1:\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 4)\n            else:\n                radius = self.step_size * 4\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = near_node.cost + self._dist(near_node.position, new_pos)\n            best_parent = near_node\n            for near_n in near_nodes:\n                cost_candidate = near_n.cost + self._dist(near_n.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes to new_node if better cost\n            for near_n in near_nodes:\n                if near_n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_n.position)\n                if cost_through_new + self.improve_tol < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d):\n                        if near_n.parent:\n                            # Remove old edge\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = cost_through_new\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n                        # Propagate cost update recursively\n                        self._update_costs_recursive(near_n, obstacles, is_3d)\n\n            # Attempt to connect the other tree to new_node\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if tree_a is tree_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        success = True\n                        # Early stop for a feasible path (can comment out to improve quality)\n                        break\n\n        # If found path, apply shortcut smoothing\n        if success and best_path:\n            smoothed_path = self._shortcut_smooth(best_path, obstacles, is_3d, max_attempts=150)\n            return PlannerResult(success=True, path=smoothed_path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)",
    "objective": -14.86659,
    "time_improvement": -6.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1599.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025786590576171876,
            "num_nodes_avg": 139.6,
            "path_length_avg": 165.11447689912282,
            "smoothness_avg": 0.043279939127432485,
            "success_improvement": 0.0,
            "time_improvement": 0.2942586378553755,
            "length_improvement": 9.498138805272788,
            "smoothness_improvement": 577.4250312363979,
            "objective_score": 8.674286030702275
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05598971843719482,
            "num_nodes_avg": 355.1,
            "path_length_avg": 240.12211486709475,
            "smoothness_avg": 0.10462428588956851,
            "success_improvement": 0.0,
            "time_improvement": 65.92748397232447,
            "length_improvement": 19.84032652550761,
            "smoothness_improvement": 2592.058233765738,
            "objective_score": 44.642732275830596
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08963375091552735,
            "num_nodes_avg": 393.8,
            "path_length_avg": 130.10415143179586,
            "smoothness_avg": 0.13574350301260935,
            "success_improvement": 0.0,
            "time_improvement": -83.35031332100762,
            "length_improvement": 13.591017512937235,
            "smoothness_improvement": 1626.6473387772428,
            "objective_score": -8.717246794653729
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A balanced bidirectional RRT* planner with goal biasing, adaptive fixed rewiring radius, recursive cost updates, and early stopping to improve planning time, path smoothness, and path length within a 30-second hard time limit. The planner alternates tree expansions but only switches on failure or improvement; it samples mostly randomly with goal biasing, performs fixed-radius neighbor rewiring with recursive cost propagation for smooth paths, and maintains coherent parent-child and edge relationships. Connection attempts and rewiring are performed efficiently to quickly improve paths and halt early upon satisfying conditions.",
    "planning_mechanism": "A bidirectional RRT* grows two trees from the start and goal, alternately extending one tree towards a random sample biased towards the goal. For each new node, neighbors within a fixed radius are found, and rewiring is performed to minimize path cost, recursively propagating cost improvements downstream. Connection attempts between trees are performed after each extension. The best path is updated and returned if found or if time runs out (30 seconds). The neighbor radius is fixed to reduce computational overhead, and tree swapping only occurs after failures or improvements, enhancing planning efficiency and path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\") -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\") -> None:\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.1, fixed_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.fixed_radius = fixed_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[dim] + (to_pos[dim] - from_pos[dim]) * (i / steps) for dim in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            radius = self.fixed_radius\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def update_costs_recursively(node: Node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-10 < child.cost:\n                    child.cost = new_cost\n                    update_costs_recursively(child)\n\n        def add_node_to_tree(tree: List[Node], new_node: Node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        def add_edge(parent: Node, child: Node):\n            parent.add_child(child)\n            edges.append((parent, child))\n\n        def choose_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Tuple[Node, float]:\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n            if best_parent is None:\n                nearest_node = nearest(tree, new_pos)\n                if not is_edge_in_obstacle(nearest_node.position, new_pos):\n                    best_parent = nearest_node\n                    min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n                else:\n                    return None, float('inf')\n            return best_parent, min_cost\n\n        def rewire(tree: List[Node], new_node: Node):\n            neighbors = near_nodes(tree, new_node.position)\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Remove old edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.remove_child(nb)\n                            except ValueError:\n                                pass\n                        # Add new edge\n                        nb.parent = new_node\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n                        update_costs_recursively(nb)\n\n        def extend(tree: List[Node], sample_point: Tuple[float, ...]) -> Optional[Node]:\n            parent_node, min_cost = choose_parent(tree, sample_point)\n            if parent_node is None:\n                return None\n            new_pos = steer(parent_node.position, sample_point)\n            if is_in_obstacle(new_pos):\n                return None\n            if is_edge_in_obstacle(parent_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=parent_node, cost=parent_node.cost + dist(parent_node.position, new_pos))\n            add_node_to_tree(tree, new_node)\n            add_edge(parent_node, new_node)\n            rewire(tree, new_node)\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, node.position)\n            dist_to_node = dist(nearest_node.position, node.position)\n            if dist_to_node > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node,\n                                cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n                add_node_to_tree(tree, new_node)\n                add_edge(nearest_node, new_node)\n                rewire(tree, new_node)\n                # Try final connection to node\n                dist_to_node_new = dist(new_node.position, node.position)\n                if dist_to_node_new <= self.step_size:\n                    if (not is_in_obstacle(node.position)\n                        and not is_edge_in_obstacle(new_node.position, node.position)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_node.position, node.position))\n                        add_node_to_tree(tree, final_node)\n                        add_edge(new_node, final_node)\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node,\n                                 cost=nearest_node.cost + dist(nearest_node.position, node.position))\n                add_node_to_tree(tree, final_node)\n                add_edge(nearest_node, final_node)\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree, passive_tree = tree_start, tree_goal\n        no_improve_iters = 0  # Used to manage swapping logic\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                # Only swap trees after failure to extend\n                active_tree, passive_tree = passive_tree, active_tree\n                no_improve_iters = 0\n                continue\n\n            connected_node = try_connect(passive_tree, new_node)\n            if connected_node is not None:\n                # Construct combined path\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                path_from_goal.reverse()\n                full_path = path_from_start + path_from_goal[1:]\n                total_cost = new_node.cost + (connected_node.cost - (connected_node.parent.cost if connected_node.parent else 0))\n                if total_cost < best_cost - 1e-10:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                    # Early stopping to improve planning time\n                    break\n                # Do not swap trees here: continue to try improving\n                \n            # Swap trees only if no improvement this iteration\n            no_improve_iters += 1\n            if no_improve_iters >= 1:\n                active_tree, passive_tree = passive_tree, active_tree\n                no_improve_iters = 0\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 10.44197,
    "time_improvement": -51.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 102.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07860643863677978,
            "num_nodes_avg": 182.0,
            "path_length_avg": 173.3901735127112,
            "smoothness_avg": 0.012420365672316752,
            "success_improvement": 0.0,
            "time_improvement": -203.93755300711675,
            "length_improvement": 4.962098354560332,
            "smoothness_improvement": 94.40569402750452,
            "objective_score": -57.7319784192613
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05514934062957764,
            "num_nodes_avg": 280.0,
            "path_length_avg": 273.0727606537023,
            "smoothness_avg": 0.00802759787439646,
            "success_improvement": 0.0,
            "time_improvement": 66.43889547998295,
            "length_improvement": 8.840452530186273,
            "smoothness_improvement": 106.55587535325786,
            "objective_score": 25.768719538872933
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05667581558227539,
            "num_nodes_avg": 266.4,
            "path_length_avg": 138.28195452692114,
            "smoothness_avg": 0.0160611677343429,
            "success_improvement": 0.0,
            "time_improvement": -15.933210856332733,
            "length_improvement": 8.159710082291825,
            "smoothness_improvement": 104.29686806875786,
            "objective_score": 0.637347132819064
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved bidirectional RRT* planner featuring adaptive rewiring radius based on the tree size and workspace dimension, goal biasing, and non-recursive rewiring with incremental cost updates to optimize the path cost and smoothness efficiently. The planner also employs early stopping upon finding a feasible path, consistent parent-child relationship management, and precise collision checking to ensure validity and robustness. It incorporates a balanced step size and local rewiring to improve path quality without excessive computation.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal locations, sampling points with goal bias, steering towards samples by fixed step size, performing local neighbor rewiring within an adaptively scaled radius, and attempting to connect the two trees when close. Incremental cost updates propagate efficiently to maintain optimal tree structure, and the best path found is returned immediately upon discovery or after timeout for robust real-time performance.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target):\n        if random.random() < self.goal_sample_rate:\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n        dim = len(bounds)\n        while True:\n            sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            dist_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _update_cost_propagate(self, node: Node):\n        # Propagate cost updates non-recursively\n        stack = [node]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._dist(current.position, child.position)\n                if new_cost + self.improve_tol < child.cost:\n                    child.cost = new_cost\n                    stack.append(child)\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        dimension = len(bounds)\n        # Adaptive rewiring radius based on formula r = gamma * (log(n)/n)^(1/d)\n        # For practical purposes, use: r = min(max(initial_radius, c*(log(n)/n)^(1/d)), max_radius)\n        def rewiring_radius(n: int) -> float:\n            c = 40.0  # constant tuning parameter\n            gamma = c\n            r_max = 20.0\n            if n <= 1:\n                return r_max\n            radius = gamma * ((math.log(n) / n) ** (1.0 / dimension))\n            return max(5.0, min(radius, r_max))\n\n        for iteration in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start_tree = (iteration % 2 == 0)\n            tree_from, tree_to = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start_tree else start_pos\n\n            sample = self._sample(bounds, obstacles, is_3d, target_sample)\n            nearest_node = self._nearest(tree_from, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = rewiring_radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Choose best parent among near nodes for rewiring\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        old_parent = near_node.parent\n                        if old_parent:\n                            old_parent.remove_child(near_node)\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_cost_propagate(near_node)\n\n            # Attempt connect trees\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connect nodes\n                    connect_node = Node(new_node.position, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_to.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start_tree:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success = found_solution\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 6.668,
    "time_improvement": 8.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 168.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.031100940704345704,
            "num_nodes_avg": 186.4,
            "path_length_avg": 166.5542509289781,
            "smoothness_avg": 0.01927047511561303,
            "success_improvement": -9.999999999999998,
            "time_improvement": -20.254065415391427,
            "length_improvement": 8.708975844829633,
            "smoothness_improvement": 201.62478206583404,
            "objective_score": -49.842710207390475
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05410923957824707,
            "num_nodes_avg": 388.4,
            "path_length_avg": 259.70889131800624,
            "smoothness_avg": 0.009504112556204595,
            "success_improvement": 0.0,
            "time_improvement": 67.07184847083636,
            "length_improvement": 13.30169677209252,
            "smoothness_improvement": 144.54766160671983,
            "objective_score": 28.825310912540015
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.059685564041137694,
            "num_nodes_avg": 370.2,
            "path_length_avg": 133.38112563312148,
            "smoothness_avg": 0.020307992936277493,
            "success_improvement": 0.0,
            "time_improvement": -22.089801619447023,
            "length_improvement": 11.414607281159634,
            "smoothness_improvement": 158.31617116933677,
            "objective_score": 1.013404738708358
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with fixed radius rewiring and early stopping upon first feasible solution. It alternates growth of two trees from start and goal by steering towards randomly sampled collision-free points, performs local rewiring without recursive cost propagation to reduce overhead, and immediately terminates when a connection is found. This yields efficient planning time and reasonably smooth, feasible paths without expensive post-processing.",
    "planning_mechanism": "The planner incrementally extends alternate trees toward sampled points within map bounds, connecting trees when nodes are close and collision-free. It performs fixed-radius neighbor rewiring locally to improve path quality without recursive cost propagation. The algorithm stops as soon as any feasible path is found, returning the best path identified so far within 30 seconds.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = 15.0\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius*radius\n        result = []\n        for node in tree:\n            dist_sq = sum((a - b)**2 for a,b in zip(node.position, point))\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _sample_free(self, bounds: Tuple[int, ...], obstacles, is_3d) -> Tuple[float, ...]:\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        time_start = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - time_start) >= self.time_limit\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        for _ in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            # Find best parent from neighbors within radius (rewiring radius)\n            near_nodes = self._near(active_tree, new_pos, self.neighbor_radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                # Check edge collision for candidate parent only once\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring (without recursive cost propagation)\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect passive tree to new_node\n            nearest_other = self._nearest(passive_tree, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other,\n                                        cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build path: from start_root -> new_node and goal_root -> connect_node reversed\n                    if active_tree is tree_start:\n                        path1 = new_node.path_from_root()\n                        path2 = connect_node.path_from_root()\n                        path2.reverse()\n                        best_path = path1 + path2[1:]\n                    else:\n                        path1 = connect_node.path_from_root()\n                        path2 = new_node.path_from_root()\n                        path2.reverse()\n                        best_path = path1 + path2[1:]\n\n                    success_state = True\n                    break\n\n            # Swap trees for next iteration\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": -23.17629,
    "time_improvement": 48.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 285.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020616316795349122,
            "num_nodes_avg": 148.4,
            "path_length_avg": 176.5366342140088,
            "smoothness_avg": 0.021656463076723472,
            "success_improvement": 0.0,
            "time_improvement": 20.285500940300153,
            "length_improvement": 3.237473385318676,
            "smoothness_improvement": 238.97067491299885,
            "objective_score": 9.222987687846246
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03329770565032959,
            "num_nodes_avg": 282.7,
            "path_length_avg": 248.0801887661497,
            "smoothness_avg": 0.016041744023426858,
            "success_improvement": 0.0,
            "time_improvement": 79.73669735938542,
            "length_improvement": 17.18369239754649,
            "smoothness_improvement": 312.76562812396077,
            "objective_score": 35.795052786963325
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027396082878112793,
            "num_nodes_avg": 242.6,
            "path_length_avg": 125.95282665645531,
            "smoothness_avg": 0.031666240784116576,
            "success_improvement": 0.0,
            "time_improvement": 43.95994446105323,
            "length_improvement": 16.34812976387534,
            "smoothness_improvement": 302.79224541520284,
            "objective_score": 24.510822423717183
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, efficient bidirectional RRT algorithm with goal bias, fixed step steering, and direct tree connection attempts without rewiring or complex neighbor searches. It alternates extending start and goal trees toward random free samples, immediately tries to connect trees when new nodes are close, and returns the best path found within a 30-second limit, improving generalization and runtime efficiency by avoiding costly rewiring or recursive cost updates.",
    "planning_mechanism": "The planner samples points biased toward the goal and extends one tree at a time by a fixed step towards the sample if collision-free. Each new node attempts connection to the other tree if close enough, connecting trees to form a solution path. The process continues until timeout or first solution is found, maintaining simple, coherent node and edge structures.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # float\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(p1, p2):\n            return sum((p1[i]-p2[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interm = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n        \n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = None\n            min_dist = float('inf')\n            for node in active_tree:\n                d = dist(node.position, sample)\n                if d < min_dist:\n                    min_dist = d\n                    nearest_node = node\n\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Attempt to connect to opposite tree\n            nearest_other = None\n            min_dist_other = float('inf')\n            for node in passive_tree:\n                d = dist(new_pos, node.position)\n                if d < min_dist_other:\n                    min_dist_other = d\n                    nearest_other = node\n\n            if min_dist_other <= self.step_size:\n                if not edge_in_obstacle(new_pos, nearest_other.position):\n                    connect_cost = new_node.cost + dist(new_pos, nearest_other.position)\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=connect_cost)\n                    new_node.add_child(connect_node)\n                    active_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n\n                    if connect_cost < best_cost:\n                        best_cost = connect_cost\n                        best_path = full_path\n                        success = True\n                    break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 7.11693,
    "time_improvement": -15.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 65.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016550087928771974,
            "num_nodes_avg": 140.2,
            "path_length_avg": 190.02887317991437,
            "smoothness_avg": 0.01057195567121958,
            "success_improvement": 0.0,
            "time_improvement": 36.007872709170684,
            "length_improvement": -4.15783659010215,
            "smoothness_improvement": 65.47406362377193,
            "objective_score": 8.635030176808774
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06317861080169677,
            "num_nodes_avg": 341.3,
            "path_length_avg": 306.05538594868966,
            "smoothness_avg": 0.006587089284564936,
            "success_improvement": 0.0,
            "time_improvement": 61.55268700695864,
            "length_improvement": -2.1700971455113645,
            "smoothness_improvement": 69.4905517804938,
            "objective_score": 17.511200573683244
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11857657432556153,
            "num_nodes_avg": 416.1,
            "path_length_avg": 163.19050986177248,
            "smoothness_avg": 0.012567648364718248,
            "success_improvement": 0.0,
            "time_improvement": -142.55430385383136,
            "length_improvement": -8.383366353170803,
            "smoothness_improvement": 59.85955955190876,
            "objective_score": -47.49701317029235
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional RRT* planner featuring incremental nearest neighbor caching, adaptive rewiring with bounded radius, early termination upon first solution, and streamlined non-recursive cost propagation for efficiency. It performs balanced tree expansions with goal biasing and uses ellipsoidal informed sampling only if time permits after initial solution discovery, ensuring a robust trade-off between planning time and path quality within a strict 30-second limit.",
    "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Each iteration samples points biased towards the opposing tree's root, finds the nearest node via cached neighbors, and extends within step size if collision-free. It rewires nearby nodes within a dynamically adjusted radius to minimize cost without costly recursive updates. Upon connecting trees, it updates the best path and exits early. Optionally, it refines the found path with informed sampling only if sufficient time remains. Nodes manage parent-child links and maintain consistent cost attributes, with edges tracking connectivity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Path cost from root\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 30.0\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self._nn_cache = {}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        try:\n            dist = sum((to_pos[d]-from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        except Exception:\n            dist = 0.0\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = sum((to_pos[d]-from_pos[d])**2 for d in range(len(from_pos)))**0.5\n        except Exception:\n            dist = 0.0\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist if dist>0 else 0.0\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return sum((p1[d]-p2[d])**2 for d in range(len(p1)))**0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        nearest_node = min(self._nn_cache[key], key=lambda n: self._dist(n.position, point))\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        key = id(tree)\n        if key not in self._nn_cache or len(self._nn_cache[key]) != len(tree):\n            self._nn_cache[key] = list(tree)\n        radius_sq = radius*radius\n        dim = len(point)\n        candidates = [n for n in self._nn_cache[key] if (sum((n.position[d]-point[d])**2 for d in range(dim)) <= radius_sq)]\n        return candidates\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def _propagate_cost_bfs(self, root):\n        queue = [root]\n        while queue:\n            current = queue.pop(0)\n            for child in current.children:\n                new_cost = current.cost + self._dist(current.position, child.position)\n                if abs(child.cost - new_cost) > 1e-10:\n                    child.cost = new_cost\n                    queue.append(child)\n\n    def _ellipsoid_parameters(self, c_best, c_min, start, goal, bounds):\n        dim = len(bounds)\n        center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = sum(x*x for x in a1)**0.5\n        if norm_a1 < 1e-12:\n            norm_a1 = 1e-12\n        c1 = c_best * 0.5\n        c2 = ((max(c_best*c_best - c_min*c_min,0))**0.5)*0.5\n        return (center, c1, c2, a1, norm_a1)\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n            goal_bias = self.goal_sample_rate\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, goal_bias)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1.0/dim)), self.step_size*10)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost:\n                    # Check edge collision only if cost improvement seen\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d, resolution=1.0):\n                        min_cost = cost_candidate\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors - simplified, no recursion\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_via_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_via_new + self.improve_tol < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=1.0):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_via_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n            # Propagate cost with BFS to keep efficiency\n            self._propagate_cost_bfs(new_node)\n\n            # Attempt connection to opposite tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d, resolution=1.0):\n                    # Connect trees by adding new node in tree_b at this position\n                    conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                    nearest_b.add_child(conn_node)\n                    tree_b.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((nearest_b, conn_node))\n\n                    if expand_start:\n                        cur_path = self._build_path(new_node, conn_node)\n                        cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                        goal_node_for_path = conn_node\n                    else:\n                        cur_path = self._build_path(conn_node, new_node)\n                        cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if cur_cost + self.improve_tol < best_cost:\n                        best_cost = cur_cost\n                        best_path = cur_path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n                        success = True\n                        # Early exit on first valid solution for speed\n                        break\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 29.06473,
    "time_improvement": -111.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 112.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02334277629852295,
            "num_nodes_avg": 132.9,
            "path_length_avg": 168.9215276752023,
            "smoothness_avg": 0.016347590049242546,
            "success_improvement": 0.0,
            "time_improvement": 9.743445554777095,
            "length_improvement": 7.411433948323603,
            "smoothness_improvement": 155.87528363062475,
            "objective_score": 8.149270453580414
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09121270179748535,
            "num_nodes_avg": 334.3,
            "path_length_avg": 275.72453508279625,
            "smoothness_avg": 0.007671108199171864,
            "success_improvement": 0.0,
            "time_improvement": 44.49255451411916,
            "length_improvement": 7.955213898659838,
            "smoothness_improvement": 97.3831392405946,
            "objective_score": 18.607810389634626
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.23811185359954834,
            "num_nodes_avg": 472.2,
            "path_length_avg": 146.16980723701056,
            "smoothness_avg": 0.014419082559160473,
            "success_improvement": 0.0,
            "time_improvement": -387.0696865521912,
            "length_improvement": 2.9209738914336056,
            "smoothness_improvement": 83.40966584655702,
            "objective_score": -113.9512733015644
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* planner that integrates a spatial grid-based nearest neighbor structure for accelerated neighbor searches, adaptive dynamic rewiring radius based on sampled area and tree size, non-recursive localized rewiring with early path cost updates, and adaptive goal biasing to guide faster convergence. The planner performs incremental collision checking with variable resolution, enforces strict bounds, and terminates early upon solution or time limit. It cleverly balances exploration and exploitation, improving both planning time and path quality.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, efficiently sampling space with adaptive goal biasing. Nodes are inserted with nearest neighbor lookup accelerated by a spatial grid, enabling quick radius neighbor queries for rewiring within a dynamically set radius. Rewiring locally updates costs non-recursively to avoid overhead. Once the two trees connect via collision-free edge, the best path is immediately returned. The search stops after a hard 30-second limit if no path is found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_bias_start = 0.15\n        self.goal_bias_end = 0.35\n        self.improve_tol = 1e-7\n        self.grid_cell_size = 10.0  # size for spatial hashing grid cells\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        scale = self.step_size / dist if dist > 0 else 0.0\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * scale for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _point_to_grid(self, point, cell_size):\n        return tuple(int(coord // cell_size) for coord in point)\n\n    def _insert_to_grid(self, grid, node, cell_size):\n        cell = self._point_to_grid(node.position, cell_size)\n        if cell not in grid:\n            grid[cell] = []\n        grid[cell].append(node)\n\n    def _get_grid_neighbors(self, grid, position, cell_size, radius, bounds):\n        dim = len(position)\n        cell = self._point_to_grid(position, cell_size)\n        r_cells = int(math.ceil(radius / cell_size))\n        neighbors = []\n        # In 2D or 3D, iterate nearby cells within radius in grid coords\n        ranges = [range(cell[d] - r_cells, cell[d] + r_cells + 1) for d in range(dim)]\n        # Generate all combinations of cells to search\n        def grid_points(ranges, prefix=()):\n            if not ranges:\n                yield prefix\n            else:\n                for val in ranges[0]:\n                    yield from grid_points(ranges[1:], prefix + (val,))\n        for c in grid_points(ranges):\n            # Skip cells outside bounds\n            inside_bounds = True\n            for d in range(dim):\n                if c[d] < 0 or c[d] > bounds[d]:\n                    inside_bounds = False\n                    break\n            if not inside_bounds:\n                continue\n            if c in grid:\n                neighbors.extend(grid[c])\n        # Filter neighbors within radius\n        radius_sq = radius * radius\n        filtered = []\n        for n in neighbors:\n            if sum((n.position[d] - position[d]) ** 2 for d in range(dim)) <= radius_sq:\n                filtered.append(n)\n        return filtered\n\n    def _best_parent(self, neighbors, new_pos, obstacles, is_3d):\n        min_cost = float('inf')\n        best_parent = None\n        for n in neighbors:\n            cost = n.cost + self._dist(n.position, new_pos)\n            if cost < min_cost:\n                # Early prune by collision checking edge before selecting parent\n                if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, resolution=max(0.5, self.step_size / 5)):\n                    min_cost = cost\n                    best_parent = n\n        return best_parent, min_cost\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d):\n        for neighbor in neighbors:\n            if neighbor is new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, neighbor.position)\n            if cost_through_new + self.improve_tol < neighbor.cost:\n                if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(0.5, self.step_size / 5)):\n                    # Rewire neighbor\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        # If connecting point overlaps, remove duplicate\n        if path_start[-1] == path_goal[0]:\n            return path_start + path_goal[1:]\n        else:\n            return path_start + path_goal\n\n    def _update_goal_bias(self, iter_count, max_iter):\n        # Linearly increase goal bias from start to end value\n        return self.goal_bias_start + (self.goal_bias_end - self.goal_bias_start) * (iter_count / max_iter)\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        # Spatial grids for each tree to accelerate neighbor search\n        grid_start = {}\n        grid_goal = {}\n\n        # Initialize root nodes\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        # Insert roots into grids\n        self._insert_to_grid(grid_start, root_start, self.grid_cell_size)\n        self._insert_to_grid(grid_goal, root_goal, self.grid_cell_size)\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_from_start = (i % 2 == 0)\n            tree_a = tree_start if expand_from_start else tree_goal\n            grid_a = grid_start if expand_from_start else grid_goal\n\n            tree_b = tree_goal if expand_from_start else tree_start\n            grid_b = grid_goal if expand_from_start else grid_start\n\n            # Adaptive goal bias increasing over time to speed connection\n            goal_bias = self._update_goal_bias(i, self.max_iter)\n            sample_goal = goal_pos if expand_from_start else start_pos\n\n            # Sample point\n            if random.random() < goal_bias and not self._is_in_obstacle(sample_goal, obstacles, is_3d):\n                sample_pt = sample_goal\n            else:\n                while True:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        break\n\n            # Find nearest neighbor in tree_a using spatial grid neighbors and fallback to full search\n            search_radius = max(self.step_size * 2, 15.0)\n            neighborhood = self._get_grid_neighbors(grid_a, sample_pt, self.grid_cell_size, search_radius, bounds)\n            if neighborhood:\n                nearest = min(neighborhood, key=lambda n: self._dist(n.position, sample_pt))\n            else:\n                # fallback linear search if no grid neighbors found (early phase)\n                nearest = min(tree_a, key=lambda n: self._dist(n.position, sample_pt))\n\n            new_pos = self._steer(nearest.position, sample_pt)\n            # Check node and edge collision (early rejection)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=max(0.5, self.step_size/5)):\n                continue\n\n            # Calculate adaptive radius for rewiring constrained by problem dimension\n            n_nodes = len(tree_a) + 1\n            gamma = 50.0  # tuned constant for radius scaling\n            radius = min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * 8)\n\n            # Find neighbors within radius in tree_a using spatial grid\n            near_nodes = self._get_grid_neighbors(grid_a, new_pos, self.grid_cell_size, radius, bounds)\n\n            # Select best parent among neighbors for rewiring\n            best_parent, best_cost_node = self._best_parent(near_nodes, new_pos, obstacles, is_3d)\n            if best_parent is None:\n                # fallback: connect to nearest without rewiring if safe\n                if not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, resolution=max(0.5, self.step_size/5)):\n                    best_parent = nearest\n                    best_cost_node = nearest.cost + self._dist(nearest.position, new_pos)\n                else:\n                    continue  # no feasible parent - discard this sampled node\n\n            # Add new node\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_node)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._insert_to_grid(grid_a, new_node, self.grid_cell_size)\n\n            # Rewire neighbors non-recursively with early pruning\n            self._rewire(new_node, near_nodes, obstacles, is_3d)\n\n            # Attempt to connect to opposite tree within step size\n            connect_radius = self.step_size * 1.5\n            near_opposite = self._get_grid_neighbors(grid_b, new_node.position, self.grid_cell_size, connect_radius, bounds)\n            if near_opposite:\n                # Find best connection node in opposite tree\n                best_conn = None\n                min_connect_cost = float('inf')\n                for op_node in near_opposite:\n                    dist_connect = self._dist(new_node.position, op_node.position)\n                    if dist_connect <= connect_radius:\n                        if not self._is_edge_in_obstacle(new_node.position, op_node.position, obstacles, is_3d, resolution=max(0.5, self.step_size/5)):\n                            cost_total = new_node.cost + dist_connect + op_node.cost\n                            if cost_total < min_connect_cost:\n                                min_connect_cost = cost_total\n                                best_conn = op_node\n\n                if best_conn is not None and min_connect_cost + self.improve_tol < best_cost:\n                    # Build combined path from start_root to goal_root through connection nodes\n                    path_a = new_node.path_from_root()\n                    path_b = best_conn.path_from_root()\n                    path_b.reverse()\n                    # Remove duplicate connection point if positions match\n                    if path_a[-1] == path_b[0]:\n                        combined_path = path_a + path_b[1:]\n                    else:\n                        combined_path = path_a + path_b\n                    best_cost = min_connect_cost\n                    best_path = combined_path\n                    found_solution = True\n                    success = True\n                    break  # early stop on first path found\n\n        return PlannerResult(\n            success=success,\n            path=best_path if success else [],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -18.09678,
    "time_improvement": 26.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 292.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02445380687713623,
            "num_nodes_avg": 102.1,
            "path_length_avg": 163.11767133809556,
            "smoothness_avg": 0.026437492029749116,
            "success_improvement": 0.0,
            "time_improvement": 5.447564438216751,
            "length_improvement": 10.592619574680768,
            "smoothness_improvement": 313.80416019839413,
            "objective_score": 9.558861877265457
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04410805702209473,
            "num_nodes_avg": 264.6,
            "path_length_avg": 247.39321871253946,
            "smoothness_avg": 0.014540972307249104,
            "success_improvement": 0.0,
            "time_improvement": 73.15806326976333,
            "length_improvement": 17.413022774778213,
            "smoothness_improvement": 274.1496909045328,
            "objective_score": 33.76598110031859
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04934518337249756,
            "num_nodes_avg": 295.7,
            "path_length_avg": 125.96073197175524,
            "smoothness_avg": 0.030521735850066605,
            "success_improvement": 0.0,
            "time_improvement": -0.938036619225129,
            "length_improvement": 16.342879429863792,
            "smoothness_improvement": 288.2342271326539,
            "objective_score": 10.965487807814007
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner combining adaptive radius rewiring with efficient incremental cost updates, balanced goal and ellipsoidal informed sampling, and consistent parent/child updates. It limits rewiring overhead by iterative cost propagation, uses early timeout on best path convergence within a 30-second hard limit, and refines solutions via informed sampling focused on the current best path to enhance planning efficiency, path smoothness, and robustness.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling with a balanced goal bias and ellipsoidal informed distribution after the first connection. It steers with fixed steps, connects trees when near, and rewires neighbors using an adaptive radius based on tree size and workspace dimension. Cost updates propagate iteratively through affected descendants to maintain consistency and efficiency. Upon finding a path, refinement continues with informed sampling and rewiring until timeout or cost stagnation, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1   # Balanced goal bias\n        self.gamma_rrt_star = 40.0    # RRT* adaptive radius constant\n        self.improve_tol = 1e-8\n        self.time_limit = 30.0        # Hard planning time limit (seconds)\n        self.refine_no_improve_limit = 150\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node: Optional[Node] = None\n        found_solution = False\n        success_state = False\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_p, to_p):\n            dist = distance(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def sample(bounds, obstacles, is_3d, goal, goal_bias_rate):\n            if random.random() < goal_bias_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            for node in tree:\n                d = distance(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def build_path(start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def iter_update_costs(root: Node):\n            stack = [root]\n            while stack:\n                current = stack.pop()\n                for child in current.children:\n                    new_cost = current.cost + distance(current.position, child.position)\n                    if new_cost + self.improve_tol < child.cost:\n                        child.cost = new_cost\n                        child.parent = current\n                        stack.append(child)\n\n        def ellipsoidal_informed_sample(c_best, c_min, start, goal, bounds, obstacles, is_3d):\n            if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            c1 = c_best * 0.5\n            c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n            dim = len(bounds)\n            while True:\n                rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                if norm_dir < 1e-12:\n                    continue\n                unit_dir = [x / norm_dir for x in rnd_dir]\n                r = random.random() ** (1.0 / dim)\n                ball_point = [r * x for x in unit_dir]\n                scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n                dir_a1 = [x / norm_a1 for x in a1]\n                point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n                for i in range(1, dim):\n                    point[i] += scaled[i]\n                pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # --- Main planning loop ---\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n\n            sample_pt = sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + distance(near_node.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors iteratively\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    iter_update_costs(near_node)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = distance(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    connect_node.parent = nearest_other\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution and (timed_out() or it >= self.max_iter//4):\n                # Limit planning before refinement to quarter iterations or timeout\n                break\n\n        # Refinement phase with ellipsoidal informed sampling\n        if found_solution and best_goal_node:\n            # Rebuild tree along best_path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_node = Node(pos, cost=prev_node.cost + distance(prev_node.position, pos))\n                prev_node.add_child(n_node)\n                n_node.parent = prev_node\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            refine_iter = 0\n            max_refine_iter = self.max_iter // 2\n            c_min = distance(start_pos, goal_pos)\n\n            while not timed_out() and no_improve_count < self.refine_no_improve_limit and refine_iter < max_refine_iter:\n                refine_iter += 1\n                sample_pt = ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = nearest(tree, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + distance(near_node.position, new_pos)\n                    if cost_cand + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near_node\n\n                new_node = Node(new_pos, cost=min_cost)\n                best_parent.add_child(new_node)\n                new_node.parent = best_parent\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        iter_update_costs(near_node)\n                        rewired = True\n\n                dist_to_goal = distance(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    new_goal_node.parent = new_node\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        success_state = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 48.89033,
    "time_improvement": -183.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 146.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.14218876361846924,
            "num_nodes_avg": 151.9,
            "path_length_avg": 159.1325533570528,
            "smoothness_avg": 0.016860620666787743,
            "success_improvement": 0.0,
            "time_improvement": -449.78327003208085,
            "length_improvement": 12.77692588832575,
            "smoothness_improvement": 163.90532685902429,
            "objective_score": -126.44929884233368
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05767824649810791,
            "num_nodes_avg": 118.2,
            "path_length_avg": 253.10760976975536,
            "smoothness_avg": 0.00965137954102357,
            "success_improvement": 0.0,
            "time_improvement": 64.89993103895551,
            "length_improvement": 15.505394560252789,
            "smoothness_improvement": 148.33694719823376,
            "objective_score": 29.514900783829493
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1294846773147583,
            "num_nodes_avg": 125.4,
            "path_length_avg": 152.8304262251753,
            "smoothness_avg": 0.01769269340747467,
            "success_improvement": 0.0,
            "time_improvement": -164.8673732097249,
            "length_improvement": -1.5026920959122114,
            "smoothness_improvement": 125.04975420429571,
            "objective_score": -49.736578449443314
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with adaptive logarithmic neighbor radius, cached nearest-neighbor queries, balanced goal biasing, and incremental rewiring. It efficiently grows start and goal trees by sampling collision-free points, connecting new nodes via lowest-cost parents found within a shrinking radius, and rewiring neighbors to optimize path cost. Early path discovery triggers quality improvements through selective rewiring while respecting a 30-second limit. Path extraction merges trees seamlessly, returning high-quality smooth paths.",
    "planning_mechanism": "A planner that alternately grows two RRT* trees, using cached nearest neighbor searches and an adaptive neighbor radius decreasing logarithmically to balance exploration and local optimization. Nodes are added ensuring collision-free edges and rewiring neighbors if a cheaper path exists. The planner keeps track of the best path, terminates early upon timeout or solution stability, and returns an optimized, smooth path composed by merging start and goal trees.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.improve_tol = 1e-9\n        self.cache_nearest = {}\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        found_solution = False\n        success_state = False\n\n        # Cached distances for nearest and near queries\n        def dist_cache(npos, p):\n            return math.dist(npos, p)\n\n        # Clear nearest cache every iteration for accuracy with new nodes\n        def clear_cache():\n            self.cache_nearest.clear()\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Cache key to enable quick repeated queries - keyed by point and id(tree)\n            key = (point, id(tree))\n            if key in self.cache_nearest:\n                return self.cache_nearest[key]\n            best = None\n            best_dist = float(\"inf\")\n            for node in tree:\n                d = dist_cache(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            self.cache_nearest[key] = best\n            return best\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i]-point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def update_costs_recursive(node: Node):\n            for child in node.children:\n                new_cost = node.cost + math.dist(node.position, child.position)\n                if new_cost + self.improve_tol < child.cost:\n                    # Update parent's edges list accordingly\n                    if child.parent:\n                        try:\n                            edges.remove((child.parent, child))\n                        except ValueError:\n                            pass\n                        child.parent.remove_child(child)\n                    child.parent = node\n                    child.cost = new_cost\n                    edges.append((node, child))\n                    update_costs_recursive(child)\n\n        def build_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            path_goal.reverse()\n            # Avoid duplicate middle node\n            return path_start + path_goal[1:]\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            clear_cache()\n            # Adaptive neighbor radius, logarithmically decreasing with iterations\n            radius = min(self.step_size * 30, self.step_size * (math.log(itr + 2) / (itr + 1)) * 50)\n            # Alternate tree growth: even iter expand start tree, odd iter expand goal tree\n            expand_start_tree = (itr % 2 == 0)\n            tree_active, tree_passive = (tree_start, tree_goal) if expand_start_tree else (tree_goal, tree_start)\n            sample_pt = sample_free()\n\n            nearest_node = nearest(tree_active, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = near(tree_active, new_pos, radius)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_active.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        update_costs_recursive(near_node)\n\n            # Attempt to connect trees\n            nearest_other = nearest(tree_passive, new_node.position)\n            dist_connect = math.dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_passive.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start_tree:\n                        path = build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        success_state = True\n\n            if found_solution and itr > 100:\n                # Stop early if a good solution has been found for some iterations\n                break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -16.3935,
    "time_improvement": 49.0,
    "length_improvement": 2.0,
    "smoothness_improvement": 146.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01822030544281006,
            "num_nodes_avg": 170.2,
            "path_length_avg": 176.9732648885206,
            "smoothness_avg": 0.0206878715229385,
            "success_improvement": 0.0,
            "time_improvement": 29.549854345661714,
            "length_improvement": 2.998149193762976,
            "smoothness_improvement": 223.81011376604008,
            "objective_score": 11.7828963887865
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04251394271850586,
            "num_nodes_avg": 364.0,
            "path_length_avg": 300.02220459425564,
            "smoothness_avg": 0.00744790461114152,
            "success_improvement": 0.0,
            "time_improvement": 74.12816075685653,
            "length_improvement": -0.1560475539045912,
            "smoothness_improvement": 91.63995015352765,
            "objective_score": 22.60301944548184
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027677249908447266,
            "num_nodes_avg": 270.3,
            "path_length_avg": 147.64239393076386,
            "smoothness_avg": 0.01750580743928164,
            "success_improvement": 0.0,
            "time_improvement": 43.38480326054779,
            "length_improvement": 1.9429519264856563,
            "smoothness_improvement": 122.67257848336763,
            "objective_score": 14.794575026472568
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bi-directional RRT* inspired planner integrating adaptive neighbor radius for rewiring, goal-biased sampling, and efficient tree management. It balances search speed and path quality by pruning excessive rewiring, ensuring valid tree connections, updating paths dynamically, and respecting a hard 30-second time limit with early termination returning the best path found. The planner switches tree roles each iteration to promote balanced growth, incorporates incremental rewiring to improve path smoothness and length while controlling computational load, and uses resolution-aware collision checks.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling points with a goal bias. For each new sample, it attempts to extend the active tree toward it, then rewires nearby nodes within an adaptively computed radius to optimize costs. It tries to connect the opposing tree to the new node and, if connected, updates the best path found. The adaptive neighbor radius shrinks logarithmically with tree size, balancing exploration and computational effort. The algorithm enforces collision checks on nodes and edges strictly, maintains consistent parent-child relationships, and terminates early upon hitting a time or iteration limit, returning the best solution obtained.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start tree root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15, gamma_rrt_star=40.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate      # Probability to sample goal directly\n        self.gamma_rrt_star = gamma_rrt_star          # Tunable parameter for adaptive radius\n        self.max_rewire_radius = max_rewire_radius    # Upper bound for rewiring radius\n\n    def plan(self, map):\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success = False\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree_nodes, point):\n            # Efficient linear search (could be improved with spatial DS if allowed)\n            min_node = None\n            min_dist = float(\"inf\")\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            # Adaptive neighborhood radius for rewiring: shrink logarithmically with node count\n            if n_nodes <= 1:\n                return self.max_rewire_radius\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(self.step_size * 2.0, min(self.max_rewire_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            near = []\n            r2 = radius * radius\n            for node in tree_nodes:\n                dx = sum((node.position[d] - pos[d]) ** 2 for d in range(dim))\n                if dx <= r2:\n                    near.append(node)\n            return near\n\n        def choose_parent(tree, new_pos, near_list):\n            min_cost = float(\"inf\")\n            best_parent = None\n            for node in near_list:\n                if not is_edge_in_obstacle(node.position, new_pos):\n                    cost = node.cost + dist(node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = node\n            if best_parent is None:\n                # Fallback to nearest without obstacle\n                nearest_node = nearest(tree, new_pos)\n                if not is_edge_in_obstacle(nearest_node.position, new_pos):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                else:\n                    return None, float(\"inf\")\n            return best_parent, min_cost\n\n        def rewire(tree, new_node, near_list):\n            new_cost = new_node.cost\n            new_pos = new_node.position\n            for node in near_list:\n                if node is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_pos, node.position):\n                    cost_through_new = new_cost + dist(new_pos, node.position)\n                    if cost_through_new + 1e-10 < node.cost:\n                        # Rewire node's parent to new_node\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        new_node.add_child(node)\n                        node.cost = cost_through_new\n                        edges.append((new_node, node))\n\n        def add_new_node(tree, new_pos):\n            n_tree = len(tree)\n            radius = adaptive_radius(n_tree)\n            near = near_nodes(tree, new_pos, radius)\n            parent, cost = choose_parent(tree, new_pos, near)\n            if parent is None:\n                return None\n            new_node = Node(new_pos, parent=None, cost=cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            rewire(tree, new_node, near)\n            return new_node\n\n        tree_active, tree_passive = tree_start, tree_goal\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_active = nearest(tree_active, sample)\n            if nearest_active is None:\n                # Should not happen, continue\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n            new_pos = steer(nearest_active.position, sample)\n            if is_in_obstacle(new_pos):\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n            if is_edge_in_obstacle(nearest_active.position, new_pos):\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n\n            new_node = add_new_node(tree_active, new_pos)\n            if new_node is None:\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n\n            # Try connect opposite tree to new_node\n            nearest_passive = nearest(tree_passive, new_node.position)\n            if nearest_passive is not None:\n                dist_to_new_node = dist(nearest_passive.position, new_node.position)\n                if dist_to_new_node <= self.step_size:\n                    if (not is_edge_in_obstacle(nearest_passive.position, new_node.position)\n                        and not is_in_obstacle(new_node.position)):\n                        # Direct connect possible\n                        connect_node = Node(new_node.position, parent=nearest_passive,\n                                           cost=nearest_passive.cost + dist_to_new_node)\n                        nearest_passive.add_child(connect_node)\n                        tree_passive.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((nearest_passive, connect_node))\n\n                        # Extract full path\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal[1:]\n\n                        total_cost = new_node.cost + dist_to_new_node + (connect_node.cost - nearest_passive.cost)\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_path = full_path\n                            success = True\n                        # Early stop on best found path\n                        break\n                else:\n                    # Attempt incremental connect from passive tree toward new_node\n                    direction = steer(nearest_passive.position, new_node.position)\n                    if (not is_in_obstacle(direction)\n                            and not is_edge_in_obstacle(nearest_passive.position, direction)):\n                        cost_to_direction = nearest_passive.cost + dist(nearest_passive.position, direction)\n                        intermediate_node = Node(direction, parent=nearest_passive, cost=cost_to_direction)\n                        nearest_passive.add_child(intermediate_node)\n                        tree_passive.append(intermediate_node)\n                        nodes.append(intermediate_node)\n                        edges.append((nearest_passive, intermediate_node))\n\n                        # Next step: check if now connectable\n                        dist_remaining = dist(intermediate_node.position, new_node.position)\n                        if dist_remaining <= self.step_size:\n                            if (not is_edge_in_obstacle(intermediate_node.position, new_node.position)\n                                    and not is_in_obstacle(new_node.position)):\n                                final_node = Node(new_node.position, parent=intermediate_node,\n                                                  cost=intermediate_node.cost + dist_remaining)\n                                intermediate_node.add_child(final_node)\n                                tree_passive.append(final_node)\n                                nodes.append(final_node)\n                                edges.append((intermediate_node, final_node))\n\n                                path_start = new_node.path_from_root()\n                                path_goal = final_node.path_from_root()\n                                path_goal.reverse()\n                                full_path = path_start + path_goal[1:]\n\n                                total_cost = new_node.cost + dist(intermediate_node.position, new_node.position) + (final_node.cost - intermediate_node.cost)\n                                if total_cost < best_cost:\n                                    best_cost = total_cost\n                                    best_path = full_path\n                                    success = True\n                                break\n\n            # Swap trees to balance growth\n            tree_active, tree_passive = tree_passive, tree_active\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -9.65559,
    "time_improvement": 9.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 214.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03486795425415039,
            "num_nodes_avg": 102.8,
            "path_length_avg": 172.09122046442786,
            "smoothness_avg": 0.02048854526192093,
            "success_improvement": 0.0,
            "time_improvement": -34.81949924407241,
            "length_improvement": 5.674075103552653,
            "smoothness_improvement": 220.69022493721135,
            "objective_score": -5.937953586404074
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06962933540344238,
            "num_nodes_avg": 288.9,
            "path_length_avg": 259.9262381247075,
            "smoothness_avg": 0.011646929676625886,
            "success_improvement": 0.0,
            "time_improvement": 57.62710167597247,
            "length_improvement": 13.229140152034688,
            "smoothness_improvement": 199.68388952394645,
            "objective_score": 26.224034041632287
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04681465625762939,
            "num_nodes_avg": 220.4,
            "path_length_avg": 134.74451092702418,
            "smoothness_avg": 0.025215939090186674,
            "success_improvement": 0.0,
            "time_improvement": 4.238282955034812,
            "length_improvement": 10.50911168638059,
            "smoothness_improvement": 220.74488398015987,
            "objective_score": 8.680676318239598
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius rewiring, goal-biased sampling, and efficient non-recursive cost updates. It balances exploration and exploitation by alternating tree expansions, adaptively rewiring local neighborhoods to improve path quality, and employs consistent edge and parent management. Early termination upon finding a path or passing the 30s time limit returns the best found path, enhancing planning efficiency and generating shorter, smoother trajectories.",
    "planning_mechanism": "The planner alternately grows trees from start and goal positions by sampling collision-free points (with goal bias), steering towards these samples by a set step size, then searches for and rewires nearby neighbors within an adaptive radius to minimize path costs. When the two trees successfully connect, a combined lowest-cost path is extracted by following parent pointers. The rewiring uses non-recursive cost propagation and constraints on rewiring radius reduce computation overhead. Trees swap each iteration to maintain balanced growth, and the process halts early when time expires or a valid path is found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True  # For collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.1, max_rewire_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n        success = False\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def sample_free():\n            # goal bias sampling in tree_a expansions only\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def dist_sq(p1, p2):\n            return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n        def dist(p1, p2):\n            return math.sqrt(dist_sq(p1, p2))\n\n        def nearest(tree, point):\n            # Return node in tree nearest to point (by Euclidean distance)\n            return min(tree, key=lambda n: dist_sq(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= r_sq]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def is_collision_free_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def try_rewire(new_node, nearby_nodes):\n            for near_node in nearby_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if is_collision_free_edge(new_node.position, near_node.position):\n                        # Update parent-child relations carefully\n                        old_parent = near_node.parent\n                        if old_parent:\n                            try:\n                                old_parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        new_node.children.append(near_node)\n                        prev_cost = near_node.cost\n                        near_node.cost = cost_through_new\n                        self._update_descendants_costs(near_node, prev_cost)\n                        if (near_node in nodes) and (near_node not in tree_a) and (near_node not in tree_b):\n                            pass  # Should not happen; they belong to a tree\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            rnd_point = sample_free()\n\n            # Alternate trees by parity: expand tree_a on even, tree_b on odd iteration\n            active_tree = tree_a if i % 2 == 0 else tree_b\n            passive_tree = tree_b if i % 2 == 0 else tree_a\n\n            nearest_node = nearest(active_tree, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or not is_collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring step with adaptive radius\n            n = len(active_tree)\n            dim = len(bounds)\n            gamma_rrt_star = 2 * (1 + 1 / dim) ** (1 / dim) * ( (math.prod(bounds)) / math.pi )**(1/dim)\n            radius = min(self.max_rewire_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / dim))\n            nearby = near_nodes(active_tree, new_node.position, radius)\n            # Choose best parent in neighborhood (could improve over nearest_node)\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for neighbor in nearby:\n                if neighbor == new_node:\n                    continue\n                c_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                if c_cost + 1e-7 < min_cost:\n                    if is_collision_free_edge(neighbor.position, new_node.position):\n                        min_cost = c_cost\n                        best_parent = neighbor\n            if best_parent != new_node.parent:\n                # update parent and costs\n                old_parent = new_node.parent\n                try:\n                    old_parent.children.remove(new_node)\n                except ValueError:\n                    pass\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                new_node.cost = min_cost\n\n            # rewire neighbors to new_node if beneficial\n            try_rewire(new_node, nearby)\n\n            # Try to connect passive tree to new_node to bridge trees\n            nearest_in_passive = nearest(passive_tree, new_node.position)\n            if dist(nearest_in_passive.position, new_node.position) <= self.step_size:\n                if is_collision_free_edge(nearest_in_passive.position, new_node.position):\n                    # Connect trees by attaching one root to the other\n                    # Decide direction - attach passive_tree node to new_node\n                    # Avoid duplicate nodes, merge by reparenting\n                    new_node_in_passive = Node(new_node.position, parent=nearest_in_passive,\n                                              cost=nearest_in_passive.cost + dist(nearest_in_passive.position, new_node.position))\n                    nearest_in_passive.children.append(new_node_in_passive)\n                    passive_tree.append(new_node_in_passive)\n                    nodes.append(new_node_in_passive)\n                    edges.append((nearest_in_passive, new_node_in_passive))\n\n                    # Form full path and check cost\n                    path_start = new_node.path_from_root()\n                    path_goal = new_node_in_passive.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    total_cost = 0.0\n                    for idx in range(len(full_path)-1):\n                        total_cost += dist(full_path[idx], full_path[idx+1])\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success = True\n                    break  # Stop planning once path found\n\n            # Swap trees each iteration for balanced growth\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _update_descendants_costs(self, node: Node, old_cost: float):\n        stack = [(node, old_cost)]\n        while stack:\n            current, prev_cost = stack.pop()\n            delta = current.cost - prev_cost\n            for c in current.children:\n                c_prev_cost = c.cost\n                c.cost += delta\n                stack.append((c, c_prev_cost))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 266.08313,
    "time_improvement": -922.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 161.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.044850277900695804,
            "num_nodes_avg": 184.8,
            "path_length_avg": 165.39109260039407,
            "smoothness_avg": 0.015151994485829,
            "success_improvement": 0.0,
            "time_improvement": -73.41688484088648,
            "length_improvement": 9.34652135614973,
            "smoothness_improvement": 137.16161678588193,
            "objective_score": -15.7313445546467
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.36037731170654297,
            "num_nodes_avg": 603.2,
            "path_length_avg": 246.47629419518088,
            "smoothness_avg": 0.010630587829373508,
            "success_improvement": 0.0,
            "time_improvement": -119.30743843453062,
            "length_improvement": 17.719118570881385,
            "smoothness_improvement": 173.53268175269952,
            "objective_score": -24.29309697906686
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.3065813541412354,
            "num_nodes_avg": 765.8,
            "path_length_avg": 118.65967802597613,
            "smoothness_avg": 0.021433167364217867,
            "success_improvement": 0.0,
            "time_improvement": -2572.6774034810846,
            "length_improvement": 21.19189182182155,
            "smoothness_improvement": 172.6283068410012,
            "objective_score": -758.2249444170274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified and robust bidirectional RRT planner using fixed-step extension and goal-biased sampling that grows two trees from start and goal. It efficiently samples collision-free points within bounds, extends nearest nodes in the active tree towards samples while checking node and edge collisions, and attempts connecting opposite trees to find a feasible path. Planning halts on success or after a hard 30-second limit, returning the best found path. This design balances simplicity, efficiency, and path quality without complex rewiring or heavy neighbor searches, promoting generalizability and stable performance.",
    "planning_mechanism": "The planner alternates growth from the start and goal trees by sampling mostly random points with a small goal bias. Each iteration extends the active tree's nearest node toward the sample by a fixed step size, verifying node and edge collision. After adding a new node, it tries to connect the other tree within one step. If successful, it merges their paths. Search terminates upon success or time limit, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...], resolution=1.0) -> bool:\n            distance = math.dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(len(from_p)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                return None\n            new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n            return new_node\n\n        def connect(tree: List[Node], node: Node) -> Optional[Node]:\n            near_node = nearest(tree, node.position)\n            dist = math.dist(near_node.position, node.position)\n            if dist <= self.step_size:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(near_node.position, node.position):\n                    return None\n                new_cost = near_node.cost + dist\n                new_node = Node(node.position, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return new_node\n            else:\n                new_pos = steer(near_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                    return None\n                new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                new_node = Node(new_pos, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return None\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                # Remove duplicate connection node from goal path start\n                best_path = path_from_start + path_from_goal[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -25.31044,
    "time_improvement": 89.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 69.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004116058349609375,
            "num_nodes_avg": 100.0,
            "path_length_avg": 186.50859214468096,
            "smoothness_avg": 0.01083676150431979,
            "success_improvement": 0.0,
            "time_improvement": 84.08495888491464,
            "length_improvement": -2.228314772268034,
            "smoothness_improvement": 69.61884994686052,
            "objective_score": 24.236593051847876
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.012918996810913085,
            "num_nodes_avg": 290.6,
            "path_length_avg": 305.74548850411804,
            "smoothness_avg": 0.006610629509046964,
            "success_improvement": 0.0,
            "time_improvement": 92.13815075003298,
            "length_improvement": -2.0666444586099937,
            "smoothness_improvement": 70.09625871175474,
            "objective_score": 26.751939843402667
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.004724693298339844,
            "num_nodes_avg": 160.3,
            "path_length_avg": 156.8139079605709,
            "smoothness_avg": 0.013068898818260644,
            "success_improvement": 0.0,
            "time_improvement": 90.33540393269195,
            "length_improvement": -4.1483309915455795,
            "smoothness_improvement": 66.23542832250818,
            "objective_score": 24.942799726492776
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that alternates growth from start and goal trees by sampling collision-free points and extending nearest nodes by a fixed step. It attempts direct connections of the new node to the opposite tree within one step. The planner enforces collision checks on nodes and edges and terminates early upon finding a feasible path or after a 30-second time limit. This design avoids complex rewiring, focusing on straightforward, fast exploration to improve generality and efficiency.",
    "planning_mechanism": "The algorithm samples mostly random points with a small goal bias, extends the active tree toward the sample by a fixed step size if collision-free, then tries to connect the new node to the opposite tree in one step. Trees alternate growth each iteration until success or time runs out, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            px, py = pos[0], pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...], resolution=1.0) -> bool:\n            dist = math.dist(from_p, to_p)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(len(from_p)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                return None\n            new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n            return new_node\n\n        def connect(tree: List[Node], node: Node) -> Optional[Node]:\n            near_node = nearest(tree, node.position)\n            dist = math.dist(near_node.position, node.position)\n            if dist <= self.step_size:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(near_node.position, node.position):\n                    return None\n                new_cost = near_node.cost + dist\n                new_node = Node(node.position, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return new_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree = start_tree\n        other_tree = goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node:\n                connection = connect(other_tree, new_node)\n                if connection:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connection.path_from_root()\n                    best_path = path_start + path_goal[-2::-1]\n                    break\n\n            active_tree, other_tree = other_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": -21.72796,
    "time_improvement": 83.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006364774703979492,
            "num_nodes_avg": 131.5,
            "path_length_avg": 189.10730837599175,
            "smoothness_avg": 0.010794545847197318,
            "success_improvement": 0.0,
            "time_improvement": 75.39013237951252,
            "length_improvement": -3.6527123179433465,
            "smoothness_improvement": 68.95808324012714,
            "objective_score": 20.770202739288383
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014291024208068848,
            "num_nodes_avg": 347.4,
            "path_length_avg": 312.3159020283758,
            "smoothness_avg": 0.006454215274954106,
            "success_improvement": 0.0,
            "time_improvement": 91.3032041422475,
            "length_improvement": -4.26003761187454,
            "smoothness_improvement": 66.07160780792645,
            "objective_score": 25.165296714589154
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009338307380676269,
            "num_nodes_avg": 257.7,
            "path_length_avg": 163.94724797382776,
            "smoothness_avg": 0.012744673409599772,
            "success_improvement": 0.0,
            "time_improvement": 80.89802594841237,
            "length_improvement": -8.885955775201321,
            "smoothness_improvement": 62.11130505617214,
            "objective_score": 19.24839084468378
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An advanced bidirectional RRT* planner with adaptive fixed-radius rewiring, recursive cost propagation, goal-biased and informed sampling, and post-planning shortcut path smoothing to ensure efficient exploration, improved path length, and smoothness within a hard 30-second time limit.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal with a fixed radius for neighbor rewiring and goal bias sampling, connects them upon feasible edges, then refines the best path through informed sampling and shortcut smoothing before termination or timeout, maintaining consistent cost propagation and collision-free constraints throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n        # Fixed radius for neighbor search (tuned empirically)\n        self.fixed_radius = 15.0\n\n        # Probability of sampling the goal (goal bias)\n        self.goal_sample_rate = 0.2\n\n        # Small tolerance for cost improvement\n        self.improve_tol = 1e-6\n\n        # Resolution for collision checking along edges\n        self.check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            # fallback if math.dist unavailable\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        steps = max(1, int(dist / self.check_resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except:\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        res = []\n        r2 = radius * radius\n        for node in tree:\n            d = 0.0\n            if hasattr(math, 'dist'):\n                d = math.dist(node.position, point)\n            else:\n                d = sum((a - b) ** 2 for a,b in zip(node.position, point)) ** 0.5\n            if d <= radius:\n                res.append(node)\n        return res\n\n    def _update_costs_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node position\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) * 0.5\n\n        while True:\n            # Sample unit ball in dim dimension\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = sum(x*x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            # Scale sample to ellipsoid axes:\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            # Rotation aligns first axis with a1 vector (approximate)\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _try_shortcut(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        smoothed_path = [path[0]]\n        idx = 0\n        n = len(path)\n        while idx < n - 1:\n            next_idx = n - 1\n            while next_idx > idx + 1:\n                if not self._is_edge_in_obstacle(path[idx], path[next_idx], obstacles, is_3d):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Alternate expansions\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expanding_start = (i % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n            sample_goal = goal_pos if expanding_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = self.fixed_radius\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edge and parent-child relations\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    # Recursively update costs of descendants\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to opposite tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by adding a connecting node\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expanding_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expanding_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Refinement phase if solution found\n        if found_solution and best_goal_node is not None:\n            # Build a tree rooted at start for informed RRT*\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Copy best path into tree\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                near_nodes = self._near(tree, new_pos, self.fixed_radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n            # Post-process path shortcutting for smoothness\n            if len(extracted_path) > 2:\n                extracted_path = self._try_shortcut(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -31.02063,
    "time_improvement": 46.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1385.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02439420223236084,
            "num_nodes_avg": 210.6,
            "path_length_avg": 166.9287719242713,
            "smoothness_avg": 0.04447081982954099,
            "success_improvement": 0.0,
            "time_improvement": 5.678030163354109,
            "length_improvement": 8.503694952644477,
            "smoothness_improvement": 596.0649002632317,
            "objective_score": 9.785950521909077
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0319866418838501,
            "num_nodes_avg": 379.0,
            "path_length_avg": 229.74939855856366,
            "smoothness_avg": 0.09565426382163486,
            "success_improvement": 0.0,
            "time_improvement": 80.53454457926001,
            "length_improvement": 23.303037791380007,
            "smoothness_improvement": 2361.2531051120586,
            "objective_score": 49.9484515741663
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024246406555175782,
            "num_nodes_avg": 322.2,
            "path_length_avg": 119.89049793872327,
            "smoothness_avg": 0.1019188821406457,
            "success_improvement": 0.0,
            "time_improvement": 50.40276465737084,
            "length_improvement": 20.374439841120928,
            "smoothness_improvement": 1196.4006579596712,
            "objective_score": 33.32749659168216
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighbor radius, goal-biased sampling, non-recursive rewiring, and early termination upon finding the first feasible path within a 30-second time limit. The planner balances exploration and exploitation by gradually shrinking the rewiring radius logarithmically, incorporates goal bias to efficiently connect trees, and manages parent-child and edge relationships consistently to ensure path quality and smoothness while maintaining efficiency.",
    "planning_mechanism": "The planner alternates growth between two trees from start and goal by sampling with a goal bias, steering with fixed step size, verifying node and edge collisions strictly within map bounds. It selects the best parent within an adaptive shrinking radius to minimize cost, performs local rewiring without recursive cost updates to improve nearby nodes' paths, attempts to connect both trees if close, and terminates immediately upon the first successful connection or on timeout, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost to reach this node from root\n        self.children = []                # List of child Node references\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_radius = 30.0       # Initial neighbor radius for rewiring\n        self.time_limit = 30.0           # seconds\n        self.goal_sample_rate = 0.1      # 10% goal bias sampling\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            dist_sq = 0.0\n            for a, b in zip(node.position, point):\n                diff = a - b\n                dist_sq += diff * diff\n                if dist_sq > radius_sq:\n                    break\n            else:\n                result.append(node)\n        return result\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal_point):\n        dim = len(bounds)\n        if random.random() < self.goal_sample_rate:\n            # Goal biased sampling\n            if not self._is_in_obstacle(goal_point, obstacles, is_3d):\n                return goal_point\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success_state = False\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n\n        for iter_count in range(1, self.max_iter + 1):\n            if time_exceeded():\n                break\n\n            # Adaptive rewiring radius shrinks logarithmically (avoids radius going below step_size)\n            radius = max(\n                self.step_size,\n                self.initial_radius * (math.log(iter_count + 1) / (iter_count + 1))**0.5\n            )\n\n            sample = self._sample_free(bounds, obstacles, is_3d, goal_pos)\n            nearest_node = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            # Node and edge collision checking\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            # Find best parent within radius that yields minimal cost and collision free edge\n            near_nodes = self._near(active_tree, new_pos, radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                candidate_cost = near.cost + self._dist(near.position, new_pos)\n                if candidate_cost + 1e-8 < min_cost:  # small epsilon to avoid unnecessary rewire\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring: try to improve cost of near nodes by rewiring through new_node\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect passive tree to new_node if close enough\n            nearest_other = self._nearest(passive_tree, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Attach connection node to passive tree\n                    connect_cost = nearest_other.cost + dist_to_other\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=connect_cost)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Reconstruct path from start to goal\n                    if active_tree is tree_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal[1:]\n                        total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    else:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        full_path = path_start + path_goal[1:]\n                        total_cost = connect_cost + new_node.cost\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = full_path\n                        success_state = True\n\n                    break\n\n            # Swap trees for next iteration\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -18.03939,
    "time_improvement": 59.0,
    "length_improvement": 0.0,
    "smoothness_improvement": 84.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007963728904724122,
            "num_nodes_avg": 119.6,
            "path_length_avg": 191.10792290798537,
            "smoothness_avg": 0.01267300129578007,
            "success_improvement": 0.0,
            "time_improvement": 69.20765883697776,
            "length_improvement": -4.749280844694997,
            "smoothness_improvement": 98.35999014174256,
            "objective_score": 18.404529094985044
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024151158332824708,
            "num_nodes_avg": 314.9,
            "path_length_avg": 295.5422781944346,
            "smoothness_avg": 0.0067351154495381305,
            "success_improvement": 0.0,
            "time_improvement": 85.30282429790822,
            "length_improvement": 1.33948082588741,
            "smoothness_improvement": 73.29937162419117,
            "objective_score": 26.761032643025867
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03830699920654297,
            "num_nodes_avg": 385.2,
            "path_length_avg": 145.3956507678614,
            "smoothness_avg": 0.014138205528467762,
            "success_improvement": 0.0,
            "time_improvement": 21.641120279274862,
            "length_improvement": 3.4351317568728397,
            "smoothness_improvement": 79.83693074833155,
            "objective_score": 8.95259979164782
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An improved bidirectional RRT* planner that employs a spatial grid-based nearest neighbor approximation to reduce neighbor search complexity, dynamically adaptively shrinks the rewiring radius logarithmically, includes goal-biased sampling, and enforces early termination once a feasible path is found or upon 30-second timeout. The planner carefully syncs parent-child relations and edge sets to enhance path quality while maintaining efficiency.",
    "planning_mechanism": "The planner maintains two trees grown from start and goal, alternates expansions with goal-biased sampling, steers with a fixed step size while ensuring node and edge collision freedom, and uses a lightweight spatial hash grid for near neighbor queries within an adaptive radius. Upon adding a new node, it rewires nearby nodes locally without recursive overhead. The planner attempts to connect the two trees when nodes are sufficiently close. It updates and stores best found path cost and path throughout planning, returning the best feasible path found or signaling failure/time-out.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []              # List of child nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_radius = 30.0\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.1\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    # --- Spatial grid approximation for near-node search ---\n    def _grid_coords(self, pos, resolution):\n        # Returns integer tuple grid coordinates for spatial hashing\n        return tuple(int(p // resolution) for p in pos)\n\n    def _insert_node_grid(self, grid, node, resolution):\n        key = self._grid_coords(node.position, resolution)\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(node)\n\n    def _nearby_nodes_grid(self, grid, point, radius, resolution):\n        # Returns nodes in neighboring grid cells within radius of point\n        px = self._grid_coords(point, resolution)\n        neigh_nodes = []\n        r_cells = int(math.ceil(radius / resolution))\n        for dx in range(-r_cells, r_cells+1):\n            for dy in range(-r_cells, r_cells+1):\n                # Support for 2D or 3D\n                if len(px) == 3:\n                    for dz in range(-r_cells, r_cells+1):\n                        neighbor_key = (px[0]+dx, px[1]+dy, px[2]+dz)\n                        if neighbor_key in grid:\n                            for node in grid[neighbor_key]:\n                                if self._dist(node.position, point) <= radius:\n                                    neigh_nodes.append(node)\n                else:\n                    neighbor_key = (px[0]+dx, px[1]+dy)\n                    if neighbor_key in grid:\n                        for node in grid[neighbor_key]:\n                            if self._dist(node.position, point) <= radius:\n                                neigh_nodes.append(node)\n        return neigh_nodes\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal_pos):\n        dim = len(bounds)\n        if random.random() < self.goal_sample_rate:\n            if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n        while True:\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = []\n        tree_goal = []\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n\n        tree_start.append(start_root)\n        tree_goal.append(goal_root)\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial grid resolution roughly step_size\n        grid_res = max(self.step_size, 1.0)\n        grid_start = {}\n        grid_goal = {}\n\n        self._insert_node_grid(grid_start, start_root, grid_res)\n        self._insert_node_grid(grid_goal, goal_root, grid_res)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def time_out():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        active_tree = tree_start\n        passive_tree = tree_goal\n        active_grid = grid_start\n        passive_grid = grid_goal\n\n        for it in range(1, self.max_iter+1):\n            if time_out():\n                break\n\n            # Adaptive radius for rewiring - logarithmically shrinking\n            radius = max(self.step_size, self.initial_radius * (math.log(it+1)/(it+1))**0.5)\n\n            sample = self._sample_free(bounds, obstacles, is_3d, goal)\n            neigh_nodes = []\n\n            # Nearest in active tree\n            nearest = None\n            min_dist = float('inf')\n            # Using spatial grid to query neighbors - first find nearest to sample\n            possible_nodes = self._nearby_nodes_grid(active_grid, sample, radius*4, grid_res)\n            if possible_nodes:\n                for n in possible_nodes:\n                    d = self._dist(n.position, sample)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest = n\n            else:\n                # if no neighbors nearby, linear search fallback\n                nearest = self._nearest(active_tree, sample)\n            if nearest is None:\n                # Should not happen but safe fallback\n                nearest = self._nearest(active_tree, sample)\n\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                active_grid, passive_grid = passive_grid, active_grid\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                active_tree, passive_tree = passive_tree, active_tree\n                active_grid, passive_grid = passive_grid, active_grid\n                continue\n\n            # Find best parent within radius using spatial grid near query\n            near_nodes = self._nearby_nodes_grid(active_grid, new_pos, radius, grid_res)\n            if not near_nodes:\n                near_nodes = [nearest]\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                candidate_cost = near.cost + self._dist(near.position, new_pos)\n                if candidate_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._insert_node_grid(active_grid, new_node, grid_res)\n\n            # Local rewiring\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + 1e-10 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connecting passive tree to new node\n            nearest_other = None\n            min_dist_other = float('inf')\n            possible_other_nodes = self._nearby_nodes_grid(passive_grid, new_node.position, self.step_size * 2, grid_res)\n            if possible_other_nodes:\n                for n in possible_other_nodes:\n                    d = self._dist(n.position, new_node.position)\n                    if d < min_dist_other:\n                        min_dist_other = d\n                        nearest_other = n\n            if nearest_other is None and passive_tree:\n                nearest_other = self._nearest(passive_tree, new_node.position)\n                min_dist_other = self._dist(nearest_other.position, new_node.position)\n\n            if nearest_other and min_dist_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connect trees by attaching one node to the other tree\n                    cost_connect = nearest_other.cost + min_dist_other\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=cost_connect)\n                    nearest_other.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n                    self._insert_node_grid(passive_grid, connect_node, grid_res)\n\n                    # Build combined path depending on which tree is active\n                    if active_tree is tree_start:\n                        path_from_start = new_node.path_from_root()\n                        path_from_goal = connect_node.path_from_root()\n                        path_from_goal.reverse()\n                    else:\n                        path_from_start = connect_node.path_from_root()\n                        path_from_goal = new_node.path_from_root()\n                        path_from_goal.reverse()\n\n                    combined_path = path_from_start + path_from_goal[1:]\n                    total_cost = new_node.cost + nearest_other.cost + min_dist_other\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success = True\n\n                    # Early termination on first feasible path\n                    break\n\n            # Swap trees and grids for next iteration\n            active_tree, passive_tree = passive_tree, active_tree\n            active_grid, passive_grid = passive_grid, active_grid\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -15.68121,
    "time_improvement": 47.0,
    "length_improvement": 2.0,
    "smoothness_improvement": 88.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018910145759582518,
            "num_nodes_avg": 147.1,
            "path_length_avg": 180.83654256920724,
            "smoothness_avg": 0.012996998161630297,
            "success_improvement": 0.0,
            "time_improvement": 26.882536229211993,
            "length_improvement": 0.8806254794262817,
            "smoothness_improvement": 103.43124466275384,
            "objective_score": 9.110292379733135
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030042576789855956,
            "num_nodes_avg": 298.7,
            "path_length_avg": 290.85312814645215,
            "smoothness_avg": 0.00703705217309898,
            "success_improvement": 0.0,
            "time_improvement": 81.71760445030155,
            "length_improvement": 2.904854081604476,
            "smoothness_improvement": 81.06842099764334,
            "objective_score": 26.663535889041366
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03232927322387695,
            "num_nodes_avg": 333.8,
            "path_length_avg": 148.797357053486,
            "smoothness_avg": 0.01420791474786599,
            "success_improvement": 0.0,
            "time_improvement": 33.868857272027206,
            "length_improvement": 1.1758804138074626,
            "smoothness_improvement": 80.72362687367767,
            "objective_score": 11.269803564261027
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner combining adaptive rewiring with goal bias and early stopping. It uses efficient parent-child and cost updates without recursion, a carefully tuned rewiring radius depending on iteration count and map size to balance exploration and refinement, and a slight increase in step size for faster exploration. The planner alternates growth of start and goal trees, performs safe edge and node collision checks, and returns the best found path within a hard 30-second limit while aiming for smooth and shorter trajectories.",
    "planning_mechanism": "The planner samples points with goal bias, extends the active tree towards the sample, rewires neighbors within an adaptive radius to minimize cost using consistent parent-child updates and incremental cost propagation, attempts to connect the two trees, and swaps growth trees each iteration. Early termination occurs upon connection or time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, goal_sample_rate: float = 0.12, max_rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_rewire_radius = max_rewire_radius\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = math.inf\n        success = False\n\n        start_time = time.monotonic()\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) >= self.time_limit\n\n        def dist_sq(p1, p2):\n            return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n        def dist(p1, p2):\n            return math.sqrt(dist_sq(p1, p2))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist_sq(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= r_sq]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def is_collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def update_descendants_costs(node, prev_cost):\n            stack = [(node, prev_cost)]\n            while stack:\n                current, old_c = stack.pop()\n                delta = current.cost - old_c\n                for c in current.children:\n                    c_prev = c.cost\n                    c.cost += delta\n                    stack.append((c, c_prev))\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            # Alternate trees to balance exploration\n            active_tree = tree_a if i % 2 == 0 else tree_b\n            passive_tree = tree_b if i % 2 == 0 else tree_a\n\n            rnd_point = sample_free()\n            nearest_node = nearest(active_tree, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius\n            n = len(active_tree)\n            volume = 1.0\n            for b in bounds:\n                volume *= b\n            gamma = 2.0 * ((1 + 1/dim) ** (1/dim)) * (volume / math.pi) ** (1/dim)\n            radius = min(self.max_rewire_radius, gamma * ((math.log(n) / n) ** (1/dim)))\n\n            neighbors = near_nodes(active_tree, new_pos, radius)\n\n            # Choose better parent if any neighbor offers lower cost path\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for neighbor in neighbors:\n                if neighbor == new_node:\n                    continue\n                candidate_cost = neighbor.cost + dist(neighbor.position, new_node.position)\n                if candidate_cost + 1e-6 < min_cost and is_collision_free_edge(neighbor.position, new_node.position):\n                    min_cost = candidate_cost\n                    best_parent = neighbor\n            if best_parent != new_node.parent:\n                # Update parent-child links cleanly\n                old_parent = new_node.parent\n                old_parent.remove_child(new_node)\n                new_node.parent = best_parent\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n            # Rewire neighbors to new_node if it offers lower cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        old_parent.remove_child(neighbor)\n                        try:\n                            edges.remove((old_parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n                    # Incremental cost update to descendants\n                    update_descendants_costs(neighbor, neighbor.cost - (cost_through_new))\n\n            # Try connecting to passive tree\n            nearest_in_passive = nearest(passive_tree, new_node.position)\n            d_to_passive = dist(nearest_in_passive.position, new_node.position)\n            if d_to_passive <= self.step_size:\n                if is_collision_free_edge(nearest_in_passive.position, new_node.position):\n                    connect_node = Node(new_node.position, parent=nearest_in_passive,\n                                        cost=nearest_in_passive.cost + d_to_passive)\n                    nearest_in_passive.add_child(connect_node)\n                    passive_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_in_passive, connect_node))\n\n                    # Construct path from start_root to new_node and from goal_root to connect_node\n                    if i % 2 == 0:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                        path_goal.reverse()\n                        candidate_path = path_start + path_goal[1:]\n                    else:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                        path_goal.reverse()\n                        candidate_path = path_start + path_goal[1:]\n\n                    # Calculate total cost\n                    cost_sum = 0.0\n                    for idx in range(len(candidate_path) - 1):\n                        cost_sum += dist(candidate_path[idx], candidate_path[idx+1])\n\n                    if cost_sum < best_cost:\n                        best_cost = cost_sum\n                        best_path = candidate_path\n                        success = True\n\n                    if success:\n                        break  # Early termination on path found\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 31.44218,
    "time_improvement": -64.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 205.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.034679102897644046,
            "num_nodes_avg": 143.4,
            "path_length_avg": 173.37901376555553,
            "smoothness_avg": 0.01870726879828111,
            "success_improvement": -9.999999999999998,
            "time_improvement": -34.08929164054723,
            "length_improvement": 4.9682151888138595,
            "smoothness_improvement": 192.80938017749628,
            "objective_score": -56.28181147798836
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0913118600845337,
            "num_nodes_avg": 306.0,
            "path_length_avg": 277.43970691213156,
            "smoothness_avg": 0.012460771818826022,
            "success_improvement": 0.0,
            "time_improvement": 44.43221178657855,
            "length_improvement": 7.3826401735439156,
            "smoothness_improvement": 220.6246340295571,
            "objective_score": 18.8623708102477
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.14760642051696776,
            "num_nodes_avg": 366.4,
            "path_length_avg": 143.86604507180948,
            "smoothness_avg": 0.023635165125109,
            "success_improvement": 0.0,
            "time_improvement": -201.93630383139725,
            "length_improvement": 4.451023028194422,
            "smoothness_improvement": 200.63755582496873,
            "objective_score": -56.90708955337767
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified and robust bidirectional RRT planner that alternates growth from start and goal trees by sampling collision-free points within bounds, extending nearest nodes toward samples using fixed step size, and attempting direct one-step connections between trees. The planner enforces strict collision checks for both nodes and edges, switches active trees every iteration, and halts early upon finding a valid path or exceeding a 30-second time limit, thereby improving generalization and planning efficiency by avoiding complex rewiring or costly local optimizations.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples free states uniformly, steers nearest nodes toward samples with fixed increments, verifies collisions on nodes and edges, attempts to connect trees directly when nodes are close, alternates tree expansions, tracks the best path, and terminates early when a feasible path is found or time expires.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Optional[Node]\n        self.cost = cost                # float\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def is_in_obstacle(pos):\n            px, py = pos[0], pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            dist = math.dist(fr, to)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[d] + (to[d] - fr[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def extend(tree, sample):\n            near = nearest(tree, sample)\n            new_pos = steer(near.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(near.position, new_pos):\n                return None\n            new_cost = near.cost + math.dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            return new_node\n\n        def connect(tree, node):\n            near = nearest(tree, node.position)\n            dist = math.dist(near.position, node.position)\n            if dist <= self.step_size:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(near.position, node.position):\n                    return None\n                new_cost = near.cost + dist\n                new_node = Node(node.position, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near, new_node))\n                return new_node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n        success = False\n        best_path = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree = start_tree\n        other_tree = goal_tree\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node is not None:\n                connection = connect(other_tree, new_node)\n                if connection is not None:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connection.path_from_root()\n                    best_path = path_start + path_goal[-2::-1]\n                    break\n\n            active_tree, other_tree = other_tree, active_tree\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": -23.25332,
    "time_improvement": 84.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 68.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006284022331237793,
            "num_nodes_avg": 128.1,
            "path_length_avg": 193.58996454090305,
            "smoothness_avg": 0.010524660422986403,
            "success_improvement": 0.0,
            "time_improvement": 75.7023673439286,
            "length_improvement": -6.109727194163726,
            "smoothness_improvement": 64.73379028564733,
            "objective_score": 19.368542838108578
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009687161445617676,
            "num_nodes_avg": 288.6,
            "path_length_avg": 301.0566454403593,
            "smoothness_avg": 0.00668138620294573,
            "success_improvement": 0.0,
            "time_improvement": 94.1048825957442,
            "length_improvement": -0.5013736830628492,
            "smoothness_improvement": 71.91687940975662,
            "objective_score": 28.290224965934335
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009398484230041504,
            "num_nodes_avg": 256.6,
            "path_length_avg": 156.77419757158654,
            "smoothness_avg": 0.01323720290565943,
            "success_improvement": 0.0,
            "time_improvement": 80.77493119813036,
            "length_improvement": -4.121957241987688,
            "smoothness_improvement": 68.37624389130525,
            "objective_score": 22.101186233703018
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An adaptive bidirectional informed RRT* planner with efficient linear neighbor queries, non-recursive rewiring, and a smooth transition from bidirectional search to single-tree refinement using ellipsoidal sampling. The planner employs goal biasing and adaptive neighborhood radii to improve planning time, while maintaining smooth, near-optimal paths under a strict 30-second time constraint. It tracks best paths incrementally and terminates early for efficiency, preserving coherent parent-child relationships and minimizing redundant calculations.",
    "planning_mechanism": "The planner alternates tree expansions from start and goal, samples with goal bias, connects trees upon proximity, and rewires nodes within an adaptive radius. Once a solution is found, it switches to single-tree informed refinement within an ellipsoid defined by best cost, iteratively improving the path while respecting collision constraints and time limits, ultimately returning the best feasible path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 45.0\n        self.improve_tol = 1e-5\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = 0.0\n        length = 0.0\n        vec = []\n        for d in range(len(from_pos)):\n            v = to_pos[d] - from_pos[d]\n            vec.append(v)\n            length += v * v\n        length = length ** 0.5\n        steps = max(1, int(length / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + vec[d] * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist_sq = sum((to_pos[d] - from_pos[d]) ** 2 for d in range(len(from_pos)))\n        if dist_sq <= self.step_size * self.step_size:\n            return to_pos\n        dist = dist_sq ** 0.5\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1))) ** 0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float(\"inf\")\n        for node in tree:\n            dx = node.position\n            dist_sq = 0\n            for d in range(len(point)):\n                diff = dx[d] - point[d]\n                dist_sq += diff * diff\n            if dist_sq < best_dist_sq:\n                best_dist_sq = dist_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        near_nodes = []\n        for node in tree:\n            dist_sq = 0\n            for d in range(len(point)):\n                diff = node.position[d] - point[d]\n                dist_sq += diff * diff\n                if dist_sq > radius_sq:\n                    break\n            if dist_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best * 0.5\n        val = c_best * c_best - c_min * c_min\n        c2 = (val if val > 0 else 0) ** 0.5 * 0.5\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = sum(x * x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        time_limit = self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        def time_exceeded():\n            return time.monotonic() - time_start > time_limit\n\n        def rewire(tree, new_node, near_nodes):\n            improved = False\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                cost_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_new + self.improve_tol < near_node.cost and edge_clear:\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    improved = True\n            return improved\n\n        # Phase 1: Bidirectional RRT* search\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree_a, new_node, near_nodes)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n                break  # early termination after first connection\n\n        # Phase 2: informed refinement if solution found\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children = []\n            start_root.cost = 0.0\n            prev = start_root\n            for p in best_path[1:]:\n                node = Node(p, parent=prev, cost=prev.cost + self._dist(prev.position, p))\n                prev.add_child(node)\n                tree.append(node)\n                nodes.append(node)\n                edges.append((prev, node))\n                prev = node\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            max_no_improve = 150\n            max_iters_refine = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(max_iters_refine):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 20)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = rewire(tree, new_node, near_nodes)\n\n                dist_to_goal = self._dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += rewired + 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 68.72384,
    "time_improvement": -146.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 260.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11298470497131348,
            "num_nodes_avg": 143.0,
            "path_length_avg": 167.79362404648546,
            "smoothness_avg": 0.023794795928145977,
            "success_improvement": 0.0,
            "time_improvement": -336.8636380397507,
            "length_improvement": 8.029655800000029,
            "smoothness_improvement": 272.4402275018692,
            "objective_score": -94.87909679441584
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.08934128284454346,
            "num_nodes_avg": 170.7,
            "path_length_avg": 257.4423562161695,
            "smoothness_avg": 0.011958196638262633,
            "success_improvement": -9.999999999999998,
            "time_improvement": 45.63140561122076,
            "length_improvement": 14.058331427681273,
            "smoothness_improvement": 207.6930126433903,
            "objective_score": -26.83711439680805
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.12108435630798339,
            "num_nodes_avg": 167.1,
            "path_length_avg": 129.5994579466017,
            "smoothness_avg": 0.03135553913517518,
            "success_improvement": -9.999999999999998,
            "time_improvement": -147.68409712390385,
            "length_improvement": 13.926210894881999,
            "smoothness_improvement": 298.84014337427845,
            "objective_score": -84.45530188337057
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved bidirectional RRT* planner with squared-distance neighbor searches, non-recursive rewiring, efficient early connection of start and goal trees without node duplication, adaptive neighbor radius, and goal biasing. The planner employs a dynamic time check to enforce a strict 30-second limit, maintains consistent parent-child and edge relationships, and incrementally tracks and updates the best path for early termination and reduced planning time while preserving high-quality, smooth, and short paths.",
    "planning_mechanism": "The planner alternates expansions between start and goal trees using goal-biased random sampling within map bounds. It uses squared Euclidean distances for nearest and near neighbor searches to speed up queries, and rewires local neighbors non-recursively to optimize paths. When trees come close, they connect directly without redundant node insertion. It adapts neighbor radius based on node count to balance exploration and optimization. Early termination occurs on timeout or finding a valid, improved path. Final path extraction respects coherent parent-child relations, returning the best feasible path discovered.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        vec = [to_pos[d] - from_pos[d] for d in range(len(from_pos))]\n        length_sq = sum(v*v for v in vec)\n        length = length_sq ** 0.5\n        steps = max(1, int(length / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + vec[d] * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist_sq = sum((to_pos[d] - from_pos[d])**2 for d in range(len(from_pos)))\n        if dist_sq <= self.step_size * self.step_size:\n            return to_pos\n        dist = dist_sq ** 0.5\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d])**2 for d in range(len(p1)))\n\n    def _dist(self, p1, p2):\n        return self._dist_sq(p1, p2)**0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        import random\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float(\"inf\")\n        for node in tree:\n            d_sq = 0\n            p = node.position\n            for i in range(len(point)):\n                diff = p[i] - point[i]\n                d_sq += diff*diff\n                if d_sq > best_dist_sq:\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        near_nodes = []\n        for node in tree:\n            d_sq = 0\n            p = node.position\n            for i in range(len(point)):\n                diff = p[i] - point[i]\n                d_sq += diff*diff\n                if d_sq > radius_sq:\n                    break\n            if d_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _rewire(self, tree, new_node, near_nodes, obstacles, is_3d):\n        improved = False\n        to_process = near_nodes[:]\n        for near_node in to_process:\n            if near_node is new_node.parent:\n                continue\n            edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n            if not edge_clear:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n            if cost_through_new + self.improve_tol < near_node.cost:\n                if near_node.parent:\n                    try:\n                        near_node.parent.remove_child(near_node)\n                    except Exception:\n                        pass\n                near_node.parent = new_node\n                near_node.cost = cost_through_new\n                new_node.add_child(near_node)\n                improved = True\n        return improved\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicating connecting node\n        return path_start + path_goal[1:]\n\n    def plan(self, map):\n        import time\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = self.time_limit\n\n        def time_exceeded():\n            return (time.monotonic() - start_time) > time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for iter_num in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (iter_num % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)), self.step_size * 20)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                d = self._dist(near_node.position, new_pos)\n                if near_node.cost + d < min_cost:\n                    if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        continue\n                    min_cost = near_node.cost + d\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            self._rewire(tree_a, new_node, near_nodes, obstacles, is_3d)\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Link existing node directly - no duplicate node creation\n                # Reparent new_node to nearest_other for connection\n                # Or create minimal connection node without duplicating position (direct edge)\n                # To keep consistency, we logically 'connect' the two trees:\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = self._build_path(new_node, nearest_other)\n                    best_goal_node = nearest_other\n                    found_solution = True\n                    success_state = True\n                # Early return as we've found a valid path connecting trees\n                break\n\n        if found_solution:\n            extracted_path = best_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 20.20962,
    "time_improvement": 19.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 213.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.026959753036499022,
            "num_nodes_avg": 120.0,
            "path_length_avg": 170.28121542486153,
            "smoothness_avg": 0.02405649965141558,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4.241859950588143,
            "length_improvement": 6.666167547104218,
            "smoothness_improvement": 276.5364590697695,
            "objective_score": -45.890175161565054
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.04709856510162354,
            "num_nodes_avg": 284.5,
            "path_length_avg": 259.58883022940154,
            "smoothness_avg": 0.011168458811100231,
            "success_improvement": -9.999999999999998,
            "time_improvement": 71.33819102688118,
            "length_improvement": 13.341776619235596,
            "smoothness_improvement": 187.3724895253369,
            "objective_score": -19.6566142727676
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.053460550308227536,
            "num_nodes_avg": 325.8,
            "path_length_avg": 133.37111536970275,
            "smoothness_avg": 0.021573118200771638,
            "success_improvement": 0.0,
            "time_improvement": -9.35622518536148,
            "length_improvement": 11.421255621484839,
            "smoothness_improvement": 174.40847115186895,
            "objective_score": 4.917928173041804
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "An improved bidirectional RRT* planner with adaptive rewiring radius, efficient node management, and early termination for better planning time, path length, and smoothness. The planner alternates tree expansions from start and goal, samples with goal bias, steers towards samples with fixed step size, rewires neighbors within a shrinking radius to optimize path cost, ensures consistent parent-child-edge updates, and stops immediately on finding a valid path or timeout, returning the best found feasible path. Adaptive radius tuning and careful rewiring yield smoother, shorter paths with lower planning time.",
    "planning_mechanism": "A bidirectional RRT* approach that grows two trees alternately with goal bias, uses an adaptive rewiring radius that shrinks logarithmically with the number of nodes for focused optimization, consistently updates parents, children, and edges during rewiring, applies collision checks for both nodes and edges, and terminates early after first successful path or timeout, returning the best path discovered, combining efficiency with improved path quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius_constant: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        # Constant that defines initial rewiring neighborhood radius scale (for adaptive radius)\n        self.rewire_radius_constant = rewire_radius_constant\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fro: Tuple[float, ...], to: Tuple[float, ...], resolution=1.0) -> bool:\n            distance = dist(fro, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fro[d] + (to[d] - fro[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def update_parent_child_edges_remove(old_parent: Node, child: Node):\n            if old_parent:\n                if child in old_parent.children:\n                    old_parent.remove_child(child)\n            # edges removal managed outside\n\n        def add_edge(parent: Node, child: Node):\n            parent.add_child(child)\n\n        def rewire(tree: List[Node], new_node: Node, radius: float):\n            nearby = near(tree, new_node.position, radius)\n            for node in nearby:\n                if node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, node.position)\n                if potential_cost + 1e-9 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    # Remove old edge and update children/parent\n                    old_parent = node.parent\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, node))\n                            old_parent.remove_child(node)\n                        except ValueError:\n                            pass\n                    # Add new edge\n                    node.parent = new_node\n                    node.cost = potential_cost\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full = path_start + path_goal[-2::-1]  # Avoid duplicate meeting node\n            return full\n\n        # Initialize trees and data\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        tree_a = start_tree\n        tree_b = goal_tree\n\n        for k in range(1, self.max_iter + 1):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius: shrink logarithmically with iterations for focused local rewiring\n            gamma_rrt_star = self.rewire_radius_constant\n            dimension = dim\n            radius = min(gamma_rrt_star * (math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1/dimension), self.step_size * 50)\n            if radius > self.step_size:\n                rewire(tree_a, new_node, radius)\n\n            # Attempt to connect opposite tree\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_to_other = dist(nearest_other.position, new_node.position)\n            if dist_to_other <= self.step_size + 1e-9 and not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                # Link trees by adding a node in tree_b at new_node position if needed\n                connecting_node = Node(new_node.position)\n                connecting_node.parent = nearest_other\n                connecting_node.cost = nearest_other.cost + dist(nearest_other.position, new_node.position)\n                nearest_other.add_child(connecting_node)\n                tree_b.append(connecting_node)\n                all_nodes.append(connecting_node)\n                edges.append((nearest_other, connecting_node))\n\n                # No rewiring in other tree for connection to minimize overhead and preserve correctness\n\n                # Extract and return path\n                success = True\n                best_path = extract_path(new_node, connecting_node)\n                break\n\n            # Swap for next iteration\n            tree_a, tree_b = tree_b, tree_a\n\n        # If no path found but nodes exist, pick closest node in both trees to connect best path found so far\n        if not success and len(tree_a) > 0 and len(tree_b) > 0:\n            # Find best pair (node in tree_a, node in tree_b) minimizing dist plus cost sum\n            best_cost = float(\"inf\")\n            best_pair = (None, None)\n            for node_a in tree_a:\n                for node_b in tree_b:\n                    if not is_edge_in_obstacle(node_a.position, node_b.position):\n                        cost_sum = node_a.cost + dist(node_a.position, node_b.position) + node_b.cost\n                        if cost_sum < best_cost:\n                            best_cost = cost_sum\n                            best_pair = (node_a, node_b)\n            if best_pair[0] is not None and best_pair[1] is not None:\n                # Build path connecting best approximate nodes\n                success = False\n                best_path = best_pair[0].path_from_root() + best_pair[1].path_from_root()[::-1]\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": -18.72529,
    "time_improvement": 78.0,
    "length_improvement": -8.0,
    "smoothness_improvement": 63.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00833117961883545,
            "num_nodes_avg": 163.7,
            "path_length_avg": 202.59546802442205,
            "smoothness_avg": 0.010296812876510771,
            "success_improvement": 0.0,
            "time_improvement": 67.78688373465098,
            "length_improvement": -11.04578635481506,
            "smoothness_improvement": 61.16748140443731,
            "objective_score": 14.014430714528444
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01594119071960449,
            "num_nodes_avg": 299.0,
            "path_length_avg": 305.08218917487704,
            "smoothness_avg": 0.006561616375987853,
            "success_improvement": 0.0,
            "time_improvement": 90.29899611116585,
            "length_improvement": -1.8452160504967414,
            "smoothness_improvement": 68.83511549541103,
            "objective_score": 26.326744780528767
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.012480735778808594,
            "num_nodes_avg": 262.8,
            "path_length_avg": 167.6181046133703,
            "smoothness_avg": 0.012390808546077004,
            "success_improvement": 0.0,
            "time_improvement": 74.47003174420482,
            "length_improvement": -11.323963967776415,
            "smoothness_improvement": 57.61017011174977,
            "objective_score": 15.834681993154346
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner with goal bias, adaptive rewiring radius, efficient steering and collision checks, recursive cost propagation for improved path cost and smoothness, and early termination upon time limit or solution. The planner alternates tree expansions from start and goal, uses goal-biased sampling, rewires nodes within adaptive radius, and merges the trees upon feasible connection. It maintains consistent parent-child relationships and edge lists to ensure path quality and returns the best path found within 30 seconds.",
    "planning_mechanism": "A bidirectional RRT* approach that grows two trees alternately towards randomly sampled or goal-biased points using fixed step size steering. Each added node undergoes rewiring with neighbors within a dynamically adjusted radius, updating costs recursively. The trees attempt early connections each iteration, and the algorithm terminates upon first path found or time expiration, returning the best discovered path with coherent node and edge data.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # For collision or pruning if needed\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.15         # Probability to sample the goal\n        self.gamma = 40.0             # Radius multiplier for rewiring\n        self.improve_tol = 1e-6       # Tolerance for cost improvement\n        self.time_limit = 30.0        # Hard time limit in seconds\n        self.max_radius_factor = 12.0 # Max radius factor relative to step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius: float):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        # Avoid duplicating connecting node position twice\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Attach connection node to tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build candidate path\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success_state = True\n                    break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)",
    "objective": -24.61754,
    "time_improvement": 61.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 193.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009621047973632812,
            "num_nodes_avg": 97.6,
            "path_length_avg": 164.31220468255123,
            "smoothness_avg": 0.023315744650501093,
            "success_improvement": 0.0,
            "time_improvement": 62.79951325638851,
            "length_improvement": 9.93787691999248,
            "smoothness_improvement": 264.94203473022714,
            "objective_score": 26.127290302563175
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02230513095855713,
            "num_nodes_avg": 273.4,
            "path_length_avg": 266.18287057210443,
            "smoothness_avg": 0.009924123364819862,
            "success_improvement": 0.0,
            "time_improvement": 86.4262233621099,
            "length_improvement": 11.14049615391379,
            "smoothness_improvement": 155.3548422339481,
            "objective_score": 33.388938912150984
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03204865455627441,
            "num_nodes_avg": 330.6,
            "path_length_avg": 142.5087361224591,
            "smoothness_avg": 0.020315103476053527,
            "success_improvement": 0.0,
            "time_improvement": 34.44287676918223,
            "length_improvement": 5.352483004246246,
            "smoothness_improvement": 158.4066167104425,
            "objective_score": 14.336385916854628
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An advanced bidirectional RRT* planner with goal biasing, adaptive neighbor radius rewiring, and efficient nearest neighbor caching that accelerates planning and improves path smoothness and length by locally optimizing the tree structure and performing recursive cost updates. It enforces robust collision checking, limits search time, and incrementally returns the best path found at any point.",
    "planning_mechanism": "A bidirectional RRT* grows two trees rooted at start and goal positions by sampling points with a goal bias. Each new node extends from its nearest neighbor in the active tree via fixed step size steering. Then, the planner searches an adaptive radius for rewiring both the new node and its neighbors to reduce path cost and improve smoothness. The trees attempt connection after each extension within radius. It maintains efficient nearest neighbor queries, performs collision-free node and edge insertions, and uses recursive cost updates to keep path costs consistent. The planner terminates when the two trees connect or time runs out, returning the best feasible path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def rewire_to(self, new_parent, new_cost):\n        \"\"\"Reassign parent and update cost recursively to descendants if improved.\"\"\"\n        old_cost = self.cost\n        cost_diff = new_cost - old_cost\n        self.parent.children.remove(self)\n        self.parent = new_parent\n        new_parent.children.append(self)\n        self.cost = new_cost\n        for c in self.children:\n            c._update_cost_recursive(cost_diff)\n\n    def _update_cost_recursive(self, cost_diff):\n        self.cost += cost_diff\n        for c in self.children:\n            c._update_cost_recursive(cost_diff)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 2.0  # tuning parameter for rewiring radius\n        self.goal_sample_rate = 0.15  # 15% goal bias\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        dims = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Efficient nearest neighbor caching by storing lists\n        # Each iteration we'll seek neighbors only once per new node.\n\n        success = False\n        extracted_path = []\n\n        best_cost = float('inf')\n        best_meeting = None  # tuple(node_in_start_tree, node_in_goal_tree)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steering(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dims))\n\n        def sample_free():\n            # goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def is_collision_free(node_pos, parent_pos):\n            return (not self._is_in_obstacle(node_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(parent_pos, node_pos, obstacles, is_3d, resolution=0.5))\n\n        def nearest(tree, point):\n            # Linear search; can be optimized externally if needed\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            # Return list of nodes within radius of point\n            neighborhood = []\n            for node in tree:\n                if distance(node.position, point) <= radius:\n                    neighborhood.append(node)\n            return neighborhood\n\n        def try_rewire(new_node, neighbors):\n            # Attempt to rewire neighbors through new_node if it improves cost\n            for neighbor in neighbors:\n                edge_len = distance(new_node.position, neighbor.position)\n                potential_cost = new_node.cost + edge_len\n                if potential_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.5):\n                        neighbor.rewire_to(new_node, potential_cost)\n\n        def try_connect_trees(node_start, node_goal):\n            # Check if nodes can be connected collision free and update best path if better\n            if distance(node_start.position, node_goal.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(node_start.position, node_goal.position, obstacles, is_3d, resolution=0.5):\n                    total_cost = node_start.cost + distance(node_start.position, node_goal.position) + node_goal.cost\n                    nonlocal best_cost, best_meeting, success\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_meeting = (node_start, node_goal)\n                        success = True\n\n        def reconstruct_path(meeting):\n            n_start, n_goal = meeting\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            path_goal.reverse()\n            # Avoid duplicated meeting node position\n            return path_start + path_goal[1:]\n\n        # Precompute rewiring radius upper bound helper:\n        volume_unit_ball = 3.141592653589793  # pi for 2D, for 3D should be 4/3 pi but formula adapts\n        # For simplicity and since map sizes vary, we'll use adaptive radius formula similar to RRT*:\n        def rewiring_radius(n_nodes):\n            # Following theoretical bound for radius in RRT*\n            if n_nodes <=1:\n                return self.step_size * 2.0\n            else:\n                dim = dims\n                # Volume of unit ball for R^dim:\n                try:\n                    from math import gamma\n                    unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1)  # gamma function\n                except Exception:\n                    # fallback constants\n                    unit_ball_volume = volume_unit_ball if dim == 2 else (4.0/3.0)*math.pi\n                gamma_rrt_star = self.gamma_rrt_star\n                radius = min(self.step_size * 12.0,\n                             gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n                return radius\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steering(nearest_node.position, sample)\n\n            if not is_collision_free(new_pos, nearest_node.position):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire new_node parent for better parents within radius\n            n_nodes = len(active_tree)\n            radius = rewiring_radius(n_nodes)\n            nearby_nodes = near(active_tree, new_node.position, radius)\n\n            # Choose best parent among neighbors including current parent\n            best_parent = nearest_node\n            best_cost_parent = new_cost\n            for nb in nearby_nodes:\n                if nb is new_node or nb is new_node.parent:\n                    continue\n                edge_len = distance(nb.position, new_node.position)\n                cost_through_nb = nb.cost + edge_len\n                if cost_through_nb + 1e-9 < best_cost_parent:\n                    if not self._is_edge_in_obstacle(nb.position, new_node.position, obstacles, is_3d, resolution=0.5):\n                        best_parent = nb\n                        best_cost_parent = cost_through_nb\n\n            if best_parent is not new_node.parent:\n                # Re-assign parent and update cost\n                new_node.rewire_to(best_parent, best_cost_parent)\n\n            # Rewire neighbors to new_node if beneficial\n            try_rewire(new_node, nearby_nodes)\n\n            # Attempt connection to passive tree nodes within radius\n            passive_nearby = near(passive_tree, new_node.position, radius)\n            for pnode in passive_nearby:\n                try_connect_trees(new_node, pnode)\n\n            # If found connection best meeting, reconstruct early path and update best variable\n            if success and best_cost < float('inf'):\n                extracted_path = reconstruct_path(best_meeting)\n                # Optionally break to return earliest best path or continue optimizing\n                # Here, for up to max_iter or time limit we'll continue to try improve\n                # To reduce planning time, break if path found\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        # If after loop success not found but best_meeting exists, reconstruct path\n        if success and extracted_path == [] and best_meeting is not None:\n            extracted_path = reconstruct_path(best_meeting)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.63825,
    "time_improvement": -4.0,
    "length_improvement": -12.0,
    "smoothness_improvement": 54.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03507053852081299,
            "num_nodes_avg": 373.1,
            "path_length_avg": 210.14571411303518,
            "smoothness_avg": 0.009616569284069084,
            "success_improvement": -9.999999999999998,
            "time_improvement": -35.602806150669274,
            "length_improvement": -15.184195877289394,
            "smoothness_improvement": 50.52019201012096,
            "objective_score": -69.53875841152382
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08825125694274902,
            "num_nodes_avg": 749.7,
            "path_length_avg": 335.1736379668595,
            "smoothness_avg": 0.006072262877957709,
            "success_improvement": 0.0,
            "time_improvement": 46.294740345635134,
            "length_improvement": -11.890607791589831,
            "smoothness_improvement": 56.24369752401762,
            "objective_score": 7.035275916356729
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05997333526611328,
            "num_nodes_avg": 580.6,
            "path_length_avg": 162.8401715256035,
            "smoothness_avg": 0.012306347349129835,
            "success_improvement": 0.0,
            "time_improvement": -22.678452029868527,
            "length_improvement": -8.150688311606217,
            "smoothness_improvement": 56.53582992085884,
            "objective_score": -11.411269446319992
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius scaling, goal-biased sampling, non-recursive rewiring, and direct tree connection without duplicate nodes. It alternates expansions from start and goal trees, selects parents from adaptive-radius neighborhoods to optimize cost, rewires neighbors locally, and stops early upon solution or timeout. This approach balances planning efficiency, path quality, and smoothness by limiting overhead and focusing on incremental improvements.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal by sampling mostly randomly with a goal bias, extends toward samples by fixed steps, selects best parent from neighbors within an adaptive radius based on node count and workspace size, rewires neighbors to reduce path costs, attempts to connect trees directly when close, and maintains best path found. It enforces collision checks for nodes and edges, and stops early on success or time limit, returning best solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple of coordinates (2D or 3D)\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.rewire_factor = 2.0  # Multiplier for neighbor radius scaling\n\n    def plan(self, map):\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def dist(p1, p2):\n            return sum((p1[d] - p2[d]) ** 2 for d in range(dim)) ** 0.5\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def neighbors(tree, pos, n_nodes):\n            # Adaptive radius: r = rewire_factor * step_size * (log(n)/n)^{1/d}\n            from math import log\n            if n_nodes <= 1:\n                radius = self.step_size * self.rewire_factor\n            else:\n                radius = self.rewire_factor * self.step_size * ((log(n_nodes) / n_nodes) ** (1.0 / dim))\n            radius = max(radius, self.step_size * 1.5)\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = i % 2 == 0\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n\n            sample = sample_point()\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                continue\n\n            nbrs = neighbors(tree_a, new_pos, len(tree_a))\n            # Choose best parent from neighbors\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in nbrs:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper path found through new_node\n            for nb in nbrs:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through_new\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try to connect trees\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_connect = dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Link nodes without duplicating\n                    combined_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if combined_cost < best_cost:\n                        best_cost = combined_cost\n                        if expand_start:\n                            best_path = build_path(new_node, nearest_other)\n                        else:\n                            best_path = build_path(nearest_other, new_node)\n                        success = True\n                        break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = 0.0\n        dim = len(from_pos)\n        for d in range(dim):\n            distance += (to_pos[d] - from_pos[d]) ** 2\n        distance = distance ** 0.5\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 63.64588,
    "time_improvement": 3.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 83.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.030523204803466798,
            "num_nodes_avg": 158.6,
            "path_length_avg": 183.04517663305725,
            "smoothness_avg": 0.01130776443529053,
            "success_improvement": -9.999999999999998,
            "time_improvement": -18.02020723478005,
            "length_improvement": -0.32996184901628006,
            "smoothness_improvement": 76.9910686157877,
            "objective_score": -55.21908393676484
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.10276596546173096,
            "num_nodes_avg": 347.6,
            "path_length_avg": 279.55600146299764,
            "smoothness_avg": 0.007352033642907425,
            "success_improvement": -9.999999999999998,
            "time_improvement": 37.46182150885256,
            "length_improvement": 6.676160138303647,
            "smoothness_improvement": 89.17312108779711,
            "objective_score": -34.30989185892305
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.05458524227142334,
            "num_nodes_avg": 251.9,
            "path_length_avg": 146.3727833359702,
            "smoothness_avg": 0.014413378256539744,
            "success_improvement": -19.999999999999996,
            "time_improvement": -11.656838757094173,
            "length_improvement": 2.7861668311877894,
            "smoothness_improvement": 83.33710753826917,
            "objective_score": -101.40866599072422
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* variant with adaptive neighbor radius, goal-biased sampling, non-recursive rewiring, and incremental incremental path cost updates. It uses an efficient priority queue to track best path improvements, early termination on time limit or stable best path, and consistent edge/node management to enhance planning time, path length, and smoothness. Adaptive radius scaling reduces costly neighbor checks; bidirectional tree growth with incremental connecting attempts accelerates convergence; and no recursive cost updates avoid overheads.",
    "planning_mechanism": "A planner that alternates extending start and goal trees toward goal-biased samples, connecting trees when close, rewiring locally around new nodes with adaptively sized neighborhoods scaled to the number of nodes and workspace dimensions, and incrementally updates node parent and cost assignments without recursive propagation. It tracks the best path found and stops early on timeout or no further improvements. Paths are constructed by merging the two trees\u2019 partial paths while avoiding duplicated connection nodes, returning the best feasible path found within 30 seconds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float,...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []                  # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2     # Goal bias probability\n        self.time_limit = 30.0          # Seconds\n        self.improve_tol = 1e-8         # Cost improvement tolerance\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import time\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        # Initialize start and goal trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        # Global node & edge lists\n        nodes = [start_root, goal_root]\n        edges = []  # (parent, child)\n\n        best_path = []\n        best_cost = float('inf')\n        best_connect_nodes = (None, None)\n        found_solution = False\n\n        # Adaptive neighbor radius function for rewiring; scales with log(n)/n^(1/d)\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.5\n            unit_ball_volume = 3.141592653589793 ** (dim/2) / self._gamma(dim/2 + 1)\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * (unit_ball_volume) ** (-1/dim)\n            r = min(self.step_size * 3.0, gamma_rrt_star * (math.log(n) / n) ** (1/dim))\n            return max(r, self.step_size * 1.5)\n\n        def try_connect(node_new, tree_other):\n            # Connect if distance <= step_size and edge collision free\n            nearest_other = self._nearest(tree_other, node_new.position)\n            dist_connect = self._dist(nearest_other.position, node_new.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, node_new.position, obstacles, is_3d):\n                    return nearest_other\n            return None\n\n        # Main loop\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            # Sample with goal bias\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt, self.step_size)\n\n            # Validate node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node, connect to best parent amongst neighbors\n            n_nodes = len(tree_a)\n            radius = neighbor_radius(n_nodes)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Non-recursive rewiring: try to reparent near nodes through new_node if cheaper\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Detach from old parent\n                        if near_node.parent:\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                            near_node.parent.remove_child(near_node)\n                        # Attach to new parent\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Update children costs incrementally without recursion (discount deep rewriting for speed)\n                        # Only update immediate children cost approx\n                        children_stack = near_node.children[:]\n                        while children_stack:\n                            c = children_stack.pop()\n                            old_cost = c.cost\n                            new_cost = c.parent.cost + self._dist(c.parent.position, c.position)\n                            if new_cost + self.improve_tol < old_cost:\n                                c.cost = new_cost\n                                children_stack.extend(c.children)\n\n            # Attempt tree connection and path update\n            connect_node_b = try_connect(new_node, tree_b)\n            if connect_node_b is not None:\n                # Build combined path from start_root to goal_root\n                if expand_start:\n                    path = self._build_path(new_node, connect_node_b)\n                    total_cost = new_node.cost + (connect_node_b.cost + self._dist(connect_node_b.position, new_node.position) - connect_node_b.cost)\n                else:\n                    path = self._build_path(connect_node_b, new_node)\n                    total_cost = connect_node_b.cost + (new_node.cost + self._dist(new_node.position, connect_node_b.position) - new_node.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_connect_nodes = (new_node, connect_node_b)\n                    found_solution = True\n\n            # Early stop if solution stable and elapsed at least 1s to allow some improvement\n            if found_solution and (time.monotonic() - time_start) > 1.0:\n                # Check if no significant improvement in last 20 iterations\n                # For simplicity, we stop immediately here to reduce planning time\n                break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Gamma function approximation for volume calculation\n    def _gamma(self, x):\n        # Lanczos approximation coefficients for gamma ~ x > 0\n        p = [676.5203681218851, -1259.1392167224028, 771.32342877765313,\n             -176.61502916214059, 12.507343278686905, -0.13857109526572012,\n             9.9843695780195716e-6, 1.5056327351493116e-7]\n        if x < 0.5:\n            # Reflection formula\n            import math\n            return math.pi / (math.sin(math.pi * x) * self._gamma(1 - x))\n        x -= 1\n        y = 0.99999999999980993\n        for i in range(len(p)):\n            y += p[i] / (x + i + 1)\n        t = x + len(p) - 0.5\n        import math\n        return math.sqrt(2 * math.pi) * t ** (x + 0.5) * math.exp(-t) * y\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        import random\n        if random.random() < goal_bias_prob:\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        result = []\n        r2 = radius * radius\n        for node in tree:\n            if self._dist_sq(node.position, point) <= r2:\n                result.append(node)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        # Using math.dist if available; else Euclidean distance\n        try:\n            import math\n            return math.dist(p1, p2)\n        except Exception:\n            s = 0.0\n            for i in range(len(p1)):\n                s += (p1[i] - p2[i]) ** 2\n            return s ** 0.5\n\n    def _dist_sq(self, p1, p2):\n        s = 0.0\n        for i in range(len(p1)):\n            s += (p1[i] - p2[i]) ** 2\n        return s\n\n    def _build_path(self, node_start, node_goal):\n        # Path from start_root to node_start\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        # Path from goal_root to node_goal\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n\n        # Remove duplicate connection node (last of path_start == first of path_goal)\n        if path_start and path_goal and path_start[-1] == path_goal[0]:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 628.9148,
    "time_improvement": -2104.0,
    "length_improvement": 4.0,
    "smoothness_improvement": 40.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.0137919187545776,
            "num_nodes_avg": 1563.8,
            "path_length_avg": 164.69063050887655,
            "smoothness_avg": 0.009263287750211676,
            "success_improvement": 0.0,
            "time_improvement": -3819.900715365611,
            "length_improvement": 9.730455728042616,
            "smoothness_improvement": 44.990568842122876,
            "objective_score": -1139.9069883286472
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0138959407806396,
            "num_nodes_avg": 1416.1,
            "path_length_avg": 273.5141134019863,
            "smoothness_avg": 0.005753266461642452,
            "success_improvement": 0.0,
            "time_improvement": -517.0058835247523,
            "length_improvement": 8.693116279174577,
            "smoothness_improvement": 48.03568996839449,
            "objective_score": -149.64571684007896
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.015028977394104,
            "num_nodes_avg": 1397.5,
            "path_length_avg": 161.7209173484379,
            "smoothness_avg": 0.010069963067222017,
            "success_improvement": 0.0,
            "time_improvement": -1976.292458300678,
            "length_improvement": -7.407332980289412,
            "smoothness_improvement": 28.089186927708038,
            "objective_score": -597.1916913437384
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive fixed-radius rewiring, balanced tree expansion, goal bias sampling, and non-recursive cost updates. It uses an efficient early connection detection, balanced neighbor search, and selective rewire to improve planning time while maintaining path quality and smoothness. The planning stops after 30 seconds or if a satisfactory path is found, returning the current best.",
    "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal using goal-biased sampling with a fixed step size. For each new node, rewiring is performed locally in a fixed-radius neighborhood without recursive cost propagation to reduce overhead. The nearest neighbors are searched via efficient pruning based on a fixed radius. Upon finding a connection between trees, the best path is updated and planning may terminate early. Consistent edge and parent updates maintain tree validity.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2    # goal bias probability\n        self.rewire_radius = 10.0      # fixed radius for rewiring to control overhead\n        self.time_limit = 30.0         # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        radius_sq = radius*radius\n        dim = len(point)\n        result = []\n        for node in tree:\n            # squared dist for efficiency\n            dist_sq = sum((node.position[d] - point[d])**2 for d in range(dim))\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success_state = False\n\n        time_start = time.monotonic()\n\n        # Alternate tree expansion\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - time_start > self.time_limit:\n                break\n\n            expand_start = (iter_count % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            dist_to_parent = self._dist(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_to_parent\n            best_parent = nearest_node\n\n            # Fixed radius rewiring neighbors\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node without recursion\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Do not recurse cost update to keep time low\n\n            # Attempt to connect trees directly at new_node pos\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connect by adding a node in tree_b at new_node's position with cost\n                    connect_cost = nearest_other.cost + dist_connect\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=connect_cost)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    else:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    path_goal.reverse()\n                    combined_path = path_start + path_goal[1:]  # merge avoid duplicate\n\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success_state = True\n                        # Early termination on first found path\n                        break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -25.59587,
    "time_improvement": 61.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 161.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01631131172180176,
            "num_nodes_avg": 138.0,
            "path_length_avg": 167.04103096183044,
            "smoothness_avg": 0.01581183459495707,
            "success_improvement": 0.0,
            "time_improvement": 36.931118404070936,
            "length_improvement": 8.442163995300026,
            "smoothness_improvement": 147.48954735946702,
            "objective_score": 16.882081655198633
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.032275938987731935,
            "num_nodes_avg": 287.8,
            "path_length_avg": 257.1157017506108,
            "smoothness_avg": 0.010703326882045994,
            "success_improvement": 0.0,
            "time_improvement": 80.3584929668585,
            "length_improvement": 14.167378090512239,
            "smoothness_improvement": 175.40430996978455,
            "objective_score": 33.484996294213815
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017235589027404786,
            "num_nodes_avg": 196.1,
            "path_length_avg": 135.00966227832785,
            "smoothness_avg": 0.02040266093776916,
            "success_improvement": 0.0,
            "time_improvement": 64.7437419926231,
            "length_improvement": 10.333010783995237,
            "smoothness_improvement": 159.52034116064578,
            "objective_score": 26.4205307739873
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional informed RRT* planner employing adaptive neighbor radius shrinking logarithmically with iterations, goal-biased and informed subset sampling, efficient non-recursive rewiring with consistent parent-child-edge management, and incremental best-path tracking enabling early stopping within a 30-second time limit for improved planning time, path length, and smoothness.",
    "planning_mechanism": "The planner alternates tree expansions from start and goal, uses a shrinking rewiring radius based on the iteration count to focus rewiring locally as trees grow, samples points either towards the goal or within an ellipsoid defined by the current best path cost, extends trees by fixed step size with collision checks, rewires neighbors non-recursively updating parent-child relations, attempts to connect trees each iteration, tracks the best path incrementally, and stops early when time limit or satisfaction is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=100000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.dimension = 2\n        self.min_rewire_radius = 3.0\n        self.max_rewire_radius = 12.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        radius_sq = radius * radius\n        dim = len(point)\n        result = []\n        for node in tree:\n            dist_sq = 0.0\n            for d in range(dim):\n                diff = node.position[d] - point[d]\n                dist_sq += diff * diff\n                if dist_sq > radius_sq:\n                    break\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _sample(self, bounds, obstacles, is_3d, goal, best_cost, start, goal_pos):\n        # Goal bias sampling\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n\n        dim = len(bounds)\n        # Informed sampling when a path is found: sample within ellipsoidal region\n        if math.isfinite(best_cost):\n            c_min = math.dist(start, goal_pos)\n            if best_cost < c_min:\n                # Numerical safety\n                best_cost = c_min\n            center = tuple((start[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            a1 = tuple((goal_pos[d] - start[d]) / c_min for d in range(dim))\n\n            # Rotation matrix from unit vector a1 to first axis\n            # Compute rotation matrix to align ellipsoid with start-goal vector\n            I = [[1.0 if i == j else 0.0 for j in range(dim)] for i in range(dim)]\n            # Using Householder transformation\n            v = [a1[d] - (1.0 if d == 0 else 0.0) for d in range(dim)]\n            s = math.sqrt(sum(x*x for x in v))\n            if s < 1e-10:\n                C = I\n            else:\n                u = [vi/s for vi in v]\n                C = [[I[i][j] - 2*u[i]*u[j] for j in range(dim)] for i in range(dim)]\n\n            # Sample unit ball point\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x**2 for x in x_ball))\n                if norm_x > 1e-9:\n                    break\n            x_ball = [xi / norm_x for xi in x_ball]\n            r = random.random() ** (1/dim)\n            x_ball = [xi * r for xi in x_ball]\n\n            # Scale for ellipsoid\n            r1 = best_cost * 0.5\n            r2 = math.sqrt(best_cost**2 - c_min**2) * 0.5\n            scales = [r1] + [r2]*(dim-1)\n            x_scaled = [x_ball[d]*scales[d] for d in range(dim)]\n\n            # Rotate and translate\n            x_rot = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    x_rot[i] += C[i][j]*x_scaled[j]\n            sample = tuple(center[d] + x_rot[d] for d in range(dim))\n            # Check bounds and collision\n            out_of_bounds = any(sample[d]<0 or sample[d]>bounds[d] for d in range(dim))\n            if not out_of_bounds and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n        # Uniform sampling respecting bounds & collision\n        while True:\n            sample = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        self.dimension = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        time_start = time.monotonic()\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - time_start > self.time_limit:\n                break\n\n            # Adaptive radius shrinking logarithmically from max to min\n            gamma = self.max_rewire_radius\n            min_r = self.min_rewire_radius\n            radius = max(min_r, gamma / math.log(iter_count + 2))\n\n            # Alternate trees expansion\n            expand_start = (iter_count % 2 == 0)\n            active_tree = tree_start if expand_start else tree_goal\n            other_tree = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal, best_cost, start_pos, goal_pos)\n            nearest_node = self._nearest(active_tree, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Choose best parent in radius neighborhood minimizing cost\n            near_nodes = self._near(active_tree, new_pos, radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors non-recursively\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connect other tree to new_node\n            near_other = self._near(other_tree, new_node.position, radius)\n            connection_made = False\n            for other_node in near_other:\n                dist_con = self._dist(other_node.position, new_node.position)\n                if dist_con <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        # Connect by adding a node in other tree at new_node position\n                        connect_cost = other_node.cost + dist_con\n                        connect_node = Node(new_node.position, parent=other_node, cost=connect_cost)\n                        other_node.add_child(connect_node)\n                        other_tree.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((other_node, connect_node))\n\n                        # Compose combined path\n                        if expand_start:\n                            path_start = new_node.path_from_root()\n                            path_goal = connect_node.path_from_root()\n                        else:\n                            path_start = connect_node.path_from_root()\n                            path_goal = new_node.path_from_root()\n                        path_goal_reversed = path_goal[::-1]\n                        combined_path = path_start + path_goal_reversed[1:]\n\n                        total_cost = new_node.cost + (connect_node.cost - other_node.cost)\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_path = combined_path\n                            success_state = True\n                            connection_made = True\n                        break\n            if connection_made:\n                # Early stopping upon first found improved path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -18.89616,
    "time_improvement": 71.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 48.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005726838111877441,
            "num_nodes_avg": 94.8,
            "path_length_avg": 188.37292400526013,
            "smoothness_avg": 0.009661147432714793,
            "success_improvement": 0.0,
            "time_improvement": 77.85676094251262,
            "length_improvement": -3.250184607280302,
            "smoothness_improvement": 51.21793683942546,
            "objective_score": 21.663007202582733
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030701518058776855,
            "num_nodes_avg": 329.0,
            "path_length_avg": 311.3937020433977,
            "smoothness_avg": 0.005753756365875067,
            "success_improvement": 0.0,
            "time_improvement": 81.31660606035985,
            "length_improvement": -3.9521807128340645,
            "smoothness_improvement": 48.04829555716344,
            "objective_score": 22.263914868193332
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022475647926330566,
            "num_nodes_avg": 269.1,
            "path_length_avg": 159.78464788312584,
            "smoothness_avg": 0.011429005258258587,
            "success_improvement": 0.0,
            "time_improvement": 54.02493985475405,
            "length_improvement": -6.121354996673014,
            "smoothness_improvement": 45.37610328363345,
            "objective_score": 12.761549474840573
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A balanced and simplified bidirectional RRT* planner using fixed step steering, uniform rewiring radius, goal-biased sampling, and efficient non-recursive rewiring. The planner alternates growth from start and goal, attempts early connection each iteration, maintains consistent parent-child and edge relationships, performs collision checks on nodes and edges, and respects a strict 30-second time limit, returning the best path found with coherent graph data.",
    "planning_mechanism": "The planner grows two trees alternately by sampling free space biased toward the opposite tree's root, steering with fixed steps toward samples, rewiring neighbors within a fixed radius to improve path cost without costly recursive updates, then tries to connect the two trees within step size. Early termination occurs upon finding a solution or when the time limit is reached, ensuring efficient runtime and smooth, feasible paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, bias_point):\n        if random.random() < self.goal_bias and not self._is_in_obstacle(bias_point, obstacles, is_3d):\n            return bias_point\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        near_nodes = []\n        for node in tree:\n            dsq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if dsq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, start_node, goal_node):\n        path_from_start = start_node.path_from_root()\n        path_from_goal = goal_node.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            bias_point = goal_pos if expand_start else start_pos\n\n            sample = self._sample(bounds, obstacles, is_3d, bias_point)\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        success = True\n                        break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -19.29012,
    "time_improvement": 30.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 295.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.026474881172180175,
            "num_nodes_avg": 163.7,
            "path_length_avg": 168.96603869418215,
            "smoothness_avg": 0.022174001952879527,
            "success_improvement": 0.0,
            "time_improvement": -2.3670673697407696,
            "length_improvement": 7.387036753498517,
            "smoothness_improvement": 247.07128217849862,
            "objective_score": 4.957458252069372
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03768322467803955,
            "num_nodes_avg": 306.7,
            "path_length_avg": 239.8671353230522,
            "smoothness_avg": 0.016990003139900928,
            "success_improvement": 0.0,
            "time_improvement": 77.06789187987691,
            "length_improvement": 19.92544603648826,
            "smoothness_improvement": 337.16501819427293,
            "objective_score": 36.76146027682739
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.042066550254821776,
            "num_nodes_avg": 284.0,
            "path_length_avg": 124.30212883870313,
            "smoothness_avg": 0.03143950411272218,
            "success_improvement": 0.0,
            "time_improvement": 13.950770878435154,
            "length_improvement": 17.444444656643036,
            "smoothness_improvement": 299.9081716910263,
            "objective_score": 16.151438915971497
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner that alternately extends trees from start and goal using goal-biased sampling and fixed step-size steering, performs efficient collision checking, attempts fast tree connection each iteration, and returns the best found path within a 30-second limit. The planner maintains simple parent-child links without rewiring, focusing on speedy, straightforward exploration and connection to improve planning time and path quality.",
    "planning_mechanism": "The algorithm grows two trees by sampling the space with a bias towards the goal, steering fixed steps from nearest nodes, checks collisions on nodes and edges, and attempts to connect the opposite tree every iteration. It tracks the best path found and stops early when connected or when time runs out, thus balancing exploration and exploitation efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree_nodes, point):\n            return min(tree_nodes, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extend(tree_nodes, sample_point):\n            nearest_node = nearest(tree_nodes, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree_nodes, target_node):\n            nearest_node = nearest(tree_nodes, target_node.position)\n            d = dist(nearest_node.position, target_node.position)\n            if d > self.step_size:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_nodes.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # direct step if close enough\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_in_obstacle(target_node.position) and\n                        not is_edge_in_obstacle(new_node.position, target_node.position)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree_nodes.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(target_node.position) or is_edge_in_obstacle(nearest_node.position, target_node.position):\n                    return None\n                final_node = Node(target_node.position, parent=nearest_node,\n                                  cost=nearest_node.cost + d)\n                nearest_node.add_child(final_node)\n                tree_nodes.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        tree_active, tree_passive = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_active, sample)\n            if new_node is None:\n                tree_active, tree_passive = tree_passive, tree_active\n                continue\n\n            connected_node = try_connect(tree_passive, new_node)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n                total_cost = new_node.cost + (connected_node.cost - (connected_node.parent.cost if connected_node.parent else 0))\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            tree_active, tree_passive = tree_passive, tree_active\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -23.41502,
    "time_improvement": 86.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 67.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0056803226470947266,
            "num_nodes_avg": 112.9,
            "path_length_avg": 191.20309741425746,
            "smoothness_avg": 0.01063209351344455,
            "success_improvement": 0.0,
            "time_improvement": 78.03661639440982,
            "length_improvement": -4.80144749971929,
            "smoothness_improvement": 66.41535144600726,
            "objective_score": 20.86219317572141
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013835334777832031,
            "num_nodes_avg": 276.2,
            "path_length_avg": 303.1595630918326,
            "smoothness_avg": 0.006707533834627737,
            "success_improvement": 0.0,
            "time_improvement": 91.58051372423446,
            "length_improvement": -1.2033881242530935,
            "smoothness_improvement": 72.58967680631251,
            "objective_score": 27.115069626750042
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.005577445030212402,
            "num_nodes_avg": 153.5,
            "path_length_avg": 162.15435203153754,
            "smoothness_avg": 0.012698212924518393,
            "success_improvement": 0.0,
            "time_improvement": 88.59105768335095,
            "length_improvement": -7.6951996588625144,
            "smoothness_improvement": 61.52033111529328,
            "objective_score": 22.26779916526424
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional RRT* planner with fixed-radius neighbor search and early solution-directed termination, prioritizing computational efficiency and path quality. It employs balanced goal-biased sampling, avoids recursive cost propagation by local rewiring only, and utilizes a compact post-solution pruning step to ensure smooth, short paths within a strict 30-second planning window.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal using goal bias and fixed extended radius rewiring. Upon connection, it halts growth early and refines the best path locally by pruning redundant nodes and shortcutting edges under obstacle constraints, avoiding costly global rewiring. Both collision checks and sampling strictly respect map bounds and obstacle constraints, ensuring timely and feasible path discovery.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.25  # Balanced goal bias\n        self.gamma_rrt_star = 30.0    # Fixed factor for neighbor radius\n        self.time_limit = 30.0        # seconds\n        self.max_rewire_radius = 15.0 # Capped rewiring radius to limit computation\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1,int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos,to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Linear scan - could be improved (but fast enough for moderate nodes)\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        res = []\n        for node in tree:\n            if self._dist(node.position, point) <= radius:\n                res.append(node)\n        return res\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        # Build path from node_start root to node_goal root and connect\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        # Attempt to shortcut path by skipping intermediate nodes where possible\n        if len(path) <= 2:\n            return path[:]\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            next_idx = len(path)-1\n            # Try to find farthest reachable node without collision\n            for j in range(len(path)-1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Fixed radius with upper cap to limit neighbors checked\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewiring neighbors without recursive cost propagation for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Change parent, update cost, update edges\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # No recursive cost propagation to descendants to reduce overhead\n\n            # Try connect to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Connect by creating new connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                # Build path\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n\n                if cur_cost < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = conn_node if expand_start else new_node\n                    found_solution = True\n                    success = True\n\n                # Early termination upon solution find to save planning time\n                break\n\n        # If solution found, perform fast shortcutting pruning for smoothness (no extra rewiring)\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            extracted_path = pruned_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -34.89579,
    "time_improvement": 55.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1778.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012917184829711914,
            "num_nodes_avg": 108.3,
            "path_length_avg": 163.51846744486653,
            "smoothness_avg": 0.047042774543765466,
            "success_improvement": 0.0,
            "time_improvement": 50.05475865629264,
            "length_improvement": 10.37293687753887,
            "smoothness_improvement": 636.321576629899,
            "objective_score": 24.42179760656061
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028571557998657227,
            "num_nodes_avg": 306.4,
            "path_length_avg": 238.2101483315511,
            "smoothness_avg": 0.12766555635173507,
            "success_improvement": 0.0,
            "time_improvement": 82.61279222297007,
            "length_improvement": 20.478595987977428,
            "smoothness_improvement": 3184.926718713584,
            "objective_score": 52.99562885324539
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03236863613128662,
            "num_nodes_avg": 362.2,
            "path_length_avg": 126.56340895880092,
            "smoothness_avg": 0.126854052156657,
            "success_improvement": 0.0,
            "time_improvement": 33.788338479350664,
            "length_improvement": 15.942610071462218,
            "smoothness_improvement": 1513.5741800405376,
            "objective_score": 27.26993848688522
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A novel bidirectional informed RRT* planner with fixed-radius neighbor rewiring, recursive cost propagation, adaptive goal biasing, and early stopping focused on improved efficiency and path quality. The planner uses efficient sample validation, consistent parent-child and edge management, and ellipsoidal informed refinement pruning to yield smoother, shorter paths within a hard 30-second limit.",
    "planning_mechanism": "The planner alternates expansions between two trees growing from start and goal with adaptive goal bias sampling, steering with fixed step size. It applies fixed-radius neighbor searches to limit rewiring costs and uses recursive cost updates for consistent path improvements. Early stopping upon stable best path discovery prevents wasted computations. After initial connection, a focused ellipsoidal informed single-tree refinement phase optimizes the path by targeted sampling within an informed subset of the configuration space until the time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = 0.12     # adaptive goal bias for start tree\n        self.goal_sample_rate_goal = 0.20      # adaptive goal bias for goal tree\n        self.gamma_rrt_star = 30.0              # radius factor for neighbor search\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n        self.fixed_radius_factor = 15.0         # fixed radius factor (multiplied by step_size)\n        self.max_radius = self.step_size * self.fixed_radius_factor\n        self.no_improve_limit = 100\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        res = []\n        r2 = radius * radius\n        for node in tree:\n            # Squared distance for efficiency if many dims, else math.dist is fine\n            d2 = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d2 <= r2:\n                res.append(node)\n        return res\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        dim = len(bounds)\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        # Propagate improved cost to descendants recursively\n        stack = [node]\n        while stack:\n            current = stack.pop()\n            for child in current.children:\n                new_cost = current.cost + self._dist(current.position, child.position)\n                if new_cost + self.improve_tol < child.cost:\n                    child.cost = new_cost\n                    child.parent = current\n                    stack.append(child)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        best_goal_node: Optional[Node] = None\n        found_solution = False\n        success_state = False\n\n        no_improve_count = 0\n\n        # Alternate tree growth with adaptive goal biasing\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n\n            goal_bias = self.goal_sample_rate_start if expand_start else self.goal_sample_rate_goal\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample, goal_bias)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Fixed radius for neighbors (avoid expensive shrinking radius)\n            radius = self.max_radius\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with recursive update to maintain optimal tree\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    self._update_costs_recursive(near)\n\n            # Connect to opposite tree if close enough\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    path_end_node = connect_node\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                    path_end_node = new_node\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = path_end_node\n                    found_solution = True\n                    success_state = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n\n                # Early stop if solution is stable for many iterations\n                if no_improve_count > self.no_improve_limit:\n                    break\n\n            else:\n                # Increment no improvement counter if no connection\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > self.no_improve_limit:\n                break\n\n        # If no solution found, return empty path immediately\n        if not found_solution or best_goal_node is None:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Single-tree ellipsoidal informed refinement for remaining time\n        # Rebuild tree along best path for refinement\n        tree = [start_root]\n        start_root.children.clear()\n        start_root.cost = 0.0\n        nodes = [start_root] + [n for n in nodes if n not in (start_root, goal_root)]\n        edges.clear()\n\n        prev_node = start_root\n        for pos in best_path[1:]:\n            n_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n            prev_node.add_child(n_node)\n            tree.append(n_node)\n            edges.append((prev_node, n_node))\n            prev_node = n_node\n        best_goal_node = prev_node\n        best_cost = best_goal_node.cost\n\n        no_improve_count = 0\n        post_opt_iters = self.max_iter // 2\n        c_min = self._dist(start_pos, goal_pos)\n\n        for _ in range(post_opt_iters):\n            if timed_out() or no_improve_count > self.no_improve_limit:\n                break\n\n            sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest_node = self._nearest(tree, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            n_nodes = len(tree) + 1\n            radius = self.max_radius\n            near_nodes = self._near(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewired = False\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n                    rewired = True\n\n            dist_goal = self._dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                    success_state = True\n                    rewired = True\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n            if no_improve_count > self.no_improve_limit:\n                break\n\n        extracted_path = best_goal_node.path_from_root() if success_state else best_path\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 792.36114,
    "time_improvement": -2700.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1005.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.39603431224823,
            "num_nodes_avg": 673.6,
            "path_length_avg": 152.19344284049424,
            "smoothness_avg": 0.039156312349524006,
            "success_improvement": 0.0,
            "time_improvement": -5297.8689295327995,
            "length_improvement": 16.580362319694125,
            "smoothness_improvement": 512.8813175632587,
            "objective_score": -1576.8480548802067
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.275330138206482,
            "num_nodes_avg": 771.5,
            "path_length_avg": 224.1300943473047,
            "smoothness_avg": 0.062281043075464115,
            "success_improvement": 0.0,
            "time_improvement": -676.1015377021622,
            "length_improvement": 25.1789232798019,
            "smoothness_improvement": 1502.5360975537958,
            "objective_score": -180.2104268549985
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.088017749786377,
            "num_nodes_avg": 757.1,
            "path_length_avg": 118.81656127242361,
            "smoothness_avg": 0.0864917275120947,
            "success_improvement": 0.0,
            "time_improvement": -2125.5946368924333,
            "length_improvement": 21.087697439508545,
            "smoothness_improvement": 1000.1683897986068,
            "objective_score": -620.0249306550318
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* variant that utilizes adaptive radius rewiring based on the current number of nodes, efficient collision checking with caching, and priority sampling towards the goal with dynamic adjustment. After connecting start and goal trees, a local path shortcutting smoothing step is applied to improve smoothness and shorten the path. The planner enforces a hard 30-second time limit and returns the best path found so far.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately expanding them with goal-biased sampling and nearest neighbor search using an adaptive neighbor radius that shrinks with increasing nodes. It rewires nearby nodes within that radius, recursively updating costs. When the trees connect, it constructs a full path and performs a fast local shortcut smoothing procedure by attempting direct edge replacements between non-adjacent nodes to improve smoothness and reduce path length. Throughout, collision checks are cached per node and edge to avoid redundant testing, improving efficiency within the fixed overall time budget.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n        self._is_in_obstacle_cache = None\n        self._edge_collision_cache = dict()  # key: Node -> bool\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self.goal_sample_rate_start = 0.15\n        self.goal_sample_rate_goal = 0.20\n        self.no_improve_limit = 100\n\n    def _is_in_obstacle(self, node: Node, obstacles, is_3d):\n        if node._is_in_obstacle_cache is not None:\n            return node._is_in_obstacle_cache\n        pos = node.position\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    node._is_in_obstacle_cache = True\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    node._is_in_obstacle_cache = True\n                    return True\n        node._is_in_obstacle_cache = False\n        return False\n\n    def _is_edge_in_obstacle(self, from_node: Node, to_node: Node, obstacles, is_3d, resolution=1.0):\n        if to_node in from_node._edge_collision_cache:\n            return from_node._edge_collision_cache[to_node]\n        from_pos = from_node.position\n        to_pos = to_node.position\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = interp\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        from_node._edge_collision_cache[to_node] = True\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = interp\n                    if x <= px <= x + w and y <= py <= y + h:\n                        from_node._edge_collision_cache[to_node] = True\n                        return True\n        from_node._edge_collision_cache[to_node] = False\n        return False\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._point_in_obstacles(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._point_in_obstacles(pt, obstacles, is_3d):\n                return pt\n\n    def _point_in_obstacles(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        res = []\n        for node in tree:\n            d2 = sum((node.position[d] - point[d]) ** 2 for d in range(len(point)))\n            if d2 <= radius_sq:\n                res.append(node)\n        return res\n\n    def _update_costs_recursive(self, node: Node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            for c in curr.children:\n                new_cost = curr.cost + self._dist(curr.position, c.position)\n                if new_cost + self.improve_tol < c.cost:\n                    c.cost = new_cost\n                    c.parent = curr\n                    stack.append(c)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_checks=100) -> List[Tuple[float, ...]]:\n        # Attempt to shortcut path by connecting non-consecutive waypoints directly if collision-free\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        checks = 0\n        i = 0\n        while i < len(new_path) - 2 and checks < max_checks:\n            j = len(new_path) - 1\n            shortcut_made = False\n            while j > i + 1:\n                if self._edge_collision_free(new_path[i], new_path[j], obstacles, is_3d):\n                    # Remove intermediate waypoints i+1..j-1\n                    del new_path[i + 1:j]\n                    shortcut_made = True\n                    break\n                j -= 1\n                checks += 1\n            if not shortcut_made:\n                i += 1\n        return new_path\n\n    def _edge_collision_free(self, p1, p2, obstacles, is_3d):\n        dist = math.dist(p1, p2)\n        steps = max(1, int(dist))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(len(p1)))\n            if self._point_in_obstacles(interp, obstacles, is_3d):\n                return False\n        return True\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start[:] + tree_goal[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        best_connect_nodes = (None, None)\n        found_solution = False\n\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            bias_goal = goal_pos if expand_start else start_pos\n            goal_sample_rate = self.goal_sample_rate_start if expand_start else self.goal_sample_rate_goal\n\n            sample = self._sample(bounds, obstacles, is_3d, bias_goal, goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n            new_node = Node(new_pos)\n\n            if self._is_in_obstacle(new_node, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node, new_node, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a)\n            dim = len(bounds)\n            # Shrinking radius based on RRT* formula r = min(gamma*(log(n)/n)^(1/d), step_size*12)\n            gamma = 30.0\n            radius = gamma * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)\n            max_radius = self.step_size * 12.0\n            radius = min(radius, max_radius)\n            radius = max(radius, self.step_size)  # Avoid radius too small\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent based on cost + collision-free edge\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node, new_node, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near_node\n\n            # Link new_node\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to use new_node if cheaper\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node, near_node, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n\n            # Try to connect to opposite tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node, nearest_other, obstacles, is_3d):\n                    # Connect nodes\n                    # Create connecting node to avoid duplicates\n                    connect_node = Node(new_node.position)\n                    connect_node.cost = nearest_other.cost + dist_connect\n                    connect_node.parent = nearest_other\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        end_node = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        end_node = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_connect_nodes = (new_node, connect_node)\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if no_improve_count > self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                if no_improve_count > self.no_improve_limit:\n                    break\n\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Local shortcut smoothing to improve path length and smoothness\n        smoothed_path = self._shortcut_path(best_path, obstacles, is_3d, max_checks=500)\n\n        return PlannerResult(success=True, path=smoothed_path, nodes=nodes, edges=edges)",
    "objective": 75.25648,
    "time_improvement": -310.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1876.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0697739601135254,
            "num_nodes_avg": 461.0,
            "path_length_avg": 160.1322122129521,
            "smoothness_avg": 0.05444228315017415,
            "success_improvement": 0.0,
            "time_improvement": -169.78612780707255,
            "length_improvement": 12.228997028799087,
            "smoothness_improvement": 752.1399546103157,
            "objective_score": -39.837740351790735
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1828937530517578,
            "num_nodes_avg": 985.7,
            "path_length_avg": 235.43979031050804,
            "smoothness_avg": 0.12414808797068062,
            "success_improvement": 0.0,
            "time_improvement": -11.299904806771973,
            "length_improvement": 21.40342123573591,
            "smoothness_improvement": 3094.419723738984,
            "objective_score": 24.924179918104876
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4148143768310547,
            "num_nodes_avg": 1113.0,
            "path_length_avg": 138.52144709694866,
            "smoothness_avg": 0.14781199484593088,
            "success_improvement": 0.0,
            "time_improvement": -748.523521387713,
            "length_improvement": 8.000650520690224,
            "smoothness_improvement": 1780.157664093688,
            "objective_score": -210.8558777834313
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved bidirectional RRT* planner featuring adaptive rewiring radius based on tree size and workspace scale, goal-biased sampling to accelerate convergence, incremental non-recursive rewiring for cost optimization, early termination upon first valid path discovery to limit planning time, and a concise post-processing shortcutting for path smoothness within a 30-second hard time limit.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal states, samples points biased towards the goal, connects new nodes via a step-size limited extension, rewires neighbors within an adaptively computed radius to minimize path cost, and attempts connection between trees. Upon connecting, it early-stops, extracts the combined path, and applies shortcutting to smooth the path while respecting collision constraints, all under strict collision checking and bounded workspace constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter:int=5000, step_size:float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # goal bias\n        self.gamma_rrt_star = 40.0   # rewiring radius factor\n        self.max_rewire_radius = 50.0\n        self.time_limit = 30.0       # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _build_path(self, node_start, node_goal):\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        shortcut = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut.append(path[j])\n            i = j\n        return shortcut\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = list(tree_start + tree_goal)\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for iter_count in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_count % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal if expand_start else start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2\n            radius = min(r, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                c = near.cost + math.dist(near.position, new_pos)\n                if c < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = c\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors non-recursively for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try connecting to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_b, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    cost = new_node.cost + (connect_node.cost - nearest_b.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_solution = True\n\n                # Early termination on first found solution\n                break\n\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            final_path = pruned_path\n        else:\n            final_path = best_path\n\n        return PlannerResult(\n            success=found_solution,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -36.26177,
    "time_improvement": 62.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1672.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012625908851623536,
            "num_nodes_avg": 103.0,
            "path_length_avg": 164.87498169989678,
            "smoothness_avg": 0.04858417756921969,
            "success_improvement": 0.0,
            "time_improvement": 51.18099856189387,
            "length_improvement": 9.629409919012868,
            "smoothness_improvement": 660.4478811885014,
            "objective_score": 24.43418492591839
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019319438934326173,
            "num_nodes_avg": 271.7,
            "path_length_avg": 232.03427155195612,
            "smoothness_avg": 0.12010507348073766,
            "success_improvement": 0.0,
            "time_improvement": 88.24316479687397,
            "length_improvement": 22.540281419763005,
            "smoothness_improvement": 2990.390048847121,
            "objective_score": 54.9490685351556
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025907230377197266,
            "num_nodes_avg": 366.8,
            "path_length_avg": 129.31737878879724,
            "smoothness_avg": 0.11528828010842909,
            "success_improvement": 0.0,
            "time_improvement": 47.00546659689346,
            "length_improvement": 14.113554440329642,
            "smoothness_improvement": 1366.458413283569,
            "objective_score": 29.402064709683664
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner using fixed step size and fixed neighbor radius with non-recursive rewiring, goal-biased sampling, and early termination upon first solution discovery to balance planning time and path quality. It alternates growing trees from start and goal, connects them when possible, and maintains coherent parent-child links with cost updates limited to local rewiring to reduce overhead. No extensive post-processing or adaptive radius computations are performed, favoring simplicity and efficiency.",
    "planning_mechanism": "A bidirectional RRT* alternates expansions from start and goal trees, samples points with goal bias, extends towards samples by a fixed step, connects trees when paths are close, refines connections locally with fixed radius rewiring, and stops when a collision-free connecting path is first found or timeout occurs, returning the best path discovered.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15          # goal bias sampling rate\n        self.fixed_radius = 14.0               # fixed neighbor radius for rewiring\n        self.time_limit = 30.0                 # seconds\n        self.improve_tol = 1e-9                # tolerance for cost improvement\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire locally but only with direct rewiring (no recursive updates)\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        success_state = True\n                    break  # early stop at first found solution\n\n            if success_state:\n                break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Avoid duplicate connection point\n        return path_start + path_goal[1:]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -29.41149,
    "time_improvement": 67.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 262.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015022873878479004,
            "num_nodes_avg": 127.2,
            "path_length_avg": 166.58720661496753,
            "smoothness_avg": 0.021817355324787333,
            "success_improvement": 0.0,
            "time_improvement": 41.91295770493012,
            "length_improvement": 8.69091231112256,
            "smoothness_improvement": 241.48898797830705,
            "objective_score": 18.995879638044105
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026909470558166504,
            "num_nodes_avg": 294.0,
            "path_length_avg": 243.31536602427045,
            "smoothness_avg": 0.014871472156801322,
            "success_improvement": 0.0,
            "time_improvement": 83.6242547295916,
            "length_improvement": 18.774327376604038,
            "smoothness_improvement": 282.65369008293095,
            "objective_score": 37.76514129525456
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01235973834991455,
            "num_nodes_avg": 187.9,
            "path_length_avg": 131.1163729137751,
            "smoothness_avg": 0.028411044937784503,
            "success_improvement": 0.0,
            "time_improvement": 74.71753802696283,
            "length_improvement": 12.918748201413955,
            "smoothness_improvement": 261.3863945234228,
            "objective_score": 31.473442301554336
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner using fixed step size and alternating tree expansion, with goal-biased sampling. It avoids rewiring complexity by only connecting the two trees upon proximity, returning the first valid path found. The planner uses straightforward nearest neighbor searches without radius-based rewiring, favoring simplicity and faster execution at some potential cost to path optimality.",
    "planning_mechanism": "The planner alternately grows trees from start and goal towards random samples biased towards the opposing root. Each extension adds one node per iteration. When nodes from opposing trees become close enough without obstacle collision, their paths are joined to form a complete path. The search stops immediately on finding the first valid connection or upon timeout.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        best_path: List[Tuple[float, ...]] = []\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            target_pos = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, target_pos, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = self._nearest(tree_b, new_pos)\n            dist_connect = self._dist(nearest_other.position, new_pos)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_pos, obstacles, is_3d):\n                    # Connect trees by joining paths at new_node and nearest_other\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    best_path = full_path\n                    success_state = True\n                    break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.13292,
    "time_improvement": 75.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 70.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009052515029907227,
            "num_nodes_avg": 133.0,
            "path_length_avg": 187.79218656493885,
            "smoothness_avg": 0.010962478903348437,
            "success_improvement": 0.0,
            "time_improvement": 64.99778752903869,
            "length_improvement": -2.9318732138665764,
            "smoothness_improvement": 71.58660024136036,
            "objective_score": 18.098145331598463
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.012996983528137208,
            "num_nodes_avg": 247.6,
            "path_length_avg": 300.7967885143761,
            "smoothness_avg": 0.006699421567300454,
            "success_improvement": -9.999999999999998,
            "time_improvement": 92.09069197105116,
            "length_improvement": -0.4146259616027489,
            "smoothness_improvement": 72.38094232495153,
            "objective_score": -22.259663274021538
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015647459030151366,
            "num_nodes_avg": 281.1,
            "path_length_avg": 161.01680067002653,
            "smoothness_avg": 0.012993460184377598,
            "success_improvement": 0.0,
            "time_improvement": 67.9923412046021,
            "length_improvement": -6.939692208921777,
            "smoothness_improvement": 65.27585446781657,
            "objective_score": 16.560266308366643
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, robust bidirectional RRT planner that alternately grows from start and goal using fixed step size with goal-biased uniform sampling; it connects trees when close to return the first found valid path, employing straightforward nearest neighbor search, edge and node collision checks, and early termination on timeout or success.",
    "planning_mechanism": "The planner grows two trees towards random samples biased toward the opposite root. Each iteration extends one tree by one step towards a sampled point if collision-free, then attempts to connect to the other tree within step size. Upon a valid connection, the combined path is returned immediately, or search continues until timeout or max iterations.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        time_start = time.monotonic()\n\n        def timed_out() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        success_state = False\n        best_path: List[Tuple[float, ...]] = []\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            target_pos = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, target_pos, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + self._dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = self._nearest(tree_b, new_pos)\n            dist_connect = self._dist(nearest_other.position, new_pos)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_pos, obstacles, is_3d):\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    path_goal.reverse()\n                    full_path = path_start + path_goal[1:]\n                    best_path = full_path\n                    success_state = True\n                    break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.50358,
    "time_improvement": 71.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 68.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.006746768951416016,
            "num_nodes_avg": 112.7,
            "path_length_avg": 185.69147288854546,
            "smoothness_avg": 0.011008752120412364,
            "success_improvement": -9.999999999999998,
            "time_improvement": 73.91312364025222,
            "length_improvement": -1.7804387598969678,
            "smoothness_improvement": 72.31087657230997,
            "objective_score": -28.53277178100096
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.013434934616088866,
            "num_nodes_avg": 251.9,
            "path_length_avg": 299.2992156739375,
            "smoothness_avg": 0.006791300376937275,
            "success_improvement": -9.999999999999998,
            "time_improvement": 91.82417704866752,
            "length_improvement": 0.08530695777982564,
            "smoothness_improvement": 74.74505027453861,
            "objective_score": -22.027837459359148
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025540781021118165,
            "num_nodes_avg": 374.2,
            "path_length_avg": 169.53907414203047,
            "smoothness_avg": 0.012314917468678346,
            "success_improvement": 0.0,
            "time_improvement": 47.75505705324628,
            "length_improvement": -12.599780461973333,
            "smoothness_improvement": 56.64484120893548,
            "objective_score": 7.049873044834561
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased sampling, and recursive cost updates that efficiently balances exploration and exploitation. The algorithm alternates expansions between start and goal trees with fixed-radius neighbor search to limit rewiring overhead. It tracks the best path with early termination on improvement to reduce planning time. Edge and node collision checks ensure path validity, while cost updates propagate recursively for consistent, smooth, and low-cost paths within a 30-second time limit.",
    "planning_mechanism": "A bidirectional sampling-based planner that samples with goal bias, grows two trees by fixed step sizes, uses adaptive fixed-radius rewiring based on node count and dimension to reduce neighbor evaluations, connects trees when close, and performs recursive cost updating for optimized rewiring. Early stopping on solution improvement and efficient collision checks contribute to reduced planning time and improved path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15    # Goal bias probability\n        self.time_limit = 30.0          # Hard time limit in seconds\n        self.improve_tol = 1e-9         # Small tolerance for cost improvements\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        found_solution = False\n        success = False\n\n        # Adaptive fixed radius for neighbor search (based on RRT* theory)\n        def rewiring_radius(n: int) -> float:\n            if n <= 1:\n                return self.step_size * 2\n            gamma_r = 30.0  # hand-tuned constant for radius scaling\n            r = gamma_r * (math.log(n) / n) ** (1/dim)\n            return max(r, self.step_size)\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            # Alternate trees\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose parent minimizing cost + distance from parent to new node\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node offers cheaper path\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    # Link trees by adding new node to tree_b\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path from start to goal\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        best_path = path\n                        found_solution = True\n                        success = True\n\n            if found_solution:\n                # Early termination on improvement to reduce planning time\n                break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        # Upon rewiring, recursively update costs and edges of children\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Exclude duplicate connecting position to avoid repetition\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.71377,
    "time_improvement": 70.0,
    "length_improvement": 5.0,
    "smoothness_improvement": 135.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013166141510009766,
            "num_nodes_avg": 149.0,
            "path_length_avg": 167.92513770947517,
            "smoothness_avg": 0.01719467639795058,
            "success_improvement": 0.0,
            "time_improvement": 49.09214941553891,
            "length_improvement": 7.957571077348025,
            "smoothness_improvement": 169.13402446535358,
            "objective_score": 20.347857593397258
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018252086639404298,
            "num_nodes_avg": 260.9,
            "path_length_avg": 286.64962201456353,
            "smoothness_avg": 0.008089599894158899,
            "success_improvement": 0.0,
            "time_improvement": 88.8927015188115,
            "length_improvement": 4.308105419644362,
            "smoothness_improvement": 108.15123197999512,
            "objective_score": 29.793429867330044
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01366419792175293,
            "num_nodes_avg": 218.6,
            "path_length_avg": 146.1829738133406,
            "smoothness_avg": 0.017891955502714767,
            "success_improvement": 0.0,
            "time_improvement": 72.04920083513254,
            "length_improvement": 2.912229278360186,
            "smoothness_improvement": 127.5843533477518,
            "objective_score": 24.00001958429463
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* with adaptive fixed-radius rewiring, goal-biased sampling, batch informed sampling after initial connection, local rewiring without costly recursive cost updates, and early stopping. The planner uses a KD-tree for efficient nearest neighbor queries, alternates start/goal tree expansions, connects trees promptly with consistent parent-child edges, and performs local smoothing shortcutting on the best path found to improve path smoothness and length within a strict 30s time limit.",
    "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal by sampling with goal bias. Each new node is connected using fixed-radius rewiring around the new node with efficient collision checks and local rewiring without full recursive cost updates to limit overhead. After initial path connection, the planner performs ellipsoidal informed batch sampling around the best path to refine it. The best path found is locally shortcut-smoothed before returning. The planner stops early when time limit is reached or no improvement is observed over several iterations.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # for extension if needed\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.17  # goal bias probability\n        self.fixed_radius = 20.0       # fixed radius for rewiring (adjusted)\n        self.time_limit = 30.0         # seconds\n        self.improve_tol = 1e-8\n        self.batch_informed_iters = 1500 # iterations for post-initial solution refinement\n        self.no_improve_limit = 150      # iterations without improvement before stopping refinement\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        # Trees initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Fast Euclidean distance function alias\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        # Sample function with goal bias\n        def sample():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        # Steer from from_pos toward to_pos by at most step_size\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Find nearest node in a tree\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Find nodes near a point within fixed radius\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            rad_sq = radius*radius\n            return [n for n in tree if (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 + (0 if dim==2 else (n.position[2]-point[2])**2) <= rad_sq]\n\n        # Build path from joining two nodes from different trees (avoid double node)\n        def build_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path1 = node_start.path_from_root()\n            path2 = node_goal.path_from_root()\n            path2.reverse()\n            return path1 + path2[1:]\n\n        # Local shortcut smoothing of path (simple random short-circuiting)\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts: int = 1000) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                p_start = new_path[i]\n                p_end = new_path[j]\n                if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                    # shortcut possible, replace intermediate points\n                    new_path = new_path[:i+1] + new_path[j:]\n                attempts += 1\n            return new_path\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            q_rand = sample()\n            q_near = nearest(tree_a, q_rand)\n            q_new_pos = steer(q_near.position, q_rand)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = near(tree_a, q_new_pos, self.fixed_radius)\n            min_cost = q_near.cost + dist(q_near.position, q_new_pos)\n            best_parent = q_near\n\n            for nnode in neighbors:\n                c_cand = nnode.cost + dist(nnode.position, q_new_pos)\n                if c_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(nnode.position, q_new_pos, obstacles, is_3d):\n                        min_cost = c_cand\n                        best_parent = nnode\n\n            q_new = Node(q_new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((best_parent, q_new))\n\n            # Local rewiring - only neighbors of q_new\n            for nnode in neighbors:\n                if nnode is best_parent:\n                    continue\n                c_through_new = q_new.cost + dist(q_new.position, nnode.position)\n                if c_through_new + self.improve_tol < nnode.cost:\n                    if not self._is_edge_in_obstacle(q_new.position, nnode.position, obstacles, is_3d):\n                        if nnode.parent:\n                            try:\n                                edges.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            nnode.parent.remove_child(nnode)\n                        nnode.parent = q_new\n                        nnode.cost = c_through_new\n                        q_new.add_child(nnode)\n                        edges.append((q_new, nnode))\n\n            # Attempt connect to other tree within step size\n            q_new_near_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, q_new_near_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(q_new.position, q_new_near_other.position, obstacles, is_3d):\n                    # Connect trees by adding node to tree_b\n                    connect_node = Node(q_new.position, parent=q_new_near_other, cost=q_new_near_other.cost + d_connect)\n                    q_new_near_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((q_new_near_other, connect_node))\n\n                    # Build candidate path and cost\n                    if expand_start:\n                        candidate_path = build_path(q_new, connect_node)\n                        candidate_cost = q_new.cost + (connect_node.cost - q_new_near_other.cost)\n                    else:\n                        candidate_path = build_path(connect_node, q_new)\n                        candidate_cost = connect_node.cost + (q_new.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else q_new\n                        found_solution = True\n                        success_state = True\n                        # break early after first found path - balanced trees and fixed radius helps fast first solution\n                        break\n\n            if found_solution:\n                break\n\n        # If no solution found, return immediately\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Refinement phase - batch ellipsoidal informed sampling around best path to improve path quality\n        c_min = dist(start_pos, goal_pos)\n        c_best = best_cost\n\n        # Reset nodes and edges for refinement\n        # We'll maintain a single tree from start_root built along best_path\n        refinement_tree: List[Node] = [start_root]\n        start_root.children.clear()\n        start_root.cost = 0.0\n        nodes_refine: List[Node] = [start_root]\n        edges_refine: List[Tuple[Node, Node]] = []\n        prev_node = start_root\n        for pos in best_path[1:]:\n            cost_inc = dist(prev_node.position, pos)\n            new_node = Node(pos, parent=prev_node, cost=prev_node.cost + cost_inc)\n            prev_node.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((prev_node, new_node))\n            prev_node = new_node\n        best_goal_node_refine = prev_node\n\n        no_improve_count = 0\n        for _ in range(self.batch_informed_iters):\n            if timed_out() or no_improve_count >= self.no_improve_limit:\n                break\n\n            sample_pt = self._ellipsoidal_informed_sample(c_best, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest_node = nearest(refinement_tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            near_nodes = near(refinement_tree, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                c_cand = nnode.cost + dist(nnode.position, new_pos)\n                if c_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                        min_cost = c_cand\n                        best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((best_parent, new_node))\n\n            # Local rewiring (no recursive update)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if c_through_new + self.improve_tol < nnode.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nnode.position, obstacles, is_3d):\n                        if nnode.parent:\n                            try:\n                                edges_refine.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            nnode.parent.remove_child(nnode)\n                        nnode.parent = new_node\n                        nnode.cost = c_through_new\n                        new_node.add_child(nnode)\n                        edges_refine.append((new_node, nnode))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    refinement_tree.append(goal_node)\n                    nodes_refine.append(goal_node)\n                    edges_refine.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node_refine = goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n        refined_path = best_goal_node_refine.path_from_root()\n        smoothed_path = shortcut_path(refined_path)\n\n        # Merge nodes & edges from refinement with original exploration sets\n        # Avoid duplicates: merge unique nodes and edges smoothly\n        # To maximize correctness, we return the refinement constructs only (plus roots) as final\n        # as this is a refinement phase\n\n        return PlannerResult(success=True, path=smoothed_path, nodes=nodes_refine, edges=edges_refine)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        r1 = c_best * 0.5\n        r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) * 0.5\n\n        while True:\n            # Sample uniformly on unit ball scaled by radii\n            unit_vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm = math.sqrt(sum(x*x for x in unit_vec))\n            if norm < 1e-12:\n                continue\n            unit_vec = [x / norm for x in unit_vec]\n            radius_sample = random.random()**(1/dim)\n            point_ball = [radius_sample * x for x in unit_vec]\n\n            # Scale along ellipsoid axes\n            scaled_point = [r1 * point_ball[0]] + [r2 * point_ball[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point_ellipsoid = [center[i] + dir_a1[i] * scaled_point[0] for i in range(dim)]\n            for i in range(1, dim):\n                point_ellipsoid[i] += scaled_point[i]\n\n            pt = tuple(max(0.0, min(bounds[i], point_ellipsoid[i])) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt",
    "objective": -1.30336,
    "time_improvement": -57.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1415.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07969634532928467,
            "num_nodes_avg": 126.6,
            "path_length_avg": 164.59211520466957,
            "smoothness_avg": 0.0466929822427923,
            "success_improvement": 0.0,
            "time_improvement": -208.15175707068846,
            "length_improvement": 9.784453527353355,
            "smoothness_improvement": 630.8465675335299,
            "objective_score": -53.42062216712688
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08926122188568116,
            "num_nodes_avg": 156.6,
            "path_length_avg": 230.74519409081557,
            "smoothness_avg": 0.09485063519652866,
            "success_improvement": 0.0,
            "time_improvement": 45.6801266689465,
            "length_improvement": 22.97061258032915,
            "smoothness_improvement": 2340.575161757774,
            "objective_score": 39.18928135767031
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05235123634338379,
            "num_nodes_avg": 150.2,
            "path_length_avg": 115.69614454467587,
            "smoothness_avg": 0.10804272239445294,
            "success_improvement": 0.0,
            "time_improvement": -7.087068077151739,
            "length_improvement": 23.160129651801483,
            "smoothness_improvement": 1274.2954539732307,
            "objective_score": 18.141434637801524
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with adaptive fixed-radius rewiring, goal-biased and informed sampling, early solution detection with incremental local refinement, and progressive shortcut smoothing to balance fast convergence and high-quality smooth paths within a strict 30-second limit. The planner alternates growing trees from start and goal, performs rewiring without costly recursive subtree updates, employs ellipsoidal informed sampling after initial solution, and uses multiple passes of efficient local shortcut smoothing to enhance path smoothness and reduce length.",
    "planning_mechanism": "The algorithm maintains two RRT* trees grown alternately towards sampled points with goal bias; neighbors are searched within an adaptively computed fixed radius based on node count and environment dimension. Rewiring updates costs locally without recursive cascades. Upon first connection of the two trees, the best path is recorded and a shorter refinement phase using ellipsoidal sampling improves the path incrementally. After planning or timeout, the final path undergoes multiple iterative shortcut smoothing passes, reducing sharp turns and unnecessary waypoints for smoothness improvements. The time limit is enforced strictly to stop planning and return the current best path if exceeded.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.check_resolution = 1.0\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample(goal):\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            res = []\n            r2 = radius * radius\n            for node in tree:\n                d_ = dist(node.position, point)\n                if d_ <= radius:\n                    res.append(node)\n            return res\n\n        def rewiring_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            gamma = 20.0  # Tuned constant\n            r = gamma * (math.log(n)/n) ** (1/dim)\n            return max(r, self.step_size)\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            # Multiple passes of shortcutting for smoother curves\n            if len(path) <= 2:\n                return path[:]\n            for _ in range(3):  # Iteratively improve smoothness\n                new_path = [path[0]]\n                i = 0\n                n = len(path)\n                while i < n - 1:\n                    j = n - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        best_goal_node = None\n\n        for iter_ in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (iter_ % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = sample(sample_goal)\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nnode in near_nodes:\n                cc = nnode.cost + dist(nnode.position, new_pos)\n                if cc + self.improve_tol < min_cost and not is_edge_in_obstacle(nnode.position, new_pos):\n                    min_cost = cc\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Local rewiring (no recursive cost update for speed)\n            for nnode in near_nodes:\n                if nnode is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_through_new + self.improve_tol < nnode.cost and not is_edge_in_obstacle(new_node.position, nnode.position):\n                    if nnode.parent:\n                        try:\n                            edges.remove((nnode.parent, nnode))\n                        except ValueError:\n                            pass\n                        nnode.parent.remove_child(nnode)\n                    nnode.parent = new_node\n                    nnode.cost = cost_through_new\n                    new_node.add_child(nnode)\n                    edges.append((new_node, nnode))\n\n            # Try connecting trees\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(nearest_other.position, new_node.position):\n                # Connect trees by adding a node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = build_path(new_node, connect_node)\n                    path_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = build_path(connect_node, new_node)\n                    path_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if path_cost + self.improve_tol < best_cost:\n                    best_cost = path_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n\n            if found_solution:\n                # Early stop after first solution to save time\n                break\n\n        # Incremental Refinement via ellipsoidal informed sampling to improve path\n        if found_solution and best_goal_node:\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            tree = [start_root]\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            # Insert best path nodes into new tree (no duplicates)\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + dist(prev_node.position, pos)\n                n_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 100\n            refinement_iters = min(self.max_iter//3, 1000)\n\n            def ellipsoidal_sample():\n                if c_best == float('inf') or c_best < c_min - 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                center = tuple((s+g)*0.5 for s,g in zip(start_pos, goal_pos))\n                a1 = tuple(g - s for s,g in zip(start_pos, goal_pos))\n                norm_a1 = math.sqrt(sum(x*x for x in a1))\n                if norm_a1 < 1e-12:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(pt):\n                            return pt\n                c1 = c_best * 0.5\n                c2 = 0.5 * math.sqrt(max(c_best*c_best - c_min*c_min, 0))\n                while True:\n                    rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n                    if norm_dir < 1e-12:\n                        continue\n                    unit_dir = [x / norm_dir for x in rnd_dir]\n                    r = random.random() ** (1.0/dim)\n                    ball_point = [r * x for x in unit_dir]\n                    scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n                    dir_a1 = [x / norm_a1 for x in a1]\n                    point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n                    for i in range(1, dim):\n                        point[i] += scaled[i]\n                    pt = tuple(max(0, min(bounds[d], point[d])) for d in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            for _ in range(refinement_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n                s_pt = ellipsoidal_sample()\n                n_node = nearest(tree, s_pt)\n                new_pos = steer(n_node.position, s_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(n_node.position, new_pos):\n                    no_improve_count += 1\n                    continue\n                near_nodes = near(tree, new_pos, rewiring_radius(len(tree)))\n                min_cost = n_node.cost + dist(n_node.position, new_pos)\n                best_parent = n_node\n                for n_ in near_nodes:\n                    c_cand = n_.cost + dist(n_.position, new_pos)\n                    if c_cand + self.improve_tol < min_cost and not is_edge_in_obstacle(n_.position, new_pos):\n                        min_cost = c_cand\n                        best_parent = n_\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                rewired_flag = False\n                for n_ in near_nodes:\n                    if n_ is best_parent: \n                        continue\n                    cost_th = new_node.cost + dist(new_node.position, n_.position)\n                    if cost_th + self.improve_tol < n_.cost and not is_edge_in_obstacle(new_node.position, n_.position):\n                        if n_.parent:\n                            try:\n                                edges.remove((n_.parent, n_))\n                            except Exception:\n                                pass\n                            n_.parent.remove_child(n_)\n                        n_.parent = new_node\n                        n_.cost = cost_th\n                        new_node.add_child(n_)\n                        edges.append((new_node, n_))\n                        rewired_flag = True\n                dist_to_goal = dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        found_solution = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n                if not rewired_flag:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if found_solution else best_path\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = best_path\n\n        success_state = bool(extracted_path)\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -36.43867,
    "time_improvement": 60.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1653.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017981839179992676,
            "num_nodes_avg": 185.9,
            "path_length_avg": 162.59923720922134,
            "smoothness_avg": 0.05228999958836421,
            "success_improvement": 0.0,
            "time_improvement": 30.471901618791254,
            "length_improvement": 10.87678153583121,
            "smoothness_improvement": 718.4520431094295,
            "objective_score": 19.25989962268325
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022843813896179198,
            "num_nodes_avg": 366.6,
            "path_length_avg": 235.69548545844145,
            "smoothness_avg": 0.1106068428399279,
            "success_improvement": 0.0,
            "time_improvement": 86.09840812141438,
            "length_improvement": 21.318062835578978,
            "smoothness_improvement": 2745.9937331600827,
            "objective_score": 52.35032880357211
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018364214897155763,
            "num_nodes_avg": 319.3,
            "path_length_avg": 121.68574565278978,
            "smoothness_avg": 0.12525212938789504,
            "success_improvement": 0.0,
            "time_improvement": 62.43508141859384,
            "length_improvement": 19.182121789947647,
            "smoothness_improvement": 1493.1978406635246,
            "objective_score": 37.705786702864366
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner that alternates tree expansions with fixed-radius rewiring, efficient nearest neighbor via squared distance, direct tree connection without redundant node insertion, and local path shortcut smoothing to improve runtime, path length, and smoothness within a 30-second limit. The planner samples with goal bias, uses fixed step size steering, rewires neighbors without recursion, and terminates early upon solution or time-out.",
    "planning_mechanism": "A bidirectional RRT* alternates growing two trees from start and goal by sampling random free points biased towards the goal. Each expansion extends the nearest node towards the sample with a fixed step size, then locally rewires nearby nodes within a fixed radius to lower cost edges if collision-free. The two trees attempt connection directly linking existing nodes without creating duplicate nodes. The best path found is locally shortcut-smoothed before return. The planner respects obstacles and map bounds, and aborts after 30 seconds, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost to reach this node from start of its tree\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.15\n        self.neighbor_radius = 10.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        def squared_dist(p1, p2):\n            return sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n        def dist(p1, p2):\n            return math.sqrt(squared_dist(p1, p2))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_bias and not is_in_obstacle(goal_pos):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = squared_dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            rsq = radius * radius\n            return [node for node in tree if squared_dist(node.position, point) <= rsq]\n\n        def try_rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n\n        def connect_trees(node_a, tree_b):\n            nearest_b = nearest(tree_b, node_a.position)\n            d = dist(nearest_b.position, node_a.position)\n            if d <= self.step_size and not is_edge_in_obstacle(nearest_b.position, node_a.position):\n                return nearest_b\n            # otherwise try to extend from nearest_b toward node_a.position\n            new_pos = steer(nearest_b.position, node_a.position)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_b.position, new_pos):\n                return None\n            new_node_b = Node(new_pos, parent=nearest_b, cost=nearest_b.cost + dist(nearest_b.position,new_pos))\n            nearest_b.add_child(new_node_b)\n            tree_b.append(new_node_b)\n            nodes.append(new_node_b)\n            edges.append((nearest_b, new_node_b))\n            # Check if can connect to node_a from new_node_b\n            d2 = dist(new_node_b.position, node_a.position)\n            if d2 <= self.step_size and not is_edge_in_obstacle(new_node_b.position, node_a.position):\n                return new_node_b\n            return None\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            # Remove duplicate join node\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            # Simple shortcutting: attempt to connect farther apart points directly if free of collision\n            if len(path) < 3:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n\n        start_time = time.monotonic()\n\n        # Alternate tree expansion\n        for iter_num in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start_tree = (iter_num % 2 == 0)\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            sample_pt = sample_free()\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            # Fixed radius for neighbor search\n            radius = min(self.neighbor_radius, self.step_size * 3)\n            neighbors = near(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for near_node in neighbors:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c + self.improve_tol < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                    min_cost = c\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            try_rewire(tree_a, new_node, neighbors)\n\n            # Try connect trees\n            connect_node = connect_trees(new_node, tree_b)\n            if connect_node is not None:\n                # Found connection\n                if expand_start_tree:\n                    path = build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost)\n                else:\n                    path = build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start_tree else new_node\n                    found_solution = True\n                    # Early stop on first feasible solution\n                    break\n\n        if found_solution and best_path:\n            # Local shortcut smoothing\n            extracted_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -12.82539,
    "time_improvement": 39.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1607.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018108892440795898,
            "num_nodes_avg": 102.3,
            "path_length_avg": 164.77637252876158,
            "smoothness_avg": 0.04708108784799129,
            "success_improvement": 0.0,
            "time_improvement": 29.980640879088465,
            "length_improvement": 9.683459168274378,
            "smoothness_improvement": 636.921263039705,
            "objective_score": 17.98887407988969
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06826229095458984,
            "num_nodes_avg": 304.5,
            "path_length_avg": 231.02962854672919,
            "smoothness_avg": 0.11453600574072098,
            "success_improvement": 0.0,
            "time_improvement": 58.459015912982274,
            "length_improvement": 22.875660171953314,
            "smoothness_improvement": 2847.093924659134,
            "objective_score": 45.49857050036234
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.03563137054443359,
            "num_nodes_avg": 208.7,
            "path_length_avg": 125.0374948050732,
            "smoothness_avg": 0.11290655095417428,
            "success_improvement": -9.999999999999998,
            "time_improvement": 27.114252314000858,
            "length_improvement": 16.956049596144418,
            "smoothness_improvement": 1336.1629942424065,
            "objective_score": -25.011279576901057
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT* planner with fixed step size and fixed neighbor radius rewiring that alternately grows trees from start and goal positions, uses straightforward nearest and near searches without spatial indexing, attempts direct tree connection, and applies simple path shortcutting for smoothing. The planner respects collision constraints, uses goal-biased sampling, and terminates when a path is found or after 30 seconds, returning the best path found with updated parent-child and edge relations.",
    "planning_mechanism": "The planner alternately samples points biased toward the goal, extends the nearest tree node toward each sample by a fixed step, locally rewires nearby nodes for cost improvement without recursion, attempts direct connections between the two trees to form a solution, and upon success extracts and shortcut smooths the path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.15\n        self.neighbor_radius = 10.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        def dist_sq(p1, p2):\n            return sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n        def dist(p1, p2):\n            return dist_sq(p1, p2) ** 0.5\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            if length == 0:\n                return is_in_obstacle(a)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_bias and not is_in_obstacle(goal_pos):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            rsq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= rsq]\n\n        def rewire(tree, new_node, neighbors):\n            for n in neighbors:\n                if n is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, n.position)\n                if new_cost + self.improve_tol < n.cost and not is_edge_in_obstacle(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n\n        def try_connect_trees(node, other_tree):\n            nearest_other = nearest(other_tree, node.position)\n            d = dist(nearest_other.position, node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(nearest_other.position, node.position):\n                return nearest_other\n            new_pos = steer(nearest_other.position, node.position)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_other.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_other, cost=nearest_other.cost + dist(nearest_other.position, new_pos))\n            nearest_other.add_child(new_node)\n            other_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_other, new_node))\n            d2 = dist(new_node.position, node.position)\n            if d2 <= self.step_size and not is_edge_in_obstacle(new_node.position, node.position):\n                return new_node\n            return None\n\n        def build_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal[1:]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n            expand_start = (i % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n\n            sample_point = sample_free()\n            nearest_node = nearest(tree_a, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            radius = min(self.neighbor_radius, self.step_size * 3)\n            neighbors = near(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for n in neighbors:\n                c = n.cost + dist(n.position, new_pos)\n                if c + self.improve_tol < min_cost and not is_edge_in_obstacle(n.position, new_pos):\n                    min_cost = c\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_node = try_connect_trees(new_node, tree_b)\n            if connect_node is not None:\n                if expand_start:\n                    path = build_path(new_node, connect_node)\n                    total_cost = new_node.cost + connect_node.cost\n                else:\n                    path = build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + new_node.cost\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    found_solution = True\n                    break\n\n        if found_solution and best_path:\n            extracted_path = shortcut_path(best_path)\n            success = True\n        else:\n            extracted_path = []\n            success = False\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -11.29505,
    "time_improvement": 33.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1616.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02131044864654541,
            "num_nodes_avg": 110.1,
            "path_length_avg": 165.8926028653907,
            "smoothness_avg": 0.04500992534693937,
            "success_improvement": -9.999999999999998,
            "time_improvement": 17.601589291640547,
            "length_improvement": 9.071635632966382,
            "smoothness_improvement": 604.5030722968849,
            "objective_score": -36.25402647124358
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06913847923278808,
            "num_nodes_avg": 312.0,
            "path_length_avg": 229.98767527652814,
            "smoothness_avg": 0.09634177277909464,
            "success_improvement": 0.0,
            "time_improvement": 57.92581196080203,
            "length_improvement": 23.223494164508413,
            "smoothness_improvement": 2378.943205780185,
            "objective_score": 43.20655611584658
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.036767983436584474,
            "num_nodes_avg": 218.4,
            "path_length_avg": 125.04624495523436,
            "smoothness_avg": 0.15449328015664665,
            "success_improvement": 0.0,
            "time_improvement": 24.789253886824024,
            "length_improvement": 16.95023816304475,
            "smoothness_improvement": 1865.14312008481,
            "objective_score": 26.93263466429811
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "An efficient bidirectional RRT* planner employing fixed-radius neighbor search and non-recursive rewiring to reduce computational overhead, combined with goal-biased uniform and ellipsoidal informed sampling. It integrates lazy collision checking, incremental tree rewiring without costly recursion, and early stopping upon finding an initial solution, followed by a limited focused refinement phase, ensuring real-time planning under 30 seconds while improving path length and smoothness.",
    "planning_mechanism": "A bidirectional RRT* grows two trees alternately towards random samples biased towards the goal, connecting when close enough to form an initial path. It uses a fixed neighborhood radius for rewiring without recursive cost updates to minimize overhead. After an initial solution is found, a single-tree ellipsoidal informed sampling refines the path within a constrained subset of the space. The algorithm terminates early once no better path is found or the time limit is reached, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2\n        self.gamma_rrt_star = 30.0\n        self.time_limit = 30.0\n        self.max_radius_factor = 8.0\n        self.improve_tol = 5e-4\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        result = []\n        r_sq = radius * radius\n        for node in tree:\n            dx = [node.position[i] - point[i] for i in range(len(point))]\n            dist_sq = sum(x*x for x in dx)\n            if dist_sq <= r_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        dim = len(bounds)\n        center = tuple((s + g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n\n        while True:\n            rnd = [random.gauss(0,1) for _ in range(dim)]\n            norm_rnd = math.sqrt(sum(x*x for x in rnd))\n            if norm_rnd < 1e-12:\n                continue\n            unit = [x / norm_rnd for x in rnd]\n            r = random.random() ** (1.0/dim)\n            ball = [r * u for u in unit]\n            scaled = [c1 * ball[0]] + [c2 * ball[i] for i in range(1,dim)]\n            dir_a1 = [x/norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            candidate = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                return candidate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional RRT* growth until first connection\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            forward = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if forward else (tree_goal, tree_start)\n            sample_goal = goal_pos if forward else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent with minimal cost\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near_node in near_nodes:\n                cost_cand = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors (non-recursive)\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connect tree_b to new_node\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by new node in tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build full path\n                if forward:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if forward else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Single-tree refinement via ellipsoidal RRT*\n        if found_solution and best_goal_node:\n            tree = [start_root]\n            # Reset children and costs for refinement tree\n            start_root.children.clear()\n            start_root.cost = 0.0\n\n            # Build tree from best_path\n            prev = start_root\n            for pos in best_path[1:]:\n                cost_edge = self._dist(prev.position, pos)\n                node = Node(pos, parent=prev, cost=prev.cost + cost_edge)\n                prev.add_child(node)\n                tree.append(node)\n                nodes.append(node)\n                edges.append((prev, node))\n                prev = node\n\n            best_goal_node = prev\n            best_cost = best_goal_node.cost\n            no_improve = 0\n            c_min = self._dist(start_pos, goal_pos)\n            max_refine_iters = self.max_iter // 2\n\n            for _ in range(max_refine_iters):\n                if timed_out() or no_improve >= 100:\n                    break\n\n                sample_pt = self._ellipsoidal_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n                nearest = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    no_improve += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                # Best parent for new_node\n                min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near_node in near_nodes:\n                    temp_cost = near_node.cost + self._dist(near_node.position, new_pos)\n                    if temp_cost + self.improve_tol < min_cost:\n                        if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                            min_cost = temp_cost\n                            best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                improved = False\n                # Rewire neighbors non-recursively\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                            if near_node.parent:\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except ValueError:\n                                    pass\n                                near_node.parent.remove_child(near_node)\n                            near_node.parent = new_node\n                            near_node.cost = cost_through_new\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            improved = True\n\n                # Try connecting to goal\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve = 0\n                        success_state = True\n                        improved = True\n                    else:\n                        no_improve += 1\n                else:\n                    no_improve += 1 if not improved else 0\n\n                if not improved:\n                    no_improve += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": -10.92269,
    "time_improvement": 20.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 130.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016711997985839843,
            "num_nodes_avg": 194.0,
            "path_length_avg": 172.99902300391338,
            "smoothness_avg": 0.017078964704146486,
            "success_improvement": 0.0,
            "time_improvement": 35.381835613407574,
            "length_improvement": 5.176494146608862,
            "smoothness_improvement": 167.32288518535464,
            "objective_score": 14.557061597914362
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04023168087005615,
            "num_nodes_avg": 409.2,
            "path_length_avg": 276.1969595393081,
            "smoothness_avg": 0.007645722274144094,
            "success_improvement": 0.0,
            "time_improvement": 75.5170300989641,
            "length_improvement": 7.7975050170921545,
            "smoothness_improvement": 96.72994110488736,
            "objective_score": 27.817261745468954
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07361211776733398,
            "num_nodes_avg": 433.4,
            "path_length_avg": 138.1919014708765,
            "smoothness_avg": 0.017849425539286305,
            "success_improvement": 0.0,
            "time_improvement": -50.57726268292909,
            "length_improvement": 8.219519034250954,
            "smoothness_improvement": 127.04337535217714,
            "objective_score": -9.606250507567268
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A bidirectional RRT* planner with balanced tree growth, fixed radius local rewiring, efficient linear nearest-neighbor searches, goal biasing, early stopping upon first path found, and a focused refinement phase using ellipsoidal informed sampling and path shortcut smoothing. This design reduces planning time by avoiding costly recursive rewiring and radius computations, improves path quality by local rewiring and batch refinement, and enhances path smoothness by applying shortcutting techniques on the final path within a 30-second hard time limit.",
    "planning_mechanism": "A pair of trees grow alternately from start and goal states using goal-biased random sampling, connecting nodes with fixed-radius local rewiring and collision checking. Upon initial path connection, a single-tree refinement phase applies ellipsoidal informed sampling confined to the current best solution cost, performing local rewiring and attempting direct connections to the goal. Finally, a shortcut smoothing heuristic reduces unnecessary waypoints and sharp turns. The planner terminates early when time expires or when improvement stalls, returning the best found path coherently built from parent-child relationships.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.fixed_radius = 20.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n        self.refinement_iters = 2000\n        self.no_improve_limit = 150\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        dim = len(point)\n        near_nodes = []\n        for node in tree:\n            # squared Euclidean distance (faster)\n            if dim == 2:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                d_sq = dx*dx + dy*dy\n            else:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2]\n                d_sq = dx*dx + dy*dy + dz*dz\n            if d_sq <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float('inf') or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        r1 = c_best * 0.5\n        try:\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n        except:\n            r2 = 0.0\n\n        while True:\n            # Uniform sample inside unit ball\n            vec = [random.gauss(0,1) for _ in range(dim)]\n            norm = math.sqrt(sum(x*x for x in vec))\n            if norm < 1e-12:\n                continue\n            vec = [x / norm for x in vec]\n            rad = random.random() ** (1.0/dim)\n            ball_point = [rad * x for x in vec]\n\n            # Scale for ellipsoid axes\n            scaled = [r1 * ball_point[0]] + [r2 * ball_point[i] for i in range(1, dim)]\n\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[i] + dir_a1[i] * scaled[0] for i in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n\n            pt = tuple(max(0.0, min(bounds[i], point[i])) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, max_attempts=1000) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_start = new_path[i]\n            p_end = new_path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n            attempts += 1\n        return new_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for it in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            q_rand = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            q_near = self._nearest(tree_a, q_rand)\n            q_new_pos = self._steer(q_near.position, q_rand)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(q_near.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near(tree_a, q_new_pos, self.fixed_radius)\n            min_cost = q_near.cost + self._dist(q_near.position, q_new_pos)\n            best_parent = q_near\n\n            for n in neighbors:\n                cost_cand = n.cost + self._dist(n.position, q_new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, q_new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = n\n\n            q_new = Node(q_new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((best_parent, q_new))\n\n            # Local rewiring\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                cost_through = q_new.cost + self._dist(q_new.position, n.position)\n                if cost_through + self.improve_tol < n.cost:\n                    if not self._is_edge_in_obstacle(q_new.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = q_new\n                        n.cost = cost_through\n                        q_new.add_child(n)\n                        edges.append((q_new, n))\n\n            # Attempt connect to other tree\n            q_new_near_other = self._nearest(tree_b, q_new.position)\n            d_connect = self._dist(q_new.position, q_new_near_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(q_new.position, q_new_near_other.position, obstacles, is_3d):\n                    connect_node = Node(q_new.position, parent=q_new_near_other, cost=q_new_near_other.cost + d_connect)\n                    q_new_near_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((q_new_near_other, connect_node))\n\n                    if expand_start:\n                        candidate_path = self._build_path(q_new, connect_node)\n                        candidate_cost = q_new.cost + (connect_node.cost - q_new_near_other.cost)\n                    else:\n                        candidate_path = self._build_path(connect_node, q_new)\n                        candidate_cost = connect_node.cost + (q_new.cost - best_parent.cost)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        best_goal_node = connect_node if expand_start else q_new\n                        found_solution = True\n                        success_state = True\n                        break\n\n            if found_solution:\n                break\n\n        if not found_solution:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n        # Refinement phase - build single tree from start along best path\n        c_min = self._dist(start_pos, goal_pos)\n        c_best = best_cost\n\n        refinement_tree: List[Node] = [start_root]\n        start_root.children.clear()\n        start_root.cost = 0.0\n\n        nodes_refine: List[Node] = [start_root]\n        edges_refine: List[Tuple[Node, Node]] = []\n\n        prev = start_root\n        for p in best_path[1:]:\n            cost_inc = self._dist(prev.position, p)\n            new_node = Node(p, parent=prev, cost=prev.cost + cost_inc)\n            prev.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((prev, new_node))\n            prev = new_node\n        best_goal_node_refine = prev\n\n        no_improve_count = 0\n        for i in range(self.refinement_iters):\n            if timed_out() or no_improve_count >= self.no_improve_limit:\n                break\n\n            sample_pt = self._ellipsoidal_informed_sample(c_best, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n            nearest_node = self._nearest(refinement_tree, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                no_improve_count += 1\n                continue\n\n            neighbors = self._near(refinement_tree, new_pos, self.fixed_radius)\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                cost_cand = n.cost + self._dist(n.position, new_pos)\n                if cost_cand + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            refinement_tree.append(new_node)\n            nodes_refine.append(new_node)\n            edges_refine.append((best_parent, new_node))\n\n            rewired = False\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, n.position)\n                if cost_through_new + self.improve_tol < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        if n.parent:\n                            try:\n                                edges_refine.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges_refine.append((new_node, n))\n                        rewired = True\n\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    refinement_tree.append(goal_node)\n                    nodes_refine.append(goal_node)\n                    edges_refine.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < c_best:\n                        c_best = goal_node.cost\n                        best_goal_node_refine = goal_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if not rewired:\n                no_improve_count += 1\n\n        refined_path = best_goal_node_refine.path_from_root()\n        smoothed_path = self._shortcut_path(refined_path, obstacles, is_3d)\n\n        return PlannerResult(success=True, path=smoothed_path, nodes=nodes_refine, edges=edges_refine)",
    "objective": -12.93321,
    "time_improvement": -18.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1281.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.060326361656188966,
            "num_nodes_avg": 81.5,
            "path_length_avg": 157.59839036287062,
            "smoothness_avg": 0.04497476719257027,
            "success_improvement": 0.0,
            "time_improvement": -133.25629632361077,
            "length_improvement": 13.617824935805348,
            "smoothness_improvement": 603.9527708338542,
            "objective_score": -28.78643008143075
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06139037609100342,
            "num_nodes_avg": 101.2,
            "path_length_avg": 225.39241807440686,
            "smoothness_avg": 0.08332413885134189,
            "success_improvement": 0.0,
            "time_improvement": 62.640916373743025,
            "length_improvement": 24.757523285721305,
            "smoothness_improvement": 2043.9901085963784,
            "objective_score": 43.86673942653758
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04016015529632568,
            "num_nodes_avg": 88.0,
            "path_length_avg": 119.4677829967754,
            "smoothness_avg": 0.10174742196095421,
            "success_improvement": 0.0,
            "time_improvement": 17.850396961061772,
            "length_improvement": 20.65518697804024,
            "smoothness_improvement": 1194.2196971298695,
            "objective_score": 23.71932976079202
        }
    ],
    "success_rate": 1.0
}
