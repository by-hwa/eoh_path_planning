[
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner with fixed-radius neighbor search and early solution-directed termination, prioritizing computational efficiency and path quality. It employs balanced goal-biased sampling, avoids recursive cost propagation by local rewiring only, and utilizes a compact post-solution pruning step to ensure smooth, short paths within a strict 30-second planning window.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal using goal bias and fixed extended radius rewiring. Upon connection, it halts growth early and refines the best path locally by pruning redundant nodes and shortcutting edges under obstacle constraints, avoiding costly global rewiring. Both collision checks and sampling strictly respect map bounds and obstacle constraints, ensuring timely and feasible path discovery.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.25  # Balanced goal bias\n        self.gamma_rrt_star = 30.0    # Fixed factor for neighbor radius\n        self.time_limit = 30.0        # seconds\n        self.max_rewire_radius = 15.0 # Capped rewiring radius to limit computation\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1,int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos,to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*r for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        # Linear scan - could be improved (but fast enough for moderate nodes)\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        res = []\n        for node in tree:\n            if self._dist(node.position, point) <= radius:\n                res.append(node)\n        return res\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        # Build path from node_start root to node_goal root and connect\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        # Attempt to shortcut path by skipping intermediate nodes where possible\n        if len(path) <= 2:\n            return path[:]\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            next_idx = len(path)-1\n            # Try to find farthest reachable node without collision\n            for j in range(len(path)-1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - start_time) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            # Fixed radius with upper cap to limit neighbors checked\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*2, self.max_rewire_radius)\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for near in near_nodes:\n                if near is nearest:\n                    continue\n                cost_candidate = near.cost + self._dist(near.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewiring neighbors without recursive cost propagation for speed\n            for near in near_nodes:\n                if near is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Change parent, update cost, update edges\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # No recursive cost propagation to descendants to reduce overhead\n\n            # Try connect to other tree\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_b.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_b.position, new_node.position, obstacles, is_3d):\n                # Connect by creating new connecting node in tree_b as child of nearest_b\n                conn_node = Node(new_node.position, parent=nearest_b, cost=nearest_b.cost + dist_connect)\n                nearest_b.add_child(conn_node)\n                tree_b.append(conn_node)\n                nodes.append(conn_node)\n                edges.append((nearest_b, conn_node))\n\n                # Build path\n                if expand_start:\n                    cur_path = self._build_path(new_node, conn_node)\n                    cur_cost = new_node.cost + (conn_node.cost - nearest_b.cost)\n                else:\n                    cur_path = self._build_path(conn_node, new_node)\n                    cur_cost = conn_node.cost + (new_node.cost - best_parent.cost)\n\n                if cur_cost < best_cost:\n                    best_cost = cur_cost\n                    best_path = cur_path\n                    best_goal_node = conn_node if expand_start else new_node\n                    found_solution = True\n                    success = True\n\n                # Early termination upon solution find to save planning time\n                break\n\n        # If solution found, perform fast shortcutting pruning for smoothness (no extra rewiring)\n        if found_solution and best_path:\n            pruned_path = self._shortcut_path(best_path, obstacles, is_3d)\n            extracted_path = pruned_path\n        else:\n            extracted_path = best_path\n            success = found_solution\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -34.89579,
          "time_improvement": 55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1778.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917184829711914,
                    "num_nodes_avg": 108.3,
                    "path_length_avg": 163.51846744486653,
                    "smoothness_avg": 0.047042774543765466,
                    "success_improvement": 0.0,
                    "time_improvement": 50.05475865629264,
                    "length_improvement": 10.37293687753887,
                    "smoothness_improvement": 636.321576629899,
                    "objective_score": 24.42179760656061
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028571557998657227,
                    "num_nodes_avg": 306.4,
                    "path_length_avg": 238.2101483315511,
                    "smoothness_avg": 0.12766555635173507,
                    "success_improvement": 0.0,
                    "time_improvement": 82.61279222297007,
                    "length_improvement": 20.478595987977428,
                    "smoothness_improvement": 3184.926718713584,
                    "objective_score": 52.99562885324539
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03236863613128662,
                    "num_nodes_avg": 362.2,
                    "path_length_avg": 126.56340895880092,
                    "smoothness_avg": 0.126854052156657,
                    "success_improvement": 0.0,
                    "time_improvement": 33.788338479350664,
                    "length_improvement": 15.942610071462218,
                    "smoothness_improvement": 1513.5741800405376,
                    "objective_score": 27.26993848688522
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An advanced bidirectional RRT* planner with adaptive fixed-radius rewiring, recursive cost propagation, goal-biased and informed sampling, and post-planning shortcut path smoothing to ensure efficient exploration, improved path length, and smoothness within a hard 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal with a fixed radius for neighbor rewiring and goal bias sampling, connects them upon feasible edges, then refines the best path through informed sampling and shortcut smoothing before termination or timeout, maintaining consistent cost propagation and collision-free constraints throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n        # Fixed radius for neighbor search (tuned empirically)\n        self.fixed_radius = 15.0\n\n        # Probability of sampling the goal (goal bias)\n        self.goal_sample_rate = 0.2\n\n        # Small tolerance for cost improvement\n        self.improve_tol = 1e-6\n\n        # Resolution for collision checking along edges\n        self.check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            # fallback if math.dist unavailable\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        steps = max(1, int(dist / self.check_resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = 0.0\n        try:\n            dist = math.dist(from_pos, to_pos)\n        except:\n            dist = sum((f - t) ** 2 for f, t in zip(from_pos, to_pos)) ** 0.5\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        try:\n            return math.dist(p1, p2)\n        except:\n            return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        res = []\n        r2 = radius * radius\n        for node in tree:\n            d = 0.0\n            if hasattr(math, 'dist'):\n                d = math.dist(node.position, point)\n            else:\n                d = sum((a - b) ** 2 for a,b in zip(node.position, point)) ** 0.5\n            if d <= radius:\n                res.append(node)\n        return res\n\n    def _update_costs_recursive(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node position\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float('inf') or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = sum(x * x for x in a1) ** 0.5\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best * 0.5\n        c2 = (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) * 0.5\n\n        while True:\n            # Sample unit ball in dim dimension\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = sum(x*x for x in rnd_dir) ** 0.5\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            # Scale sample to ellipsoid axes:\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            # Rotation aligns first axis with a1 vector (approximate)\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _try_shortcut(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path[:]\n        smoothed_path = [path[0]]\n        idx = 0\n        n = len(path)\n        while idx < n - 1:\n            next_idx = n - 1\n            while next_idx > idx + 1:\n                if not self._is_edge_in_obstacle(path[idx], path[next_idx], obstacles, is_3d):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Alternate expansions\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expanding_start = (i % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n            sample_goal = goal_pos if expanding_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = self.fixed_radius\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Update edge and parent-child relations\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    # Recursively update costs of descendants\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to opposite tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Connect trees by adding a connecting node\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expanding_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expanding_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Refinement phase if solution found\n        if found_solution and best_goal_node is not None:\n            # Build a tree rooted at start for informed RRT*\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            # Copy best path into tree\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_cost = prev_node.cost + self._dist(prev_node.position, pos)\n                new_node = Node(pos, parent=prev_node, cost=n_cost)\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 120\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                near_nodes = self._near(tree, new_pos, self.fixed_radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate + self.improve_tol < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n            # Post-process path shortcutting for smoothness\n            if len(extracted_path) > 2:\n                extracted_path = self._try_shortcut(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -31.02063,
          "time_improvement": 46.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1385.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02439420223236084,
                    "num_nodes_avg": 210.6,
                    "path_length_avg": 166.9287719242713,
                    "smoothness_avg": 0.04447081982954099,
                    "success_improvement": 0.0,
                    "time_improvement": 5.678030163354109,
                    "length_improvement": 8.503694952644477,
                    "smoothness_improvement": 596.0649002632317,
                    "objective_score": 9.785950521909077
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0319866418838501,
                    "num_nodes_avg": 379.0,
                    "path_length_avg": 229.74939855856366,
                    "smoothness_avg": 0.09565426382163486,
                    "success_improvement": 0.0,
                    "time_improvement": 80.53454457926001,
                    "length_improvement": 23.303037791380007,
                    "smoothness_improvement": 2361.2531051120586,
                    "objective_score": 49.9484515741663
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024246406555175782,
                    "num_nodes_avg": 322.2,
                    "path_length_avg": 119.89049793872327,
                    "smoothness_avg": 0.1019188821406457,
                    "success_improvement": 0.0,
                    "time_improvement": 50.40276465737084,
                    "length_improvement": 20.374439841120928,
                    "smoothness_improvement": 1196.4006579596712,
                    "objective_score": 33.32749659168216
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A hybrid bidirectional RRT* planner with fixed-radius rewiring, goal-biased sampling, and incremental path cost updating, designed for efficient exploration and rapid convergence to short, smooth paths. It alternates expansions from start and goal trees, connects trees with collision-free edges, and maintains best path tracking with early stopping under a 30-second time limit. Edge and node collision checks, consistent tree updates, and pruning ensure high path quality and robustness.",
          "planning_mechanism": "The planner samples with goal bias, extends trees via fixed step size steer functions, uses a fixed-radius neighborhood for parent selection and rewiring to optimize path costs, alternates between start and goal expansions, attempts immediate connections, keeps track of best path found, and stops early either on timeout or solution stabilization, thus improving planning time, path length, and smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Goal bias probability\n        self.fixed_radius = 15.0       # Fixed rewiring/neighbor radius\n        self.time_limit = 30.0         # Hard time limit in seconds\n        self.improve_tol = 1e-9        # Small tolerance for cost comparison\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        for itr in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (itr % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.fixed_radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths exist through new_node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node, edges)\n\n            # Attempt to connect trees\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = connect_node if expand_start else new_node\n                        found_solution = True\n                        success_state = True\n\n            if found_solution:\n                # Early stop on improvement for efficiency\n                break\n\n        extracted_path = best_path if found_solution else []\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_recursive(self, node: Node, edges: List[Tuple[Node, Node]]):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                if child.parent:\n                    try:\n                        edges.remove((child.parent, child))\n                    except ValueError:\n                        pass\n                    child.parent.remove_child(child)\n                child.parent = node\n                child.cost = new_cost\n                edges.append((node, child))\n                self._update_costs_recursive(child, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        return math.dist(p1, p2)\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # Remove duplicated connection node position to avoid double count\n        combined = path_start + path_goal[1:]\n        return combined\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.79261,
          "time_improvement": 64.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 286.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014900636672973634,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 159.47130040463088,
                    "smoothness_avg": 0.02276354128553975,
                    "success_improvement": 0.0,
                    "time_improvement": 42.38559681404182,
                    "length_improvement": 12.591253263757743,
                    "smoothness_improvement": 256.29885293978236,
                    "objective_score": 21.5519252671661
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03198549747467041,
                    "num_nodes_avg": 320.0,
                    "path_length_avg": 240.61799786727897,
                    "smoothness_avg": 0.01613382883159849,
                    "success_improvement": 0.0,
                    "time_improvement": 80.53524100891183,
                    "length_improvement": 19.674786506845358,
                    "smoothness_improvement": 315.1350365642233,
                    "objective_score": 37.541119389601874
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015687036514282226,
                    "num_nodes_avg": 203.9,
                    "path_length_avg": 129.30542997382435,
                    "smoothness_avg": 0.03047932298139177,
                    "success_improvement": 0.0,
                    "time_improvement": 67.91138348452755,
                    "length_improvement": 14.121490274293217,
                    "smoothness_improvement": 287.69473857370235,
                    "objective_score": 30.284782902802707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A tuned adaptive bidirectional RRT* planner with recursive descendant cost propagation, enhanced goal bias, and ellipsoidal informed refinement that balances exploration and exploitation. It uses adaptive neighbor radius shrinking for rewiring, efficient collision checking, consistent edge and parent-child updates, and early termination on a 30-second limit to improve planning time, path smoothness, and path length.",
          "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately with goal bias sampling until first connection, then conducts single-tree ellipsoidal informed RRT* refinement focused on the best path. Neighbor radius adapts with tree size. Rewiring propagates cost updates recursively to descendants ensuring path cost consistency and smoother paths. The best path is updated progressively and returned when time limit is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.18          # goal bias probability\n        self.gamma_rrt_star = 40.0            # adaptive radius multiplier tuned for balance\n        self.improve_tol = 1e-6               # small tolerance for cost improvements\n        self.time_limit = 30.0                # hard time limit in seconds\n        self.max_radius_factor = 12.0         # max radius factor for neighbor search\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node: Node, goal_node: Node) -> List[Tuple[float, ...]]:\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        # avoid duplicate connecting node\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        if c_best == float(\"inf\") or c_best < c_min - 1e-10:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        dim = len(bounds)\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n        a1 = tuple(g - s for s,g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x*x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n\n        while True:\n            rnd_dir = [random.gauss(0,1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x*x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0/dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d]*scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        # Phase 1: Bidirectional growth until initial path found\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire within neighbors with recursive cost update\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n                    break\n\n        # Phase 2: Refinement via single-tree informed RRT*\n        if found_solution and best_goal_node is not None:\n            tree = [start_root]\n            start_root.children = []\n            start_root.cost = 0.0\n\n            prev_node = start_root\n            for pos in best_path[1:]:\n                new_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((prev_node, new_node))\n                prev_node = new_node\n\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n            no_improve_count = 0\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if timed_out() or no_improve_count >= 120:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                    if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                    if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_costs_recursive(near_node)\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        no_improve_count = 0\n                        success_state = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -26.48735,
          "time_improvement": 58.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 228.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017215156555175783,
                    "num_nodes_avg": 208.5,
                    "path_length_avg": 160.40239983380974,
                    "smoothness_avg": 0.02374652355073028,
                    "success_improvement": 0.0,
                    "time_improvement": 33.43633614808805,
                    "length_improvement": 12.08090291241019,
                    "smoothness_improvement": 271.6846599701681,
                    "objective_score": 18.637865891723372
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03504271507263183,
                    "num_nodes_avg": 467.1,
                    "path_length_avg": 253.42542860882128,
                    "smoothness_avg": 0.010719255016317384,
                    "success_improvement": 0.0,
                    "time_improvement": 78.67477272090856,
                    "length_improvement": 15.399297483864519,
                    "smoothness_improvement": 175.8141523371588,
                    "objective_score": 33.72108106827707
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019155335426330567,
                    "num_nodes_avg": 300.1,
                    "path_length_avg": 131.29531716904052,
                    "smoothness_avg": 0.02638587363121502,
                    "success_improvement": 0.0,
                    "time_improvement": 60.81680487189903,
                    "length_improvement": 12.799901947476434,
                    "smoothness_improvement": 235.62636498645543,
                    "objective_score": 27.103114454987843
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.388981117243627,
          "time_improvement": 63.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 183.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01468205451965332,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 170.0777299899863,
                    "smoothness_avg": 0.01815393444540405,
                    "success_improvement": 0.0,
                    "time_improvement": 43.23076072126553,
                    "length_improvement": 6.77770113839239,
                    "smoothness_improvement": 184.14849597019096,
                    "objective_score": 17.956591379266047
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03251075744628906,
                    "num_nodes_avg": 236.4,
                    "path_length_avg": 260.6786075049101,
                    "smoothness_avg": 0.010607444299952517,
                    "success_improvement": 0.0,
                    "time_improvement": 80.2155943076742,
                    "length_improvement": 12.977977597171186,
                    "smoothness_improvement": 172.93718207108697,
                    "objective_score": 32.7161507609604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016566014289855956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 131.24402594159469,
                    "smoothness_avg": 0.022953022539448645,
                    "success_improvement": 0.0,
                    "time_improvement": 66.11339055320946,
                    "length_improvement": 12.833967138520164,
                    "smoothness_improvement": 191.96075248589716,
                    "objective_score": 28.494201211504425
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -25.88903997320672,
          "time_improvement": 62.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 175.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012654733657836915,
                    "num_nodes_avg": 142.7,
                    "path_length_avg": 168.74937337871444,
                    "smoothness_avg": 0.01750117800517029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.06954533721745,
                    "length_improvement": 7.505794446187998,
                    "smoothness_improvement": 173.93144019723505,
                    "objective_score": 20.693997469864208
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020306038856506347,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 258.7447467197662,
                    "smoothness_avg": 0.010763143861376633,
                    "success_improvement": 0.0,
                    "time_improvement": 87.64276989224348,
                    "length_improvement": 13.623555990348581,
                    "smoothness_improvement": 176.94344393239058,
                    "objective_score": 35.351681781544144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02561664581298828,
                    "num_nodes_avg": 265.8,
                    "path_length_avg": 134.34631990981856,
                    "smoothness_avg": 0.02165635834384294,
                    "success_improvement": 0.0,
                    "time_improvement": 47.59987183319978,
                    "length_improvement": 10.773571200189904,
                    "smoothness_improvement": 175.46727962758771,
                    "objective_score": 21.621440668211815
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with uniform rewiring radius, goal-biased sampling, and early path connection checking. It maintains consistent parent-child relations and incremental cost updates without recursive propagation. The planner alternates tree expansions from start and goal, uses fixed step steering, and respects a 30-second time limit, returning the best path found.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling free points biased toward the opposite tree's root. New nodes are connected via nearest neighbors, rewiring locally with a uniform radius for cost improvement. On each expansion, it attempts to connect the two trees to form a solution. The method uses simple collision checking and incremental updates avoiding recursion for efficient time use while balancing exploration and refinement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best, best_dist = node, d\n        return best\n\n    def _near(self, tree, point, radius):\n        res = []\n        r_sq = radius * radius\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= r_sq:\n                res.append(node)\n        return res\n\n    def _build_path(self, start_node, goal_node):\n        path_from_start = start_node.path_from_root()\n        path_from_goal = goal_node.path_from_root()\n        path_from_goal.reverse()\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_goal_node = None\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position,\n                                    parent=nearest_other,\n                                    cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                        goal_node_for_path = connect_node\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n                        goal_node_for_path = new_node\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        best_goal_node = goal_node_for_path\n                        found_solution = True\n\n            if found_solution:\n                break\n\n        final_path = best_path if found_solution else []\n\n        return PlannerResult(success=found_solution,\n                             path=final_path,\n                             nodes=nodes,\n                             edges=edges)",
          "objective": -25.63427,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 293.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01984410285949707,
                    "num_nodes_avg": 143.3,
                    "path_length_avg": 171.67360458367028,
                    "smoothness_avg": 0.022584930568577976,
                    "success_improvement": 0.0,
                    "time_improvement": 23.27132268888971,
                    "length_improvement": 5.90297698534299,
                    "smoothness_improvement": 253.5032073599508,
                    "objective_score": 11.79069903467246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025874114036560057,
                    "num_nodes_avg": 243.0,
                    "path_length_avg": 242.09986453995447,
                    "smoothness_avg": 0.016588755758426728,
                    "success_improvement": 0.0,
                    "time_improvement": 84.25432043918015,
                    "length_improvement": 19.180096758339072,
                    "smoothness_improvement": 326.84063406213465,
                    "objective_score": 38.41855735706817
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024422097206115722,
                    "num_nodes_avg": 210.2,
                    "path_length_avg": 125.00263383013859,
                    "smoothness_avg": 0.031336834215711706,
                    "success_improvement": 0.0,
                    "time_improvement": 50.04338065783512,
                    "length_improvement": 16.979202595794742,
                    "smoothness_improvement": 298.6022181793566,
                    "objective_score": 26.693546845724164
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive fixed-radius rewiring, balanced tree expansion, goal bias sampling, and non-recursive cost updates. It uses an efficient early connection detection, balanced neighbor search, and selective rewire to improve planning time while maintaining path quality and smoothness. The planning stops after 30 seconds or if a satisfactory path is found, returning the current best.",
          "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal using goal-biased sampling with a fixed step size. For each new node, rewiring is performed locally in a fixed-radius neighborhood without recursive cost propagation to reduce overhead. The nearest neighbors are searched via efficient pruning based on a fixed radius. Upon finding a connection between trees, the best path is updated and planning may terminate early. Consistent edge and parent updates maintain tree validity.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2    # goal bias probability\n        self.rewire_radius = 10.0      # fixed radius for rewiring to control overhead\n        self.time_limit = 30.0         # seconds\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius):\n        radius_sq = radius*radius\n        dim = len(point)\n        result = []\n        for node in tree:\n            # squared dist for efficiency\n            dist_sq = sum((node.position[d] - point[d])**2 for d in range(dim))\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [start_root]\n        tree_goal: List[Node] = [goal_root]\n        nodes: List[Node] = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success_state = False\n\n        time_start = time.monotonic()\n\n        # Alternate tree expansion\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - time_start > self.time_limit:\n                break\n\n            expand_start = (iter_count % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            sample_goal = goal_pos if expand_start else start_pos\n\n            sample_point = self._sample(bounds, obstacles, is_3d, sample_goal)\n            nearest_node = self._nearest(tree_a, sample_point)\n            new_pos = self._steer(nearest_node.position, sample_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            dist_to_parent = self._dist(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_to_parent\n            best_parent = nearest_node\n\n            # Fixed radius rewiring neighbors\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node without recursion\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Do not recurse cost update to keep time low\n\n            # Attempt to connect trees directly at new_node pos\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    # Connect by adding a node in tree_b at new_node's position with cost\n                    connect_cost = nearest_other.cost + dist_connect\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=connect_cost)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    # Build combined path\n                    if expand_start:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    else:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    path_goal.reverse()\n                    combined_path = path_start + path_goal[1:]  # merge avoid duplicate\n\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = combined_path\n                        success_state = True\n                        # Early termination on first found path\n                        break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -25.59587,
          "time_improvement": 61.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 161.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01631131172180176,
                    "num_nodes_avg": 138.0,
                    "path_length_avg": 167.04103096183044,
                    "smoothness_avg": 0.01581183459495707,
                    "success_improvement": 0.0,
                    "time_improvement": 36.931118404070936,
                    "length_improvement": 8.442163995300026,
                    "smoothness_improvement": 147.48954735946702,
                    "objective_score": 16.882081655198633
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032275938987731935,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 257.1157017506108,
                    "smoothness_avg": 0.010703326882045994,
                    "success_improvement": 0.0,
                    "time_improvement": 80.3584929668585,
                    "length_improvement": 14.167378090512239,
                    "smoothness_improvement": 175.40430996978455,
                    "objective_score": 33.484996294213815
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017235589027404786,
                    "num_nodes_avg": 196.1,
                    "path_length_avg": 135.00966227832785,
                    "smoothness_avg": 0.02040266093776916,
                    "success_improvement": 0.0,
                    "time_improvement": 64.7437419926231,
                    "length_improvement": 10.333010783995237,
                    "smoothness_improvement": 159.52034116064578,
                    "objective_score": 26.4205307739873
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified and robust bidirectional RRT planner using fixed-step extension and goal-biased sampling that grows two trees from start and goal. It efficiently samples collision-free points within bounds, extends nearest nodes in the active tree towards samples while checking node and edge collisions, and attempts connecting opposite trees to find a feasible path. Planning halts on success or after a hard 30-second limit, returning the best found path. This design balances simplicity, efficiency, and path quality without complex rewiring or heavy neighbor searches, promoting generalizability and stable performance.",
          "planning_mechanism": "The planner alternates growth from the start and goal trees by sampling mostly random points with a small goal bias. Each iteration extends the active tree's nearest node toward the sample by a fixed step size, verifying node and edge collision. After adding a new node, it tries to connect the other tree within one step. If successful, it merges their paths. Search terminates upon success or time limit, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...], resolution=1.0) -> bool:\n            distance = math.dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(len(from_p)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def extend(tree: List[Node], sample: Tuple[float, ...]) -> Optional[Node]:\n            near_node = nearest(tree, sample)\n            new_pos = steer(near_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                return None\n            new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near_node, new_node))\n            return new_node\n\n        def connect(tree: List[Node], node: Node) -> Optional[Node]:\n            near_node = nearest(tree, node.position)\n            dist = math.dist(near_node.position, node.position)\n            if dist <= self.step_size:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(near_node.position, node.position):\n                    return None\n                new_cost = near_node.cost + dist\n                new_node = Node(node.position, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return new_node\n            else:\n                new_pos = steer(near_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(near_node.position, new_pos):\n                    return None\n                new_cost = near_node.cost + math.dist(near_node.position, new_pos)\n                new_node = Node(new_pos, parent=near_node, cost=new_cost)\n                near_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((near_node, new_node))\n                return None\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                # Remove duplicate connection node from goal path start\n                best_path = path_from_start + path_from_goal[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -25.31044,
          "time_improvement": 89.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004116058349609375,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 186.50859214468096,
                    "smoothness_avg": 0.01083676150431979,
                    "success_improvement": 0.0,
                    "time_improvement": 84.08495888491464,
                    "length_improvement": -2.228314772268034,
                    "smoothness_improvement": 69.61884994686052,
                    "objective_score": 24.236593051847876
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012918996810913085,
                    "num_nodes_avg": 290.6,
                    "path_length_avg": 305.74548850411804,
                    "smoothness_avg": 0.006610629509046964,
                    "success_improvement": 0.0,
                    "time_improvement": 92.13815075003298,
                    "length_improvement": -2.0666444586099937,
                    "smoothness_improvement": 70.09625871175474,
                    "objective_score": 26.751939843402667
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004724693298339844,
                    "num_nodes_avg": 160.3,
                    "path_length_avg": 156.8139079605709,
                    "smoothness_avg": 0.013068898818260644,
                    "success_improvement": 0.0,
                    "time_improvement": 90.33540393269195,
                    "length_improvement": -4.1483309915455795,
                    "smoothness_improvement": 66.23542832250818,
                    "objective_score": 24.942799726492776
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with goal bias, adaptive rewiring radius, efficient steering and collision checks, recursive cost propagation for improved path cost and smoothness, and early termination upon time limit or solution. The planner alternates tree expansions from start and goal, uses goal-biased sampling, rewires nodes within adaptive radius, and merges the trees upon feasible connection. It maintains consistent parent-child relationships and edge lists to ensure path quality and returns the best path found within 30 seconds.",
          "planning_mechanism": "A bidirectional RRT* approach that grows two trees alternately towards randomly sampled or goal-biased points using fixed step size steering. Each added node undergoes rewiring with neighbors within a dynamically adjusted radius, updating costs recursively. The trees attempt early connections each iteration, and the algorithm terminates upon first path found or time expiration, returning the best discovered path with coherent node and edge data.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True  # For collision or pruning if needed\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = 0.15         # Probability to sample the goal\n        self.gamma = 40.0             # Radius multiplier for rewiring\n        self.improve_tol = 1e-6       # Tolerance for cost improvement\n        self.time_limit = 30.0        # Hard time limit in seconds\n        self.max_radius_factor = 12.0 # Max radius factor relative to step_size\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal_pos):\n        if random.random() < self.goal_bias and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return goal_pos\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree: List[Node], point):\n        best_node = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree: List[Node], point, radius: float):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _update_costs_recursive(self, node: Node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + self.improve_tol < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_costs_recursive(child)\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_from_start = node_start.path_from_root()\n        path_from_goal = node_goal.path_from_root()\n        path_from_goal.reverse()\n        # Avoid duplicating connecting node position twice\n        return path_from_start + path_from_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_start = time.monotonic()\n        def timed_out():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        success_state = False\n\n        for i in range(self.max_iter):\n            if timed_out():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_pos if expand_start else start_pos)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.step_size * self.max_radius_factor)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    self._update_costs_recursive(near_node)\n\n            # Attempt connection to other tree\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                # Attach connection node to tree_b\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                # Build candidate path\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    success_state = True\n                    break\n\n        return PlannerResult(success=success_state, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61754,
          "time_improvement": 61.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 193.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009621047973632812,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 164.31220468255123,
                    "smoothness_avg": 0.023315744650501093,
                    "success_improvement": 0.0,
                    "time_improvement": 62.79951325638851,
                    "length_improvement": 9.93787691999248,
                    "smoothness_improvement": 264.94203473022714,
                    "objective_score": 26.127290302563175
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02230513095855713,
                    "num_nodes_avg": 273.4,
                    "path_length_avg": 266.18287057210443,
                    "smoothness_avg": 0.009924123364819862,
                    "success_improvement": 0.0,
                    "time_improvement": 86.4262233621099,
                    "length_improvement": 11.14049615391379,
                    "smoothness_improvement": 155.3548422339481,
                    "objective_score": 33.388938912150984
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03204865455627441,
                    "num_nodes_avg": 330.6,
                    "path_length_avg": 142.5087361224591,
                    "smoothness_avg": 0.020315103476053527,
                    "success_improvement": 0.0,
                    "time_improvement": 34.44287676918223,
                    "length_improvement": 5.352483004246246,
                    "smoothness_improvement": 158.4066167104425,
                    "objective_score": 14.336385916854628
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A straightforward bidirectional RRT planner that grows two trees from start and goal by iteratively sampling free points and extending the nearest node from each tree towards the sample with a fixed step size; it alternates tree extensions, checks for collision-free connections between trees to find a complete path, and returns the best found path within a 30-second time limit.",
          "planning_mechanism": "The planner maintains two trees rooted at start and goal, samples collision-free points uniformly within map bounds, extends the nearest node in the active tree toward the sampled point, alternates trees each iteration, and tries to connect the opposite tree to the newly added node. Upon successful connection, it merges the two partial paths into a complete solution. Planning stops when the path is found or time limit expires, returning the current best path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        success = False\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(tree, node):\n            nearest_node = nearest(tree, node.position)\n            dist = math.dist(nearest_node.position, node.position)\n            if dist > self.step_size:\n                new_pos = steer(nearest_node.position, node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                # attempt direct connection if close\n                if math.dist(new_node.position, node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, node.position):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(node.position) or is_edge_in_obstacle(nearest_node.position, node.position):\n                    return None\n                final_node = Node(node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        tree_a = tree_start\n        tree_b = tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = connect_trees(tree_b, new_node)\n            if connected_node is not None:\n                success = True\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                best_path = path_a + path_b[-2::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -24.61746,
          "time_improvement": 87.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003728294372558594,
                    "num_nodes_avg": 84.9,
                    "path_length_avg": 180.87966860281307,
                    "smoothness_avg": 0.01103987851253821,
                    "success_improvement": 0.0,
                    "time_improvement": 85.58427670636823,
                    "length_improvement": 0.8569874170311926,
                    "smoothness_improvement": 72.7980722011218,
                    "objective_score": 26.553465823134793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009920716285705566,
                    "num_nodes_avg": 246.6,
                    "path_length_avg": 301.0670492796362,
                    "smoothness_avg": 0.006705809145069515,
                    "success_improvement": 0.0,
                    "time_improvement": 93.96275291096713,
                    "length_improvement": -0.5048467840713801,
                    "smoothness_improvement": 72.54529930173578,
                    "objective_score": 28.248644299355988
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009735631942749023,
                    "num_nodes_avg": 234.2,
                    "path_length_avg": 163.86030235550345,
                    "smoothness_avg": 0.012918469003538813,
                    "success_improvement": 0.0,
                    "time_improvement": 80.08527871645923,
                    "length_improvement": -8.82821063541575,
                    "smoothness_improvement": 64.3219721828204,
                    "objective_score": 19.05026709460242
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, robust bidirectional RRT planner with goal-biased sampling and incremental tree extension that balances exploration between start and goal trees, while performing efficient collision checks and early path updates. It avoids complex rewiring and uses straightforward nearest neighbor selection to maintain generality and simplicity for various environments.",
          "planning_mechanism": "A planning mechanism where two trees grow alternately from start and goal by sampling free configurations biased toward the goal, extending toward these samples in fixed step increments, and attempting quick connections between trees after each extension. The planner tracks the best path incrementally, respects a 30-second runtime limit, and returns the best feasible path found, emphasizing simplicity and consistent collision checking to enhance generalization and robustness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node) -> None:\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        def dist(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], resolution: float=1.0) -> bool:\n            d = dist(from_pos, to_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[dim] + (to_pos[dim] - from_pos[dim]) * (i / steps) for dim in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[dim]) for dim in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def extend(tree: List[Node], sample_point: Tuple[float, ...]) -> Node:\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node) -> Node:\n            nearest_node = nearest(tree, target_node.position)\n            d = dist(nearest_node.position, target_node.position)\n            if d > self.step_size:\n                new_pos = steer(nearest_node.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    return None\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_in_obstacle(target_node.position) and \n                        not is_edge_in_obstacle(new_node.position, target_node.position)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                return None\n            else:\n                if is_in_obstacle(target_node.position) or is_edge_in_obstacle(nearest_node.position, target_node.position):\n                    return None\n                final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + d)\n                nearest_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_node, final_node))\n                return final_node\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        active_tree, passive_tree = tree_start, tree_goal\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = sample_free()\n            new_node = extend(active_tree, sample)\n            if new_node is None:\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            connected = try_connect(passive_tree, new_node)\n            if connected is not None:\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected.path_from_root()\n                path_from_goal.reverse()\n                full_path = path_from_start + path_from_goal[1:]\n                total_cost = new_node.cost + (connected.cost - (connected.parent.cost if connected.parent else 0))\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(success, best_path, nodes, edges)",
          "objective": -23.99146,
          "time_improvement": 85.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005986332893371582,
                    "num_nodes_avg": 102.9,
                    "path_length_avg": 186.3878844459078,
                    "smoothness_avg": 0.010717739755280646,
                    "success_improvement": 0.0,
                    "time_improvement": 76.85340536155462,
                    "length_improvement": -2.162152969834569,
                    "smoothness_improvement": 67.75590111453309,
                    "objective_score": 22.09750933213831
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012749218940734863,
                    "num_nodes_avg": 257.1,
                    "path_length_avg": 308.38377975949993,
                    "smoothness_avg": 0.006534880980414862,
                    "success_improvement": 0.0,
                    "time_improvement": 92.24146899067176,
                    "length_improvement": -2.9473820186597015,
                    "smoothness_improvement": 68.1471945105909,
                    "objective_score": 26.244747458558663
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006320595741271973,
                    "num_nodes_avg": 198.8,
                    "path_length_avg": 157.6342104276583,
                    "smoothness_avg": 0.012998822830330053,
                    "success_improvement": 0.0,
                    "time_improvement": 87.07090579496337,
                    "length_improvement": -4.693136831579113,
                    "smoothness_improvement": 65.34406692850246,
                    "objective_score": 23.632109974184054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius rewiring, balanced goal bias sampling, and a focused refinement phase using ellipsoidal informed sampling for path improvement. The planner alternates expansions between start and goal trees, performs local rewiring to optimize paths, efficiently manages parent-child relationships and edges, and enforces a hard 30-second time limit returning the best found solution.",
          "planning_mechanism": "The planner grows two trees alternately, sampling with goal bias, steering towards samples with fixed step size, and connecting trees when possible. Adaptive near neighbor radius shrinks with node count providing efficient local rewiring to reduce cost. Upon first path discovery, the planner refines the solution using ellipsoidal informed sampling focused around the current best path, with rewiring and direct goal connections. The process continues until time runs out, returning the best viable path with its nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 30.0\n        self.improve_tol = 1e-6\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_node = node\n                best_dist = d\n        return best_node\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._dist(node.position, point) <= radius]\n\n    def _build_path(self, start_node, goal_node):\n        path_start = start_node.path_from_root()\n        path_goal = goal_node.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def _ellipsoidal_informed_sample(self, c_best, c_min, start, goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_best < c_min - 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        a1 = tuple(g - s for s, g in zip(start, goal))\n        norm_a1 = math.sqrt(sum(x * x for x in a1))\n        if norm_a1 < 1e-12:\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n        c1 = c_best / 2.0\n        c2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n        while True:\n            rnd_dir = [random.gauss(0, 1) for _ in range(dim)]\n            norm_dir = math.sqrt(sum(x * x for x in rnd_dir))\n            if norm_dir < 1e-12:\n                continue\n            unit_dir = [x / norm_dir for x in rnd_dir]\n            r = random.random() ** (1.0 / dim)\n            ball_point = [r * x for x in unit_dir]\n            scaled = [c1 * ball_point[0]] + [c2 * ball_point[i] for i in range(1, dim)]\n            dir_a1 = [x / norm_a1 for x in a1]\n            point = [center[d] + dir_a1[d] * scaled[0] for d in range(dim)]\n            for i in range(1, dim):\n                point[i] += scaled[i]\n            pt = tuple(max(0.0, min(bounds[d], point[d])) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        found_solution = False\n        success_state = False\n\n        time_start = time.monotonic()\n        def time_exceeded():\n            return (time.monotonic() - time_start) > self.time_limit\n\n        for it in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            goal_sample = goal_pos if expand_start else start_pos\n            sample_pt = self._sample(bounds, obstacles, is_3d, goal_sample, self.goal_sample_rate)\n\n            nearest_node = self._nearest(tree_a, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                cost_cand = near.cost + self._dist(near.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = near\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_connect = self._dist(nearest_other.position, new_node.position)\n            if dist_connect <= self.step_size and not self._is_edge_in_obstacle(nearest_other.position, new_node.position, obstacles, is_3d):\n                connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_connect)\n                nearest_other.add_child(connect_node)\n                tree_b.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((nearest_other, connect_node))\n\n                if expand_start:\n                    path = self._build_path(new_node, connect_node)\n                    total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                else:\n                    path = self._build_path(connect_node, new_node)\n                    total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    best_goal_node = connect_node if expand_start else new_node\n                    found_solution = True\n                    success_state = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_goal_node:\n            # Rebuild tree along best path for refinement\n            tree = [start_root]\n            nodes = [start_root]\n            edges = []\n            start_root.children.clear()\n            start_root.cost = 0.0\n            prev_node = start_root\n            for pos in best_path[1:]:\n                n_node = Node(pos, parent=prev_node, cost=prev_node.cost + self._dist(prev_node.position, pos))\n                prev_node.add_child(n_node)\n                tree.append(n_node)\n                nodes.append(n_node)\n                edges.append((prev_node, n_node))\n                prev_node = n_node\n            best_goal_node = prev_node\n            best_cost = best_goal_node.cost\n\n            no_improve_count = 0\n            max_no_improve = 150\n            post_opt_iters = self.max_iter // 2\n            c_min = self._dist(start_pos, goal_pos)\n\n            for _ in range(post_opt_iters):\n                if time_exceeded() or no_improve_count >= max_no_improve:\n                    break\n\n                sample_pt = self._ellipsoidal_informed_sample(best_cost, c_min, start_pos, goal_pos, bounds, obstacles, is_3d)\n                nearest_node = self._nearest(tree, sample_pt)\n                new_pos = self._steer(nearest_node.position, sample_pt)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    no_improve_count += 1\n                    continue\n\n                n_nodes = len(tree) + 1\n                radius = min(self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)), self.step_size * 12)\n                near_nodes = self._near(tree, new_pos, radius)\n\n                min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near in near_nodes:\n                    cost_cand = near.cost + self._dist(near.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = near\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                rewired = False\n                for near in near_nodes:\n                    if near == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n                    if cost_through_new + self.improve_tol < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        rewired = True\n\n                dist_goal = self._dist(new_node.position, goal_pos)\n                if dist_goal <= self.step_size and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    new_goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(new_goal_node)\n                    tree.append(new_goal_node)\n                    nodes.append(new_goal_node)\n                    edges.append((new_node, new_goal_node))\n                    if new_goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = new_goal_node.cost\n                        best_goal_node = new_goal_node\n                        success_state = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n\n                if not rewired:\n                    no_improve_count += 1\n\n            extracted_path = best_goal_node.path_from_root() if success_state else best_path\n        else:\n            extracted_path = best_path\n            success_state = found_solution\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -23.94126,
          "time_improvement": 61.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 149.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015314602851867675,
                    "num_nodes_avg": 102.6,
                    "path_length_avg": 174.31466392127092,
                    "smoothness_avg": 0.018042815740374477,
                    "success_improvement": 0.0,
                    "time_improvement": 40.78496625981784,
                    "length_improvement": 4.455370512140755,
                    "smoothness_improvement": 182.40924693834805,
                    "objective_score": 15.820758419921546
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02311997413635254,
                    "num_nodes_avg": 124.2,
                    "path_length_avg": 277.74141234820326,
                    "smoothness_avg": 0.008272828990118159,
                    "success_improvement": 0.0,
                    "time_improvement": 85.93035094105784,
                    "length_improvement": 7.281922214873708,
                    "smoothness_improvement": 112.86584859361024,
                    "objective_score": 30.712587854209623
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021300077438354492,
                    "num_nodes_avg": 97.7,
                    "path_length_avg": 131.4716872369412,
                    "smoothness_avg": 0.019683669711549293,
                    "success_improvement": 0.0,
                    "time_improvement": 56.42962798952232,
                    "length_improvement": 12.682765346216934,
                    "smoothness_improvement": 150.37482583354094,
                    "objective_score": 25.29042173375456
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT that grows two trees from start and goal by extending towards random samples within map bounds, with straightforward collision checking and edge validation. The trees alternately extend, and upon nearby connection attempts, the shortest feasible path joining both trees is extracted. This reduces complexity by avoiding local rewiring and ensures efficient early solution discovery with clear parent-child relationships.",
          "planning_mechanism": "The planner initializes two trees at start and goal. It samples free points uniformly, extends the nearest node of the active tree towards the sample with a fixed step size if collision-free, then tries to connect the other tree to this new node. Trees swap roles each iteration. If nodes connect successfully, the path is reconstructed by concatenating the two tree paths. Planning terminates upon reaching the goal or hitting a 30-second time limit, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connected_node = self._connect_tree(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if connected_node is not None:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = connected_node.path_from_root()\n                # avoid duplicate join node\n                extracted_path = path_a + path_b[-2::-1] \n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, sample_point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest_node.position, sample_point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n        new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n        nearest_node.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest_node, new_node))\n        return new_node\n\n    def _connect_tree(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, target_node.position)\n        dist = math.dist(nearest_node.position, target_node.position)\n        if dist > self.step_size:\n            new_pos = self._steer(nearest_node.position, target_node.position)\n            if (self._is_in_obstacle(new_pos, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            if math.dist(new_node.position, target_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                final_node = Node(target_node.position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            return None\n        else:\n            if (self._is_in_obstacle(target_node.position, obstacles, is_3d) or \n                self._is_edge_in_obstacle(nearest_node.position, target_node.position, obstacles, is_3d)):\n                return None\n            final_node = Node(target_node.position, parent=nearest_node, cost=nearest_node.cost + dist)\n            nearest_node.add_child(final_node)\n            tree.append(final_node)\n            nodes.append(final_node)\n            edges.append((nearest_node, final_node))\n            return final_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.81258,
          "time_improvement": 85.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005401754379272461,
                    "num_nodes_avg": 114.2,
                    "path_length_avg": 191.91931169727346,
                    "smoothness_avg": 0.010422378140458174,
                    "success_improvement": 0.0,
                    "time_improvement": 79.11372100741177,
                    "length_improvement": -5.19401589738194,
                    "smoothness_improvement": 63.13285045454905,
                    "objective_score": 20.933371016067113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009308695793151855,
                    "num_nodes_avg": 249.9,
                    "path_length_avg": 303.7405843856087,
                    "smoothness_avg": 0.0065543332961882795,
                    "success_improvement": 0.0,
                    "time_improvement": 94.33519768518391,
                    "length_improvement": -1.397349755886233,
                    "smoothness_improvement": 68.64771660637766,
                    "objective_score": 27.80538803505532
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009527850151062011,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 155.08847600410883,
                    "smoothness_avg": 0.013322467560618296,
                    "success_improvement": 0.0,
                    "time_improvement": 80.51030674685057,
                    "length_improvement": -3.002381242304039,
                    "smoothness_improvement": 69.46080400879985,
                    "objective_score": 22.69896729871675
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that uses fixed radius rewiring with consistent parent-child relationship updates, goal-biased sampling, and early stopping upon finding a solution to balance exploration and planning efficiency. The algorithm avoids recursive cost propagation by incremental cost updates during rewiring and maintains a time limit for robust real-time performance.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points biased toward their opposite root, extends toward samples with fixed step size, locally rewires neighbors within a constant radius to improve path cost, and attempts connection of the two trees. Collision checks ensure feasibility of nodes and edges. Upon connecting trees, the planner extracts the path and terminates early, returning the best path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.rewire_radius = 15.0\n        self.time_limit = 30.0\n        self.improve_tol = 1e-8\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, p1, p2):\n        return math.dist(p1, p2)\n\n    def _sample(self, bounds, obstacles, is_3d, target, goal_bias_prob):\n        if random.random() < goal_bias_prob and not self._is_in_obstacle(target, obstacles, is_3d):\n            return target\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree: List[Node], point: Tuple[float, ...]) -> Node:\n        nearest_node = None\n        min_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n        radius_sq = radius * radius\n        result = []\n        for node in tree:\n            d_sq = sum((a - b) ** 2 for a, b in zip(node.position, point))\n            if d_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _build_path(self, node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n        path_start = node_start.path_from_root()\n        path_goal = node_goal.path_from_root()\n        path_goal.reverse()\n        return path_start + path_goal[1:]\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        time_start = time.monotonic()\n        def time_exceeded() -> bool:\n            return (time.monotonic() - time_start) > self.time_limit\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for i in range(self.max_iter):\n            if time_exceeded():\n                break\n\n            expand_start = (i % 2 == 0)\n            tree_a, tree_b = (tree_start, tree_goal) if expand_start else (tree_goal, tree_start)\n            target_sample = goal_pos if expand_start else start_pos\n            sample = self._sample(bounds, obstacles, is_3d, target_sample, self.goal_sample_rate)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = self._near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_candidate + self.improve_tol < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = near_node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, near_node.position)\n                if cost_through_new + self.improve_tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            nearest_other = self._nearest(tree_b, new_node.position)\n            dist_to_other = self._dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    connect_node = Node(new_node.position, parent=nearest_other, cost=nearest_other.cost + dist_to_other)\n                    nearest_other.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((nearest_other, connect_node))\n\n                    if expand_start:\n                        path = self._build_path(new_node, connect_node)\n                        total_cost = new_node.cost + (connect_node.cost - nearest_other.cost)\n                    else:\n                        path = self._build_path(connect_node, new_node)\n                        total_cost = connect_node.cost + (new_node.cost - best_parent.cost)\n\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n                        found_solution = True\n                        break\n\n            if found_solution:\n                break\n\n        success_state = found_solution\n        extracted_path = best_path if found_solution else []\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": -23.64699,
          "time_improvement": 42.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 312.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012988829612731933,
                    "num_nodes_avg": 105.7,
                    "path_length_avg": 158.0716475211238,
                    "smoothness_avg": 0.02391556040922841,
                    "success_improvement": 0.0,
                    "time_improvement": 49.77773885467754,
                    "length_improvement": 13.35842518812721,
                    "smoothness_improvement": 274.3304538750773,
                    "objective_score": 24.32002903865497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02958998680114746,
                    "num_nodes_avg": 266.1,
                    "path_length_avg": 243.47383404946873,
                    "smoothness_avg": 0.017303870387007696,
                    "success_improvement": 0.0,
                    "time_improvement": 81.99302786864814,
                    "length_improvement": 18.72142618854365,
                    "smoothness_improvement": 345.24104853177045,
                    "objective_score": 37.55696931637948
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05162415504455566,
                    "num_nodes_avg": 288.1,
                    "path_length_avg": 127.56547078962936,
                    "smoothness_avg": 0.03266774598713309,
                    "success_improvement": 0.0,
                    "time_improvement": -5.599786973902844,
                    "length_improvement": 15.27708831648271,
                    "smoothness_improvement": 315.53131767414845,
                    "objective_score": 9.063973486089514
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner with fixed step size and unbiased random sampling that grows two trees alternately from start and goal without goal bias or rewiring. The planner uses straightforward linear nearest neighbor search, edge and node collision checks with fixed resolution, and attempts tree connection whenever new nodes are close enough. It terminates upon the first connection or after a 30-second timeout, returning the path found.",
          "planning_mechanism": "The planner alternately grows start and goal trees by uniformly sampling free states without goal bias, extending nearest nodes by a fixed step, and checking node and edge collisions. Upon each extension, it attempts to connect the newly added node to the opposite tree if within step size, merging paths when successful. The process repeats until a path is found or time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = math.dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        active_tree = start_tree\n        passive_tree = goal_tree\n\n        best_path = []\n        success = False\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            rnd_point = sample_free()\n            nearest_node = nearest(active_tree, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                active_tree, passive_tree = passive_tree, active_tree\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_in_passive = nearest(passive_tree, new_pos)\n            dist_connect = math.dist(new_pos, nearest_in_passive.position)\n\n            if dist_connect <= self.step_size and not edge_in_obstacle(new_pos, nearest_in_passive.position):\n                connect_cost = new_node.cost + dist_connect\n                connect_node = Node(nearest_in_passive.position, parent=new_node, cost=connect_cost)\n                new_node.add_child(connect_node)\n                active_tree.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                path_start = connect_node.path_from_root()\n                path_goal = nearest_in_passive.path_from_root()\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n\n                if connect_cost < best_cost:\n                    best_cost = connect_cost\n                    best_path = full_path\n                    success = True\n                break\n\n            active_tree, passive_tree = passive_tree, active_tree\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -23.45641,
          "time_improvement": 81.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008159184455871582,
                    "num_nodes_avg": 160.3,
                    "path_length_avg": 185.4314620002835,
                    "smoothness_avg": 0.010785415437332243,
                    "success_improvement": 0.0,
                    "time_improvement": 68.45191563110734,
                    "length_improvement": -1.637922671904396,
                    "smoothness_improvement": 68.81517249873633,
                    "objective_score": 19.896896948683246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009363079071044922,
                    "num_nodes_avg": 279.5,
                    "path_length_avg": 310.9313421212245,
                    "smoothness_avg": 0.0065849312150528996,
                    "success_improvement": 0.0,
                    "time_improvement": 94.30210276777103,
                    "length_improvement": -3.797831662520182,
                    "smoothness_improvement": 69.43502309755448,
                    "objective_score": 26.359106948306973
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009993338584899902,
                    "num_nodes_avg": 256.3,
                    "path_length_avg": 150.83101605197797,
                    "smoothness_avg": 0.01337512549586337,
                    "success_improvement": 0.0,
                    "time_improvement": 79.55812691146785,
                    "length_improvement": -0.17477906055582124,
                    "smoothness_improvement": 70.13060905831273,
                    "objective_score": 24.113223682398424
               }
          ],
          "success_rate": 1.0
     }
]