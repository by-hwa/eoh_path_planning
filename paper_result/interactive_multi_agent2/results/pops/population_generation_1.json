[
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
          "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -31.88223,
          "time_improvement": 70.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 318.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.893579481866173,
          "time_improvement": 56.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 178.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0102372407913208,
                    "num_nodes_avg": 117.5,
                    "path_length_avg": 167.09773058241916,
                    "smoothness_avg": 0.01743061917619911,
                    "success_improvement": 0.0,
                    "time_improvement": 59.25898163821438,
                    "length_improvement": 8.411086034792367,
                    "smoothness_improvement": 172.82704130288656,
                    "objective_score": 23.688481318854166
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02068014144897461,
                    "num_nodes_avg": 270.5,
                    "path_length_avg": 254.91986206815108,
                    "smoothness_avg": 0.010869990893363076,
                    "success_improvement": 0.0,
                    "time_improvement": 87.1335117617854,
                    "length_improvement": 14.900412580258132,
                    "smoothness_improvement": 179.6926950242082,
                    "objective_score": 35.978764551811544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03835470676422119,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 131.0348919324295,
                    "smoothness_avg": 0.02219113712511561,
                    "success_improvement": 0.0,
                    "time_improvement": 21.061420166541545,
                    "length_improvement": 12.97286398951632,
                    "smoothness_improvement": 182.26962625211246,
                    "objective_score": 15.013492574932817
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -24.394856704415727,
          "time_improvement": 84.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037204265594482423,
                    "num_nodes_avg": 58.5,
                    "path_length_avg": 184.8763674372614,
                    "smoothness_avg": 0.010656061011327317,
                    "success_improvement": 0.0,
                    "time_improvement": 85.19386523557586,
                    "length_improvement": -1.3336665458757502,
                    "smoothness_improvement": 66.79049483412726,
                    "objective_score": 25.091912117317943
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007217264175415039,
                    "num_nodes_avg": 195.5,
                    "path_length_avg": 293.476072886139,
                    "smoothness_avg": 0.006583639266204931,
                    "success_improvement": 0.0,
                    "time_improvement": 95.50966105071444,
                    "length_improvement": 2.0292396302187403,
                    "smoothness_improvement": 69.4017803231431,
                    "objective_score": 30.217450994961293
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014179682731628418,
                    "num_nodes_avg": 216.3,
                    "path_length_avg": 159.7621915423607,
                    "smoothness_avg": 0.012486187243912596,
                    "success_improvement": 0.0,
                    "time_improvement": 70.81651479687723,
                    "length_improvement": -6.106440564392849,
                    "smoothness_improvement": 58.82338010809535,
                    "objective_score": 17.875207000967936
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -23.298298969701534,
          "time_improvement": 51.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 174.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016666102409362792,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 171.93676993008617,
                    "smoothness_avg": 0.017258852621246313,
                    "success_improvement": 0.0,
                    "time_improvement": 33.67412195140466,
                    "length_improvement": 5.758731888850669,
                    "smoothness_improvement": 170.1385217208312,
                    "objective_score": 14.408168327335954
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026815319061279298,
                    "num_nodes_avg": 207.7,
                    "path_length_avg": 254.55172472875432,
                    "smoothness_avg": 0.010846570009997185,
                    "success_improvement": 0.0,
                    "time_improvement": 83.31641066589374,
                    "length_improvement": 15.023307420394557,
                    "smoothness_improvement": 179.09005882582343,
                    "objective_score": 34.90435794613397
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0310056209564209,
                    "num_nodes_avg": 214.5,
                    "path_length_avg": 128.32906870441866,
                    "smoothness_avg": 0.02145278500029813,
                    "success_improvement": 0.0,
                    "time_improvement": 36.186718876507044,
                    "length_improvement": 14.769942940104954,
                    "smoothness_improvement": 172.8778417239189,
                    "objective_score": 20.58237063563468
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.256651771997145,
          "time_improvement": 85.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005163788795471191,
                    "num_nodes_avg": 88.6,
                    "path_length_avg": 194.6296584579342,
                    "smoothness_avg": 0.01167543363104651,
                    "success_improvement": 0.0,
                    "time_improvement": 79.44973470673519,
                    "length_improvement": -6.679599905092896,
                    "smoothness_improvement": 82.74588993580629,
                    "objective_score": 20.24088991864385
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014127516746520996,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 298.3796473209629,
                    "smoothness_avg": 0.007304556076322401,
                    "success_improvement": 0.0,
                    "time_improvement": 91.21033439240306,
                    "length_improvement": 0.3922853423102244,
                    "smoothness_improvement": 87.95148910285546,
                    "objective_score": 28.03822896862133
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007713985443115234,
                    "num_nodes_avg": 141.8,
                    "path_length_avg": 161.00482297708567,
                    "smoothness_avg": 0.014351820764112542,
                    "success_improvement": 0.0,
                    "time_improvement": 84.12369414062309,
                    "length_improvement": -6.931737195586904,
                    "smoothness_improvement": 82.55410077829661,
                    "objective_score": 21.490836428726265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
          "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.90364,
          "time_improvement": -8.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025247907638549803,
                    "num_nodes_avg": 233.8,
                    "path_length_avg": 170.12946546952813,
                    "smoothness_avg": 0.014816791053862539,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4787803341404643,
                    "length_improvement": 6.749344102254376,
                    "smoothness_improvement": 131.91495516970375,
                    "objective_score": 4.565547136959005
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12624733448028563,
                    "num_nodes_avg": 859.5,
                    "path_length_avg": 236.88602288914717,
                    "smoothness_avg": 0.011656507882273733,
                    "success_improvement": 0.0,
                    "time_improvement": 21.453156004545612,
                    "length_improvement": 20.920627173489493,
                    "smoothness_improvement": 199.93034365416824,
                    "objective_score": 19.98797482372822
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07023768424987793,
                    "num_nodes_avg": 492.5,
                    "path_length_avg": 121.35915641758058,
                    "smoothness_avg": 0.02178086692654423,
                    "success_improvement": 0.0,
                    "time_improvement": -44.55756576526181,
                    "length_improvement": 19.399026809465404,
                    "smoothness_improvement": 177.0510196092805,
                    "objective_score": -0.842598545852899
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
          "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.73775,
          "time_improvement": -3.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 143.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031192827224731445,
                    "num_nodes_avg": 228.2,
                    "path_length_avg": 173.47041072322037,
                    "smoothness_avg": 0.016212433782287948,
                    "success_improvement": 0.0,
                    "time_improvement": -24.137702006209146,
                    "length_improvement": 4.918119068040286,
                    "smoothness_improvement": 153.759794556254,
                    "objective_score": -3.521640188257302
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1286400556564331,
                    "num_nodes_avg": 775.0,
                    "path_length_avg": 247.3898406969005,
                    "smoothness_avg": 0.00894525060365523,
                    "success_improvement": 0.0,
                    "time_improvement": 19.964485390459707,
                    "length_improvement": 17.414150453629286,
                    "smoothness_improvement": 130.16774103563074,
                    "objective_score": 17.088674594493636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050321340560913086,
                    "num_nodes_avg": 417.3,
                    "path_length_avg": 125.51343547763591,
                    "smoothness_avg": 0.01937830391026074,
                    "success_improvement": 0.0,
                    "time_improvement": -3.567345296452773,
                    "length_improvement": 16.639952463287656,
                    "smoothness_improvement": 146.4905953809094,
                    "objective_score": 9.64622086594131
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
          "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 4.05717,
          "time_improvement": -77.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1607.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03238720893859863,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 156.8355269466239,
                    "smoothness_avg": 0.04571460503828216,
                    "success_improvement": 0.0,
                    "time_improvement": -28.890967883954104,
                    "length_improvement": 14.03596246259457,
                    "smoothness_improvement": 615.5328397028414,
                    "objective_score": 2.831951310884718
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.147990083694458,
                    "num_nodes_avg": 859.9,
                    "path_length_avg": 231.82003384026544,
                    "smoothness_avg": 0.10402068439578667,
                    "success_improvement": 0.0,
                    "time_improvement": 7.925548965645519,
                    "length_improvement": 22.611800134415976,
                    "smoothness_improvement": 2576.527132574148,
                    "objective_score": 28.827380433213982
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15016646385192872,
                    "num_nodes_avg": 570.8,
                    "path_length_avg": 123.61458665916646,
                    "smoothness_avg": 0.13595502682176802,
                    "success_improvement": 0.0,
                    "time_improvement": -209.06056635900154,
                    "length_improvement": 17.901077435050915,
                    "smoothness_improvement": 1629.3379060166778,
                    "objective_score": -43.83083391658651
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
          "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
          "objective": 5.46059,
          "time_improvement": -53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 293.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06232309341430664,
                    "num_nodes_avg": 267.2,
                    "path_length_avg": 168.2463107739374,
                    "smoothness_avg": 0.02259680420437422,
                    "success_improvement": 0.0,
                    "time_improvement": -148.0264306480139,
                    "length_improvement": 7.781531031403382,
                    "smoothness_improvement": 253.68905554417486,
                    "objective_score": -38.47056529784127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08523426055908204,
                    "num_nodes_avg": 568.0,
                    "path_length_avg": 241.3226903680994,
                    "smoothness_avg": 0.016808760155440354,
                    "success_improvement": 0.0,
                    "time_improvement": 46.970110737287854,
                    "length_improvement": 19.439539866622514,
                    "smoothness_improvement": 332.5015056600573,
                    "objective_score": 27.41726466946015
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07625963687896728,
                    "num_nodes_avg": 483.4,
                    "path_length_avg": 124.7326333683994,
                    "smoothness_avg": 0.03084680379066026,
                    "success_improvement": 0.0,
                    "time_improvement": -56.951465457596676,
                    "length_improvement": 17.15852404644154,
                    "smoothness_improvement": 292.3690673429857,
                    "objective_score": -5.328479872699152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
          "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.11942,
          "time_improvement": -70.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 182.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02458224296569824,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 160.91673392411104,
                    "smoothness_avg": 0.01622189562126349,
                    "success_improvement": 0.0,
                    "time_improvement": 2.170356988333177,
                    "length_improvement": 11.798988247370831,
                    "smoothness_improvement": 153.90789288293342,
                    "objective_score": 8.50003950933712
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16582508087158204,
                    "num_nodes_avg": 988.6,
                    "path_length_avg": 230.06388904405716,
                    "smoothness_avg": 0.011826311396694525,
                    "success_improvement": 0.0,
                    "time_improvement": -3.170786229848748,
                    "length_improvement": 23.198051815215557,
                    "smoothness_improvement": 204.29951038474306,
                    "objective_score": 13.989092772098425
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14947149753570557,
                    "num_nodes_avg": 650.0,
                    "path_length_avg": 121.70930984019235,
                    "smoothness_avg": 0.022669727327406998,
                    "success_improvement": 0.0,
                    "time_improvement": -207.63024245189973,
                    "length_improvement": 19.166471578680884,
                    "smoothness_improvement": 188.3572582994048,
                    "objective_score": -49.84740349686436
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
          "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 18.33169,
          "time_improvement": -104.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 277.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03312251567840576,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 163.67692862769394,
                    "smoothness_avg": 0.020726203772078875,
                    "success_improvement": 0.0,
                    "time_improvement": -31.81725886398311,
                    "length_improvement": 10.28608179225304,
                    "smoothness_improvement": 224.41009670489822,
                    "objective_score": -2.251478100318617
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2541221618652344,
                    "num_nodes_avg": 968.5,
                    "path_length_avg": 223.78483919358527,
                    "smoothness_avg": 0.016494501307333334,
                    "success_improvement": 0.0,
                    "time_improvement": -58.106259320137475,
                    "length_improvement": 25.29417938773204,
                    "smoothness_improvement": 324.4153991467646,
                    "objective_score": -0.633293167668195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15669703483581543,
                    "num_nodes_avg": 482.5,
                    "path_length_avg": 117.3805344167902,
                    "smoothness_avg": 0.030113844927462913,
                    "success_improvement": 0.0,
                    "time_improvement": -222.5012635370204,
                    "length_improvement": 22.04143810076968,
                    "smoothness_improvement": 283.0458847045111,
                    "objective_score": -52.11028677712176
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, unidirectional RRT* algorithm with goal bias sampling, fixed step extension, fixed-radius rewiring, and immediate termination upon successful goal connection, emphasizing efficient local cost improvements and early path discovery for improved planning time and path quality.",
          "planning_mechanism": "A tree grows from the start by sampling mostly uniformly with occasional sampling of the goal to speed convergence. Each iteration extends towards the sampled point by a fixed step size clipped within map bounds, checks node and edge collisions, selects the lowest-cost parent within a fixed radius, adds the new node, rewires neighbors to improve local path costs, and terminates immediately when a collision-free connection to the goal vicinity is found. The final path is extracted by tracing parents from goal to start.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Goal bias sampling\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within rewiring radius\n            neighbors = [n for n in nodes if dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select best parent minimizing cost + distance, checking edge collision\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better and collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Early stopping if new node close enough to goal and collision free connection\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 21.50785,
          "time_improvement": -106.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 173.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06068551540374756,
                    "num_nodes_avg": 318.7,
                    "path_length_avg": 168.18065361864075,
                    "smoothness_avg": 0.015896461857993056,
                    "success_improvement": 0.0,
                    "time_improvement": -141.5093820450733,
                    "length_improvement": 7.817518758625687,
                    "smoothness_improvement": 148.81414779702322,
                    "objective_score": -37.018232619361456
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1837256908416748,
                    "num_nodes_avg": 894.7,
                    "path_length_avg": 236.1022438834725,
                    "smoothness_avg": 0.01116483989364266,
                    "success_improvement": 0.0,
                    "time_improvement": -14.307943497623887,
                    "length_improvement": 21.18227516541151,
                    "smoothness_improvement": 187.2793721725527,
                    "objective_score": 9.353378910822503
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12804923057556153,
                    "num_nodes_avg": 504.7,
                    "path_length_avg": 122.2273744873662,
                    "smoothness_avg": 0.022171094224557604,
                    "success_improvement": 0.0,
                    "time_improvement": -163.54065154347794,
                    "length_improvement": 18.822397707615522,
                    "smoothness_improvement": 182.01468203642764,
                    "objective_score": -36.85868342829193
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping. The planner dynamically adjusts neighbor search radius based on the number of nodes to balance exploration and exploitation, incorporates goal bias with a higher sampling rate for faster convergence, and performs incremental rewiring using efficient neighbor queries. Collision checks are optimized with adaptive edge resolution, and the planner terminates immediately once the goal is connected, ensuring reduced planning time with high-quality, smooth paths.",
          "planning_mechanism": "The algorithm incrementally grows a single tree from start, sampling randomly with goal bias, and steering toward samples with fixed step size. It dynamically computes neighbors within an adaptive radius proportional to log(n)/n for better rewiring efficiency. For each new node, the best parent minimizing cost and verified for collision is chosen, followed by local rewiring to improve path cost and smoothness. Early termination upon reaching the goal with collision-free connection guarantees fast runtime and high success rates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        final_path = []\n\n        # To accelerate nearest neighbor queries, store positions separately\n        positions = [root.position]\n\n        # Adaptive neighbor radius: r = gamma * (log(n)/n)^{1/d} with gamma tuned for good rewiring\n        # Gamma chosen as 30.0 for moderate neighbor count\n        gamma = 30.0\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return gamma\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 20)\n\n        # Optimized collision checking resolution based on step_size and distance\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size/2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Main loop\n        for iter_id in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Time limit reached, break with best path if any\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search (linear, as no k-d tree available)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision from nearest_node to new_pos\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius search\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Choose best parent minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improving cost\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list carefully\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if goal can connect directly\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n\n                    # Backtrack path\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success but nodes exist, extract path from best node near goal\n        if not success and len(nodes) > 1:\n            # Find node closest to goal\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                # Extract path backwards\n                path = []\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 24.4788,
          "time_improvement": -89.0,
          "length_improvement": 3.0,
          "smoothness_improvement": 112.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015737581253051757,
                    "num_nodes_avg": 191.3,
                    "path_length_avg": 179.56403283207513,
                    "smoothness_avg": 0.01421437809371725,
                    "success_improvement": 0.0,
                    "time_improvement": 37.36934591357285,
                    "length_improvement": 1.5781082305555436,
                    "smoothness_improvement": 122.48588418274917,
                    "objective_score": 12.770098133318925
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14423696994781493,
                    "num_nodes_avg": 916.7,
                    "path_length_avg": 303.4419163034794,
                    "smoothness_avg": 0.007145793076982586,
                    "success_improvement": 0.0,
                    "time_improvement": 10.260610067476575,
                    "length_improvement": -1.2976457533873764,
                    "smoothness_improvement": 83.86640277747577,
                    "objective_score": 2.7189275820979253
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20188889503479004,
                    "num_nodes_avg": 778.9,
                    "path_length_avg": 137.83772884194133,
                    "smoothness_avg": 0.01816319064757809,
                    "success_improvement": 0.0,
                    "time_improvement": -315.51152394832013,
                    "length_improvement": 8.454743630501442,
                    "smoothness_improvement": 131.03444436991745,
                    "objective_score": -88.92543878434559
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
          "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 34.17936,
          "time_improvement": -148.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 307.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06862092018127441,
                    "num_nodes_avg": 284.0,
                    "path_length_avg": 170.5991073480199,
                    "smoothness_avg": 0.023639461522089605,
                    "success_improvement": 0.0,
                    "time_improvement": -173.08981258681808,
                    "length_improvement": 6.491925946701232,
                    "smoothness_improvement": 270.00890673302524,
                    "objective_score": -46.68174367435956
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09145197868347169,
                    "num_nodes_avg": 589.8,
                    "path_length_avg": 238.92126140318732,
                    "smoothness_avg": 0.017217767150899767,
                    "success_improvement": 0.0,
                    "time_improvement": 43.10165571180447,
                    "length_improvement": 20.24120597641038,
                    "smoothness_improvement": 343.0255502490592,
                    "objective_score": 26.790348050632865
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20080511569976806,
                    "num_nodes_avg": 632.2,
                    "path_length_avg": 125.97622721535136,
                    "smoothness_avg": 0.03204491385721169,
                    "success_improvement": 0.0,
                    "time_improvement": -313.2809762847595,
                    "length_improvement": 16.332588226871458,
                    "smoothness_improvement": 307.60893895423396,
                    "objective_score": -82.6466952545338
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
          "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 34.24822,
          "time_improvement": -158.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 287.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05595297813415527,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 160.14345768443917,
                    "smoothness_avg": 0.020991279248420664,
                    "success_improvement": 0.0,
                    "time_improvement": -122.67536302290098,
                    "length_improvement": 12.22283320768113,
                    "smoothness_improvement": 228.55910353025726,
                    "objective_score": -28.326113464610327
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23264851570129394,
                    "num_nodes_avg": 948.8,
                    "path_length_avg": 225.03802962507376,
                    "smoothness_avg": 0.017004339084283518,
                    "success_improvement": 0.0,
                    "time_improvement": -44.746079145276,
                    "length_improvement": 24.875828350614626,
                    "smoothness_improvement": 337.5338923690004,
                    "objective_score": 3.189342728630977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19719173908233642,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 118.75610965494363,
                    "smoothness_avg": 0.030953946710724024,
                    "success_improvement": 0.0,
                    "time_improvement": -305.8442144725285,
                    "length_improvement": 21.127846525442067,
                    "smoothness_improvement": 293.73191737772913,
                    "objective_score": -77.60789683960466
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 69.43496400372943,
          "time_improvement": -276.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 165.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05916297435760498,
                    "num_nodes_avg": 394.9,
                    "path_length_avg": 155.53505227340733,
                    "smoothness_avg": 0.014549204278916808,
                    "success_improvement": 0.0,
                    "time_improvement": -135.4501446019083,
                    "length_improvement": 14.748773238324494,
                    "smoothness_improvement": 127.72664106782084,
                    "objective_score": -31.14714623223869
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.580695104598999,
                    "num_nodes_avg": 1589.2,
                    "path_length_avg": 226.77578579094256,
                    "smoothness_avg": 0.011489796720712679,
                    "success_improvement": 0.0,
                    "time_improvement": -261.2889569322687,
                    "length_improvement": 24.29571532390974,
                    "smoothness_improvement": 195.64074539000617,
                    "objective_score": -62.831054158384745
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.25779869556427004,
                    "num_nodes_avg": 856.3,
                    "path_length_avg": 115.47581220588968,
                    "smoothness_avg": 0.02144048255314569,
                    "success_improvement": 0.0,
                    "time_improvement": -430.58058912720264,
                    "length_improvement": 23.30646390012476,
                    "smoothness_improvement": 172.72135550421203,
                    "objective_score": -114.32669162056487
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 71.35259809409325,
          "time_improvement": -285.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 406.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15097854137420655,
                    "num_nodes_avg": 375.4,
                    "path_length_avg": 150.76257022061387,
                    "smoothness_avg": 0.03392657193105306,
                    "success_improvement": 0.0,
                    "time_improvement": -500.847401340509,
                    "length_improvement": 17.364646276278172,
                    "smoothness_improvement": 431.0245234511015,
                    "objective_score": -137.6803100191303
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1728947401046753,
                    "num_nodes_avg": 649.8,
                    "path_length_avg": 238.74738839156012,
                    "smoothness_avg": 0.016703858220063185,
                    "success_improvement": 0.0,
                    "time_improvement": -7.569290350104155,
                    "length_improvement": 20.29924979234869,
                    "smoothness_improvement": 329.8023033049928,
                    "objective_score": 11.55777428690293
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21681342124938965,
                    "num_nodes_avg": 472.1,
                    "path_length_avg": 116.30409151558926,
                    "smoothness_avg": 0.04370027229081557,
                    "success_improvement": 0.0,
                    "time_improvement": -346.2279862409406,
                    "length_improvement": 22.756360221044645,
                    "smoothness_improvement": 455.8642379206061,
                    "objective_score": -87.93525855005237
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 73.40333338576892,
          "time_improvement": -288.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 389.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.16166269779205322,
                    "num_nodes_avg": 366.6,
                    "path_length_avg": 156.66138543147994,
                    "smoothness_avg": 0.03327697545139476,
                    "success_improvement": 0.0,
                    "time_improvement": -543.3670041976302,
                    "length_improvement": 14.131412186493867,
                    "smoothness_improvement": 420.8569279231159,
                    "objective_score": -152.42696930777717
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11132118701934815,
                    "num_nodes_avg": 537.4,
                    "path_length_avg": 239.26410796616088,
                    "smoothness_avg": 0.017889281630668625,
                    "success_improvement": 0.0,
                    "time_improvement": 30.739702773186362,
                    "length_improvement": 20.126753925398656,
                    "smoothness_improvement": 360.3041014858415,
                    "objective_score": 23.099483694624308
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21873629093170166,
                    "num_nodes_avg": 477.3,
                    "path_length_avg": 119.85461749636617,
                    "smoothness_avg": 0.03827330701031982,
                    "success_improvement": 0.0,
                    "time_improvement": -350.185482327656,
                    "length_improvement": 20.398269922491448,
                    "smoothness_improvement": 386.8336401296087,
                    "objective_score": -90.88251454415389
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid anytime RRT* variant leveraging incremental informed sampling, adaptive connection radius, and batch rewiring to improve efficiency and path quality within a 30-second hard limit. The planner initially explores globally with uniform samples, then focuses sampling within an ellipsoidal informed set after finding a solution. It maintains node validity strictly with collision checks, dynamically selects the best parent, rewires neighbors to reduce cost, and terminates early if elapsed time or solution quality stabilizes. The final path is extracted from the best goal node or closest node otherwise, returning a well-optimized, smooth path.",
          "planning_mechanism": "The planner builds a single tree by iteratively sampling states using a goal-biased plus informed ellipsoidal distribution. Each new sample is connected to the lowest-cost parent within an adaptive radius and neighbors are rewired to optimize paths. Collision checks ensure node and edge feasibility. The connection radius shrinks as iterations grow. Early termination occurs if no improvement over a threshold is observed or time limit elapses. The solution path is extracted from the best goal node found or nearest node if no complete path is available.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.batch_size = 50  # batch rewiring frequency\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            # If no solution yet or degenerate, uniform sample\n            if c_best == float('inf') or c_min < 1e-10 or dim not in (2, 3):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n\n            axes = (r1,) + (r_other,) * (dim - 1)\n\n            attempts = 0\n            while attempts < 200:\n                # sample random point on unit ball\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate sample so major axis aligns with vector e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    else:  # dim == 3\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0.0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            # Linear search acceptable due to modest node count; KD-tree could help for performance\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (dist(n.position, point) <= radius)]\n\n        def path_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_counter = 0\n        max_no_improve = 150\n\n        c_min = dist(start_pos, goal_pos)\n\n        for iteration in range(self.max_iter):\n\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n            c_best = best_cost if found_solution else float('inf')\n\n            # Sample: goal biasing and informed sampling after first solution\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            # Reject invalid samples\n            if is_in_obstacle(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius (RRT* radius with lower/upper bounds)\n            rmax = self.step_size * 20.0\n            rmin = self.step_size\n            gamma_rrt_star = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (1 + 1/dim) ) / ( ( (4/3)*math.pi if dim==3 else 1) ) )**(1/dim) )\n            radius = min(rmax, max(rmin, gamma_rrt_star * ( (math.log(len(nodes)+1) / (len(nodes)+1))**(1/dim) )))\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent among neighbors (lowest cost + feasibilty)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + self.improve_tol < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring every batch_size nodes to reduce overhead\n            if (len(nodes) % self.batch_size) == 0:\n                for nbr in neighbors:\n                    if nbr == best_parent or nbr == new_node:\n                        continue\n                    rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if rewired_cost + self.improve_tol < nbr.cost:\n                        if not is_edge_in_obstacle(new_node.position, nbr.position):\n                            # Rewire tree structure and edges\n                            old_parent = nbr.parent\n                            if old_parent:\n                                old_parent.remove_child(nbr)\n                                try:\n                                    edges.remove((old_parent, nbr))\n                                except ValueError:\n                                    pass\n                            new_node.add_child(nbr)\n                            nbr.cost = rewired_cost\n                            edges.append((new_node, nbr))\n\n            # Check goal connection if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_counter = 0\n\n            # Early stopping if solution stable\n            if found_solution:\n                no_improve_counter += 1\n                if no_improve_counter > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # Return path to closest node to goal if no full solution found\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
          "objective": 86.90523,
          "time_improvement": -233.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0693166971206665,
                    "num_nodes_avg": 474.6,
                    "path_length_avg": 189.36555780350008,
                    "smoothness_avg": 0.01005017057735644,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -175.85878731753974,
                    "length_improvement": -3.7942629213847154,
                    "smoothness_improvement": 57.306993830346954,
                    "objective_score": -104.747658978941
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2834985971450806,
                    "num_nodes_avg": 1140.4,
                    "path_length_avg": 305.68179407811465,
                    "smoothness_avg": 0.006235597586945562,
                    "success_improvement": 0.0,
                    "time_improvement": -76.38328899816969,
                    "length_improvement": -2.0453814258676606,
                    "smoothness_improvement": 60.44641723151071,
                    "objective_score": -23.83998346881395
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2649787425994873,
                    "num_nodes_avg": 736.2,
                    "path_length_avg": 147.6887523984348,
                    "smoothness_avg": 0.013082809065717802,
                    "success_improvement": 0.0,
                    "time_improvement": -445.35798579931594,
                    "length_improvement": 1.9121628396116364,
                    "smoothness_improvement": 66.41236564341555,
                    "objective_score": -132.12803620781074
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid single-tree RRT* planner with adaptive informed sampling, dynamic rewiring radius, and early termination by time and solution stability. The algorithm integrates cost-aware parent selection, rewiring of neighbors to ensure smooth and shorter paths, ellipsoidal sampling for focused search once a solution is found, and robust node and edge collision checks within a 30-second time limit.",
          "planning_mechanism": "The planner incrementally builds a tree from start, sampling uniformly at first and within an informed ellipsoidal region after finding a first feasible path. Nodes are extended towards samples using fixed step size, with best-parent selection from neighbors under an adaptive radius. Rewiring refines local connections to reduce path cost, and search terminates early upon either time limit or stability in path cost improvements. The final path is backtracked from the best goal node or closest node if no complete path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0        # seconds\n        self.improve_tol = 1e-6       # cost improvement threshold for rewiring and early stop\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf') or (dim != 2 and dim != 3):\n                return uniform_sample()\n\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            rest_radius = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n\n            if dim == 2:\n                axes = (r1, rest_radius)\n            else:  # dim == 3\n                axes = (r1, rest_radius, rest_radius)\n\n            attempts = 0\n            while attempts < 200:\n                # Sample unit ball point\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n\n                # Scale by random radius within ball\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotation matrix aligning [1,0,...] to e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    else:  # dim == 3\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0.0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, pt):\n            return min(nodes_list, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            return [n for n in nodes_list if dist(n.position, pt) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            cost_limit = best_cost if found_solution else float('inf')\n            # Sample with goal biasing and informed region when solution found\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(cost_limit, dist(start_pos, goal_pos))\n\n            if is_in_obstacle(sample):\n                continue\n\n            nn = nearest_node(nodes, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nn.position, new_pos):\n                continue\n\n            tentative_cost = nn.cost + dist(nn.position, new_pos)\n            new_node = Node(new_pos, cost=tentative_cost)\n\n            # Dynamic radius based on number of nodes (RRT* radius)\n            gamma_rrt_star = 50.0\n            radius = gamma_rrt_star * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1.0 / dim))\n            radius = max(radius, self.step_size)\n            radius = min(radius, self.step_size * 15.0)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n            # Best parent selection (lowest-cost among neighbors)\n            best_parent = nn\n            best_parent_cost = tentative_cost\n\n            for nbr in neighbors:\n                if nbr == nn:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_parent_cost = cost_thru_nbr\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        new_node.add_child(nbr)\n                        nbr.cost = cost_thru_new\n                        edges.append((new_node, nbr))\n\n            # Check if near goal to connect\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos, cost=goal_cost)\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n        else:\n            # Return path to closest node to goal\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 107.04616,
          "time_improvement": -388.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 129.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07088694572448731,
                    "num_nodes_avg": 500.2,
                    "path_length_avg": 162.77132866625377,
                    "smoothness_avg": 0.01701956550948016,
                    "success_improvement": 0.0,
                    "time_improvement": -182.10788592769148,
                    "length_improvement": 10.782455481268096,
                    "smoothness_improvement": 166.3931588014109,
                    "objective_score": -47.33092669553953
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.29100329875946046,
                    "num_nodes_avg": 1173.7,
                    "path_length_avg": 253.0320888728905,
                    "smoothness_avg": 0.00691947049603768,
                    "success_improvement": 0.0,
                    "time_improvement": -81.05246185131362,
                    "length_improvement": 15.530605609374762,
                    "smoothness_improvement": 78.04295975619733,
                    "objective_score": -14.607160390988245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.4858510732650757,
                    "num_nodes_avg": 1042.5,
                    "path_length_avg": 125.29571531748675,
                    "smoothness_avg": 0.019037418514756693,
                    "success_improvement": 0.0,
                    "time_improvement": -899.9396937088123,
                    "length_improvement": 16.784551826938795,
                    "smoothness_improvement": 142.15455831164047,
                    "objective_score": -259.2004042249222
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 111.44075649781428,
          "time_improvement": -317.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 419.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03433616161346435,
                    "num_nodes_avg": 448.9,
                    "path_length_avg": 189.5537633957924,
                    "smoothness_avg": 0.006227007470703637,
                    "success_improvement": 0.0,
                    "time_improvement": -36.64719032040138,
                    "length_improvement": -3.8974213888285925,
                    "smoothness_improvement": -2.533810920335722,
                    "objective_score": -13.345278984019247
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.19180481433868407,
                    "num_nodes_avg": 1625.6,
                    "path_length_avg": 307.5662827106842,
                    "smoothness_avg": 0.0038426714244542983,
                    "success_improvement": 0.0,
                    "time_improvement": -19.33450232004949,
                    "length_improvement": -2.674477973417143,
                    "smoothness_improvement": -1.1252964844377429,
                    "objective_score": -7.410663962487321
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.48322105407714844,
                    "num_nodes_avg": 1485.4,
                    "path_length_avg": 154.3427121624898,
                    "smoothness_avg": 0.10685536021737363,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -894.5267992521824,
                    "length_improvement": -2.507080408158668,
                    "smoothness_improvement": 1259.1922947227413,
                    "objective_score": -313.56632654693624
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "A structurally enhanced single-tree RRT* planner with adaptive informed sampling restricted to an ellipsoidal subset after first solution, dynamic rewiring radius adapting with node density and planning progress, incremental pruning of outdated nodes, and efficient early stopping based on path improvement and a hard 30-second time limit, aiming to improve planning efficiency, path length, and smoothness simultaneously.",
          "planning_mechanism": "The planner grows a single tree rooted at start by sampling points uniformly before first solution and then within an ellipsoidal informed subset defined by the current best path cost. It steers toward samples with fixed step size, connects only collision-free edges, and uses an adaptive neighbor radius based on the number of nodes and problem dimension to select parents and rewire neighbors, improving path cost and smoothness incrementally. Periodic pruning removes invalid or suboptimal nodes to keep the tree streamlined. Planning halts either on 30-second timeout or when no improvements occur for a threshold number of iterations. The path is extracted from the best goal-connected node.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # hard time limit in seconds\n        self.improve_tol = 1e-5\n        self.max_no_improve = 200\n        self.prune_interval = 500  # iterations between pruning\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min):\n            # If no solution found, uniform sample\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x * x for x in raw))\n                if norm_raw < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align the first axis to e1 (only implemented for 2D/3D)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n\n            while True:  # fallback uniform sample\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def prune_nodes():\n            # Remove invalid or isolated nodes to reduce tree complexity\n            to_remove = []\n            for n in nodes:\n                # Remove nodes marked invalid or disconnected from tree\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            # Remove nodes safely\n            for n in to_remove:\n                # Disconnect from parent\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                # Disconnect all children\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # Remove edges connected to n\n                for edge in list(edges):\n                    if edge[0] == n or edge[1] == n:\n                        edges.remove(edge)\n\n        iteration = 0\n        c_min = dist(start_pos, goal_pos)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min)\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius: theoretical for RRT* with safety margins\n            gamma = 35.0\n            n_nodes = len(nodes) + 1\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_parent_cost = new_cost\n            for near_node in near:\n                if near_node == nearest:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_parent_cost = cost_through\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better path found\n            for near_node in near:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge if present\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to goal if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.cost = goal_cost\n                    goal_node.parent = new_node\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Periodic pruning to improve planning efficiency\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # fallback: closest node to goal\n            closest = nearest_node(nodes, goal_pos)\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 111.52446,
          "time_improvement": -394.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 83.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.12738897800445556,
                    "num_nodes_avg": 790.2,
                    "path_length_avg": 169.3978892921885,
                    "smoothness_avg": 0.012305547640369511,
                    "success_improvement": 0.0,
                    "time_improvement": -406.9683128259236,
                    "length_improvement": 7.150332597620601,
                    "smoothness_improvement": 92.60854249618313,
                    "objective_score": -117.3372515767238
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.38849313259124757,
                    "num_nodes_avg": 1255.3,
                    "path_length_avg": 264.7068157958746,
                    "smoothness_avg": 0.0060919297753769235,
                    "success_improvement": 0.0,
                    "time_improvement": -141.70735647266443,
                    "length_improvement": 11.633245724100348,
                    "smoothness_improvement": 56.749740960107644,
                    "objective_score": -35.24851080253858
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.356812047958374,
                    "num_nodes_avg": 938.3,
                    "path_length_avg": 130.9430033769814,
                    "smoothness_avg": 0.015733291561431894,
                    "success_improvement": 0.0,
                    "time_improvement": -634.3619260720436,
                    "length_improvement": 13.033891992782134,
                    "smoothness_improvement": 100.1263073506315,
                    "objective_score": -181.98761108919064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid adaptive RRT* planner integrating dynamic informed sampling, incremental rewiring with adaptive neighborhood radius, and early stopping based on path quality and time limit to efficiently generate smooth, short paths. The algorithm grows a single tree from start to goal, uses heuristic-guided sampling within an informed prolate hyperspheroid after a first solution is found, incrementally rewires neighboring nodes for path cost improvement and smoothness, and respects a hard 30-second planning time cap while always ensuring obstacle-free nodes and edges.",
          "planning_mechanism": "A single RRT* tree rooted at the start expands by sampling free space points, steering with fixed step size, and connecting nodes avoiding collisions. Upon first solution to the goal, sampling is restricted to an informed ellipsoidal region to focus search on improving path quality. Rewiring is performed within an adaptively scaled radius, recalculating parents of nearby nodes if more optimal connections are found. Early termination occurs if the time limit is reached or path improvement stalls. Path extraction follows parent links from the best goal node found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cost to arrive at this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.improve_tol = 1e-5\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = math.dist(start_pos, goal_pos) + 1e-6  # c_min baseline\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200  # stop after no improvement streak\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            # If no valid solution yet, uniform sample in bounds\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            # Ellipsoidal informed sampling in prolate hyperspheroid\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case fallback to uniform\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                # fallback\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            attempts = 0\n            while attempts < 200:\n                # Sample point in unit n-ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n                # Rotation: align first axis to e1\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        # Higher dim no rotation\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            # fallback uniform\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            # naive linear search\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for iteration in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best_now = best_cost if found_solution else float('inf')\n            sample = informed_sample(c_best_now, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Determine radius for neighbors (theoretical for RRT*)\n            gamma_rrt_star = 30.0\n            radius = min(gamma_rrt_star * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1.0 / dim)), self.step_size * 15.0)\n            radius = max(radius, self.step_size)\n\n            near_nodes_list = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent in near nodes including nearest node\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for near_nd in near_nodes_list:\n                if near_nd == nearest_nd:\n                    continue\n                cost_to_new = near_nd.cost + dist(near_nd.position, new_pos)\n                if cost_to_new + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_parent_cost = cost_to_new\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if routing via new_node improves cost\n            for near_nd in near_nodes_list:\n                if near_nd == best_parent or near_nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        # Rewire near_nd parent to new_node\n                        if near_nd.parent:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            if near_nd in near_nd.parent.children:\n                                near_nd.parent.children.remove(near_nd)\n                        near_nd.parent = new_node\n                        near_nd.cost = alt_cost\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            # Check if new_node close enough to goal to connect\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n            # Track improvements or no improvement\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        path = []\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            # Fallback: closest node to goal in tree\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 143.08918,
          "time_improvement": -500.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15224921703338623,
                    "num_nodes_avg": 866.9,
                    "path_length_avg": 169.0294006259298,
                    "smoothness_avg": 0.010714219749564683,
                    "success_improvement": 0.0,
                    "time_improvement": -505.9042932724056,
                    "length_improvement": 7.352307074673563,
                    "smoothness_improvement": 67.70080538126352,
                    "objective_score": -147.02139971001122
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.4202205896377563,
                    "num_nodes_avg": 1270.0,
                    "path_length_avg": 260.6344910421428,
                    "smoothness_avg": 0.006124877639116277,
                    "success_improvement": 0.0,
                    "time_improvement": -161.44711279515343,
                    "length_improvement": 12.992704942264869,
                    "smoothness_improvement": 57.59751322550824,
                    "objective_score": -40.35052330705956
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.45266926288604736,
                    "num_nodes_avg": 1011.5,
                    "path_length_avg": 132.66717919553537,
                    "smoothness_avg": 0.015179209348280523,
                    "success_improvement": 0.0,
                    "time_improvement": -831.6475541358143,
                    "length_improvement": 11.888776510528306,
                    "smoothness_improvement": 93.07842249744077,
                    "objective_score": -241.8956082219401
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An adaptive single-tree RRT* planner utilizing dynamic fixed-radius rewiring, informed sampling after first solution, goal biasing, and early termination upon stable path quality or time limit. It incrementally builds a tree from start to goal, refines parent-child connections locally to improve path cost and smoothness, and efficiently rejects invalid samples and edges to speed planning and yield shorter, smoother paths within a 30-second hard runtime limit.",
          "planning_mechanism": "The planner starts from the start node and samples within bounds or an ellipsoidal informed region after the first feasible path is found. Candidates are steered toward samples under a fixed step size, checked for collision, and connected to the tree using best-parent selection within a fixed rewire radius. Nodes near the newly added node are rewired if a lower-cost connection is possible. Upon connecting near the goal, a goal node is added, updating the best path. The process early stops if improvement stalls or the time limit is exceeded. The final path is extracted by backtracking parent links from the best goal node.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1,p2,resolution=1.0):\n            length = dist(p1,p2)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                axes = (r1,r2)\n            elif dim ==3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                axes = (r1,r_side,r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi/norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius*axes[i]*x_unit[i] for i in range(dim)]\n\n                # rotation aligning first axis\n                v = [1.0]+[0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot-1.0)<1e-10:\n                    x_rot = x_scaled\n                elif abs(dot+1.0)<1e-10:\n                    x_rot = [-x_scaled[0]]+x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i]+x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, pt):\n            return min(nodes_list, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            res = [n for n in nodes_list if dist(n.position, pt)<=radius]\n            return res\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            cost_limit = best_cost if found_solution else float('inf')\n            sample = informed_sample(cost_limit, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            gamma = 50.0\n            radius = min(gamma * ((math.log(len(nodes)+1)/(len(nodes)+1))**(1.0/dim)), self.step_size*15.0)\n            radius = max(radius, self.step_size)\n\n            nearlist = near_nodes(nodes, new_pos, radius)\n\n            # Best parent selection\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for nd in nearlist:\n                if nd == nearest_nd:\n                    continue\n                c_to_new = nd.cost + dist(nd.position, new_pos)\n                if c_to_new + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nd.position, new_pos):\n                        best_parent = nd\n                        best_parent_cost = c_to_new\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nd in nearlist:\n                if nd == best_parent or nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nd.position)\n                if alt_cost + self.improve_tol < nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, nd.position):\n                        if nd.parent:\n                            try:\n                                edges.remove((nd.parent, nd))\n                            except ValueError:\n                                pass\n                            if nd in nd.parent.children:\n                                nd.parent.children.remove(nd)\n                        new_node.add_child(nd)\n                        nd.cost = alt_cost\n                        edges.append((new_node, nd))\n\n            # Check connection to goal\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            closest_to_goal = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = path_to_root(closest_to_goal)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 152.61119,
          "time_improvement": -540.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 117.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15092802047729492,
                    "num_nodes_avg": 863.8,
                    "path_length_avg": 162.36859365892434,
                    "smoothness_avg": 0.015110008485613719,
                    "success_improvement": 0.0,
                    "time_improvement": -500.6463439627754,
                    "length_improvement": 11.003200920529931,
                    "smoothness_improvement": 136.504444708454,
                    "objective_score": -142.9094604129724
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6118797302246094,
                    "num_nodes_avg": 1405.4,
                    "path_length_avg": 248.68606999022057,
                    "smoothness_avg": 0.00659233808573544,
                    "success_improvement": 0.0,
                    "time_improvement": -280.69098180792236,
                    "length_improvement": 16.98143180562754,
                    "smoothness_improvement": 69.62560721516955,
                    "objective_score": -73.67030742292432
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.45596287250518797,
                    "num_nodes_avg": 955.8,
                    "path_length_avg": 126.58496176118032,
                    "smoothness_avg": 0.019136779325541177,
                    "success_improvement": 0.0,
                    "time_improvement": -838.4261971706584,
                    "length_improvement": 15.928295726355978,
                    "smoothness_improvement": 143.41842049076695,
                    "objective_score": -241.25378961293006
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced single-tree RRT* planner featuring adaptive neighbor radius, goal-biased sampling, incremental rewiring with caching, and early stopping upon reaching the goal within time limits. It uses efficient nearest neighbor search with spatial subdivision to reduce collision checks, dynamically adjusts rewiring radius for improved path optimization and smoothness, and incorporates inline path shortcutting for post-processing path smoothing. Continuous incremental rewiring ensures locally optimal cost improvements, while early termination and strict collision checks maintain planning efficiency and path validity.",
          "planning_mechanism": "The planner incrementally grows a single tree from start to goal using goal bias sampling to accelerate convergence. Each new node is connected by choosing the best parent from neighbors within an adaptively scaled radius to minimize path cost, then rewires neighbors to leverage improved paths. Efficient nearest neighbor queries and collision checking restrict costly operations. The search terminates early upon connecting to the goal, returning a smoothed, low-cost path found within a hard 30-second time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, rewire_factor=1.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # multiplier for neighbor radius scaling\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n        from collections import deque\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # hard time limit in seconds\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def calc_neighbor_radius(n_nodes):\n            # Asymptotically optimal radius scaling (RRT*) with factor to increase neighbor candidates\n            gamma_rrt = self.rewire_factor * (2 * (1 + 1/dim))**(1/dim) * ( (math.prod(bounds)) / math.pi )**(1/dim)\n            radius = gamma_rrt * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            # Clamp radius to max step_size * 20 or min step_size * 2 for efficiency and quality balance\n            return max(self.step_size*2, min(radius, self.step_size*20))\n\n        # Efficient spatial grid for coarse nearest neighbor queries to reduce distance checks\n        grid_cell_size = self.step_size * 5\n        grid = {}\n\n        def grid_key(pos):\n            return tuple(int(pos[i]//grid_cell_size) for i in range(dim))\n\n        def insert_to_grid(node):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def get_neighbors(pos, radius):\n            # Collect grid cells around pos to search candidate neighbors\n            base_key = grid_key(pos)\n            range_cells = 1 + int(radius // grid_cell_size)\n            candidates = []\n            for dx in range(-range_cells, range_cells+1):\n                for dy in range(-range_cells, range_cells+1):\n                    if dim == 2:\n                        key = (base_key[0]+dx, base_key[1]+dy)\n                        if key in grid:\n                            candidates.extend(grid[key])\n                    else:  # dim==3\n                        for dz in range(-range_cells, range_cells+1):\n                            key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                            if key in grid:\n                                candidates.extend(grid[key])\n            # Filter by actual distance\n            radius_sq = radius*radius\n            res = [n for n in candidates if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= radius_sq]\n            return res\n\n        def path_length(path_nodes):\n            length = 0.0\n            for i in range(1, len(path_nodes)):\n                length += dist(path_nodes[i-1].position, path_nodes[i].position)\n            return length\n\n        def extract_path(goal_node):\n            path = deque()\n            cur = goal_node\n            while cur:\n                path.appendleft(cur.position)\n                cur = cur.parent\n            return list(path)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            length = dist(from_pos, to_pos)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                ipos = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(dim))\n                if _is_in_obstacle(ipos):\n                    return True\n            return False\n\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n        insert_to_grid(root)\n        success = False\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if _is_in_obstacle(sample):\n                continue\n\n            # Nearest node from sample with spatial grid acceleration\n            neighbor_radius = calc_neighbor_radius(len(nodes))\n            nearest_candidates = get_neighbors(sample, neighbor_radius*4)\n            if not nearest_candidates:\n                nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            else:\n                nearest_node = min(nearest_candidates, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if new_pos == nearest_node.position:\n                continue\n\n            if _is_in_obstacle(new_pos):\n                continue\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Find neighbors within dynamically computed neighbor radius for parent choosing and rewiring\n            near_nodes = get_neighbors(new_pos, neighbor_radius)\n\n            # Choose best parent minimizing cost + dist if edge is collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    # Early edge collision check - if obstructed, skip\n                    if _is_edge_in_obstacle(candidate.position, new_pos):\n                        continue\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            insert_to_grid(new_node)\n\n            # Rewire neighbors through new node if cost improves and edge is collision-free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-9 < neighbor.cost:\n                    if not _is_edge_in_obstacle(new_node.position, neighbor.position):\n                        # Update edge connections\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new_node can connect goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not _is_edge_in_obstacle(new_node.position, goal_pos) and not _is_in_obstacle(goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    insert_to_grid(goal_node)\n                    if goal_node.cost < best_goal_cost:\n                        best_goal_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        # Early stop upon first connection\n                        success = True\n                        break\n\n        # If success, extract path and perform shortcut smoothing\n        path = []\n        if success and best_goal_node is not None:\n            raw_path = extract_path(best_goal_node)\n\n            # Path shortcutting: attempt to connect non-consecutive nodes directly if collision free\n            def shortcut_path(path):\n                if len(path) <= 2:\n                    return path\n                smoothed = [path[0]]\n                i = 0\n                while i < len(path)-1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not _is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    smoothed.append(path[j])\n                    i = j\n                return smoothed\n\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 182.88711,
          "time_improvement": -504.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1250.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.19517505168914795,
                    "num_nodes_avg": 316.0,
                    "path_length_avg": 159.25974865167302,
                    "smoothness_avg": 0.04629519539222166,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -676.7356973151865,
                    "length_improvement": 12.707208131805992,
                    "smoothness_improvement": 624.6203395141276,
                    "objective_score": -242.2732826179017
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.9561169147491455,
                    "num_nodes_avg": 948.3,
                    "path_length_avg": 223.18985983650342,
                    "smoothness_avg": 0.07988634040203914,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -494.86377635912504,
                    "length_improvement": 25.492800622657203,
                    "smoothness_improvement": 1955.533078349682,
                    "objective_score": -173.3857871423948
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.2143566846847534,
                    "num_nodes_avg": 367.1,
                    "path_length_avg": 116.6925384956489,
                    "smoothness_avg": 0.09984684047761702,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -341.1717281751581,
                    "length_improvement": 22.4983722327465,
                    "smoothness_improvement": 1170.0444409481527,
                    "objective_score": -133.00227290815877
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm enhances bidirectional path planning by combining fast tree connections with adaptive rewiring and informed sampling. It employs a priority-expand strategy, dynamically updating a k-d tree for efficient nearest neighbor search, and limits search within an ellipsoidal informed subset after initial solution detection. The planner performs meticulous collision checking and gradual rewiring to optimize path smoothness, length, and planning efficiency, halting early upon convergence or time expiration.",
          "planning_mechanism": "The method grows two RRT* trees alternately from start and goal with adaptive radius rewiring and efficient nearest neighbor search using a k-d tree. It attempts to greedily connect the trees at each iteration, switching to informed ellipsoidal sampling after first feasible path discovery to focus search near the optimum. Each new node selects the best parent from nearby nodes, rewires neighbors to reduce costs, and updates the best path when connections form. The algorithm stops after no improvement for a threshold number of iterations or a hard time limit (30s), returning the best solution found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # (x,y) or (x,y,z)\n        self.parent = parent                # type: Node or None\n        self.cost = cost                    # path cost from root\n        self.children: List[Node] = []\n        self.valid = True                   # for obstacle validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_no_improve: int=120, post_opt_iters: int=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_bound = max(bounds)\n\n        # Initialize nodes and trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Parameters for radius calculation\n        gamma_rrt_star = 50.0\n        radius_max = max_bound * 0.25\n        radius_min = max(5.0, self.step_size * 2.0)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return radius_min\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(radius_min, min(radius_max, r))\n\n        # Efficient distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check point bounds\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Steering with fixed step size limiting\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        # Collision checks\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest neighbor search (linear brute-force)\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            rn = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if d_sq <= r_sq:\n                    rn.append(node)\n            return rn\n\n        # Best parent selection with collision check\n        def choose_best_parent(tree, new_pos):\n            r = neighbor_radius(len(tree))\n            nbrs = near_nodes(tree, new_pos, r)\n            candidates = [n for n in nbrs if not is_edge_in_obstacle(n.position, new_pos)]\n            if not candidates:\n                # fallback to nearest if nbrs empty or all invalid\n                n_near = nearest(tree, new_pos)\n                if not is_edge_in_obstacle(n_near.position, new_pos):\n                    candidates = [n_near]\n                else:\n                    return None, []\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        # Rewiring neighbors for improved paths\n        def try_rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if is_edge_in_obstacle(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Update tree structure\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        # Path cost utility\n        def path_cost(pth):\n            c = 0.0\n            for i in range(len(pth)-1):\n                c += dist(pth[i], pth[i+1])\n            return c\n\n        # Stitch paths from meeting nodes\n        def stitch_paths(node_a, node_b, a_from_start):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                full = path_a + path_b[-2::-1]\n            else:\n                full = path_a + path_b[::-1]\n            return full if a_from_start else full[::-1]\n\n        # Informed sampling within ellipsoid\n        def sample_informed(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(max(val, 0.0))/2.0\n\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_rest)\n            else:\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_rest, r_rest)\n\n            u = self._sample_unit_ball(dim)\n            mapped = [center[d] + sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # clamp in bounds\n            return tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n\n        # Helpers for cross product etc\n        def cross(a,b):\n            ax,ay,az = a\n            bx,by,bz = b\n            return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n        def norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def normalize(v):\n            n = norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x/n for x in v)\n\n        self._cross = cross\n        self._norm = norm\n        self._normalize = normalize\n        self._sample_unit_ball = lambda dim: self.__sample_unit_ball(dim)\n\n        best_path = []\n        best_cost = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        found_first_solution = False\n        no_improve_streak = 0\n        post_opt_progress = 0\n\n        start_time = time.monotonic()\n\n        use_informed = False\n\n        # Alternate growing start vs goal trees\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:  # Hard limit 30s\n                break\n\n            if it % 2 == 0:\n                tree_grow = tree_start\n                tree_other = tree_goal\n                a_from_start = True\n            else:\n                tree_grow = tree_goal\n                tree_other = tree_start\n                a_from_start = False\n\n            # Sample point\n            if use_informed:\n                sample = sample_informed(start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Skip sample if in obstacle or out of bounds\n            if (not within_bounds(sample)) or is_in_obstacle(sample):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Steer and check edge collision\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Add new node with best parent and rewiring\n            new_node, neighbors = choose_best_parent(tree_grow, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            try_rewire(new_node, neighbors)\n\n            # Attempt greedy connect from other tree toward new_node\n            other_nearest = nearest(tree_other, new_node.position)\n            current = other_nearest\n            connected_node = None\n\n            while True:\n                step_toward = steer(current.position, new_node.position)\n                if (not within_bounds(step_toward)) or is_in_obstacle(step_toward):\n                    break\n                if is_edge_in_obstacle(current.position, step_toward):\n                    break\n\n                add_node, add_neighbors = choose_best_parent(tree_other, step_toward)\n                if add_node is None:\n                    break\n                try_rewire(add_node, add_neighbors)\n                current = add_node\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(current.position, new_node.position):\n                        # Connect final edge and create connecting node at new_node.position\n                        connect_node = Node(new_node.position, parent=None,\n                                            cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(connect_node)\n                        tree_other.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((current, connect_node))\n                        connected_node = connect_node\n                    break\n\n            # If connected, update best path and check stopping criteria\n            if connected_node is not None:\n                candidate_path = stitch_paths(new_node, connected_node, a_from_start)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-8 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    no_improve_streak = 0\n                    found_first_solution = True\n                    post_opt_progress = 0\n                    use_informed = True\n                    success_state = True\n                else:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n\n                if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_first_solution,\n            path=best_path if found_first_solution else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def __sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0,1.0) for _ in range(dim)]\n            nrm = math.sqrt(sum(x*x for x in v))\n            if nrm > 1e-12:\n                v = [x/nrm for x in v]\n                r = random.random() ** (1.0/dim)\n                return tuple(v[i]*r for i in range(dim))",
          "objective": 195.68712,
          "time_improvement": -581.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 337.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.34295485019683836,
                    "num_nodes_avg": 421.0,
                    "path_length_avg": 155.62829807014288,
                    "smoothness_avg": 0.028551389198008637,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1264.8531019196757,
                    "length_improvement": 14.697663739559538,
                    "smoothness_improvement": 346.8912412828284,
                    "objective_score": -418.9028761257528
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.23502867221832274,
                    "num_nodes_avg": 408.8,
                    "path_length_avg": 250.5134008933939,
                    "smoothness_avg": 0.014713884276228101,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -46.226932451188915,
                    "length_improvement": 16.371416153344544,
                    "smoothness_improvement": 278.59884040981956,
                    "objective_score": -52.65223584130084
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2584476709365845,
                    "num_nodes_avg": 391.6,
                    "path_length_avg": 120.11505060702589,
                    "smoothness_avg": 0.03826177341249338,
                    "success_improvement": 0.0,
                    "time_improvement": -431.91625816392127,
                    "length_improvement": 20.225302650883332,
                    "smoothness_improvement": 386.68693361657796,
                    "objective_score": -115.50626119056348
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "An adaptive single-tree RRT* planner using dynamically scaling rewiring radius and goal-biased informed ellipsoidal sampling, with incremental cost propagation during rewiring and a strict 30-second time budget. The planner quickly converges to high-quality, smooth paths by focusing sampling within the minimal prolate hyperspheroid after the first path, dynamically adjusting neighbor connections for rewiring, and performing recursive downstream cost updates to maintain consistent path costs. Early termination is triggered upon timeout, returning the best path found so far.",
          "planning_mechanism": "The planner initializes a single root at the start, samples new nodes mostly within the informed ellipsoid once a path is found, extends nodes by a fixed step size towards samples, selects the best parent within a dynamically sized neighborhood calculated from the current iteration and log of tree size, rewires neighbors to minimize local costs with collision checks, propagates cost changes to descendants recursively to maintain consistency, and continuously updates the best path to the goal node. The search runs until a hard 30-second time limit expiry or iteration limit, returning the best feasible path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.improve_tol = 1e-8\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def point_in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Informed ellipsoidal sampling after first solution\n        def informed_sample(c_best, c_min):\n            # If no solution yet, uniform random sample in bounds avoiding obstacles\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # fallback uniform\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            length = math.sqrt(sum(x * x for x in diff))\n            if length < 1e-10:\n                # degenerate case fallback uniform\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            e1 = tuple(x / length for x in diff)\n            # Compute radii of ellipsoid axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                if c_best > c_min:\n                    r2 = math.sqrt(c_best * c_best - c_min * c_min) / 2\n                else:\n                    r2 = 0.0\n                radii = (r1, r2)\n            elif dim == 3:\n                if c_best > c_min:\n                    r_side = math.sqrt(c_best * c_best - c_min * c_min) / 2\n                else:\n                    r_side = 0.0\n                radii = (r1, r_side, r_side)\n            else:\n                # Fallback uniform\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Generate random point in unit n-ball scaled by radii\n            for _ in range(200):\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-12:\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius_scale = random.random() ** (1.0 / dim)\n                x_scaled = [radius_scale * radii[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate first axis to e1 direction using Rodrigues' rotation (only 2D/3D)\n                if dim == 2:\n                    # 2D rotation by angle between (1,0) and e1\n                    dot = e1[0]\n                    det = e1[1]\n                    cos_a = dot\n                    sin_a = det\n                    x_rot = (x_scaled[0]*cos_a - x_scaled[1]*sin_a,\n                             x_scaled[0]*sin_a + x_scaled[1]*cos_a)\n                elif dim == 3:\n                    # Rodrigues' rotation from (1,0,0) to e1\n                    v = (1.0, 0.0, 0.0)\n                    u = e1\n                    dot = sum(v[i]*u[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-12:\n                        # no rotation\n                        x_rot = x_scaled\n                    elif abs(dot + 1.0) < 1e-12:\n                        # 180 deg rotation around any axis perpendicular to (1,0,0)\n                        x_rot = (-x_scaled[0], -x_scaled[1], -x_scaled[2])\n                    else:\n                        k = (v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0])\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        k = tuple(kk / k_norm for kk in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2] - k[2]*v_vec[1],\n                                 k[2]*v_vec[0] - k[0]*v_vec[2],\n                                 k[0]*v_vec[1] - k[1]*v_vec[0])\n                        x_rot = [0,0,0]\n                        for i in range(3):\n                            x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                else:\n                    # fallback no rotation for higher dims\n                    x_rot = x_scaled\n\n                sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                if point_in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Find nearest node\n        def nearest_node(tree, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        # Find neighbors within radius for rewiring and parent selection\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Recursive function to propagate cost changes downstream after rewiring\n        def propagate_cost_downstream(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_downstream(c)\n\n        root = Node(start_pos, None, 0.0)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        found_solution = False\n\n        no_improve_count = 0\n        max_no_improve = 300\n\n        for iter in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            x_rand = informed_sample(c_best, c_min)\n\n            x_nearest = nearest_node(nodes, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if not point_in_bounds(x_new_pos):\n                continue\n            if is_in_obstacle(x_new_pos):\n                continue\n            if is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                continue\n\n            # Compute dynamic neighbor radius for rewiring & parent selection\n            gamma_rrt = 50.0  # tuning constant\n            radius = min(\n                gamma_rrt * ((math.log(len(nodes) + 1) / (len(nodes) +1)) ** (1.0 / dim)),\n                self.step_size * 5.0,\n            )\n\n            near = near_nodes(nodes, x_new_pos, radius)\n            near.append(x_nearest) if x_nearest not in near else None\n\n            # Choose best parent with lowest cost + dist & collision check edge\n            best_parent = None\n            best_parent_cost = float('inf')\n            for node_candidate in near:\n                if node_candidate == x_nearest or node_candidate == root or node_candidate == best_goal_node:\n                    # avoid considering goal node as parent except last step\n                    pass\n                dist_cost = node_candidate.cost + dist(node_candidate.position, x_new_pos)\n                if dist_cost < best_parent_cost:\n                    if not is_edge_in_obstacle(node_candidate.position, x_new_pos):\n                        best_parent = node_candidate\n                        best_parent_cost = dist_cost\n\n            if best_parent is None:\n                continue\n\n            x_new = Node(x_new_pos)\n            x_new.parent = best_parent\n            x_new.cost = best_parent_cost\n            best_parent.add_child(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near neighbors to x_new if cheaper and collision free\n            for node_candidate in near:\n                if node_candidate == best_parent or node_candidate == x_new:\n                    continue\n                new_cost = x_new.cost + dist(x_new.position, node_candidate.position)\n                if new_cost + self.improve_tol < node_candidate.cost:\n                    if not is_edge_in_obstacle(x_new.position, node_candidate.position):\n                        old_parent = node_candidate.parent\n                        if old_parent:\n                            old_parent.remove_child(node_candidate)\n                            try:\n                                edges.remove((old_parent, node_candidate))\n                            except ValueError:\n                                pass\n                        node_candidate.parent = x_new\n                        node_candidate.cost = new_cost\n                        x_new.add_child(node_candidate)\n                        edges.append((x_new, node_candidate))\n                        propagate_cost_downstream(node_candidate)\n\n            # Goal check: if close enough and feasible edge, add virtual goal node\n            if dist(x_new.position, goal_pos) <= self.step_size and not is_edge_in_obstacle(x_new.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + dist(x_new.position, goal_pos)\n                x_new.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    c_best = best_cost\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= max_no_improve:\n                # No improvements for many iterations, terminate early\n                break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            success = True\n        else:\n            # fallback partial best path to closest node to goal\n            success = False\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < best_goal_dist and n.valid:\n                    best_goal_dist = d\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 213.24668,
          "time_improvement": -742.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 120.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.2601533174514771,
                    "num_nodes_avg": 1135.9,
                    "path_length_avg": 165.48946772351195,
                    "smoothness_avg": 0.014197248392440983,
                    "success_improvement": 0.0,
                    "time_improvement": -935.3288839465314,
                    "length_improvement": 9.29260039231524,
                    "smoothness_improvement": 122.21776716003392,
                    "objective_score": -274.41201611277006
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.02791748046875,
                    "num_nodes_avg": 1784.8,
                    "path_length_avg": 248.93312969038897,
                    "smoothness_avg": 0.006706595874275609,
                    "success_improvement": 0.0,
                    "time_improvement": -539.535672661568,
                    "length_improvement": 16.89895616649216,
                    "smoothness_improvement": 72.56554241086673,
                    "objective_score": -151.35850038652077
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.41294155120849607,
                    "num_nodes_avg": 1100.6,
                    "path_length_avg": 125.03274044248208,
                    "smoothness_avg": 0.020753183067440163,
                    "success_improvement": 0.0,
                    "time_improvement": -749.8831657613362,
                    "length_improvement": 16.95920721739902,
                    "smoothness_improvement": 163.97895677720865,
                    "objective_score": -213.9695306140754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
          "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
          "objective": 243.86863058401775,
          "time_improvement": -865.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 403.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.3813361167907715,
                    "num_nodes_avg": 771.2,
                    "path_length_avg": 149.32789679136948,
                    "smoothness_avg": 0.029239687470625136,
                    "success_improvement": 0.0,
                    "time_improvement": -1417.5985456312005,
                    "length_improvement": 18.151013516702314,
                    "smoothness_improvement": 357.66460391289854,
                    "objective_score": -412.6006325597743
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.7203272342681885,
                    "num_nodes_avg": 1202.5,
                    "path_length_avg": 220.99114927059213,
                    "smoothness_avg": 0.021288984405565276,
                    "success_improvement": 0.0,
                    "time_improvement": -348.1633701706057,
                    "length_improvement": 26.22679349593302,
                    "smoothness_improvement": 447.78090259086366,
                    "objective_score": -86.47403044066756
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.4520768880844116,
                    "num_nodes_avg": 916.9,
                    "path_length_avg": 113.96526900775555,
                    "smoothness_avg": 0.03948870624137508,
                    "success_improvement": 0.0,
                    "time_improvement": -830.4283758519673,
                    "length_improvement": 24.309694767987946,
                    "smoothness_improvement": 402.2934286371922,
                    "objective_score": -232.53122875161145
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid single-tree RRT* planner with adaptive informed sampling and dynamic rewiring radius, implementing early stopping on time limit and solution stagnation to generate efficient, robust, and smooth paths. The planner grows one tree from start, restricts sampling to an informed ellipsoidal subset after the first solution, and rewires neighbors within a theoretically derived radius to minimize path cost while ensuring collision-free nodes and edges. It also tracks the best path and stops when improvements plateau or time limit is reached.",
          "planning_mechanism": "A single RRT* tree rooted at start iteratively samples feasible points, steers towards them with a fixed step size, and connects nodes if collision free. After the first solution, sampling is biased within an ellipsoid shaped by the current best path cost to goal. Each new node selects the lowest-cost parent within an adaptive neighborhood, followed by rewiring neighbors to update cost and parents when beneficial. The planner stops if a time limit or stagnation threshold is reached and returns the best found path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n                # Rotation of first axis to e1\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            c_best_now = best_cost if found_solution else float('inf')\n            sample = informed_sample(c_best_now, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            cost_to_new = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n\n            # Adaptive neighbor radius (from RRT* theory)\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( (math.prod(bounds) / math.pi ** (dim/2)) ** (1/dim) )\n            radius = min(gamma_rrt_star * ((math.log(len(nodes)+1) / (len(nodes)+1)) ** (1/dim)), self.step_size*20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent to minimize cost\n            best_parent = nearest_nd\n            best_parent_cost = cost_to_new\n            for nnode in near:\n                c_candidate = nnode.cost + dist(nnode.position, new_pos)\n                if c_candidate + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nnode.position, new_pos):\n                        best_parent = nnode\n                        best_parent_cost = c_candidate\n\n            new_node = Node(new_pos)\n            new_node.cost = best_parent_cost\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nnode in near:\n                if nnode == best_parent or nnode == new_node:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_via_new + self.improve_tol < nnode.cost:\n                    if not is_edge_in_obstacle(new_node.position, nnode.position):\n                        if nnode.parent:\n                            try:\n                                edges.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            if nnode in nnode.parent.children:\n                                nnode.parent.children.remove(nnode)\n                        nnode.parent = new_node\n                        nnode.cost = cost_via_new\n                        new_node.add_child(nnode)\n                        edges.append((new_node, nnode))\n\n            # Try connecting to goal if close enough\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            # fallback: path to closest node\n            if nodes:\n                closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n                path = path_to_root(closest_node)\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 257.56996,
          "time_improvement": -909.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 301.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.4373145580291748,
                    "num_nodes_avg": 1002.3,
                    "path_length_avg": 151.07054252215133,
                    "smoothness_avg": 0.0236199372445812,
                    "success_improvement": 0.0,
                    "time_improvement": -1640.3752438496745,
                    "length_improvement": 17.195841777672076,
                    "smoothness_improvement": 269.7033093923715,
                    "objective_score": -480.4465515413372
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.7815186023712158,
                    "num_nodes_avg": 1373.1,
                    "path_length_avg": 222.11429982871505,
                    "smoothness_avg": 0.014854219353823398,
                    "success_improvement": 0.0,
                    "time_improvement": -386.23458065630086,
                    "length_improvement": 25.851853511535257,
                    "smoothness_improvement": 282.20976303561724,
                    "objective_score": -98.948213274791
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3884615898132324,
                    "num_nodes_avg": 883.1,
                    "path_length_avg": 113.48823850962461,
                    "smoothness_avg": 0.03552079119676564,
                    "success_improvement": 0.0,
                    "time_improvement": -699.500473519699,
                    "length_improvement": 24.626515711095205,
                    "smoothness_improvement": 351.82184215078297,
                    "objective_score": -193.31512341849864
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements an optimized single-tree RRT* planner with adaptive neighbor radius scaling, goal-biased sampling to accelerate convergence, and enhanced rewiring for smoother and shorter paths. It dynamically adjusts the neighbor radius based on the current state space size and iteration count to balance exploration and refinement efficiently. Early stopping occurs as soon as the first feasible path to the goal is found or when the time limit is reached, returning the best path found thus far.",
          "planning_mechanism": "The planner incrementally expands a single tree from start toward the goal by sampling collision-free points with a 10% goal bias. Each new sample is steered within a fixed step size toward the sampled point and the best parent is chosen from neighbors inside an adaptively scaled radius. It performs rewiring in the neighborhood to improve path cost. The planning halts when a path within the goal radius is found or when 30 seconds elapse, guaranteeing timely return of a feasible path if found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=4.0, neighbor_gamma=60.0, goal_radius=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < 0.10:  # 10% goal bias\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos  # fallback rare case\n\n        def neighbor_radius(num_nodes, iteration):\n            if num_nodes < 2:\n                return max(10.0, self.step_size * 2.0)\n            # Adaptive radius shrinking over iterations to focus optimization\n            r_max = max(bounds) * 0.25\n            r_min = max(4.0, self.step_size)\n            adaptive_gamma = self.neighbor_gamma * (1 - iteration / self.max_iter)\n            r = adaptive_gamma * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return min(r_max, max(r_min, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            # Early exit if few nodes to avoid overhead\n            result = []\n            r_sq = radius * radius\n            for n in tree_nodes:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = neighbor_radius(len(nodes), iteration)\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path) - 1):\n                    cost += math.dist(path[i], path[i + 1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 264.27098,
          "time_improvement": -856.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 132.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.357975697517395,
                    "num_nodes_avg": 445.2,
                    "path_length_avg": 166.13475812226588,
                    "smoothness_avg": 0.015965665008901293,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1324.6313789936312,
                    "length_improvement": 8.938906499477497,
                    "smoothness_improvement": 149.8973273857846,
                    "objective_score": -441.276583161474
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.9005147695541382,
                    "num_nodes_avg": 1228.4,
                    "path_length_avg": 255.44966931004492,
                    "smoothness_avg": 0.006523846953451021,
                    "success_improvement": 0.0,
                    "time_improvement": -460.2699923206443,
                    "length_improvement": 14.723547673258047,
                    "smoothness_improvement": 67.8632810493229,
                    "objective_score": -128.90755268699183
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.4287919759750366,
                    "num_nodes_avg": 646.9,
                    "path_length_avg": 122.37841790280811,
                    "smoothness_avg": 0.021847790029162123,
                    "success_improvement": 0.0,
                    "time_improvement": -782.5052381583273,
                    "length_improvement": 18.722081862993548,
                    "smoothness_improvement": 177.9022765348305,
                    "objective_score": -222.6288109470279
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
          "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
          "objective": 295.47898,
          "time_improvement": -1033.0,
          "length_improvement": 22.0,
          "smoothness_improvement": 256.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.5913747787475586,
                    "num_nodes_avg": 758.0,
                    "path_length_avg": 151.24830260208697,
                    "smoothness_avg": 0.02058925094950933,
                    "success_improvement": 0.0,
                    "time_improvement": -2253.4867656993647,
                    "length_improvement": 17.098408661070636,
                    "smoothness_improvement": 222.2664876338706,
                    "objective_score": -664.6756520749976
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5786649703979492,
                    "num_nodes_avg": 1014.8,
                    "path_length_avg": 223.7199642443417,
                    "smoothness_avg": 0.014513759212874738,
                    "success_improvement": 0.0,
                    "time_improvement": -260.02587573506054,
                    "length_improvement": 25.31583651311142,
                    "smoothness_improvement": 273.4494783854807,
                    "objective_score": -61.451013420723896
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.333528995513916,
                    "num_nodes_avg": 730.1,
                    "path_length_avg": 114.76663509983318,
                    "smoothness_avg": 0.029182927141035354,
                    "success_improvement": 0.0,
                    "time_improvement": -586.442615791514,
                    "length_improvement": 23.777465566582624,
                    "smoothness_improvement": 271.20467917435593,
                    "objective_score": -160.31028200163283
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with adaptive rewiring and efficient neighbor search to produce asymptotically optimal, smooth, and shorter paths with reduced computational overhead. It incrementally samples free space, extends the tree toward random samples respecting obstacle constraints, selects optimal parents among nearby nodes, rewires neighbors to minimize cost, and stops early upon finding a valid path within a time limit.",
          "planning_mechanism": "The planner grows a single tree from start towards goal by iteratively sampling collision-free points and steering incrementally toward them. For each new node, it finds neighbors inside an adaptively scaled radius, picks the best parent minimizing path cost, adds the node, and rewires neighbors if rewiring reduces costs. The search stops when the goal is reachable within a step size and the path is extracted. Using incremental rewiring and efficient local radius scaling improves path smoothness and length. A hard time limit caps search effort, returning best found path if time runs out.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=30.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        tree = []\n\n        start_node = Node(start_pos, None, 0.0)\n        tree.append(start_node)\n        nodes.append(start_node)\n\n        success = False\n        best_goal_node = None\n        dist_goal = self._distance(start_pos, goal_pos)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, rand)\n            new_pos = self._steer(nearest.position, rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            # Choose best parent\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # rewire nb to new_node\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n            # Check if goal can be connected\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        best_goal_node = goal_node\n                        break\n\n        path = best_goal_node.path_from_root() if success else []\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, pos, bounds):\n        n = len(tree)\n        d = len(pos)\n        if n <= 1:\n            return [tree[0]] if tree else []\n        scale = max(1.0, sum(bounds)/d)\n        radius_theory = self.gamma * ((math.log(n)/n) ** (1/d))\n        radius = min(self.max_radius, max(self.step_size*2, radius_theory * 0.5 + scale * 0.01))\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 342.00038,
          "time_improvement": -1177.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 182.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.6105502605438232,
                    "num_nodes_avg": 637.2,
                    "path_length_avg": 162.9455247662491,
                    "smoothness_avg": 0.016476664782690602,
                    "success_improvement": 0.0,
                    "time_improvement": -2329.7991893184353,
                    "length_improvement": 10.686975838546811,
                    "smoothness_improvement": 157.89558349935672,
                    "objective_score": -691.7380933749057
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.039361596107483,
                    "num_nodes_avg": 1016.0,
                    "path_length_avg": 234.23682240353804,
                    "smoothness_avg": 0.01151286991709365,
                    "success_improvement": 0.0,
                    "time_improvement": -546.6558163813695,
                    "length_improvement": 21.805006548593838,
                    "smoothness_improvement": 196.23443535184018,
                    "objective_score": -149.93256880849535
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.36697118282318114,
                    "num_nodes_avg": 582.3,
                    "path_length_avg": 122.24375464796276,
                    "smoothness_avg": 0.02301578213338744,
                    "success_improvement": 0.0,
                    "time_improvement": -655.2706422693615,
                    "length_improvement": 18.81151878488672,
                    "smoothness_improvement": 192.7590498883673,
                    "objective_score": -184.3304861604346
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A unidirectional RRT* planner enhanced with adaptive sampling that dynamically shrinks the rewiring radius as the tree grows, efficient goal biasing to accelerate initial solution discovery, and iterative randomized shortcut smoothing to improve path smoothness and reduce length post planning, all while enforcing a strict 30-second time limit.",
          "planning_mechanism": "The planner grows a single tree from the start node, samples points mostly uniformly but with goal bias, connects new nodes using a theoretical adaptive rewiring radius for efficient local rewiring, tries to connect to the goal when close enough, and after termination applies iterative randomized shortcut smoothing to prune unnecessary waypoints and smooth the final path, returning the best found path within the time budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.goal_sample_rate = 0.1  # Probability to sample the goal\n        self.improve_tol = 1e-5  # Tolerance to consider improvement\n        self.max_no_improve = 300  # Early stop if no improvements\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def random_sample():\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n        def shortcut_smooth(path, attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p1 = path[i]\n                p2 = path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # Remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        volume = 1.0\n        for b in bounds:\n            volume *= b\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = random_sample()\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            tentative_cost = nearest.cost + dist(nearest.position, new_pos)\n\n            # Adaptive rewiring radius (theoretical approx for RRT*)\n            n_nodes = len(nodes) + 1\n            gamma_rrt_star = 2 * (1 + 1/dim)**(1/dim) * (volume / (math.pi ** (dim/2)))**(1/dim)\n            radius = min(gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 20.0)\n            radius = max(radius, self.step_size)  # At least step_size\n\n            nearinds = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent among neighbors to minimize cost\n            best_parent = nearest\n            best_cost_to_new = tentative_cost\n            for node_candidate in nearinds:\n                cost_through = node_candidate.cost + dist(node_candidate.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_to_new:\n                    if not is_edge_in_obstacle(node_candidate.position, new_pos):\n                        best_parent = node_candidate\n                        best_cost_to_new = cost_through\n\n            new_node = Node(new_pos)\n            new_node.cost = best_cost_to_new\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if the path through new_node improves cost\n            for near_node in nearinds:\n                if near_node is new_node or near_node is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_via_new + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_via_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to goal if close\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = new_node\n                    goal_node.cost = goal_cost\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > self.max_no_improve:\n                        break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            # Apply iterative shortcut smoothing to improve smoothness and shorten path\n            smoothed_path = raw_path\n            smoothing_iters = 100\n            last_len = len(smoothed_path) + 1\n            for _ in range(smoothing_iters):\n                if len(smoothed_path) < 3:\n                    break\n                smoothed_path = shortcut_smooth(smoothed_path, attempts=10)\n                if len(smoothed_path) >= last_len:\n                    break\n                last_len = len(smoothed_path)\n            extracted_path = smoothed_path\n        else:\n            # fallback to nearest node path to goal\n            if nodes:\n                closest = nearest_node(nodes, goal_pos)\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 364.05017,
          "time_improvement": -1272.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 736.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.4229812383651733,
                    "num_nodes_avg": 960.6,
                    "path_length_avg": 151.3007762388788,
                    "smoothness_avg": 0.035373793273472856,
                    "success_improvement": 0.0,
                    "time_improvement": -1583.3331119393354,
                    "length_improvement": 17.069647029247047,
                    "smoothness_improvement": 453.676680151417,
                    "objective_score": -462.48976196349525
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.777293872833252,
                    "num_nodes_avg": 2153.4,
                    "path_length_avg": 218.25660160376825,
                    "smoothness_avg": 0.041041345170612094,
                    "success_improvement": 0.0,
                    "time_improvement": -1005.7724516576625,
                    "length_improvement": 27.139664216709253,
                    "smoothness_improvement": 956.0233721259156,
                    "objective_score": -280.66782010664366
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.6441714525222778,
                    "num_nodes_avg": 1119.9,
                    "path_length_avg": 113.56621382931084,
                    "smoothness_avg": 0.07070525876661057,
                    "success_improvement": 0.0,
                    "time_improvement": -1225.7819944747857,
                    "length_improvement": 24.57472821654533,
                    "smoothness_improvement": 799.3656725919624,
                    "objective_score": -348.9929330495487
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with efficient neighbor selection, rewiring, and early stopping to improve generalization, reduce complexity, and maintain robust path quality and smoothness within a 30-second time limit. It grows a single tree from start to goal by sampling collision-free points, steering incrementally, selecting the lowest-cost parent from neighbors within a dynamically scaled radius, rewiring neighbors to reduce cost, and terminating once a path to the goal is found.",
          "planning_mechanism": "The planner builds a tree rooted at the start by iteratively sampling free points, steering toward them with fixed step size, choosing optimal parent nodes from a radius-based neighborhood, applying local rewiring to minimize path costs, and returning the best path within a time budget or when the goal neighborhood is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, neighbor_gamma: float=50.0, goal_radius: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_radius = max(bounds)*0.3\n        min_radius = max(10.0, self.step_size*2.0)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: return start (rare)\n            return start_pos\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return min_radius\n            r = self.neighbor_gamma * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            return min(max_radius, max(min_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if math.dist(n.position, pos) <= radius]\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached, return best found\n                return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, r)\n            # Select best parent in neighbors with valid edge\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                # fallback to nearest_node if edge free\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Rewire: update parent and cost, edges lists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            # Check if goal reached\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path)-1):\n                    cost += math.dist(path[i], path[i+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 680.61663,
          "time_improvement": -2311.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 212.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.2963702201843261,
                    "num_nodes_avg": 798.3,
                    "path_length_avg": 153.40311775845035,
                    "smoothness_avg": 0.01867232962112822,
                    "success_improvement": 0.0,
                    "time_improvement": -5059.148253011591,
                    "length_improvement": 15.917320328636658,
                    "smoothness_improvement": 192.26250618341595,
                    "objective_score": -1507.2327711753783
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.0090357303619384,
                    "num_nodes_avg": 1116.8,
                    "path_length_avg": 232.92130464304964,
                    "smoothness_avg": 0.011711985498954181,
                    "success_improvement": 0.0,
                    "time_improvement": -527.788083010616,
                    "length_improvement": 22.244164242124114,
                    "smoothness_improvement": 201.3578226902683,
                    "objective_score": -143.983137244459
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.7028919219970703,
                    "num_nodes_avg": 837.6,
                    "path_length_avg": 120.10951944487313,
                    "smoothness_avg": 0.0270341704816116,
                    "success_improvement": 0.0,
                    "time_improvement": -1346.6357529453908,
                    "length_improvement": 20.22897618541956,
                    "smoothness_improvement": 243.8726530712041,
                    "objective_score": -390.63397690700947
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
          "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 846.2166525796338,
          "time_improvement": -2873.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 610.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.4443773031234741,
                    "num_nodes_avg": 490.1,
                    "path_length_avg": 149.3981249102062,
                    "smoothness_avg": 0.035990421065920125,
                    "success_improvement": 0.0,
                    "time_improvement": -5648.170178608027,
                    "length_improvement": 18.11252037193215,
                    "smoothness_improvement": 463.32824413189996,
                    "objective_score": -1681.266900138589
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6314516544342041,
                    "num_nodes_avg": 513.8,
                    "path_length_avg": 234.3341588735694,
                    "smoothness_avg": 0.028262769793854607,
                    "success_improvement": 0.0,
                    "time_improvement": -292.8679745651196,
                    "length_improvement": 21.772512833222418,
                    "smoothness_improvement": 627.2214236461315,
                    "objective_score": -71.66077755137177
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.349559211730957,
                    "num_nodes_avg": 658.2,
                    "path_length_avg": 115.8319417853983,
                    "smoothness_avg": 0.06607113791056633,
                    "success_improvement": 0.0,
                    "time_improvement": -2677.554479300074,
                    "length_improvement": 23.069939590483365,
                    "smoothness_improvement": 740.4199973583002,
                    "objective_score": -785.7222800489408
               }
          ],
          "success_rate": 1.0
     }
]