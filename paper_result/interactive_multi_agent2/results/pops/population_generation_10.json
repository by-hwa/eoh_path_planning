[
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with fixed step extension, goal bias sampling, adaptive neighbor radius rewiring, and shortcut path smoothing within a 30-second time limit to efficiently find collision-free paths with reduced length and improved smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal points alternately. Each iteration samples a state biased toward the goal, extends the nearest tree toward the sample by a fixed step if collision-free, and rewires nearby nodes using an adaptive radius to optimize cost. The planner attempts to greedily connect the two trees each iteration and finishes early on success or time expiration. After planning, a shortcutting post-processing step removes unnecessary waypoints to smooth and shorten the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                s = self.step_size / d\n                new_p = tuple(from_p[i] + s * (to_p[i] - from_p[i]) for i in range(dim))\n            return tuple(max(0, min(new_p[i], bounds[i])) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n) / n) ** (1/dim), self.step_size * 10)\n\n        def near(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (nodes_start, nodes_goal) if i % 2 == 0 else (nodes_goal, nodes_start)\n            q_rand = sample()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        parent = nb\n            new_node = Node(new_pos)\n            new_node.update_parent(parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((parent, new_node))\n\n            for nb in neighbors:\n                if nb is parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, c_new)\n                        edges.append((new_node, nb))\n\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                new_to_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(new_to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, new_to_pos, obstacles, is_3d):\n                    break\n                new_to_node = Node(new_to_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, new_to_pos))\n                tree_b.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n                if dist(new_to_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_to_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_to_node.position, new_node.position))\n                        tree_b.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            if tree_a is nodes_start:\n                                best_start_node = new_node\n                                best_goal_node = final_node\n                            else:\n                                best_start_node = final_node\n                                best_goal_node = new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n            if connected:\n                break\n\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(path, obstacles, is_3d, bounds)\n        else:\n            closest = min(nodes_start, key=lambda n: dist(n.position, goal_pos), default=None)\n            extracted_path = closest.path_from_root() if closest else [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut.append(path[j])\n            i = j\n        return shortcut\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_ab = math.dist(a, b)\n        steps = max(1, int(dist_ab / resolution))\n        for i in range(steps + 1):\n            interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(len(a)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -39.02046,
          "time_improvement": 67.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1673.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011158227920532227,
                    "num_nodes_avg": 90.1,
                    "path_length_avg": 163.77008971239428,
                    "smoothness_avg": 0.05022285267966682,
                    "success_improvement": 0.0,
                    "time_improvement": 55.59374074889366,
                    "length_improvement": 10.235018725496927,
                    "smoothness_improvement": 686.0967051069562,
                    "objective_score": 26.249616985501035
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019709515571594238,
                    "num_nodes_avg": 259.0,
                    "path_length_avg": 231.03195017180343,
                    "smoothness_avg": 0.1046731272784061,
                    "success_improvement": 0.0,
                    "time_improvement": 87.73740252654807,
                    "length_improvement": 22.874885146679258,
                    "smoothness_improvement": 2593.314957879559,
                    "objective_score": 53.01272663536977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02050490379333496,
                    "num_nodes_avg": 244.2,
                    "path_length_avg": 121.04037650344381,
                    "smoothness_avg": 0.14454576908273487,
                    "success_improvement": 0.0,
                    "time_improvement": 57.79845235116024,
                    "length_improvement": 19.61074524976676,
                    "smoothness_improvement": 1738.6115134735423,
                    "objective_score": 37.79904042257584
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* algorithm with goal bias, adaptive rewiring radius, and post-processing shortcut smoothing to enhance planning time, path length, and smoothness. It grows two trees from start and goal using goal-biased sampling and adaptive neighbor radius for rewiring, continually optimizing path cost. After the first solution, it performs a shortcut smoothing to remove unnecessary waypoints, yielding shorter and smoother paths. Early stopping applies when the two trees connect.",
          "planning_mechanism": "A bidirectional RRT* planner grows start and goal trees toward randomly sampled points biased toward the goal, with an adaptive neighbor radius shrinking as the tree grows for efficient rewiring and collision checks. Upon connecting the trees, it performs post-planning shortcut smoothing to improve path smoothness and shorten path length, while enforcing node and edge collision checks and bounded planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample():\n            # Goal biased sampling: with some probability sample the goal\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # Otherwise sample uniformly inside bounds but avoid obstacles via rejection\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if no free sample found in 100 tries (unlikely)\n            return goal_pos\n\n        def steer(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            norm = dist(from_pos, to_pos)\n            if norm <= self.step_size:\n                new_pos = to_pos\n            else:\n                scale = self.step_size / norm\n                new_pos = tuple(from_pos[d] + vec[d] * scale for d in range(dim))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clip to bounds if numerics cause issues\n            clipped = tuple(min(max(new_pos[d], 0), bounds[d]) for d in range(dim))\n            return clipped\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        def adaptive_radius(n):\n            # Adaptive rewiring radius: \u03b3*(log(n)/n)^(1/d); \u03b3 chosen heuristically\n            gamma = 50.0  # Tuned constant, can be adjusted\n            if n < 2:\n                return self.step_size * 5.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Alternate between trees: grow_start -> grow_goal -> grow_start etc\n            if i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            sample_point = sample()\n            nearest = min(tree_from, key=lambda n: dist(n.position, sample_point))\n            new_pos = steer(nearest.position, sample_point)\n\n            # Validate new_pos node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            r = adaptive_radius(len(nodes))\n\n            # Find neighbors in tree_from within radius r\n            neighbors = [n for n in tree_from if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + distance via collision-free edge\n            min_cost = nearest.cost + line_cost(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_through_nbr = nbr.cost + line_cost(nbr.position, new_pos)\n                if cost_through_nbr < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + line_cost(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except Exception:\n                            pass\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n\n            # Try connecting the other tree to new_node to check if paths can be connected\n            nearest_to = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                connect_pos = steer(nearest_to.position, new_node.position)\n                # Check collision for edge\n                if self._is_in_obstacle(connect_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(nearest_to.position, connect_pos, obstacles, is_3d):\n                    break\n                # Add node to tree_to\n                new_to_node = Node(connect_pos)\n                new_to_node.update_parent(nearest_to, nearest_to.cost + line_cost(nearest_to.position, connect_pos))\n                tree_to.append(new_to_node)\n                nodes.append(new_to_node)\n                edges.append((nearest_to, new_to_node))\n\n                if dist(connect_pos, new_node.position) <= self.step_size:\n                    # Check final edge to new_node\n                    if not self._is_edge_in_obstacle(connect_pos, new_node.position, obstacles, is_3d):\n                        final_connect = Node(new_node.position)\n                        final_connect.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, connect_pos))\n                        tree_to.append(final_connect)\n                        nodes.append(final_connect)\n                        edges.append((new_to_node, final_connect))\n\n                        # Found a path connecting both trees\n                        total_cost = final_connect.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            # We return combined path by remembering nodes connecting trees\n                            best_start_node = new_node if tree_from is tree_start else final_connect\n                            best_goal_node = final_connect if tree_to is tree_goal else new_node\n                        break\n                    else:\n                        break\n                nearest_to = new_to_node\n\n            if success:\n                break\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # path_goal is from goal_root to connection, reverse except overlap connection node\n            extracted_path = path_start + path_goal[-2::-1]\n\n            # Perform path shortcutting smoothing\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        import math\n        def can_connect(a, b):\n            if a == b:\n                return True\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                return False\n            return True\n\n        if len(path) < 3:\n            return path\n\n        # Iteratively try to shortcut path by connecting farther points directly\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if can_connect(path[i], path[j]):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -38.54314,
          "time_improvement": 66.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1649.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0124739408493042,
                    "num_nodes_avg": 97.8,
                    "path_length_avg": 161.16050378318585,
                    "smoothness_avg": 0.047350045450239985,
                    "success_improvement": 0.0,
                    "time_improvement": 50.357614561905564,
                    "length_improvement": 11.665374124831326,
                    "smoothness_improvement": 641.1310335656783,
                    "objective_score": 25.312164011298858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021719694137573242,
                    "num_nodes_avg": 248.5,
                    "path_length_avg": 233.695774193213,
                    "smoothness_avg": 0.10749915802083503,
                    "success_improvement": 0.0,
                    "time_improvement": 86.48673705408524,
                    "length_improvement": 21.985624014409588,
                    "smoothness_improvement": 2666.030764389923,
                    "objective_score": 52.46754934682094
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018388795852661132,
                    "num_nodes_avg": 200.2,
                    "path_length_avg": 122.948486694335,
                    "smoothness_avg": 0.13675427801112314,
                    "success_improvement": 0.0,
                    "time_improvement": 62.15365591556138,
                    "length_improvement": 18.34346931542014,
                    "smoothness_improvement": 1639.504322150689,
                    "objective_score": 37.84969997467394
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT*-like planner with dynamic goal bias adjustment, radius annealing for neighbor search, downstream cost propagation for rewiring, and integrated incremental path shortcutting to efficiently improve path optimality and smoothness during construction, while enforcing time constraints and collision checks.",
          "planning_mechanism": "The planner grows two trees from start and goal with a gradually decreasing rewiring radius based on iteration count to balance exploration and refinement. Sampling bias toward the goal dynamically decreases over time to incentivize exploration early and exploitation later. When connecting nodes, parent rewiring propagates cost improvements downstream ensuring globally consistent shortest paths. Incremental shortcutting is applied progressively on partial paths when an improved connection is found to enhance smoothness. Early stopping occurs upon solution discovery or hard time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position  # coordinate tuple\n        self.parent = parent      # parent Node\n        self.cost = cost          # cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True         # for collision checks etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        \n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= self.step_size:\n                new_pos = to_pos\n            else:\n                scale = self.step_size / length\n                new_pos = tuple(from_pos[d] + vec[d]*scale for d in range(dim))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clip if out of bounds (numeric safety)\n            clipped = tuple(min(max(new_pos[d], 0), bounds[d]) for d in range(dim))\n            return clipped\n\n        def sample_point(iteration):\n            # Dynamic goal bias decaying exponentially from 0.15 down to 0.02 over iterations\n            bias_max = 0.15\n            bias_min = 0.02\n            decay_rate = 0.0005\n            goal_bias = bias_min + (bias_max - bias_min) * math.exp(-decay_rate * iteration)\n            if random.random() < goal_bias:\n                return goal_pos\n            # Uniform sampling with rejection capped at 100 tries\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def adaptive_radius(iteration, n_nodes):\n            # Anneal rewiring radius: start large -> shrink to minimal bound\n            gamma = 40.0  # tuned scaling factor\n            if n_nodes < 2:\n                return self.step_size * 6.0\n            rmax = self.step_size * 10\n            rmin = self.step_size * 1.5\n            # Exponential annealing of radius w.r.t normalized iteration count\n            alpha = min(1.0, iteration / self.max_iter)\n            radius = rmax * (1 - alpha) + rmin * alpha\n            # Also scale by theoretical formula for asymptotic RRT*\n            r_theoretical = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            radius = min(radius, max(r_theoretical, rmin))\n            return radius\n\n        # Initialize nodes and trees\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_path_start = None\n        best_path_goal = None\n        success = False\n\n        def collision_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=1.0)\n\n        def propagate_cost_updates(node):\n            # BFS propagation of cost updates downstream children:\n            queue = [node]\n            while queue:\n                curr = queue.pop(0)\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + 1e-8 < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        queue.append(c)\n\n        def incremental_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting applied incrementally\n            if len(path) < 3:\n                return path\n\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def connect_trees(node_from: Node, other_tree: List[Node], iteration: int):\n            nonlocal best_cost, best_path_start, best_path_goal, success\n\n            # Find closest in other tree\n            nearest_o = min(other_tree, key=lambda n: dist(n.position, node_from.position))\n            \n            # Attempt direct connection when within step size (attempt shortcut)\n            if dist(nearest_o.position, node_from.position) <= self.step_size:\n                if collision_free_edge(nearest_o.position, node_from.position):\n                    # Merge using nearest_o as parent\n                    new_node = Node(node_from.position)\n                    new_node.update_parent(nearest_o, nearest_o.cost + dist(nearest_o.position, node_from.position))\n                    other_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest_o, new_node))\n\n                    total_cost = new_node.cost + node_from.cost\n                    if total_cost + 1e-8 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_path_start = node_from if node_from in tree_start else new_node\n                        best_path_goal = new_node if new_node in tree_goal else node_from\n                    return\n\n            # Incrementally extend other tree toward node_from position (limited steps)\n            cur_node = nearest_o\n            for _ in range(5):\n                new_pos = steer(cur_node.position, node_from.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return\n                if not collision_free_edge(cur_node.position, new_pos):\n                    return\n                if dist(new_pos, cur_node.position) < 1e-6:\n                    return  # no progression\n\n                new_node = Node(new_pos)\n                new_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, new_pos))\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((cur_node, new_node))\n\n                cur_node = new_node\n\n                # If close enough, try final connection to node_from\n                if dist(cur_node.position, node_from.position) <= self.step_size:\n                    if collision_free_edge(cur_node.position, node_from.position):\n                        final_node = Node(node_from.position)\n                        final_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, node_from.position))\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((cur_node, final_node))\n                        total_cost = final_node.cost + node_from.cost\n                        if total_cost + 1e-8 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            best_path_start = node_from if node_from in tree_start else final_node\n                            best_path_goal = final_node if final_node in tree_goal else node_from\n                        return\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Alternate expanding trees\n            if i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Sample point\n            q_rand = sample_point(i)\n            # Find nearest node in tree_from\n            nearest = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest.position, q_rand)\n\n            # Validate node and edge collision\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(nearest.position, q_new_pos):\n                continue\n\n            r = adaptive_radius(i, len(nodes))\n\n            neighbors = [n for n in tree_from if dist(n.position, q_new_pos) <= r]\n\n            # Choose best parent via minimal cost + edge length and collision free\n            min_cost = nearest.cost + dist(nearest.position, q_new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_thru_nbr = nbr.cost + dist(nbr.position, q_new_pos)\n                if cost_thru_nbr + 1e-8 < min_cost:\n                    if collision_free_edge(nbr.position, q_new_pos):\n                        best_parent = nbr\n                        min_cost = cost_thru_nbr\n\n            new_node = Node(q_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-8 < nbr.cost:\n                    if collision_free_edge(new_node.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, nbr))\n                        # Propagate cost updates downstream recursively\n                        propagate_cost_updates(nbr)\n\n            # Try to connect the other tree to this new node (potential short circuit)\n            connect_trees(new_node, tree_to, i)\n\n            # If found a path, perform incremental shortcutting on extracted path for smoothness\n            if success:\n                path_start = best_path_start.path_from_root()\n                path_goal = best_path_goal.path_from_root()\n                # goal tree path reversed (excluding overlapped connection node)\n                combined_path = path_start + path_goal[-2::-1]\n                # Incremental shortcutting\n                combined_path = incremental_shortcut(combined_path)\n                return PlannerResult(success, combined_path, nodes, edges)\n\n        # After loop: return best found path or failure\n        if success:\n            path_start = best_path_start.path_from_root()\n            path_goal = best_path_goal.path_from_root()\n            combined_path = path_start + path_goal[-2::-1]\n            combined_path = incremental_shortcut(combined_path)\n            return PlannerResult(True, combined_path, nodes, edges)\n\n        # No feasible path found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        length = math.dist(from_pos, to_pos)\n        steps = max(1, int(length / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -38.53073,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1825.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01083357334136963,
                    "num_nodes_avg": 99.1,
                    "path_length_avg": 164.690717897958,
                    "smoothness_avg": 0.050677075966852836,
                    "success_improvement": 0.0,
                    "time_improvement": 56.885764492451095,
                    "length_improvement": 9.730407828702308,
                    "smoothness_improvement": 693.2062859130726,
                    "objective_score": 26.370005474522074
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026892876625061034,
                    "num_nodes_avg": 306.0,
                    "path_length_avg": 237.81555451648507,
                    "smoothness_avg": 0.12641290240664743,
                    "success_improvement": 0.0,
                    "time_improvement": 83.26815695908788,
                    "length_improvement": 20.610322761199686,
                    "smoothness_improvement": 3152.695030456311,
                    "objective_score": 53.110115896727734
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0188523530960083,
                    "num_nodes_avg": 260.8,
                    "path_length_avg": 126.4424197417197,
                    "smoothness_avg": 0.13582463246786344,
                    "success_improvement": 0.0,
                    "time_improvement": 61.19959959370538,
                    "length_improvement": 16.02296534856016,
                    "smoothness_improvement": 1627.6792994597215,
                    "objective_score": 36.11205558454632
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner featuring adaptive goal bias decay, radius annealing, efficient BFS cost propagation, and integrated incremental shortcutting applied progressively during planning to enhance path optimality and smoothness while strictly enforcing collision checks and a 30-second time limit. The planner grows trees alternately from start and goal, selecting parents among neighbors within an adaptive radius, rewiring to reduce costs with downstream cost updates, and attempts to connect both trees efficiently. Incremental shortcutting refines the solution path upon improvements, and early termination occurs either on a successful path or timeout.",
          "planning_mechanism": "A bidirectional approach grows two trees from start and goal alternately, sampling points with a decaying goal bias. New nodes are added by steering from the nearest tree node and connecting to the lowest-cost neighbor within an adaptive radius after collision checks. Rewiring updates neighbors' parents if cost can be reduced, propagating cost updates breadth-first. The planner attempts to connect both trees whenever new nodes are added. It applies incremental shortcutting progressively to the best found path to improve smoothness and length before terminating upon success or a hard 30-second limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            vector = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= self.step_size:\n                new_p = to_pos\n            else:\n                scale = self.step_size / length\n                new_p = tuple(from_pos[d] + vector[d] * scale for d in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            # Clip if numerics out of bounds\n            clipped = tuple(min(max(new_p[d], 0), bounds[d]) for d in range(dim))\n            return clipped\n\n        def sample_point(iteration):\n            # Dynamic goal bias: decays exponentially from 0.15 to 0.02\n            bias_max = 0.15\n            bias_min = 0.02\n            decay = 0.0005\n            goal_bias = bias_min + (bias_max - bias_min) * math.exp(-decay * iteration)\n            if random.random() < goal_bias:\n                return goal_pos\n            # Uniform sample rejection capped at 100 attempts\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos\n\n        def adaptive_radius(iteration, n_nodes):\n            gamma = 40.0\n            if n_nodes < 2:\n                return self.step_size * 6.0\n            rmax = self.step_size * 10\n            rmin = self.step_size * 1.5\n            alpha = min(1.0, iteration / self.max_iter)\n            radius = rmax * (1 - alpha) + rmin * alpha\n            r_theoretical = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            radius = min(radius, max(r_theoretical, rmin))\n            return radius\n\n        # Collision check for a node inside obstacles\n        def collision_node(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        # Collision check for edge between two nodes\n        def collision_edge(a, b, res=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        # Propagate cost updates downstream BFS\n        def propagate_costs(node):\n            queue = [node]\n            while queue:\n                current = queue.pop(0)\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        queue.append(c)\n\n        # Incremental shortcutting progressive improvement\n        def incremental_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i+1:\n                    if not collision_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Attempt to connect one tree node to the other tree, optionally extending if needed\n        def connect_trees(node_from: Node, other_tree: List[Node], iteration: int):\n            nonlocal best_cost, best_start_node, best_goal_node, success\n\n            # Find closest node in other_tree\n            nearest_other = min(other_tree, key=lambda n: dist(n.position, node_from.position))\n\n            # If within step size, attempt direct connection\n            if dist(nearest_other.position, node_from.position) <= self.step_size:\n                if not collision_edge(nearest_other.position, node_from.position):\n                    # Connect new node to other tree\n                    new_node = Node(node_from.position)\n                    new_node.update_parent(nearest_other, nearest_other.cost + dist(nearest_other.position, node_from.position))\n                    other_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest_other, new_node))\n\n                    # Update best solution if improved\n                    total = new_node.cost + node_from.cost\n                    if total + 1e-12 < best_cost:\n                        best_cost = total\n                        best_start_node = node_from if node_from in tree_start else new_node\n                        best_goal_node = new_node if new_node in tree_goal else node_from\n                        success = True\n                    return True\n\n            # Otherwise, attempt incremental extensions (max 5 steps)\n            current = nearest_other\n            for _ in range(5):\n                new_pos = steer(current.position, node_from.position)\n                if collision_node(new_pos) or collision_edge(current.position, new_pos):\n                    break\n                if dist(new_pos, current.position) < 1e-6:\n                    break\n                new_node = Node(new_pos)\n                new_node.update_parent(current, current.cost + dist(current.position, new_pos))\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                current = new_node\n                # Check if close enough to connect node_from\n                if dist(current.position, node_from.position) <= self.step_size:\n                    if not collision_edge(current.position, node_from.position):\n                        final_node = Node(node_from.position)\n                        final_node.update_parent(current, current.cost + dist(current.position, node_from.position))\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        total = final_node.cost + node_from.cost\n                        if total + 1e-12 < best_cost:\n                            best_cost = total\n                            best_start_node = node_from if node_from in tree_start else final_node\n                            best_goal_node = final_node if final_node in tree_goal else node_from\n                            success = True\n                        return True\n            return False\n\n        # Initialization of trees and data\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Alternate expanding trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Sample with decaying goal bias\n            q_rand = sample_point(i)\n\n            # Nearest node in tree_a to q_rand\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest.position, q_rand)\n            if collision_node(q_new_pos) or collision_edge(nearest.position, q_new_pos) or not in_bounds(q_new_pos):\n                continue\n\n            r = adaptive_radius(i, len(nodes))\n            neighbors = [n for n in tree_a if dist(n.position, q_new_pos) <= r]\n\n            # Select best parent minimizing cost + edge length, with collision checked\n            min_cost = nearest.cost + dist(nearest.position, q_new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_via = nbr.cost + dist(nbr.position, q_new_pos)\n                if cost_via + 1e-12 < min_cost and not collision_edge(nbr.position, q_new_pos):\n                    best_parent = nbr\n                    min_cost = cost_via\n\n            new_node = Node(q_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper via new_node\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-12 < nbr.cost and not collision_edge(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n                    propagate_costs(nbr)\n\n            # Attempt to connect newly added node to the other tree\n            connected = connect_trees(new_node, tree_b, i)\n\n            # On successful connection, incrementally shortcut improved paths\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                combined_path = path_start + path_goal[-2::-1] if path_goal else path_start\n                combined_path = incremental_shortcut(combined_path)\n                return PlannerResult(True, combined_path, nodes, edges)\n\n        # If no path found but nodes exist in start tree, return best partial path toward goal\n        if success:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            combined_path = path_start + path_goal[-2::-1] if path_goal else path_start\n            combined_path = incremental_shortcut(combined_path)\n            return PlannerResult(True, combined_path, nodes, edges)\n\n        # If no success, attempt fallback path to node closest to goal in start tree if any\n        closest = None\n        min_dist = float('inf')\n        for node in tree_start:\n            d_ = dist(node.position, goal_pos)\n            if d_ < min_dist:\n                min_dist = d_\n                closest = node\n        fallback_path = []\n        if closest is not None:\n            cur = closest\n            while cur:\n                fallback_path.append(cur.position)\n                cur = cur.parent\n            fallback_path.reverse()\n        else:\n            fallback_path = [start_pos]\n\n        return PlannerResult(False, fallback_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w_, h_ = obs\n                px, py = pos\n                if x <= px <= x + w_ and y <= py <= y + h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -38.01395,
          "time_improvement": 63.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1665.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010860204696655273,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 155.53679700269322,
                    "smoothness_avg": 0.048746011709329795,
                    "success_improvement": 0.0,
                    "time_improvement": 56.77978002292377,
                    "length_improvement": 14.747816924555893,
                    "smoothness_improvement": 662.9809369096846,
                    "objective_score": 29.197528846159088
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0222883939743042,
                    "num_nodes_avg": 287.0,
                    "path_length_avg": 237.38981985446594,
                    "smoothness_avg": 0.10778071815051563,
                    "success_improvement": 0.0,
                    "time_improvement": 86.13291114924665,
                    "length_improvement": 20.75244524547447,
                    "smoothness_improvement": 2673.2755093261694,
                    "objective_score": 51.657718038689524
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026546454429626463,
                    "num_nodes_avg": 259.5,
                    "path_length_avg": 122.26930603684664,
                    "smoothness_avg": 0.13837518421521658,
                    "success_improvement": 0.0,
                    "time_improvement": 45.36421761297002,
                    "length_improvement": 18.79454876901643,
                    "smoothness_improvement": 1660.1221294239067,
                    "objective_score": 33.1866051924204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner using fixed step steering and a simplified adaptive rewiring radius. It alternates growth between start and goal trees, employs goal-biased sampling, and opportunistically connects trees to find feasible paths quickly. The planner includes light rewiring for cost improvement and a post-process shortcutting step to shorten and smooth the final path within a strict 30-second time limit. This approach balances simplicity and effective path quality enhancement with constrained computation.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by sampling mostly free space biased towards the goal, extending trees with fixed-length steps checked for collisions, rewiring nearby nodes within a radius that shrinks adaptively with the number of nodes, and greedily attempts connections between the two trees. Search halts early when a path is found or time runs out. Afterward, a shortcutting routine post-processes the best path to remove unnecessary waypoints and improve smoothness and length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1  # 10% goal bias\n        self.time_limit_sec = 30.0\n        self.shortcut_max_trials = 100\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 6.0\n            gamma = 30.0\n            r = gamma * (math.log(n) / n) ** (1/dim)\n            max_radius = self.step_size * 12.0\n            return min(r, max_radius)\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest_node.position, x_rand)\n            if not in_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            radius = adaptive_radius(len(tree_a))\n            neighbors = neighbors_within_radius(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        best_parent = nb\n                        min_cost = cost_through_nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect other tree greedily to new_node\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            connect_pos = steer(nearest_other.position, new_node.position)\n            if (not self._is_in_obstacle(connect_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_other.position, connect_pos, obstacles, is_3d)):\n                dist_new_to_other = dist(connect_pos, new_node.position)\n                # If within one step and edge collision free, connect directly\n                if dist_new_to_other <= self.step_size:\n                    if not self._is_edge_in_obstacle(connect_pos, new_node.position, obstacles, is_3d):\n                        connecting_node = Node(connect_pos)\n                        connecting_node.update_parent(nearest_other, nearest_other.cost + dist(nearest_other.position, connect_pos))\n                        tree_b.append(connecting_node)\n                        nodes.append(connecting_node)\n                        edges.append((nearest_other, connecting_node))\n                        final_node_other = Node(new_node.position)\n                        final_node_other.update_parent(connecting_node, connecting_node.cost + dist(connecting_node.position, new_node.position))\n                        tree_b.append(final_node_other)\n                        nodes.append(final_node_other)\n                        edges.append((connecting_node, final_node_other))\n\n                        total_cost = final_node_other.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            if expand_start_tree:\n                                best_start_node = new_node\n                                best_goal_node = final_node_other\n                            else:\n                                best_start_node = final_node_other\n                                best_goal_node = new_node\n                        break\n\n            expand_start_tree = not expand_start_tree\n\n            if success:\n                break\n\n        extracted_path = []\n        if success and best_start_node is not None and best_goal_node is not None:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # Avoid duplicate connection point\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n        else:\n            # Partial best path towards goal from start tree\n            best_partial = None\n            min_dist = float('inf')\n            for node in tree_start:\n                d = dist(node.position, goal_pos)\n                if d < min_dist and node.valid:\n                    best_partial = node\n                    min_dist = d\n            if best_partial:\n                extracted_path = best_partial.path_from_root()\n            else:\n                extracted_path = [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        trials = 0\n        max_trials = self.shortcut_max_trials\n        while i < len(path) - 1 and trials < max_trials:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n            trials += 1\n        if shortcut_path[-1] != path[-1]:\n            shortcut_path.append(path[-1])\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -37.67647,
          "time_improvement": 65.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1585.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013344383239746094,
                    "num_nodes_avg": 109.0,
                    "path_length_avg": 165.005931368645,
                    "smoothness_avg": 0.050960182226992556,
                    "success_improvement": 0.0,
                    "time_improvement": 46.89352593346035,
                    "length_improvement": 9.557634330541676,
                    "smoothness_improvement": 697.637513659343,
                    "objective_score": 23.290825946659826
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021833038330078124,
                    "num_nodes_avg": 263.1,
                    "path_length_avg": 233.14722397521683,
                    "smoothness_avg": 0.10371347579119265,
                    "success_improvement": 0.0,
                    "time_improvement": 86.41621811090818,
                    "length_improvement": 22.16874586631928,
                    "smoothness_improvement": 2568.6224339045298,
                    "objective_score": 52.069225122586666
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018707585334777833,
                    "num_nodes_avg": 269.2,
                    "path_length_avg": 121.01515456883695,
                    "smoothness_avg": 0.12490017781693386,
                    "success_improvement": 0.0,
                    "time_improvement": 61.49754898352741,
                    "length_improvement": 19.627496457793175,
                    "smoothness_improvement": 1488.7210426592612,
                    "objective_score": 37.66936778303043
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with goal bias sampling, adaptive neighbor radius based on tree size and dimension, incremental rewiring, early stopping immediately after first path found, and final path shortcutting for improved smoothness and length. The algorithm alternately expands start and goal trees, rewires locally to optimize path cost, and efficiently connects trees upon proximity. It enforces strict collision checks for nodes and edges at every addition, respects map bounds, and robustly handles 2D/3D rectangular obstacles under a strict 30-second time limit. Final path extraction merges two parent chains cleanly and applies shortcutting to smooth and shorten the path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal with goal-biased sampling, chooses parent nodes by minimizing path cost within an adaptive radius, rewires neighbors upon discovery of better costs, attempts incremental connections between trees, and stops early on finding a valid connection. It applies shortcutting to the final path to improve smoothness and length before returning results with all explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10  # 10% chance sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback uniform sample without obstacle check\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            # Remove unnecessary waypoints by attempting direct connections skipping intermediate points\n            if len(path) <= 2:\n                return path[:]\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, proceed next node\n                    shortcut_path.append(path[i+1])\n                    i += 1\n            return shortcut_path\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius for neighbor search (approximate RRT* radius)\n            n = len(tree_a)\n            min_radius = self.step_size * 2.5\n            gamma_rrt = 50.0  # tuning constant, increased slightly for larger graphs\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n+1) / (n+1))**(1/dim)), self.step_size * 30))\n\n            # Choose best parent in radius neighbors\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with new_node if better cost found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect to opposing tree within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path, removing duplicate connection point if overlapping\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicate middle point\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Apply shortcutting to smooth path and reduce length\n                smooth_path = shortcut_path(combined_path)\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # Time limit or max_iter reached with no full path\n        # Return best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -37.37284,
          "time_improvement": 65.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1594.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013492751121520995,
                    "num_nodes_avg": 116.9,
                    "path_length_avg": 167.48639160694592,
                    "smoothness_avg": 0.046124220571561826,
                    "success_improvement": 0.0,
                    "time_improvement": 46.30306814127721,
                    "length_improvement": 8.198054768521205,
                    "smoothness_improvement": 621.9442122930357,
                    "objective_score": 21.91947436496106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023199057579040526,
                    "num_nodes_avg": 285.8,
                    "path_length_avg": 234.67161709331359,
                    "smoothness_avg": 0.11706785284768806,
                    "success_improvement": 0.0,
                    "time_improvement": 85.56632689312731,
                    "length_improvement": 21.659859566275518,
                    "smoothness_improvement": 2912.240174337157,
                    "objective_score": 53.227014679389285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0182589054107666,
                    "num_nodes_avg": 226.6,
                    "path_length_avg": 120.43817791147322,
                    "smoothness_avg": 0.10596483217621462,
                    "success_improvement": 0.0,
                    "time_improvement": 62.42098600050051,
                    "length_improvement": 20.010696880938188,
                    "smoothness_improvement": 1247.864843771141,
                    "objective_score": 36.972038147568774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified and robust bidirectional RRT* planner that alternates tree expansions from start and goal with fixed step steering and adaptive neighbor radius rewiring, combined with iterative path shortcutting. It uses goal bias sampling for efficient search, incremental parent optimization with rewiring, early stopping on first successful connection, and guarantees collision-free nodes and edges within a 30-second limit, aiming to balance planning speed, path length, and smoothness.",
          "planning_mechanism": "The planner alternately grows trees from start and goal by sampling points with goal biasing, steering toward samples with fixed step size, and rewiring neighbors within an adaptive radius to reduce cost. Each iteration attempts to connect the two trees to find a feasible path early. After success or time limit, shortcutting is applied iteratively to smooth the found path before returning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n        self.valid = True\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                new_pos = to\n            else:\n                ratio = self.step_size / d\n                new_pos = tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n            # Clip to bounds just in case\n            return tuple(max(0, min(new_pos[i], bounds[i])) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback to pure random without obstacle check\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 10.0\n            gamma = 35.0  # Tuned constant\n            return min(gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20.0)\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n\n            q_rand = sample_free()\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if (not in_bounds(new_pos) or is_in_obstacle(new_pos) or \n                is_edge_in_obstacle(nearest_node.position, new_pos)):\n                continue\n\n            n = len(all_nodes)\n            radius = adaptive_radius(n)\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Try connect tree_b to new_node\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other in near_other:\n                if is_edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start else other\n                    best_goal_node = other if expand_start else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicate connecting node in concatenation\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Iterative shortcutting for path smoothness\n                smoothed_path = combined_path\n                for _ in range(3):\n                    shortcut = shortcut_path(smoothed_path)\n                    if len(shortcut) == len(smoothed_path):\n                        break\n                    smoothed_path = shortcut\n\n                return PlannerResult(\n                    success=True,\n                    path=smoothed_path,\n                    nodes=all_nodes,\n                    edges=edges\n                )\n\n        # If failed to connect trees, return best effort start path to closest node near goal\n        closest_node = None\n        min_dist_goal = float('inf')\n        for n in tree_start:\n            if not n.valid:\n                continue\n            d = dist(n.position, goal_pos)\n            if d < min_dist_goal:\n                min_dist_goal = d\n                closest_node = n\n\n        fallback_path = []\n        if closest_node:\n            fallback_path = closest_node.path_from_root()\n            if dist(fallback_path[-1], goal_pos) > 1e-7 and not is_edge_in_obstacle(fallback_path[-1], goal_pos):\n                fallback_path.append(goal_pos)\n            # Shortcut fallback path as well\n            for _ in range(3):\n                shortcut = shortcut_path(fallback_path)\n                if len(shortcut) == len(fallback_path):\n                    break\n                fallback_path = shortcut\n\n        return PlannerResult(\n            success=False,\n            path=fallback_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -37.13607,
          "time_improvement": 62.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1687.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014321255683898925,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 161.58062527846636,
                    "smoothness_avg": 0.05324372485333625,
                    "success_improvement": 0.0,
                    "time_improvement": 43.00587895947351,
                    "length_improvement": 11.435098876016966,
                    "smoothness_improvement": 733.379914553803,
                    "objective_score": 23.42972258622125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02621777057647705,
                    "num_nodes_avg": 316.5,
                    "path_length_avg": 234.77047192424206,
                    "smoothness_avg": 0.11036249136518128,
                    "success_improvement": 0.0,
                    "time_improvement": 83.68818522896629,
                    "length_improvement": 21.626858978333054,
                    "smoothness_improvement": 2739.7063937155986,
                    "objective_score": 51.781102924267714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02021956443786621,
                    "num_nodes_avg": 280.1,
                    "path_length_avg": 123.59571670051699,
                    "smoothness_avg": 0.13260307928487777,
                    "success_improvement": 0.0,
                    "time_improvement": 58.38571491660656,
                    "length_improvement": 17.913609963095027,
                    "smoothness_improvement": 1586.7013807624646,
                    "objective_score": 36.197387356651305
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An adaptive bidirectional RRT* planner leveraging goal-biased uniform sampling before first solution, then switching to informed ellipsoidal sampling bounded by current best path cost. It uses a dynamically shrinking adaptive neighbor radius for rewiring to optimize path cost and propagates rewiring cost updates downstream for global improvements. To accelerate nearest and neighbor queries, a shared spatial hash grid is employed. The planner strictly checks node and edge collisions, respects map boundaries, and enforces a 30-second hard time limit. Upon tree connection, a multi-pass shortcut smoothing post-processing step reduces path length and enhances smoothness. Early stopping occurs immediately after connection to reduce runtime.",
          "planning_mechanism": "The planner alternately grows start and goal trees, sampling nodes preferentially within an ellipsoidal subset post-solution for focused exploration. Each iteration extends the nearest node toward the sample with bounded step size, checking collisions strictly. Neighbors for rewiring are identified efficiently using the spatial hash grid within an adaptively reduced radius. Rewiring updates costs downstream recursively to maintain consistency. On detecting a feasible connection between trees, early termination and post-processing occur, producing a smooth, shorter path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = 25.0\n        self.min_neighbor_radius = 5.0\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        # Shared spatial hash grid for acceleration\n        cell_size = max(1.0, self.step_size * 2)\n        grid = {}\n        def grid_coords(p):\n            return tuple(int(p[i] // cell_size) for i in range(dim))\n        def grid_insert(node):\n            c = grid_coords(node.position)\n            grid.setdefault(c, []).append(node)\n        def grid_nearby(p, radius):\n            min_c = [int((p[i] - radius) // cell_size) for i in range(dim)]\n            max_c = [int((p[i] + radius) // cell_size) for i in range(dim)]\n            nearby_nodes = []\n            def recurse(i, cur):\n                if i == dim:\n                    nearby_nodes.extend(grid.get(tuple(cur), []))\n                    return\n                for val in range(min_c[i], max_c[i] + 1):\n                    cur.append(val)\n                    recurse(i+1, cur)\n                    cur.pop()\n            recurse(0, [])\n            return nearby_nodes\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a,b)\n\n        def build_rotation_matrix(a):\n            if dim == 2:\n                cos_theta = a[0]\n                sin_theta = a[1]\n                return [[cos_theta, -sin_theta],\n                        [sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                dot = sum(x_axis[j]*temp[j] for j in range(3))\n                v = tuple(temp[i] - dot*x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(vi/norm_v for vi in v)\n                w = (x_axis[1]*v_unit[2]-x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0]-x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1]-x_axis[1]*v_unit[0])\n                R = [list(x_axis), list(v_unit), list(w)]\n                return [[R[0][0],R[1][0],R[2][0]],\n                        [R[0][1],R[1][1],R[2][1]],\n                        [R[0][2],R[1][2],R[2][2]]]\n            else:\n                return None\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            r1 = c_best / 2.0\n            val = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(abs(val)) / 2.0 if val > 1e-12 else 1e-6\n            radii = [r1] + [r2]*(dim-1)\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            scale = random.random() ** (1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n            sample = [0.0]*dim\n            for i in range(dim):\n                s=0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        def neighbor_radius(node_count):\n            gamma = self.max_neighbor_radius\n            val = gamma * (math.log(node_count + 1) / (node_count + 1)) ** (1.0/dim)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        start_tree_nodes = []\n        goal_tree_nodes = []\n        start_tree_edges = []\n        goal_tree_edges = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree_nodes.append(start_root)\n        goal_tree_nodes.append(goal_root)\n        grid_insert(start_root)\n        grid_insert(goal_root)\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n        active_flag = 0\n        no_improve_iters = 0\n        max_no_improve = 400\n\n        def nearest_in_tree(tree_nodes, p):\n            search_radius = self.step_size * 2.5\n            nearby = grid_nearby(p, search_radius)\n            tree_set = set(tree_nodes)\n            candidates = [n for n in nearby if n in tree_set]\n            if not candidates:\n                candidates = tree_nodes\n            best = candidates[0]\n            best_d = dist(p, best.position)\n            for n in candidates[1:]:\n                dcur = dist(p, n.position)\n                if dcur < best_d:\n                    best = n\n                    best_d = dcur\n            return best, best_d\n\n        def neighbors_in_tree(tree_nodes, p, radius):\n            nearby = grid_nearby(p, radius)\n            tree_set = set(tree_nodes)\n            result = [n for n in nearby if n in tree_set and dist(n.position, p) <= radius]\n            if not result:\n                for n in tree_nodes:\n                    if dist(n.position, p) <= radius:\n                        result.append(n)\n            return result\n\n        def backtrace_path(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def connect_paths(n1, n2):\n            p1 = backtrace_path(n1)\n            p2 = backtrace_path(n2)\n            p2.reverse()\n            return p1 + p2\n\n        def propagate_cost_updates(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-8 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        stack.append(c)\n\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            max_passes = 3\n            passes = 0\n            shortened = path_points\n            while passes < max_passes:\n                changed = False\n                new_path = [shortened[0]]\n                i = 0\n                while i < len(shortened)-1:\n                    j = len(shortened)-1\n                    while j > i+1:\n                        if is_free_edge(shortened[i], shortened[j]):\n                            new_path.append(shortened[j])\n                            i = j\n                            changed = True\n                            break\n                        j -= 1\n                    else:\n                        i += 1\n                        if i < len(shortened):\n                            new_path.append(shortened[i])\n                shortened = new_path\n                if not changed:\n                    break\n                passes += 1\n            return shortened\n\n        trees = [(start_tree_nodes, start_tree_edges), (goal_tree_nodes, goal_tree_edges)]\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            active_nodes, active_edges = trees[active_flag]\n            other_nodes, other_edges = trees[1 - active_flag]\n\n            c_best = best_cost\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if active_flag == 0 else start_pos\n            else:\n                sample = sample_informed(c_best, start_pos, goal_pos)\n\n            nearest, _ = nearest_in_tree(active_nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                active_flag = 1 - active_flag\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                active_flag = 1 - active_flag\n                continue\n\n            n_nodes = len(active_nodes)\n            radius = neighbor_radius(n_nodes)\n            nbrs = neighbors_in_tree(active_nodes, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in nbrs:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative + 1e-8 < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            active_nodes.append(new_node)\n            active_edges.append((best_parent, new_node))\n            grid_insert(new_node)\n\n            # Rewire neighbors if beneficial\n            for nb in nbrs:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            active_edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    active_edges.append((new_node, nb))\n                    propagate_cost_updates(nb)\n\n            # Attempt connect to other tree within step size\n            other_neigh = neighbors_in_tree(other_nodes, new_pos, self.step_size)\n            connected = False\n            for onode in other_neigh:\n                if dist(onode.position, new_pos) <= self.step_size:\n                    if is_free_edge(onode.position, new_pos):\n                        path = connect_paths(new_node, onode)\n                        path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                        if path_cost + 1e-8 < best_cost:\n                            best_cost = path_cost\n                            best_path = path\n                            success = True\n                            connected = True\n                            break\n            if connected:\n                break\n\n            active_flag = 1 - active_flag\n\n            if success:\n                no_improve_iters += 1\n                if no_improve_iters > max_no_improve:\n                    break\n\n        if not success:\n            # fallback: try to connect closest pair (start_tree, goal_tree) within step_size*3\n            best_pair_dist = float('inf')\n            best_pair = None\n            for sn in start_tree_nodes:\n                candidates = neighbors_in_tree(goal_tree_nodes, sn.position, self.step_size * 3)\n                for gn in candidates:\n                    d = dist(sn.position, gn.position)\n                    if d < best_pair_dist and is_free_edge(sn.position, gn.position):\n                        best_pair_dist = d\n                        best_pair = (sn, gn)\n            if best_pair is not None:\n                s, g = best_pair\n                best_path = connect_paths(s, g)\n                success = True\n\n        if not best_path:\n            best_path = [start_pos, goal_pos]\n\n        best_path = shortcut_path(best_path)\n\n        all_nodes = start_tree_nodes + goal_tree_nodes\n        all_edges = start_tree_edges + goal_tree_edges\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -36.65222,
          "time_improvement": 57.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1970.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015115761756896972,
                    "num_nodes_avg": 78.3,
                    "path_length_avg": 162.52270818031786,
                    "smoothness_avg": 0.04809738367960925,
                    "success_improvement": 0.0,
                    "time_improvement": 39.84399313805118,
                    "length_improvement": 10.918728309253273,
                    "smoothness_improvement": 652.8284997262474,
                    "objective_score": 21.768577425598554
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02111175060272217,
                    "num_nodes_avg": 194.0,
                    "path_length_avg": 239.47639500520026,
                    "smoothness_avg": 0.14588791673498644,
                    "success_improvement": 0.0,
                    "time_improvement": 86.86497906756276,
                    "length_improvement": 20.055886401423688,
                    "smoothness_improvement": 3653.8011764103076,
                    "objective_score": 56.36203144317458
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026419973373413085,
                    "num_nodes_avg": 314.9,
                    "path_length_avg": 125.17233073704627,
                    "smoothness_avg": 0.1339439108219223,
                    "success_improvement": 0.0,
                    "time_improvement": 45.62453077387349,
                    "length_improvement": 16.866497990325016,
                    "smoothness_improvement": 1603.756658943782,
                    "objective_score": 31.826041321075962
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, efficient bidirectional RRT* planner with fixed step size and rewiring radius that grows start and goal trees alternately using goal-biased sampling, performs local rewiring, attempts immediate tree connection each iteration, and applies iterative path shortcutting for smoothness before early termination upon first successful connection.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling states biased towards the other tree\u2019s root, steering by fixed steps, locally rewiring neighbors within a fixed radius to reduce costs, and attempts connecting the two trees whenever possible. Upon connecting, it extracts the combined path and iteratively shortcuts it to improve smoothness before returning. The process respects a 30-second time constraint and map bounds and avoids collisions on nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d_] + ratio * (to[d_] - frm[d_]) for d_ in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample(goal_bias_target):\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not in_obstacle(goal_bias_target):\n                    return goal_bias_target\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_bias_target\n\n        def nearby(nodes, pos, radius):\n            return [n for n in nodes if dist(n.position, pos) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        fixed_radius = self.step_size * 4\n        best_cost = float('inf')\n        success = False\n        best_start_node = None\n        best_goal_node = None\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n            goal_bias = goal_pos if expand_start else start_pos\n\n            q_rand = sample(goal_bias)\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if not in_bounds(new_pos):\n                continue\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            neighbors = nearby(tree_a, new_pos, fixed_radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_cand = nbr.cost + dist(nbr.position, new_pos)\n                if cost_cand + 1e-9 < min_cost and not edge_in_obstacle(nbr.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, nbr))\n\n            neighbors_other = nearby(tree_b, new_node.position, fixed_radius)\n            for other in neighbors_other:\n                if edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start else other\n                    best_goal_node = other if expand_start else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicated meeting points\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                full_path = path_start + path_goal[::-1]\n\n                for _ in range(5):\n                    shortened = shortcut_path(full_path)\n                    if len(shortened) == len(full_path):\n                        break\n                    full_path = shortened\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=all_nodes,\n                    edges=edges,\n                )\n\n        # Fallback: best node in start tree closest to goal\n        closest_node = min(tree_start, key=lambda n: dist(n.position, goal_pos))\n        fallback_path = closest_node.path_from_root()\n        if dist(fallback_path[-1], goal_pos) > 1e-9 and not edge_in_obstacle(fallback_path[-1], goal_pos):\n            fallback_path.append(goal_pos)\n        for _ in range(3):\n            shortened = shortcut_path(fallback_path)\n            if len(shortened) == len(fallback_path):\n                break\n            fallback_path = shortened\n\n        return PlannerResult(\n            success=False,\n            path=fallback_path,\n            nodes=all_nodes,\n            edges=edges,\n        )",
          "objective": -36.21283,
          "time_improvement": 67.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1233.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0158186674118042,
                    "num_nodes_avg": 85.9,
                    "path_length_avg": 165.12047567375396,
                    "smoothness_avg": 0.043351546284240774,
                    "success_improvement": 0.0,
                    "time_improvement": 37.04664834789473,
                    "length_improvement": 9.494850781840794,
                    "smoothness_improvement": 578.5458387378775,
                    "objective_score": 19.70363416716228
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023387598991394042,
                    "num_nodes_avg": 221.1,
                    "path_length_avg": 231.05699716707198,
                    "smoothness_avg": 0.08155827087821192,
                    "success_improvement": 0.0,
                    "time_improvement": 85.44902276972718,
                    "length_improvement": 22.86652373872083,
                    "smoothness_improvement": 1998.553053744454,
                    "objective_score": 49.34738634287292
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010654091835021973,
                    "num_nodes_avg": 123.8,
                    "path_length_avg": 124.07792451784408,
                    "smoothness_avg": 0.09606459725966353,
                    "success_improvement": 0.0,
                    "time_improvement": 78.07260308253964,
                    "length_improvement": 17.593350491095126,
                    "smoothness_improvement": 1121.9345863919382,
                    "objective_score": 39.58746415137866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that uses fixed-radius neighbor rewiring, goal bias sampling, and early termination upon first path discovery. It balances exploration and refinement by alternating tree expansions, performs collision checks rigorously, rewires neighbors to improve path costs, and returns the best found path within a 30-second time limit. Path smoothing is done by iterative shortcutting before returning.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points biased towards the goal, steering towards samples within step size, and rewiring within a fixed neighborhood radius to improve path quality. It attempts to connect the two trees after each expansion, and upon a successful connection, combines their paths and smooths them iteratively before returning. Early stopping ensures efficiency within the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d] + ratio * (to[d] - frm[d]) for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    return goal_pos\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return goal_pos\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        fixed_radius = self.step_size * 4\n        best_cost = float('inf')\n        success = False\n        best_start_node = None\n        best_goal_node = None\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n\n            q_rand = sample_free()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, fixed_radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_cand = nbr.cost + dist(nbr.position, new_pos)\n                if cost_cand + 1e-9 < min_cost and not is_edge_in_obstacle(nbr.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, nbr))\n\n            neighbors_other = near_nodes(tree_b, new_node.position, fixed_radius)\n            for other in neighbors_other:\n                if is_edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start else other\n                    best_goal_node = other if expand_start else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                full_path = path_start + path_goal[::-1]\n\n                for _ in range(3):\n                    shortened = shortcut_path(full_path)\n                    if len(shortened) == len(full_path):\n                        break\n                    full_path = shortened\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=all_nodes,\n                    edges=edges,\n                )\n\n        # Fallback best effort path\n        closest_node = None\n        min_dist_goal = float('inf')\n        for n in tree_start:\n            d = dist(n.position, goal_pos)\n            if d < min_dist_goal:\n                min_dist_goal = d\n                closest_node = n\n\n        fallback_path: List[Tuple[float, ...]] = []\n        if closest_node:\n            fallback_path = closest_node.path_from_root()\n            if dist(fallback_path[-1], goal_pos) > 1e-9 and not is_edge_in_obstacle(fallback_path[-1], goal_pos):\n                fallback_path.append(goal_pos)\n            for _ in range(3):\n                shortcut = shortcut_path(fallback_path)\n                if len(shortcut) == len(fallback_path):\n                    break\n                fallback_path = shortcut\n\n        return PlannerResult(\n            success=False,\n            path=fallback_path,\n            nodes=all_nodes,\n            edges=edges,\n        )",
          "objective": -35.99817,
          "time_improvement": 62.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015302610397338868,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.73498156934653,
                    "smoothness_avg": 0.05365365347080483,
                    "success_improvement": 0.0,
                    "time_improvement": 39.10039395480526,
                    "length_improvement": 8.061798670969395,
                    "smoothness_improvement": 739.7961875914269,
                    "objective_score": 20.26617832698035
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02900516986846924,
                    "num_nodes_avg": 265.7,
                    "path_length_avg": 228.5271498109665,
                    "smoothness_avg": 0.0905829923330458,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95395916991758,
                    "length_improvement": 23.7110596038075,
                    "smoothness_improvement": 2230.7656370214518,
                    "objective_score": 49.96665169836703
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017523741722106932,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 119.30175582224294,
                    "smoothness_avg": 0.10412298517251259,
                    "success_improvement": 0.0,
                    "time_improvement": 63.93404091406476,
                    "length_improvement": 20.765454322000227,
                    "smoothness_improvement": 1224.4366858350554,
                    "objective_score": 37.76166829659484
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* planner integrating adaptive rewiring radius shrinking with iteration, dynamic goal bias decay, efficient neighbor search, and incremental path shortcutting for enhanced smoothness during planning. The planner alternates tree expansions from start and goal, adapts rewiring radius to balance exploration and refinement, progressively reduces goal bias to encourage exploration early and goal convergence later, and applies incremental shortcutting after each found improvement to maintain smooth and shorter paths. The 30-second time limit is strictly enforced to ensure timely results.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points with a decaying goal bias and steering towards them with fixed step size. It uses a theoretically informed annealing radius for neighbor rewiring, reconnects neighbors for cost improvements, propagates cost updates downstream, and attempts tree connection attempts each iteration. When a new shorter path is discovered, it is immediately shortcut for smoothness. The search stops early on solution discovery or timeout.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            length = dist(from_pos, to_pos)\n            if length <= self.step_size:\n                new_pos = to_pos\n            else:\n                scale = self.step_size / length\n                new_pos = tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n            if in_bounds(new_pos):\n                return new_pos\n            clipped = tuple(max(0.0, min(new_pos[d], bounds[d])) for d in range(dim))\n            return clipped\n\n        def sample_point(iteration):\n            bias_max = 0.13\n            bias_min = 0.02\n            decay_rate = 0.0012\n            goal_bias = bias_min + (bias_max - bias_min)*math.exp(-decay_rate*iteration)\n            if random.random() < goal_bias:\n                return goal_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def adaptive_radius(iteration, n_nodes):\n            gamma = 45.0\n            if n_nodes < 2:\n                return self.step_size * 6.0\n            rmax = self.step_size * 10.0\n            rmin = self.step_size * 1.3\n            alpha = min(1.0, iteration / self.max_iter)\n            radius = rmax * (1 - alpha) + rmin * alpha\n            r_theoretical = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            radius = min(radius, max(r_theoretical, rmin))\n            return radius\n\n        def collision_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=1.0)\n\n        def propagate_cost_updates(node):\n            queue = [node]\n            while queue:\n                curr = queue.pop()\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + 1e-8 < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        queue.append(c)\n\n        def incremental_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def connect_trees(node_from: Node, other_tree: List[Node], iteration: int):\n            nonlocal best_cost, best_path_start, best_path_goal, success\n\n            # Find nearest in other tree\n            nearest_o = min(other_tree, key=lambda n: dist(n.position, node_from.position))\n\n            # Direct connection if close enough and collision free\n            if dist(nearest_o.position, node_from.position) <= self.step_size:\n                if collision_free_edge(nearest_o.position, node_from.position):\n                    new_node = Node(node_from.position)\n                    new_node.update_parent(nearest_o, nearest_o.cost + dist(nearest_o.position, node_from.position))\n                    other_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest_o, new_node))\n                    total_cost = new_node.cost + node_from.cost\n                    if total_cost + 1e-8 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_path_start = node_from if node_from in tree_start else new_node\n                        best_path_goal = new_node if new_node in tree_goal else node_from\n                    return\n\n            # Incremental extension towards node_from\n            cur_node = nearest_o\n            for _ in range(5):\n                new_pos = steer(cur_node.position, node_from.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return\n                if not collision_free_edge(cur_node.position, new_pos):\n                    return\n                if dist(new_pos, cur_node.position) < 1e-7:\n                    return\n                new_node = Node(new_pos)\n                new_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, new_pos))\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((cur_node, new_node))\n                cur_node = new_node\n\n                if dist(cur_node.position, node_from.position) <= self.step_size and collision_free_edge(cur_node.position, node_from.position):\n                    final_node = Node(node_from.position)\n                    final_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, node_from.position))\n                    other_tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((cur_node, final_node))\n                    total_cost = final_node.cost + node_from.cost\n                    if total_cost + 1e-8 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_path_start = node_from if node_from in tree_start else final_node\n                        best_path_goal = final_node if final_node in tree_goal else node_from\n                    return\n\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_path_start = None\n        best_path_goal = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            if i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            q_rand = sample_point(i)\n            nearest = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest.position, q_rand)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(nearest.position, q_new_pos):\n                continue\n\n            r = adaptive_radius(i, len(nodes))\n            neighbors = [n for n in tree_from if dist(n.position, q_new_pos) <= r]\n\n            min_cost = nearest.cost + dist(nearest.position, q_new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_thru_nbr = nbr.cost + dist(nbr.position, q_new_pos)\n                if cost_thru_nbr + 1e-8 < min_cost and collision_free_edge(nbr.position, q_new_pos):\n                    best_parent = nbr\n                    min_cost = cost_thru_nbr\n\n            new_node = Node(q_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-8 < nbr.cost and collision_free_edge(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, nbr))\n                    propagate_cost_updates(nbr)\n\n            # Attempt tree connection\n            connect_trees(new_node, tree_to, i)\n\n            # If solution found, incrementally shortcut and return early\n            if success:\n                path_start = best_path_start.path_from_root()\n                path_goal = best_path_goal.path_from_root()\n                combined_path = path_start + path_goal[-2::-1]\n                combined_path = incremental_shortcut(combined_path)\n                return PlannerResult(True, combined_path, nodes, edges)\n\n        # On timeout or no success, return best found path if any\n        if success:\n            path_start = best_path_start.path_from_root()\n            path_goal = best_path_goal.path_from_root()\n            combined_path = path_start + path_goal[-2::-1]\n            combined_path = incremental_shortcut(combined_path)\n            return PlannerResult(True, combined_path, nodes, edges)\n\n        # No path found: fallback single tree path closest to goal\n        min_dist = float('inf')\n        closest = None\n        for n in tree_start:\n            d_ = dist(n.position, goal_pos)\n            if d_ < min_dist:\n                min_dist = d_\n                closest = n\n        if closest is not None:\n            path = closest.path_from_root()\n        else:\n            path = [start_pos]\n\n        return PlannerResult(False, path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.65902,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1776.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0094862699508667,
                    "num_nodes_avg": 78.9,
                    "path_length_avg": 160.81674810230595,
                    "smoothness_avg": 0.05004204974942138,
                    "success_improvement": 0.0,
                    "time_improvement": 62.24761084248639,
                    "length_improvement": 11.85379206067894,
                    "smoothness_improvement": 683.2667466287678,
                    "objective_score": 29.20289222229712
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020450520515441894,
                    "num_nodes_avg": 259.7,
                    "path_length_avg": 239.45073390828475,
                    "smoothness_avg": 0.11920378976481819,
                    "success_improvement": 0.0,
                    "time_improvement": 87.27637418116664,
                    "length_improvement": 20.064452814187806,
                    "smoothness_improvement": 2967.199369668092,
                    "objective_score": 53.05758079120314
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04022374153137207,
                    "num_nodes_avg": 366.5,
                    "path_length_avg": 122.55773962648524,
                    "smoothness_avg": 0.1397865166012973,
                    "success_improvement": 0.0,
                    "time_improvement": 17.21472278243119,
                    "length_improvement": 18.60298491251007,
                    "smoothness_improvement": 1678.074173201133,
                    "objective_score": 24.71657864824106
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius, goal bias sampling, time-limited execution, and post-processing shortcut path smoothing to improve planning efficiency, path quality, and smoothness within 30 seconds. The planning mechanism strategically alternates expansion between start and goal trees, extends using fixed step steering restricted to safe regions, rewires locally for minimum cost, and attempts a greedy connection of the two trees iteratively. Early termination occurs upon a successful connection or time expiration with the best found path returned.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately by sampling mostly free space biased towards the goal, connecting new nodes via collision-free edges. An adaptive radius based on tree size guides rewiring to optimize the path cost. Each iteration tries to connect the two trees greedily, ending early on success. Once done, shortcutting smooths and shortens the path by removing unnecessary intermediate nodes, enhancing smoothness and reducing length. This approach balances simplicity, efficiency, and path quality within a fixed time budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # cost from start (or root)\n        self.children = []\n        self.valid = True             # for future use if needed\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            # Clamp inside bounds\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if all colliding\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        def neighbors_within_radius(tree, pos, radius):\n            # Simple linear neighbor search\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Initialize trees and bookkeeping\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree expansion\n            tree_from, tree_to = (nodes_start, nodes_goal) if (iter_count % 2 == 0) else (nodes_goal, nodes_start)\n\n            q_rand = sample()\n            nearest_node = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = neighbors_within_radius(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, c_via_new)\n                        edges.append((new_node, nb))\n\n            # Try connecting tree_to greedily towards new_node\n            nearest_other = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                steered_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(steered_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, steered_pos, obstacles, is_3d):\n                    break\n\n                new_to_node = Node(steered_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, steered_pos))\n                tree_to.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n\n                if dist(steered_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(steered_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, steered_pos))\n                        tree_to.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            if tree_from is nodes_start:\n                                best_start_node = new_node\n                                best_goal_node = final_node\n                            else:\n                                best_start_node = final_node\n                                best_goal_node = new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n\n            if connected:\n                break\n\n        # Extract path if found\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n        else:\n            # Fallback: best approach towards goal from start tree\n            min_dist = float('inf')\n            closest = None\n            for node in nodes_start:\n                d = dist(node.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    closest = node\n            if closest is not None:\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.51213,
          "time_improvement": 53.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1874.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011601567268371582,
                    "num_nodes_avg": 89.9,
                    "path_length_avg": 160.69641547096222,
                    "smoothness_avg": 0.05680827598999485,
                    "success_improvement": 0.0,
                    "time_improvement": 53.82938872484648,
                    "length_improvement": 11.919748282711002,
                    "smoothness_improvement": 789.1728803891951,
                    "objective_score": 27.24652998902652
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984255313873291,
                    "num_nodes_avg": 279.2,
                    "path_length_avg": 236.06687999619325,
                    "smoothness_avg": 0.12189793516611738,
                    "success_improvement": 0.0,
                    "time_improvement": 87.654631028246,
                    "length_improvement": 21.194080648878383,
                    "smoothness_improvement": 3036.521671358016,
                    "objective_score": 54.19544605459091
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.039806151390075685,
                    "num_nodes_avg": 395.8,
                    "path_length_avg": 123.7510519284601,
                    "smoothness_avg": 0.14915030167737345,
                    "success_improvement": 0.0,
                    "time_improvement": 18.07417330330286,
                    "length_improvement": 17.810443700963898,
                    "smoothness_improvement": 1797.1808282061027,
                    "objective_score": 25.094422352599707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with goal bias sampling, adaptive rewiring radius, early stopping upon path connection, and basic path shortcutting post-processing within a strict 30-second time limit. The planner alternately grows start and goal trees by sampling free space points biased toward the goal, extends trees with collision-checked edges using fixed step size steering, rewires locally for minimum cost, and attempts greedy connection of trees each iteration to find a shortest feasible path efficiently. Once connected or time expires, it extracts and smooths the path by shortcutting to provide improved path length and smoothness while reducing planning time.",
          "planning_mechanism": "The planner grows two trees from start and goal points alternately using goal-biased random sampling within map bounds and obstacle free space. Each sampled point extends the respective tree using a fixed step size and adaptive radius neighbor search to choose the best parent minimizing path cost while performing collision checks on nodes and edges. Local rewiring optimizes cost-to-come values dynamically. After extension, it attempts to connect the two trees greedily. The planner terminates early upon successful connection or after 30 seconds, returning the best path found with shortcut smoothing applied.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return goal_pos\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_from, tree_to = nodes_start, nodes_goal\n            else:\n                tree_from, tree_to = nodes_goal, nodes_start\n\n            q_rand = sample()\n            nearest_node = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = neighbors_within_radius(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = c_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                        nb.update_parent(new_node, c_via_new)\n                        edges.append((new_node, nb))\n\n            # Try connection from tree_to to new_node\n            nearest_other = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                steered_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(steered_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, steered_pos, obstacles, is_3d):\n                    break\n\n                new_to_node = Node(steered_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, steered_pos))\n                tree_to.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n\n                if dist(steered_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(steered_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, steered_pos))\n                        tree_to.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_start_node = new_node if tree_from is nodes_start else final_node\n                            best_goal_node = final_node if tree_to is nodes_goal else new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n\n            if connected:\n                break\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shorthand = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shorthand.append(path[j])\n            i = j\n        return shorthand\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.47883,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1917.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01217057704925537,
                    "num_nodes_avg": 83.6,
                    "path_length_avg": 152.90926987361797,
                    "smoothness_avg": 0.04401612878654404,
                    "success_improvement": 0.0,
                    "time_improvement": 51.56490765972629,
                    "length_improvement": 16.188006179833796,
                    "smoothness_improvement": 588.9479980629259,
                    "objective_score": 28.12701599613279
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02094416618347168,
                    "num_nodes_avg": 271.3,
                    "path_length_avg": 235.2451134926445,
                    "smoothness_avg": 0.14098320673972334,
                    "success_improvement": 0.0,
                    "time_improvement": 86.96924445494005,
                    "length_improvement": 21.468409961000273,
                    "smoothness_improvement": 3527.5994555123716,
                    "objective_score": 56.60981659064404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.043598508834838866,
                    "num_nodes_avg": 369.6,
                    "path_length_avg": 124.37076435048513,
                    "smoothness_avg": 0.13647305078069294,
                    "success_improvement": 0.0,
                    "time_improvement": 10.26904751389891,
                    "length_improvement": 17.398860217789284,
                    "smoothness_improvement": 1635.9271325376515,
                    "objective_score": 21.6996660475315
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner with fixed step extensions, uniform random sampling with goal bias, and straightforward tree connections without rewiring. It alternates expanding trees from start and goal, connects trees when nodes get close, and performs a basic path shortcutting to improve path quality. The approach seeks a balance between simplicity, efficiency, and path quality within a 30-second runtime limit.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by extending towards randomly sampled points with a fixed step size, checks for collision-free node and edge addition, attempts connection when trees are close, and upon success or timeout returns the best-found path. It applies a simple shortcutting method post-planning to remove unnecessary waypoints and smooth the path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.1\n        self.shortcut_max_trials = 50\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[d] + (to_p[d] - from_p[d]) * scale for d in range(dim))\n            new_p = tuple(min(max(new_p[d], 0.0), bounds[d]) for d in range(dim))\n            return new_p\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_start_node = None\n        best_goal_node = None\n        best_cost = float('inf')\n\n        expand_start_tree = True\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest_node.position, x_rand)\n\n            if not in_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Attempt direct connection to other tree if close\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            if dist(new_node.position, nearest_other.position) <= self.step_size:\n                if (not self._is_in_obstacle(nearest_other.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d)):\n                    # Connect trees\n                    if expand_start_tree:\n                        best_start_node = new_node\n                        best_goal_node = nearest_other\n                    else:\n                        best_start_node = nearest_other\n                        best_goal_node = new_node\n                    success = True\n                    best_cost = best_start_node.cost + best_goal_node.cost + dist(best_start_node.position, best_goal_node.position)\n                    # Add connecting edge\n                    edges.append((new_node, nearest_other) if expand_start_tree else (nearest_other, new_node))\n                    break\n\n            expand_start_tree = not expand_start_tree\n\n        # Extract path\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n        else:\n            # no full path: best partial from start tree closest to goal\n            closest_node = min(tree_start, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(success, extracted_path, nodes, edges)\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        trials = 0\n        max_trials = self.shortcut_max_trials\n        while i < len(path) - 1 and trials < max_trials:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n            trials += 1\n        if shortcut_path[-1] != path[-1]:\n            shortcut_path.append(path[-1])\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.31605,
          "time_improvement": 59.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1974.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017038679122924803,
                    "num_nodes_avg": 158.6,
                    "path_length_avg": 171.60233291780634,
                    "smoothness_avg": 0.05474950306558211,
                    "success_improvement": 0.0,
                    "time_improvement": 32.19138309258318,
                    "length_improvement": 5.942042114774837,
                    "smoothness_improvement": 756.9486134251745,
                    "objective_score": 17.00738326376573
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020350265502929687,
                    "num_nodes_avg": 316.3,
                    "path_length_avg": 238.85202782276434,
                    "smoothness_avg": 0.1305295947805393,
                    "success_improvement": 0.0,
                    "time_improvement": 87.33874947693012,
                    "length_improvement": 20.26431813833369,
                    "smoothness_improvement": 3258.6204903702146,
                    "objective_score": 54.653318177930316
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020589232444763184,
                    "num_nodes_avg": 327.4,
                    "path_length_avg": 131.83656740631235,
                    "smoothness_avg": 0.1577953854100647,
                    "success_improvement": 0.0,
                    "time_improvement": 57.62489388742499,
                    "length_improvement": 12.440429311447147,
                    "smoothness_improvement": 1907.1456551722313,
                    "objective_score": 34.287454028956944
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with goal bias and adaptive neighbor radius for efficient tree expansion and rewiring. The planner alternates tree growth from start and goal with fixed step steering, performs collision checks on nodes and edges, rewires locally to optimize costs, attempts incremental tree connections, and applies path shortcutting for smoother, shorter final paths. It respects map bounds and obstacle constraints and enforces a 30-second timeout, returning the best path found or partial progress if time expires.",
          "planning_mechanism": "The planner grows two trees alternatingly with goal-biased sampling, selects parents minimizing cumulative cost in an adaptive radius neighborhood, rewires neighbors for improved paths, connects trees incrementally, and extracts a concatenated and shortcut path. It terminates early on success or timeout, ensuring collision-free, bounded expansions and delivering improved path quality and planning efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return goal_pos\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n        expand_start_tree = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            tree_a = nodes_start if expand_start_tree else nodes_goal\n            tree_b = nodes_goal if expand_start_tree else nodes_start\n\n            q_rand = sample()\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(tree_a)\n            min_radius = self.step_size * 2.5\n            gamma = 50.0\n            radius = max(min_radius, min(gamma * ((math.log(n+1) / (n+1))**(1/dim)), self.step_size * 30))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = c_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nb))\n\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    if expand_start_tree:\n                        best_start_node, best_goal_node = new_node, other_node\n                    else:\n                        best_start_node, best_goal_node = other_node, new_node\n\n            if success:\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # Remove duplicate connection point if overlapping\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            elif path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            full_path = path_start + path_goal[::-1]\n            extracted_path = self._shortcut_path(full_path, obstacles, is_3d)\n\n        else:\n            # Return partial path from start tree closest to goal\n            best_partial = None\n            best_dist = float('inf')\n            for node in nodes_start:\n                d = dist(node.position, goal_pos)\n                if d < best_dist and node.valid:\n                    best_dist = d\n                    best_partial = node\n            if best_partial:\n                partial_path = best_partial.path_from_root()\n                extracted_path = self._shortcut_path(partial_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        shorthand = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shorthand.append(path[j])\n            i = j\n        return shorthand\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.05016,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1612.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016540145874023436,
                    "num_nodes_avg": 133.9,
                    "path_length_avg": 168.78459869753013,
                    "smoothness_avg": 0.04600087389566187,
                    "success_improvement": 0.0,
                    "time_improvement": 34.175389590180735,
                    "length_improvement": 7.486486890764221,
                    "smoothness_improvement": 620.0135689636074,
                    "objective_score": 17.844576856330793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023311591148376463,
                    "num_nodes_avg": 282.1,
                    "path_length_avg": 231.09765466399054,
                    "smoothness_avg": 0.1053828563050206,
                    "success_improvement": 0.0,
                    "time_improvement": 85.49631229241301,
                    "length_improvement": 22.852951095988253,
                    "smoothness_improvement": 2611.5767969315057,
                    "objective_score": 52.418548329974385
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02489478588104248,
                    "num_nodes_avg": 301.9,
                    "path_length_avg": 119.87946301671654,
                    "smoothness_avg": 0.1341079748863519,
                    "success_improvement": 0.0,
                    "time_improvement": 48.76354928775768,
                    "length_improvement": 20.381768710891276,
                    "smoothness_improvement": 1605.843541733377,
                    "objective_score": 34.88734372152895
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A straightforward bidirectional RRT* planner with fixed radius neighbor rewiring and goal bias sampling, using simple collision checks, fixed step steering, and iterative path shortcutting for smoothing. The planner grows two trees alternately, rewires nearby nodes for local path optimization, attempts connection after each expansion, and returns the best path found within a 30-second time limit.",
          "planning_mechanism": "The planner samples randomly with goal bias, extends the nearest node towards the sample with a fixed step, checks collisions, and connects if possible. It rewires neighbors locally to reduce cost and merges paths upon tree connection. The final path is smoothed via repeated shortcut attempts before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, dd = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+dd:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        fixed_radius = self.step_size*4\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expanding_start = (it % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n\n            q_rand = sample_free()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, fixed_radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand < min_cost and not is_edge_in_obstacle(nb.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nb))\n\n            # Attempt connection between trees\n            neighbors_other = near_nodes(tree_b, new_node.position, fixed_radius)\n            for other in neighbors_other:\n                if is_edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expanding_start else other\n                    best_goal_node = other if expanding_start else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                full_path = path_start + path_goal[::-1]\n\n                for _ in range(3):\n                    shortened = shortcut_path(full_path)\n                    if len(shortened) == len(full_path):\n                        break\n                    full_path = shortened\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=all_nodes,\n                    edges=edges,\n                )\n\n        # Fallback best effort path from start to closest node near goal\n        closest_node = None\n        min_dist_goal = float('inf')\n        for n in tree_start:\n            d = dist(n.position, goal_pos)\n            if d < min_dist_goal:\n                min_dist_goal = d\n                closest_node = n\n\n        fallback_path = []\n        if closest_node:\n            fallback_path = closest_node.path_from_root()\n            if dist(fallback_path[-1], goal_pos) > 1e-7 and not is_edge_in_obstacle(fallback_path[-1], goal_pos):\n                fallback_path.append(goal_pos)\n            for _ in range(3):\n                shortcut = shortcut_path(fallback_path)\n                if len(shortcut) == len(fallback_path):\n                    break\n                fallback_path = shortcut\n\n        return PlannerResult(\n            success=False,\n            path=fallback_path,\n            nodes=all_nodes,\n            edges=edges,\n        )",
          "objective": -34.76108,
          "time_improvement": 56.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1407.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01600613594055176,
                    "num_nodes_avg": 87.1,
                    "path_length_avg": 159.7628758737735,
                    "smoothness_avg": 0.04409632601867845,
                    "success_improvement": 0.0,
                    "time_improvement": 36.30058220295883,
                    "length_improvement": 12.431436128811692,
                    "smoothness_improvement": 590.2032588969065,
                    "objective_score": 21.300052632659195
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02583744525909424,
                    "num_nodes_avg": 247.0,
                    "path_length_avg": 231.54550273793538,
                    "smoothness_avg": 0.0998281375255198,
                    "success_improvement": 0.0,
                    "time_improvement": 83.92481084561766,
                    "length_improvement": 22.703446518313395,
                    "smoothness_improvement": 2468.649881832731,
                    "objective_score": 51.14276057383699
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025365114212036133,
                    "num_nodes_avg": 227.9,
                    "path_length_avg": 121.24235097367641,
                    "smoothness_avg": 0.09930572895509122,
                    "success_improvement": 0.0,
                    "time_improvement": 47.79555725662805,
                    "length_improvement": 19.47660342362902,
                    "smoothness_improvement": 1163.1615423223225,
                    "objective_score": 31.840436942777437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using fixed step size and radius rewiring with goal biasing and uniform sampling, early stopping on first path, and a deterministic limited-pass path shortcutting to improve smoothness and path length.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternates expanding each toward samples randomly drawn inside the map bounds or biased toward the goal. Each new sample is connected by steering a fixed step size, using collision checking. Rewiring within a fixed radius locally improves cost connections. Once the trees connect, the path is extracted and refined by systematically shortcutting edges to smooth and shorten the path. The search respects a 30s time limit with early termination upon success.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                try:\n                    self.parent.children.remove(self)\n                except ValueError:\n                    pass\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, time_limit=30.0, radius=10.0, shortcut_passes=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.radius = radius\n        self.shortcut_passes = shortcut_passes\n\n    def _in_bounds(self, p, bounds):\n        return all(0 <= p[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(p1,p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_p, to_p, max_step):\n        dist = math.dist(from_p,to_p)\n        if dist <= max_step:\n            return to_p\n        ratio = max_step / dist\n        return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(len(from_p)))\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        closest = None\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < min_dist:\n                min_dist = d\n                closest = node\n        return closest, min_dist\n\n    def _near(self, tree, point, radius):\n        result = []\n        for node in tree:\n            if math.dist(node.position, point) <= radius:\n                result.append(node)\n        return result\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_start.reverse()\n        path_goal = []\n        cur = node_goal\n        while cur:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        if path_start and path_goal and path_start[-1] == path_goal[0]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        for _ in range(self.shortcut_passes):\n            i = 0\n            while i < len(new_path) - 2:\n                j = i + 2\n                while j < len(new_path):\n                    if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                        del new_path[i+1:j]\n                        break\n                    j += 1\n                i += 1\n        return new_path\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        success = False\n        best_start = None\n        best_goal = None\n\n        forward = True  # Alternate tree expansion\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n            if success:\n                break\n\n            current_tree = tree_start if forward else tree_goal\n            other_tree = tree_goal if forward else tree_start\n\n            # Sample point: goal bias or uniform\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if forward else start_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node, _ = self._nearest(current_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample, self.step_size)\n\n            if (not self._in_bounds(new_pos, bounds)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                forward = not forward\n                continue\n\n            neighbors = self._near(current_tree, new_pos, self.radius)\n\n            # Pick best parent among neighbors by cost + distance\n            best_parent = nearest_node\n            best_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            for nbr in neighbors:\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < best_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    best_parent = nbr\n                    best_cost = cost_through_nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nbr))\n\n            # Try connect trees\n            for other_node in other_tree:\n                dist_connect = math.dist(new_node.position, other_node.position)\n                if dist_connect <= self.radius:\n                    total_cost = new_node.cost + dist_connect + other_node.cost\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        success = True\n                        best_start = new_node if forward else other_node\n                        best_goal = other_node if forward else new_node\n                        break\n\n            forward = not forward\n\n        if success and best_start and best_goal:\n            path = self._extract_path(best_start, best_goal)\n        else:\n            # fallback: path from start tree node closest to goal\n            closest, min_dist = None, float('inf')\n            for node in tree_start:\n                d = math.dist(node.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    closest = node\n            path = []\n            cur = closest\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            if not path:\n                path = [start_pos]\n\n        path = self._shortcut_path(path, obstacles, is_3d)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -34.24624,
          "time_improvement": 69.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 837.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009841299057006836,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 163.93958978667393,
                    "smoothness_avg": 0.045087448502866743,
                    "success_improvement": 0.0,
                    "time_improvement": 60.83470597611981,
                    "length_improvement": 10.142113048883692,
                    "smoothness_improvement": 605.7164780313757,
                    "objective_score": 27.36426201232303
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017429041862487792,
                    "num_nodes_avg": 249.2,
                    "path_length_avg": 247.93267106056183,
                    "smoothness_avg": 0.0442467897919282,
                    "success_improvement": 0.0,
                    "time_improvement": 89.15623654314183,
                    "length_improvement": 17.23293805373344,
                    "smoothness_improvement": 1038.5017710208178,
                    "objective_score": 42.2791426502867
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02142653465270996,
                    "num_nodes_avg": 291.5,
                    "path_length_avg": 120.46393580464454,
                    "smoothness_avg": 0.07592281963146699,
                    "success_improvement": 0.0,
                    "time_improvement": 55.90162566918393,
                    "length_improvement": 19.99358971475286,
                    "smoothness_improvement": 865.7326616726536,
                    "objective_score": 33.09530483797016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner with goal bias sampling, efficient fixed-radius neighbor rewiring, early termination upon first connection, and iterative multi-pass shortcut smoothing. The planner balances exploration and exploitation by alternating tree expansions, uses rigorous collision checks, and adapts the neighbor radius based on node count and dimensionality to optimize path quality and smoothing within a strict 30-second time limit.",
          "planning_mechanism": "The algorithm alternates growth between two trees from start and goal. Each iteration samples a random point with goal bias, finds the nearest node in the active tree, and attempts to steer toward the sample. It rewires neighbors within an adaptive radius for local cost improvement, updates parents and costs incrementally, and tries to connect to the opposite tree for path completion. Upon finding the first feasible path, it performs iterative shortcutting smoothing and terminates early. The planner respects map boundaries and obstacle constraints strictly and returns the best path found within a 30-second budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) :\n        import math\n        import random\n        import time\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x<=px<=x+w and y<=py<=y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d]+(b[d]-a[d])*(i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_dist=None):\n            d = dist(from_p,to_p)\n            step = max_dist if max_dist is not None else self.step_size\n            if d<=step:\n                return to_p\n            ratio = step/d\n            return tuple(from_p[i]+ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            max_passes = 20\n            shortened = path[:]\n            for _ in range(max_passes):\n                changed = False\n                new_path = [shortened[0]]\n                i = 0\n                while i < len(shortened) - 1:\n                    j = len(shortened)-1\n                    while j > i+1:\n                        if not edge_in_obstacle(shortened[i], shortened[j]):\n                            new_path.append(shortened[j])\n                            i = j\n                            changed = True\n                            break\n                        j -= 1\n                    else:\n                        new_path.append(shortened[i+1])\n                        i += 1\n                if not changed:\n                    break\n                shortened = new_path\n            return shortened\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_start_tree = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(tree_a)\n            gamma_rrt = 50.0\n            min_radius = self.step_size*1.5\n            radius = max(min_radius, min(gamma_rrt*( (math.log(n+1)/(n+1) )**(1/dim) ), self.step_size*20))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and not edge_in_obstacle(nb.position,new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb in (best_parent, new_node):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    if not edge_in_obstacle(new_node.position, nb.position):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            connected = False\n            for other_node in near_other:\n                if edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n                    connected = True\n\n            if connected:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Remove duplicate join node if present\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                smooth_path = combined_path\n                for _ in range(20):\n                    shortened_path = shortcut_path(smooth_path)\n                    if len(shortened_path) == len(smooth_path):\n                        break\n                    smooth_path = shortened_path\n                return PlannerResult(\n                    success=True,\n                    path=smooth_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            expand_start_tree = not expand_start_tree\n\n        # No full path found, try best partial path nearest to goal in start tree\n        best_partial_node = None\n        best_dist = float('inf')\n        for nd in tree_start:\n            if not nd.valid:\n                continue\n            d = dist(nd.position, goal_pos)\n            if d < best_dist:\n                best_dist = d\n                best_partial_node = nd\n\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(\n                success=False,\n                path=smooth_partial,\n                nodes=nodes,\n                edges=edges\n            )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -34.19888,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1520.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015099334716796874,
                    "num_nodes_avg": 107.0,
                    "path_length_avg": 157.40553728735898,
                    "smoothness_avg": 0.049513980568285175,
                    "success_improvement": 0.0,
                    "time_improvement": 39.90936762283572,
                    "length_improvement": 13.723530762445815,
                    "smoothness_improvement": 675.0013172234055,
                    "objective_score": 23.581935330435233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024740886688232423,
                    "num_nodes_avg": 311.7,
                    "path_length_avg": 229.1035364089636,
                    "smoothness_avg": 0.09845758395576734,
                    "success_improvement": 0.0,
                    "time_improvement": 84.6070526953322,
                    "length_improvement": 23.518645167027724,
                    "smoothness_improvement": 2433.3845513131655,
                    "objective_score": 51.66022566538213
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03293523788452148,
                    "num_nodes_avg": 332.3,
                    "path_length_avg": 124.39531724568334,
                    "smoothness_avg": 0.12201877545263888,
                    "success_improvement": 0.0,
                    "time_improvement": 32.21533614991683,
                    "length_improvement": 17.38255335388186,
                    "smoothness_improvement": 1452.0698172684279,
                    "objective_score": 27.354481943646302
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that alternates expansions from start and goal trees, uses uniform random sampling with goal bias, fixed-radius rewiring for local improvements, and early termination upon first path connection. It performs collision checks on nodes and edges, rewires neighbors to reduce path cost, and after finding a path, applies multiple iterations of path shortcutting for smoothing before returning.",
          "planning_mechanism": "The planner grows two trees alternately by sampling free states biased towards the goal, extends towards samples by fixed steps, rewires neighbors within a fixed radius to reduce cost, attempts connection between trees each iteration, and upon success extracts and shortcuts the path. Early stopping limits runtime, ensuring efficiency while balancing exploration and refinement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d_] + ratio * (to[d_] - frm[d_]) for d_ in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample():\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not in_obstacle(goal_pos):\n                    return goal_pos\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos\n\n        def nearby(nodes, pos, radius):\n            return [n for n in nodes if dist(n.position, pos) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        fixed_radius = self.step_size * 4\n        best_cost = float('inf')\n        success = False\n        best_start_node = None\n        best_goal_node = None\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expand_start = (it % 2 == 0)\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n\n            q_rand = sample()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if not in_bounds(new_pos):\n                continue\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            neighbors = nearby(tree_a, new_pos, fixed_radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_cand = nbr.cost + dist(nbr.position, new_pos)\n                if cost_cand + 1e-9 < min_cost and not edge_in_obstacle(nbr.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + 1e-9 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, nbr))\n\n            neighbors_other = nearby(tree_b, new_node.position, fixed_radius)\n            for other in neighbors_other:\n                if edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start else other\n                    best_goal_node = other if expand_start else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                full_path = path_start + path_goal[::-1]\n\n                for _ in range(5):\n                    shortened = shortcut_path(full_path)\n                    if len(shortened) == len(full_path):\n                        break\n                    full_path = shortened\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=all_nodes,\n                    edges=edges,\n                )\n\n        closest_node = None\n        min_dist_goal = float('inf')\n        for n in tree_start:\n            d = dist(n.position, goal_pos)\n            if d < min_dist_goal:\n                min_dist_goal = d\n                closest_node = n\n\n        fallback_path = []\n        if closest_node:\n            fallback_path = closest_node.path_from_root()\n            if dist(fallback_path[-1], goal_pos) > 1e-9 and not edge_in_obstacle(fallback_path[-1], goal_pos):\n                fallback_path.append(goal_pos)\n            for _ in range(3):\n                shortened = shortcut_path(fallback_path)\n                if len(shortened) == len(fallback_path):\n                    break\n                fallback_path = shortened\n\n        return PlannerResult(\n            success=False,\n            path=fallback_path,\n            nodes=all_nodes,\n            edges=edges,\n        )",
          "objective": -34.18597,
          "time_improvement": 57.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1395.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020667648315429686,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 169.07244564428362,
                    "smoothness_avg": 0.04764370161795668,
                    "success_improvement": 0.0,
                    "time_improvement": 17.749220060573407,
                    "length_improvement": 7.328713418021876,
                    "smoothness_improvement": 645.7273902750194,
                    "objective_score": 12.950631020360245
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026778388023376464,
                    "num_nodes_avg": 246.3,
                    "path_length_avg": 229.23492050952686,
                    "smoothness_avg": 0.09164869976332976,
                    "success_improvement": 0.0,
                    "time_improvement": 83.33938791515358,
                    "length_improvement": 23.474785372578054,
                    "smoothness_improvement": 2258.1870568006934,
                    "objective_score": 50.377622882096375
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014251351356506348,
                    "num_nodes_avg": 144.9,
                    "path_length_avg": 121.40861546113028,
                    "smoothness_avg": 0.10863674025155476,
                    "success_improvement": 0.0,
                    "time_improvement": 70.66901218393173,
                    "length_improvement": 19.366178467726257,
                    "smoothness_improvement": 1281.8513172697287,
                    "objective_score": 39.22966732216392
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An optimized bidirectional informed RRT* planner that integrates adaptive ellipsoidal sampling after the first solution is found, dynamic neighbor radius based on the number of nodes and dimension, and efficient rewiring with early stopping on connection. It aggressively applies multi-pass shortcutting post-planning for path smoothness and length optimization, while enforcing quick collision checks and respecting map boundaries. The planner uses KD-tree-like spatial partitioning via a grid-based acceleration to speed up nearest and neighbor searches, reducing planning time without sacrificing path quality.",
          "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately, sampling mostly within an ellipsoid defined by the current best path cost once a solution is found, with a set goal bias to improve convergence. Each iteration extends the nearest node in the active tree toward the sample with a fixed step size, verifying node and edge collision. Neighbors are identified from a spatial hash grid to limit search costs, and rewiring is performed with an adaptive radius shrinking as the node count grows. When trees connect within step size, planning terminates early. The returned path is extracted by connecting the two partial paths and then multi-pass shortcutting is applied to smooth and shorten the path within the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 7.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = 30.0\n        self.min_neighbor_radius = 5.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Spatial hash grid parameters to accelerate nearest and neighbor queries\n        grid_cell_size = max(1.0, self.step_size * 2)\n        grid = {}\n        def grid_coords(p):\n            return tuple(int(p[i] // grid_cell_size) for i in range(dim))\n\n        def grid_insert(node):\n            c = grid_coords(node.position)\n            grid.setdefault(c, []).append(node)\n\n        def grid_nearby(p, radius):\n            min_c = [int((p[i] - radius) // grid_cell_size) for i in range(dim)]\n            max_c = [int((p[i] + radius) // grid_cell_size) for i in range(dim)]\n            nearby_nodes = []\n            def iter_coords(i, cur):\n                if i == dim:\n                    nearby_nodes.extend(grid.get(tuple(cur), []))\n                    return\n                for val in range(min_c[i], max_c[i] + 1):\n                    cur.append(val)\n                    iter_coords(i + 1, cur)\n                    cur.pop()\n            iter_coords(0, [])\n            return nearby_nodes\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        def build_rotation_matrix(a):\n            if dim == 2:\n                cos_theta = a[0]\n                sin_theta = a[1]\n                return [[cos_theta, -sin_theta],\n                        [sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1, 0, 0)\n                else:\n                    temp = (0, 1, 0)\n                dot = sum(x_axis[j] * temp[j] for j in range(3))\n                v = tuple(temp[i] - dot * x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                if norm_v < 1e-12:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                v_unit = tuple(v[i] / norm_v for i in range(3))\n                w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                     x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                     x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                R = [list(x_axis), list(v_unit), list(w)]\n                return [[R[0][0], R[1][0], R[2][0]],\n                        [R[0][1], R[1][1], R[2][1]],\n                        [R[0][2], R[1][2], R[2][2]]]\n            else:\n                return None\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            r1 = c_best / 2.0\n            r2 = math.sqrt(abs(c_best ** 2 - c_min ** 2)) / 2.0\n            if r2 < 1e-6:\n                r2 = 1e-6\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        def neighbor_radius(node_count):\n            gamma = self.max_neighbor_radius\n            val = gamma * (math.log(node_count + 1) / (node_count + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(val, self.max_neighbor_radius))\n\n        # Alternate growth trees: start_tree and goal_tree hold nodes and edges\n        start_tree_nodes: List[Node] = []\n        goal_tree_nodes: List[Node] = []\n        start_tree_edges: List[Tuple[Node, Node]] = []\n        goal_tree_edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree_nodes.append(start_root)\n        goal_tree_nodes.append(goal_root)\n        grid_start = {}\n        grid_goal = {}\n        grid = grid  # shared grid for all nodes for lookup optimization\n\n        def insert_node_grid(node):\n            c = grid_coords(node.position)\n            if c not in grid:\n                grid[c] = []\n            grid[c].append(node)\n\n        # Insert roots in grid\n        insert_node_grid(start_root)\n        insert_node_grid(goal_root)\n\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        def nearest_node_in_tree(tree_nodes, p):\n            # Use spatial grid nearby cells heuristic for nearest node\n            search_radius = self.step_size * 3\n            nearby = grid_nearby(p, search_radius)\n            # Filter only nodes in given tree_nodes set (fast membership check)\n            tree_set = set(tree_nodes)\n            candidates = [n for n in nearby if n in tree_set]\n            if not candidates:\n                # fallback to linear search on tree_nodes if grid empty\n                candidates = tree_nodes\n            best = candidates[0]\n            best_d = dist(p, best.position)\n            for node in candidates[1:]:\n                dcur = dist(p, node.position)\n                if dcur < best_d:\n                    best = node\n                    best_d = dcur\n            return best, best_d\n\n        def nearby_nodes_in_tree(tree_nodes, p, radius):\n            candidates = []\n            grid_near = grid_nearby(p, radius)\n            tree_set = set(tree_nodes)\n            for n in grid_near:\n                if n in tree_set:\n                    if dist(n.position, p) <= radius:\n                        candidates.append(n)\n            # fallback: if empty, linear search:\n            if not candidates:\n                for n in tree_nodes:\n                    if dist(n.position, p) <= radius:\n                        candidates.append(n)\n            return candidates\n\n        def backtrace_path(node):\n            path_rev = []\n            cur = node\n            while cur is not None:\n                path_rev.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_rev))\n\n        def connect_path(n1, n2):\n            path1 = backtrace_path(n1)\n            path2 = backtrace_path(n2)\n            path2.reverse()\n            return path1 + path2\n\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            changed = True\n            shortened = path_points\n            # Limit max passes to avoid long runtimes\n            max_passes = 3\n            passes = 0\n            while changed and passes < max_passes:\n                changed = False\n                new_path = [shortened[0]]\n                i = 0\n                while i < len(shortened) - 1:\n                    j = len(shortened) - 1\n                    while j > i + 1:\n                        if is_free_edge(shortened[i], shortened[j]):\n                            new_path.append(shortened[j])\n                            i = j\n                            changed = True\n                            break\n                        j -= 1\n                    else:\n                        i += 1\n                        if i < len(shortened):\n                            new_path.append(shortened[i])\n                shortened = new_path\n                passes += 1\n            return shortened\n\n        trees = [(start_tree_nodes, start_tree_edges), (goal_tree_nodes, goal_tree_edges)]\n        active_tree_flag = 0\n        no_improve_iters = 0\n        max_no_improve = 400\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            active_nodes, active_edges = trees[active_tree_flag]\n            other_nodes, other_edges = trees[1 - active_tree_flag]\n\n            # Determine best cost to sample informed\n            c_best = best_cost\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if active_tree_flag == 0 else start_pos\n            else:\n                sample = sample_informed(c_best, start_pos, goal_pos)\n\n            nearest, _ = nearest_node_in_tree(active_nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                active_tree_flag = 1 - active_tree_flag\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                active_tree_flag = 1 - active_tree_flag\n                continue\n\n            n_nodes = len(active_nodes)\n            radius = neighbor_radius(n_nodes)\n            neighbors = nearby_nodes_in_tree(active_nodes, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            # Find best parent\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            active_nodes.append(new_node)\n            active_edges.append((best_parent, new_node))\n            insert_node_grid(new_node)\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            active_edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    active_edges.append((new_node, nb))\n\n            # Try to connect new_node to other tree\n            other_radius = neighbor_radius(len(other_nodes))\n            other_neigh = nearby_nodes_in_tree(other_nodes, new_pos, self.step_size)\n            connected = False\n            for onode in other_neigh:\n                if dist(onode.position, new_pos) <= self.step_size:\n                    if is_free_edge(new_pos, onode.position):\n                        # Connect trees\n                        path = connect_path(new_node, onode)\n                        path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            best_path = path\n                            success = True\n                            # Early stop on connection\n                            connected = True\n                            break\n            if connected:\n                break\n\n            active_tree_flag = 1 - active_tree_flag\n\n            # Terminate if no improvement for many iterations after first solution\n            if success:\n                no_improve_iters += 1\n                if no_improve_iters > max_no_improve:\n                    break\n\n        # If no path found, fallback to closest nodes connection attempt\n        if not success:\n            # Find closest pair from start and goal trees\n            min_dist_pair = float('inf')\n            best_pair = None\n            for sn in start_tree_nodes:\n                nearby_gn = nearby_nodes_in_tree(goal_tree_nodes, sn.position, self.step_size*3)\n                for gn in nearby_gn:\n                    d = dist(sn.position, gn.position)\n                    if d < min_dist_pair:\n                        if is_free_edge(sn.position, gn.position):\n                            min_dist_pair = d\n                            best_pair = (sn, gn)\n            if best_pair is not None:\n                s_node, g_node = best_pair\n                best_path = connect_path(s_node, g_node)\n                success = True\n\n        if not best_path:\n            best_path = [start_pos, goal_pos]  # fallback path\n\n        # Post-process: multi pass shortcutting to smooth and shorten path\n        best_path = shortcut_path(best_path)\n\n        # Gather all nodes and edges for output\n        nodes = start_tree_nodes + goal_tree_nodes\n        edges = start_tree_edges + goal_tree_edges\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -34.04928,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1981.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01505281925201416,
                    "num_nodes_avg": 92.4,
                    "path_length_avg": 168.76126731054643,
                    "smoothness_avg": 0.050586732174764934,
                    "success_improvement": 0.0,
                    "time_improvement": 40.094484632726335,
                    "length_improvement": 7.499275193679472,
                    "smoothness_improvement": 691.7922093822124,
                    "objective_score": 19.98687155293665
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021511530876159667,
                    "num_nodes_avg": 209.6,
                    "path_length_avg": 238.0304855965653,
                    "smoothness_avg": 0.13742631612810546,
                    "success_improvement": 0.0,
                    "time_improvement": 86.61624923180484,
                    "length_improvement": 20.538572580220777,
                    "smoothness_improvement": 3436.07809815069,
                    "objective_score": 55.488408808427366
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.033600234985351564,
                    "num_nodes_avg": 297.9,
                    "path_length_avg": 129.62656331535575,
                    "smoothness_avg": 0.15052954752687026,
                    "success_improvement": 0.0,
                    "time_improvement": 30.84669247717046,
                    "length_improvement": 13.90820879957451,
                    "smoothness_improvement": 1814.7247336063635,
                    "objective_score": 26.67255669092766
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner employing fixed step steering, adaptive neighbor radius shrinking with node count, goal-biased sampling, and incremental greedy tree connections. It enforces a strict 30-second limit and performs a fast shortcutting post-process to enhance path smoothness and length. The planner balances efficient exploration and exploitation without complex rewiring propagation, favoring runtime efficiency and solution quality.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, extends nodes towards sampled points respecting collisions and bounds, rewires neighbors within an adaptively shrinking radius, greedily connects the trees when close, and upon success or timeout returns the best path found. A post-processing shortcutting step removes unnecessary waypoints for smoother paths before returning results.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.1\n        self.shortcut_max_trials = 100\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[d] + (to_p[d] - from_p[d]) * scale for d in range(dim))\n            # Clip to bounds\n            new_p = tuple(min(max(new_p[d], 0.0), bounds[d]) for d in range(dim))\n            return new_p\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if all samples invalid\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 6.0\n            gamma = 30.0\n            r = gamma * ((math.log(n) / n) ** (1 / dim))\n            max_r = self.step_size * 12.0\n            return min(r, max_r)\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest_node.position, x_rand)\n\n            if not in_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            radius = adaptive_radius(len(tree_a))\n            neighbors = neighbors_within_radius(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        best_parent = nb\n                        min_cost = cost_through_nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors (no cost propagation, simple rewiring)\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nb))\n\n            # Attempt greedy connection of tree_b to new_node\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            connect_pos = steer(nearest_other.position, new_node.position)\n\n            if (in_bounds(connect_pos) and\n                not self._is_in_obstacle(connect_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_other.position, connect_pos, obstacles, is_3d)):\n\n                dist_to_new = dist(connect_pos, new_node.position)\n                if dist_to_new <= self.step_size and not self._is_edge_in_obstacle(connect_pos, new_node.position, obstacles, is_3d):\n                    connecting_node = Node(connect_pos)\n                    connecting_node.update_parent(nearest_other, nearest_other.cost + dist(nearest_other.position, connect_pos))\n                    tree_b.append(connecting_node)\n                    nodes.append(connecting_node)\n                    edges.append((nearest_other, connecting_node))\n\n                    final_node_other = Node(new_node.position)\n                    final_node_other.update_parent(connecting_node, connecting_node.cost + dist(connecting_node.position, new_node.position))\n                    tree_b.append(final_node_other)\n                    nodes.append(final_node_other)\n                    edges.append((connecting_node, final_node_other))\n\n                    total_cost = final_node_other.cost + new_node.cost\n                    if total_cost + 1e-8 < best_cost:\n                        success = True\n                        best_cost = total_cost\n                        if expand_start_tree:\n                            best_start_node = new_node\n                            best_goal_node = final_node_other\n                        else:\n                            best_start_node = final_node_other\n                            best_goal_node = new_node\n\n            expand_start_tree = not expand_start_tree\n\n            if success:\n                break\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_start_node is not None and best_goal_node is not None:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # Merge paths without duplicate node\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n        else:\n            # Partial best effort path towards goal from start tree\n            best_partial = None\n            min_dist = float('inf')\n            for node in tree_start:\n                d = dist(node.position, goal_pos)\n                if d < min_dist and node.valid:\n                    best_partial = node\n                    min_dist = d\n            if best_partial:\n                extracted_path = best_partial.path_from_root()\n            else:\n                extracted_path = [start_pos]\n\n        return PlannerResult(success, extracted_path, nodes, edges)\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        trials = 0\n        max_trials = self.shortcut_max_trials\n        while i < len(path) - 1 and trials < max_trials:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n            trials += 1\n        if shortcut_path[-1] != path[-1]:\n            shortcut_path.append(path[-1])\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.9072,
          "time_improvement": 51.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1761.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019754958152770997,
                    "num_nodes_avg": 170.9,
                    "path_length_avg": 165.52490720564293,
                    "smoothness_avg": 0.05618635836465134,
                    "success_improvement": 0.0,
                    "time_improvement": 21.38144161650511,
                    "length_improvement": 9.273175450584716,
                    "smoothness_improvement": 779.4385190368301,
                    "objective_score": 15.875530350486514
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024690413475036622,
                    "num_nodes_avg": 284.4,
                    "path_length_avg": 233.11596590386776,
                    "smoothness_avg": 0.11820503476481978,
                    "success_improvement": 0.0,
                    "time_improvement": 84.63845543044071,
                    "length_improvement": 22.179180710249298,
                    "smoothness_improvement": 2941.5006841439836,
                    "objective_score": 53.40654847600171
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025164103507995604,
                    "num_nodes_avg": 285.3,
                    "path_length_avg": 125.06720615354212,
                    "smoothness_avg": 0.1307390087677804,
                    "success_improvement": 0.0,
                    "time_improvement": 48.2092613583391,
                    "length_improvement": 16.93631673319374,
                    "smoothness_improvement": 1562.9905413763593,
                    "objective_score": 32.43952115429977
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bi-directional RRT* planner employing adaptive neighbor radius based on tree size and dimension, goal-biased sampling, lazy collision checking caching for nodes and edges, incremental rewiring with cost propagation, and iterative path shortcutting to enhance path quality within a strict 30-second time limit. It expands two trees alternately from start and goal, attempts connections between trees whenever nodes are in proximity, and returns the best found path upon timeout or success.",
          "planning_mechanism": "The planner grows two trees bi-directionally with adaptive rewiring radius, caches collision checks to minimize redundant computations, incrementally updates costs downstream after rewiring, uses goal bias sampling to accelerate goal-directed growth, and applies iterative shortcutting on the final extracted path for improved smoothness and length. Early termination on time expiry or first successful connection ensures efficient search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent and self in self.parent.children:\n                self.parent.children.remove(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1, time_limit=30.0,\n                 gamma_rrt=50.0, radius_factor_min=2.0, radius_factor_max=30.0, shortcut_passes=3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.gamma_rrt = gamma_rrt\n        self.radius_factor_min = radius_factor_min\n        self.radius_factor_max = radius_factor_max\n        self.shortcut_passes = shortcut_passes\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_p, to_p):\n        dist = math.dist(from_p, to_p)\n        if dist <= self.step_size:\n            return to_p\n        ratio = self.step_size / dist\n        return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        result = []\n        r2 = radius * radius\n        for node in tree:\n            # Use squared dist to speed\n            d2 = sum((node.position[i] - point[i])**2 for i in range(len(point)))\n            if d2 <= r2:\n                result.append(node)\n        return result\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, no_obstacle_cache):\n        # Goal bias sampling\n        if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal, obstacles, is_3d):\n            return goal\n        for _ in range(100):\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback: uniform (could be in obstacle)\n        return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n    def _propagate_cost_update(self, node):\n        for child in node.children:\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        for _ in range(self.shortcut_passes):\n            i = 0\n            while i < len(new_path) - 2:\n                j = len(new_path) - 1\n                shortcut_found = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                        # Remove intermediate points between i and j\n                        del new_path[i + 1:j]\n                        shortcut_found = True\n                        break\n                    j -= 1\n                if not shortcut_found:\n                    i += 1\n        return new_path\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Cache collision checks to avoid redundancy: keys are (p1,p2) tuples sorted\n        edge_collision_cache = {}\n        node_collision_cache = {}\n        \n        def is_in_obstacle_cached(p):\n            if p in node_collision_cache:\n                return node_collision_cache[p]\n            val = self._is_in_obstacle(p, obstacles, is_3d)\n            node_collision_cache[p] = val\n            return val\n\n        def is_edge_in_obstacle_cached(p1, p2):\n            key = (p1, p2) if p1 <= p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n            edge_collision_cache[key] = val\n            return val\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n            current_tree = tree_start if expand_start_tree else tree_goal\n            other_tree = tree_goal if expand_start_tree else tree_start\n\n            sample = self._sample_free(bounds, obstacles, is_3d, goal_pos if expand_start_tree else start_pos, node_collision_cache)\n\n            nearest_node = self._nearest(current_tree, sample)\n            new_pos = self._steer(nearest_node.position, sample)\n\n            # Check node and edge collision with caching\n            if new_pos[0] < 0 or new_pos[0] > bounds[0] or (dim > 1 and (new_pos[1] < 0 or new_pos[1] > bounds[1])) or (dim > 2 and (new_pos[2] < 0 or new_pos[2] > bounds[2])):\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_in_obstacle_cached(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_edge_in_obstacle_cached(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(current_tree)\n            min_radius = self.step_size * self.radius_factor_min\n            radius = max(min_radius, min(self.gamma_rrt * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * self.radius_factor_max))\n\n            neighbors = self._near(current_tree, new_pos, radius)\n\n            # Choose best parent from neighbors based on cost + distance and collision\n            best_parent = nearest_node\n            best_cost_to_new = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            for nbr in neighbors:\n                if nbr == nearest_node:\n                    continue\n                cost_through_nbr = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_through_nbr < best_cost_to_new and not is_edge_in_obstacle_cached(nbr.position, new_pos):\n                    best_parent = nbr\n                    best_cost_to_new = cost_through_nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_to_new)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better cost found\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost and not is_edge_in_obstacle_cached(new_node.position, nbr.position):\n                    # Remove old edge if exists\n                    if nbr.parent and (nbr.parent, nbr) in edges:\n                        edges.remove((nbr.parent, nbr))\n                    if nbr.parent and nbr in nbr.parent.children:\n                        nbr.parent.children.remove(nbr)\n                    nbr.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nbr))\n                    # Propagate cost update downstream\n                    self._propagate_cost_update(nbr)\n\n            # Attempt to connect to other tree within radius\n            near_other = self._near(other_tree, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle_cached(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + math.dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path from best nodes\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n\n                # Remove duplicate connection point if any\n                if path_start[-1] == path_goal[0]:\n                    combined_path = path_start + path_goal[1:]\n                else:\n                    combined_path = path_start + path_goal[::-1]\n\n                # Shortcut path for smoothness and length\n                smooth_path = self._shortcut_path(combined_path, obstacles, is_3d)\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # On time limit or no success, return best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            if not node.valid:\n                continue\n            d = math.dist(node.position, goal_pos)\n            if d < best_dist:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = self._shortcut_path(partial_path, obstacles, is_3d)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        # Fallback with start pos only\n        return PlannerResult(False, [start_pos], nodes, edges)",
          "objective": -33.58444,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1611.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02286221981048584,
                    "num_nodes_avg": 105.8,
                    "path_length_avg": 160.57780099612447,
                    "smoothness_avg": 0.044869449389219364,
                    "success_improvement": 0.0,
                    "time_improvement": 9.015511496041473,
                    "length_improvement": 11.984762755936206,
                    "smoothness_improvement": 602.304318510142,
                    "objective_score": 12.907032694924876
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04134764671325684,
                    "num_nodes_avg": 276.6,
                    "path_length_avg": 234.0415688101397,
                    "smoothness_avg": 0.10905552004080439,
                    "success_improvement": 0.0,
                    "time_improvement": 74.27488533254933,
                    "length_improvement": 21.870187818133278,
                    "smoothness_improvement": 2706.077080165987,
                    "objective_score": 48.9349636914747
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015392065048217773,
                    "num_nodes_avg": 151.0,
                    "path_length_avg": 123.49657686817454,
                    "smoothness_avg": 0.12778783078513511,
                    "success_improvement": 0.0,
                    "time_improvement": 68.32128679591546,
                    "length_improvement": 17.97945391920537,
                    "smoothness_improvement": 1525.4517752704105,
                    "objective_score": 38.91131726664991
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive rewiring radius, improved goal biasing, and early termination on first feasible path. It uses an incremental rewiring strategy focused on local neighbor nodes, efficient collision checking, and a final iterative shortcut smoothing step. The planner alternates expansions between start and goal trees, dynamically adjusts rewiring radius based on the current number of nodes and dimensionality, and carefully combines partial paths to provide shorter, smoother trajectories within a strict 30-second limit.",
          "planning_mechanism": "A bidirectional RRT* planner grows two trees alternately from start and goal with goal-biased sampling. For each new sample, it selects the best parent within an adaptive radius minimizing total cost and collision-free edges, then rewires neighbors to improve path quality locally. After each node addition, it attempts to connect the two trees to find a feasible path. Upon finding the first path, the planner performs shortcutting smoothing and terminates. It respects map boundaries and obstacles with strict node and edge collision checks and returns the best-path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 6.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(goal_bias=self.goal_sample_rate):\n            if random.random() < goal_bias and not is_in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # Fallback sampling without obstacle checking\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i + 1])\n                    i += 1\n            return shortened\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(tree_a)\n            gamma_rrt = 40.0\n            min_radius = self.step_size * 2.0\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 25))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n\n                # Avoid duplicates of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                smooth_path = combined_path\n                # Perform iterative shortcutting for smoothing (3 passes or until no changes)\n                for _ in range(3):\n                    shortened_path = shortcut_path(smooth_path)\n                    if len(shortened_path) == len(smooth_path):\n                        break\n                    smooth_path = shortened_path\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # No full path found, attempt best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            if not node.valid:\n                continue\n            d = dist(node.position, goal_pos)\n            if d < best_dist:\n                best_dist = d\n                best_partial_node = node\n\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -33.51759,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1395.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016870689392089844,
                    "num_nodes_avg": 109.1,
                    "path_length_avg": 169.23046316696446,
                    "smoothness_avg": 0.04606696226265718,
                    "success_improvement": 0.0,
                    "time_improvement": 32.859929710568466,
                    "length_improvement": 7.242101509892628,
                    "smoothness_improvement": 621.0479954202699,
                    "objective_score": 17.308479796207465
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020358180999755858,
                    "num_nodes_avg": 252.1,
                    "path_length_avg": 234.6956628422056,
                    "smoothness_avg": 0.09618350961117793,
                    "success_improvement": 0.0,
                    "time_improvement": 87.33382472111715,
                    "length_improvement": 21.65183240317686,
                    "smoothness_improvement": 2374.8709804773357,
                    "objective_score": 51.06560176062794
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024741458892822265,
                    "num_nodes_avg": 258.9,
                    "path_length_avg": 121.67835462081044,
                    "smoothness_avg": 0.10130145493652461,
                    "success_improvement": 0.0,
                    "time_improvement": 49.07911459176714,
                    "length_improvement": 19.1870305614652,
                    "smoothness_improvement": 1188.5470294969864,
                    "objective_score": 32.17868786189419
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional informed RRT* planner with balanced alternation between start and goal tree expansions, adaptive rewiring radius based on node count and problem dimension, goal-biased and ellipsoidal informed sampling after first solution to focus search, efficient collision checking, incremental cost and topology updates during rewiring, and multi-pass path shortcutting to enhance smoothness and shorten the path. The planner uses early stopping on first valid connection or stagnation, respects strict node and edge collision avoidance, and enforces a 30-second hard time limit, improving planning time, path quality, success rate, and path smoothness.",
          "planning_mechanism": "The planner grows two RRT* trees alternately from the start and goal, samples new points with initial goal bias shifting to ellipsoidal informed sampling after a feasible path is found, connects new nodes to the best parent within an adaptive radius, rewires neighbors to minimize cost with cost propagation, attempts inter-tree connections each iteration, and, upon success or timeout, extracts and shortcut the path. It enforces valid node insertion and edge collision avoidance through efficient checks and terminates early to reduce compute time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # initial goal bias\n        self.time_limit_sec = 30.0\n        self.gamma_rrt_star = 20.0  # parameter controlling rewiring radius scaling\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def compute_rotation_matrix(start, goal):\n            v = [goal[i] - start[i] for i in range(dim)]\n            norm_v = math.sqrt(sum(x*x for x in v))\n            if norm_v == 0:\n                if dim == 2:\n                    return [[1,0],[0,1]]\n                else:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n            e1 = [x / norm_v for x in v]\n            if dim == 2:\n                e2 = [-e1[1], e1[0]]\n                R = [e1, e2]\n                return [[R[0][0], R[1][0]], [R[0][1], R[1][1]]]\n            else:\n                up = [0,0,1] if abs(e1[2]) < 0.9 else [0,1,0]\n                e2 = [up[i] - sum(up[j]*e1[j] for j in range(3))*e1[i] for i in range(3)]\n                norm_e2 = math.sqrt(sum(x*x for x in e2))\n                if norm_e2 < 1e-12:\n                    up = [0,1,0]\n                    e2 = [up[i] - sum(up[j]*e1[j] for j in range(3))*e1[i] for i in range(3)]\n                    norm_e2 = math.sqrt(sum(x*x for x in e2))\n                e2 = [x / norm_e2 for x in e2]\n                e3 = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                R = [e1, e2, e3]\n                return [[R[0][0], R[1][0], R[2][0]],\n                        [R[0][1], R[1][1], R[2][1]],\n                        [R[0][2], R[1][2], R[2][2]]]\n\n        def sample_informed(start, goal, c_best, c_min, center, rotation_matrix):\n            if math.isinf(c_best):\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                    return goal\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                while True:\n                    direction = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in direction))\n                    unit_vector = [x/norm_dir for x in direction]\n                    radius = random.random() ** (1/dim)\n                    sample_unit_ball = [radius * x for x in unit_vector]\n\n                    r1 = c_best / 2.0\n                    val = c_best*c_best - c_min*c_min\n                    r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n                    if dim == 2:\n                        L = [[r1,0],[0,r2]]\n                    else:\n                        L = [[r1,0,0],[0,r2,0],[0,0,r2]]\n                    if dim == 2:\n                        px = L[0][0]*sample_unit_ball[0] + L[0][1]*sample_unit_ball[1]\n                        py = L[1][0]*sample_unit_ball[0] + L[1][1]*sample_unit_ball[1]\n                        p_ellipse = (px, py)\n                    else:\n                        px = L[0][0]*sample_unit_ball[0] + L[0][1]*sample_unit_ball[1] + L[0][2]*sample_unit_ball[2]\n                        py = L[1][0]*sample_unit_ball[0] + L[1][1]*sample_unit_ball[1] + L[1][2]*sample_unit_ball[2]\n                        pz = L[2][0]*sample_unit_ball[0] + L[2][1]*sample_unit_ball[1] + L[2][2]*sample_unit_ball[2]\n                        p_ellipse = (px, py, pz)\n\n                    if dim == 2:\n                        x = rotation_matrix[0][0]*p_ellipse[0] + rotation_matrix[0][1]*p_ellipse[1] + center[0]\n                        y = rotation_matrix[1][0]*p_ellipse[0] + rotation_matrix[1][1]*p_ellipse[1] + center[1]\n                        point = (x, y)\n                    else:\n                        x = rotation_matrix[0][0]*p_ellipse[0] + rotation_matrix[0][1]*p_ellipse[1] + rotation_matrix[0][2]*p_ellipse[2] + center[0]\n                        y = rotation_matrix[1][0]*p_ellipse[0] + rotation_matrix[1][1]*p_ellipse[1] + rotation_matrix[1][2]*p_ellipse[2] + center[1]\n                        z = rotation_matrix[2][0]*p_ellipse[0] + rotation_matrix[2][1]*p_ellipse[1] + rotation_matrix[2][2]*p_ellipse[2] + center[2]\n                        point = (x, y, z)\n                    if within_bounds(point) and not is_in_obstacle(point):\n                        return point\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size*2.0, 5.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            max_r = max(bounds) * 0.3\n            min_r = max(self.step_size, 2.0)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes, point, radius):\n            return [n for n in nodes if dist(n.position, point) <= radius]\n\n        def can_connect(a, b):\n            if not a.valid or not b.valid:\n                return False\n            if is_edge_in_obstacle(a.position, b.position):\n                return False\n            return True\n\n        def propagate_cost(node):\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                for child in cur.children:\n                    old_cost = child.cost\n                    new_cost = cur.cost + dist(cur.position, child.position)\n                    if new_cost + 1e-12 < old_cost:\n                        child.cost = new_cost\n                        child.parent = cur\n                        stack.append(child)\n\n        def rewire(new_node, neighbors, nodes_all, edges_all):\n            for nb in neighbors:\n                if nb is new_node or not nb.valid or not new_node.valid:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_all.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_all.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def add_new_node(tree, pos, nodes_all, edges_all):\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, radius)\n            connectable = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not connectable:\n                try:\n                    nearest_node = nearest(tree, pos)\n                    if is_edge_in_obstacle(nearest_node.position, pos):\n                        return None, []\n                    connectable = [nearest_node]\n                except ValueError:\n                    return None, []\n            best_parent = min(connectable, key=lambda p: p.cost + dist(p.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            new_node.cost = new_cost\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def stitch_path(n_start, n_goal, start_tree_expand):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            path_g_rev = path_g[::-1]\n\n            if path_s[-1] == path_g_rev[0]:\n                combined = path_s + path_g_rev[1:]\n            elif path_s[-1] == path_g_rev[-1]:\n                combined = path_s + path_g_rev[-2::-1]\n            else:\n                combined = path_s + path_g_rev\n\n            if not start_tree_expand:\n                combined.reverse()\n            return combined\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                max_j = i+1\n                for j in range(len(path)-1, i, -1):\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        max_j = j\n                        break\n                shortcut.append(path[max_j])\n                i = max_j\n            return shortcut\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes_all = [tree_start[0], tree_goal[0]]\n        edges_all = []\n\n        best_cost = float('inf')\n        success = False\n        best_start_node = None\n        best_goal_node = None\n        start_tree_expand = True\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        rotation_matrix = compute_rotation_matrix(start_pos, goal_pos)\n        center = tuple((start_pos[i] + goal_pos[i])/2 for i in range(dim))\n\n        iter_since_improve = 0\n        max_no_improve_iters = 3000\n\n        for _ in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit_sec:\n                break\n\n            if success:\n                x_rand = sample_informed(start_pos, goal_pos, c_best, c_min, center, rotation_matrix)\n            else:\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    x_rand = goal_pos\n                else:\n                    for _ in range(100):\n                        p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(p):\n                            x_rand = p\n                            break\n                    else:\n                        x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            tree_a = tree_start if start_tree_expand else tree_goal\n            tree_b = tree_goal if start_tree_expand else tree_start\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand)\n            if (not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos)):\n                start_tree_expand = not start_tree_expand\n                continue\n\n            new_node, neighbors = add_new_node(tree_a, new_pos, nodes_all, edges_all)\n            if new_node is None:\n                start_tree_expand = not start_tree_expand\n                continue\n\n            rewire(new_node, neighbors, nodes_all, edges_all)\n\n            radius = neighbor_radius(len(tree_b))\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            connection_found = False\n            for other_node in near_other:\n                if can_connect(new_node, other_node):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_start_node = new_node if start_tree_expand else other_node\n                        best_goal_node = other_node if start_tree_expand else new_node\n                        c_best = best_cost\n                        iter_since_improve = 0\n                        center = tuple((best_start_node.position[i] + best_goal_node.position[i]) / 2 for i in range(dim))\n                        connection_found = True\n            if not connection_found:\n                iter_since_improve += 1\n\n            if iter_since_improve > max_no_improve_iters and success:\n                combined_path = stitch_path(best_start_node, best_goal_node, start_tree_expand)\n                for _ in range(3):\n                    combined_path = shortcut_path(combined_path)\n                return PlannerResult(True, combined_path, nodes_all, edges_all)\n\n            if success:\n                combined_path = stitch_path(best_start_node, best_goal_node, start_tree_expand)\n                for _ in range(3):\n                    combined_path = shortcut_path(combined_path)\n                return PlannerResult(True, combined_path, nodes_all, edges_all)\n\n            start_tree_expand = not start_tree_expand\n\n        if success:\n            combined_path = stitch_path(best_start_node, best_goal_node, start_tree_expand)\n            for _ in range(3):\n                combined_path = shortcut_path(combined_path)\n            return PlannerResult(True, combined_path, nodes_all, edges_all)\n\n        best_partial = None\n        best_dist = float('inf')\n        for node in tree_start:\n            if node.valid:\n                d = dist(node.position, goal_pos)\n                if d < best_dist:\n                    best_dist = d\n                    best_partial = node\n        if best_partial:\n            partial_path = best_partial.path_from_root()\n            for _ in range(3):\n                partial_path = shortcut_path(partial_path)\n            return PlannerResult(False, partial_path, nodes_all, edges_all)\n\n        return PlannerResult(False, [], nodes_all, edges_all)",
          "objective": -32.98846,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2100.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02356712818145752,
                    "num_nodes_avg": 118.5,
                    "path_length_avg": 164.6764773049841,
                    "smoothness_avg": 0.056177128561756454,
                    "success_improvement": 0.0,
                    "time_improvement": 6.210196521963555,
                    "length_improvement": 9.738213323367933,
                    "smoothness_improvement": 779.2940525786873,
                    "objective_score": 11.602457213503262
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02725484371185303,
                    "num_nodes_avg": 271.2,
                    "path_length_avg": 239.48618316102474,
                    "smoothness_avg": 0.14153388631066846,
                    "success_improvement": 0.0,
                    "time_improvement": 83.04295321585813,
                    "length_improvement": 20.05261883327303,
                    "smoothness_improvement": 3541.7688375112525,
                    "objective_score": 54.65330145227752
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0284498929977417,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 124.5085301873111,
                    "smoothness_avg": 0.1633846297984009,
                    "success_improvement": 0.0,
                    "time_improvement": 41.446713086317985,
                    "length_improvement": 17.30736270867367,
                    "smoothness_improvement": 1978.2404312367617,
                    "objective_score": 32.7096337072834
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius shrinking over iterations, enhanced goal biasing, and progressive rewiring including downstream cost propagation. The planner uses efficient collision checking, early termination upon path discovery, incremental tree connections, and an improved multi-pass shortcutting method to produce shorter, smoother, and computationally efficient paths within a hard 30-second time limit. It balances exploration and exploitation with sampling strategies and uses cost-aware rewiring to refine paths dynamically, yielding notable improvements in planning time, path length, and smoothness.",
          "planning_mechanism": "The planner alternates growing trees from start and goal positions using goal-biased sampling. It adaptively tunes the neighborhood radius based on the number of nodes to limit unnecessary rewiring overhead. For each new sample, it selects the best parent minimizing cost with collision-free edges, rewires neighbors and propagates cost updates downstream to children for optimal path cost improvements, and attempts connecting the two trees incrementally. Upon successful connection, the concatenated path is extracted and refined via repeated edge shortcutting passes. The algorithm respects map bounds and obstacles, performs collision checking at node and edge levels, and returns early when a valid path is found or when the 30-second timeout is reached, always returning the best path found so far.}\n\n```python\nimport math\nimport random\nimport time\nfrom typing import Tuple, List, NamedTuple\n\nclass Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        if parent:\n            parent.children.append(self)\n        self.valid = True  # flag that can be used for future extension\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            # no change\n            return\n        # Detach from old parent\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n        # Propagate cost updates downstream\n        self._propagate_cost()\n\n    def _propagate_cost(self):\n        # Update costs of descendants consistent with this node's new cost\n        stack = list(self.children)\n        while stack:\n            child = stack.pop()\n            old_cost = child.cost\n            new_cost = child.parent.cost + math.dist(child.parent.position, child.position)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                stack.extend(child.children)  # propagate further\n\nclass PlannerResult(NamedTuple):\n    success: bool\n    path: List[Tuple[float, ...]]\n    nodes: List[Node]\n    edges: List[Tuple[Node, Node]]\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.07,\n                 time_limit: float = 30.0, shortcut_passes: int = 3, min_radius_factor: float = 2.0, gamma_rrt_star: float = 80.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.shortcut_passes = shortcut_passes\n        self.min_radius_factor = min_radius_factor\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        if parent:\n            parent.children.append(self)\n        self.valid = True  # flag that can be used for future extension\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            # no change\n            return\n        # Detach from old parent\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        # Attach to new parent\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n        # Propagate cost updates downstream\n        self._propagate_cost()\n\n    def _propagate_cost(self):\n        # Update costs of descendants consistent with this node's new cost\n        stack = list(self.children)\n        while stack:\n            child = stack.pop()\n            old_cost = child.cost\n            new_cost = child.parent.cost + math.dist(child.parent.position, child.position)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                stack.extend(child.children)  # propagate further\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.07,\n                 time_limit: float = 30.0, shortcut_passes: int = 3, min_radius_factor: float = 2.0, gamma_rrt_star: float = 80.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.shortcut_passes = shortcut_passes\n        self.min_radius_factor = min_radius_factor\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            # Ensure inside bounds (slight numerical cutoff)\n            clamped = tuple(min(max(new_p[i], 0.0), bounds[i]) for i in range(dim))\n            return clamped\n\n        def sample() -> Tuple[float, ...]:\n            # Try goal bias sample first\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            # Sample uniformly within bounds, retry max 100 times to avoid obstacles\n            for _ in range(100):\n                s = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            # fallback to start if no sample found\n            return start_pos\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            res = []\n            r_sq = radius * radius\n            for n in tree:\n                dx = 0.0\n                # Use squared distance for speed\n                for i in range(dim):\n                    dx += (n.position[i] - pos[i]) ** 2\n                if dx <= r_sq:\n                    res.append(n)\n            return res\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_start_node = None\n        best_goal_node = None\n        best_cost = float('inf')\n\n        expand_start_tree = True  # alternate growth\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed >= self.time_limit:\n                break\n            if success:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            q_rand = sample()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n\n            if not in_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(tree_a)\n            min_radius = self.min_radius_factor * self.step_size\n            # Adaptive radius computation per RRT* (sqrt(log(n)/n)) scaled by gamma and dimension\n            radius = max(min_radius, min(self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 30.0))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            # Find parent with lowest cost reachable via collision-free edge\n            for nbr in neighbors:\n                cost_via_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_via_nbr < best_cost_to_new:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        best_cost_to_new = cost_via_nbr\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_to_new)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if path cost can be improved\n            for nbr in neighbors:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nbr))\n\n            # Check connection to other tree near new_node within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    success = True\n                    best_cost = total_cost\n                    if expand_start_tree:\n                        best_start_node = new_node\n                        best_goal_node = other_node\n                    else:\n                        best_start_node = other_node\n                        best_goal_node = new_node\n\n            expand_start_tree = not expand_start_tree\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_start_node and best_goal_node:\n            path_start = self._build_path(best_start_node)\n            path_goal = self._build_path(best_goal_node)\n            # Remove duplicate connection node\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            elif path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            full_path = path_start + path_goal[::-1]\n            extracted_path = self._multi_pass_shortcut(full_path, obstacles, is_3d, self.shortcut_passes)\n        else:\n            # If no success, fallback: best partial path from start tree node closest to goal\n            best_partial_node = None\n            min_dist_goal = float('inf')\n            for node in tree_start:\n                if not node.valid:\n                    continue\n                d = dist(node.position, goal_pos)\n                if d < min_dist_goal:\n                    min_dist_goal = d\n                    best_partial_node = node\n            if best_partial_node:\n                partial_path = self._build_path(best_partial_node)\n                extracted_path = self._multi_pass_shortcut(partial_path, obstacles, is_3d, self.shortcut_passes)\n            else:\n                # Fallback to trivial path (start only)\n                extracted_path = [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _build_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        cur = node\n        while cur:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _multi_pass_shortcut(self, path: List[Tuple[float, ...]], obstacles, is_3d: bool, passes: int) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        for _ in range(passes):\n            i = 0\n            while i < len(new_path) - 2:\n                j = len(new_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                        # Remove intermediate points between i and j\n                        del new_path[i+1:j]\n                        break\n                    j -= 1\n                i += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.7714,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1362.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019727039337158202,
                    "num_nodes_avg": 83.2,
                    "path_length_avg": 158.5077483489539,
                    "smoothness_avg": 0.04669328839185768,
                    "success_improvement": 0.0,
                    "time_improvement": 21.492549775696258,
                    "length_improvement": 13.119391413933693,
                    "smoothness_improvement": 630.8513594312163,
                    "objective_score": 17.473656578225174
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033018088340759276,
                    "num_nodes_avg": 242.0,
                    "path_length_avg": 231.69067887932752,
                    "smoothness_avg": 0.09097647323438704,
                    "success_improvement": 0.0,
                    "time_improvement": 79.45725630876794,
                    "length_improvement": 22.65498254365316,
                    "smoothness_improvement": 2240.8901840257995,
                    "objective_score": 48.63461733895127
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024232077598571777,
                    "num_nodes_avg": 163.2,
                    "path_length_avg": 122.7179761347029,
                    "smoothness_avg": 0.10329843480932743,
                    "success_improvement": 0.0,
                    "time_improvement": 50.12748229821437,
                    "length_improvement": 18.496563453394483,
                    "smoothness_improvement": 1213.948466077317,
                    "objective_score": 32.20592509188758
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An efficient bidirectional RRT* planner with adaptive neighbor radius and lazy collision checking, combined with goal-biased informed sampling and progressive rewiring. The planner grows start and goal trees alternately, attempts direct connection every iteration, and employs an incremental collision checking approach to minimize unnecessary computations. Early stopping on first valid connection and a multi-pass shortcutting post-processing step ensure high-quality, smooth, and short paths within a strict 30-second time limit.",
          "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points biased toward the goal and within an informed ellipsoid around the current best path cost. Neighborhood radius adapts dynamically shrinking as nodes increase. New nodes are connected via minimal-cost parents, rewiring neighbors for better paths if collision free. Trees attempt direct connection every iteration to find a path. Lazy collision checks reduce edge validation calls. When a path is found, iterative shortcutting is applied to smooth and shorten before returning. Timing is strictly enforced to return the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=6.0,\n                 goal_sample_rate: float=0.15, gamma_rrt_star: float=50.0,\n                 max_neighbor_radius: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free(best_cost: float):\n            # Goal biased informed sampling\n            if best_cost < float('inf'):\n                c_best = best_cost\n                c_min = dist(start_pos, goal_pos)\n                if c_best < c_min:\n                    c_best = c_min + 1e-3\n                # Sample inside an ellipsoid between start and goal\n                center = tuple((s + g) / 2.0 for s, g in zip(start_pos, goal_pos))\n                diff = tuple(g - s for s, g in zip(start_pos, goal_pos))\n                unit_vec = tuple(d / c_min for d in diff)\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        p = goal_pos\n                    else:\n                        # Sample inside unit n-ball scaled to current cost radius\n                        while True:\n                            x = [random.uniform(-1,1) for _ in range(dim)]\n                            norm_x = math.sqrt(sum(v*v for v in x))\n                            if norm_x <= 1:\n                                break\n                        scale = c_best / 2.0\n                        sample = tuple(center[i] + scale * x[i] for i in range(dim))\n                        p = sample\n                    if in_bounds(p) and is_free_node(p):\n                        return p\n            else:\n                # Uniform random sampling\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if is_free_node(p):\n                        return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree[0]\n            best_dist = dist(best_node.position, point)\n            for node in tree[1:]:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], n_nodes: int) -> List[Node]:\n            if n_nodes < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2.0, r))\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def lazy_collision_check_edge(parent_pos, new_pos):\n            # Lazy collision: Check only after rewiring to reduce calls\n            # Here we'll do a coarse resolution check\n            length = dist(parent_pos, new_pos)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(parent_pos[d] + (new_pos[d] - parent_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def choose_parent_and_add(tree: List[Node], new_pos: Tuple[float, ...], nodes_ref: List[Node], edges_ref: List[Tuple[Node,Node]]) -> Optional[Tuple[Node,List[Node]]]:\n            nearest_node_ = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos, len(tree))\n            min_cost = nearest_node_.cost + dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n            for nb in neighbors:\n                if nb is nearest_node_:\n                    continue\n                new_cost = nb.cost + dist(nb.position, new_pos)\n                if new_cost < min_cost and lazy_collision_check_edge(nb.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nb\n            if not lazy_collision_check_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes_ref.append(new_node)\n            tree.append(new_node)\n            edges_ref.append((best_parent, new_node))\n            return (new_node, neighbors)\n\n        def rewire(node: Node, neighbors: List[Node], edges_ref: List[Tuple[Node, Node]]):\n            n_updated = []\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                potential_cost = node.cost + dist(node.position, nb.position)\n                if potential_cost + 1e-15 < nb.cost:\n                    if lazy_collision_check_edge(node.position, nb.position):\n                        # Remove old parent edge\n                        if nb.parent is not None:\n                            try:\n                                edges_ref.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = node\n                        nb.cost = potential_cost\n                        node.children.append(nb)\n                        edges_ref.append((node, nb))\n                        n_updated.append(nb)\n            return n_updated\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float,...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path_points: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            # Iterative shortcutting, max 20 iterations\n            if len(path_points) < 3:\n                return path_points\n            for _ in range(20):\n                changed = False\n                i = 0\n                while i < len(path_points) - 2:\n                    j = len(path_points) -1\n                    while j > i+1:\n                        if self._is_edge_in_obstacle(path_points[i], path_points[j], obstacles, is_3d) == False:\n                            # Remove intermediate points between i and j\n                            del path_points[i+1:j]\n                            changed = True\n                            break\n                        j -= 1\n                    i += 1\n                if not changed:\n                    break\n            return path_points\n\n        # Initialize trees\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path_nodes: List[Tuple[float,...]] = []\n        success = False\n\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > time_limit:\n                break\n\n            # Goal biased informed sampling\n            sample = sample_free(best_cost)\n\n            # Alternate tree expansion (start and goal)\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node_a = nearest(tree_a, sample)\n            new_pos = steer(nearest_node_a.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            result = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if result is None:\n                continue\n            new_node, neighbors = result\n\n            # Rewire neighbors for better cost and smoothness\n            rewired_list = rewire(new_node, neighbors, edges)\n            # Rewire descendants of rewired nodes to propagate cost changes\n            stack = rewired_list[:]\n            while stack:\n                current = stack.pop()\n                nbs = near_nodes(tree_a, current.position, len(tree_a))\n                updated = rewire(current, nbs, edges)\n                stack.extend(updated)\n\n            # Attempt direct connection between the trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            d_connect = dist(new_node.position, nearest_in_b.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d) and \\\n                   not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d):\n                    # Connect nodes\n                    connection_cost = new_node.cost + d_connect + nearest_in_b.cost\n                    if connection_cost < best_cost:\n                        best_cost = connection_cost\n                        success = True\n                        best_path_nodes = extract_path(new_node, nearest_in_b)\n                        break\n\n        if not success:\n            # No full path found: fallback to closest node to goal in start tree\n            nearest_to_goal = min(tree_start, key=lambda n: dist(n.position, goal_pos))\n            best_path_nodes = nearest_to_goal.path_from_root()\n\n        # Post processing shortcutting for smoothness and path length reduction\n        best_path_nodes = shortcut_path(best_path_nodes)\n\n        return PlannerResult(success=success, path=best_path_nodes, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.74393,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1472.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021446037292480468,
                    "num_nodes_avg": 113.1,
                    "path_length_avg": 176.47272688924454,
                    "smoothness_avg": 0.04248383520373107,
                    "success_improvement": 0.0,
                    "time_improvement": 14.651475243090614,
                    "length_improvement": 3.2725020026983387,
                    "smoothness_improvement": 564.9642760631306,
                    "objective_score": 9.18376515486184
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03069620132446289,
                    "num_nodes_avg": 216.9,
                    "path_length_avg": 230.6354170258171,
                    "smoothness_avg": 0.09651290874646615,
                    "success_improvement": 0.0,
                    "time_improvement": 80.90185629176865,
                    "length_improvement": 23.00725932438326,
                    "smoothness_improvement": 2383.3466574849085,
                    "objective_score": 49.99164576958509
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01662287712097168,
                    "num_nodes_avg": 151.1,
                    "path_length_avg": 120.51235911651352,
                    "smoothness_avg": 0.1233196053310919,
                    "success_improvement": 0.0,
                    "time_improvement": 65.78812814964205,
                    "length_improvement": 19.961429256679807,
                    "smoothness_improvement": 1468.6162773050767,
                    "objective_score": 39.05637738542588
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* planner using adaptive informed sampling with dynamic neighbor radius, spatial hashing for efficient neighbor queries, goal biasing to speed convergence, and incremental rewiring with strict collision checks. Early termination happens upon tree connection. The planner applies multi-pass shortcutting smoothing on the final path to improve smoothness and length without exceeding a 30-second time limit. It carefully manages node insertion and rewiring to maintain tree consistency and avoids redundant collision checks by caching partial computations where applicable.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points either uniformly or within an adaptive informed ellipsoidal region once a solution is found, biased towards the goal for faster convergence. It uses a spatial hash grid indexed by node positions for efficient nearest and neighbor queries. Nodes are connected and rewired within a dynamic radius that shrinks logarithmically with node count, optimizing path cost. Each expansion considers rewiring neighbors to improve path quality while enforcing collision-free constraints. Upon connecting the two trees within step size, it extracts the concatenated path and applies multi-pass shortcut smoothing to reduce unnecessary waypoints and sharp turns, all within a strict 30-second deadline, returning the best path found so far if time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 6.0, goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = 28.0\n        self.min_neighbor_radius = 6.0\n        self._cached_cols = {}\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        grid_cell_size = max(1.0, self.step_size * 2)\n        grid = {}\n\n        def grid_coords(p):\n            return tuple(int(p[i] // grid_cell_size) for i in range(dim))\n\n        def grid_insert(node):\n            c = grid_coords(node.position)\n            grid.setdefault(c, []).append(node)\n\n        def grid_nearby(p, radius):\n            min_c = [int((p[i] - radius) // grid_cell_size) for i in range(dim)]\n            max_c = [int((p[i] + radius) // grid_cell_size) for i in range(dim)]\n            nearby_nodes = []\n            def recur(i, cur):\n                if i == dim:\n                    nearby_nodes.extend(grid.get(tuple(cur), []))\n                    return\n                for val in range(min_c[i], max_c[i]+1):\n                    cur.append(val)\n                    recur(i+1, cur)\n                    cur.pop()\n            recur(0, [])\n            return nearby_nodes\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def _node_key(p):\n            # Rounded position key to cache collision results\n            return tuple(round(x, 5) for x in p)\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            key = _node_key(p)\n            if key in self._cached_cols:\n                return self._cached_cols[key]\n            free = True\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        free = False\n                        break\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        free = False\n                        break\n            self._cached_cols[key] = free\n            return free\n\n        def is_free_edge(p1, p2):\n            # Check edge collision by sampling points along the segment\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if not is_free_node(interp):\n                    return False\n            return True\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        def build_rotation_matrix(x_axis):\n            if dim == 2:\n                cos_theta = x_axis[0]\n                sin_theta = x_axis[1]\n                return [[cos_theta, -sin_theta],\n                        [sin_theta, cos_theta]]\n            elif dim == 3:\n                u = x_axis\n                if abs(u[0]) < 0.9:\n                    v_temp = (1, 0, 0)\n                else:\n                    v_temp = (0, 1, 0)\n                dot = sum(u[i]*v_temp[i] for i in range(3))\n                v = tuple(v_temp[i] - dot*u[i] for i in range(3))\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(x / norm_v for x in v)\n                w = (u[1]*v_unit[2] - u[2]*v_unit[1],\n                     u[2]*v_unit[0] - u[0]*v_unit[2],\n                     u[0]*v_unit[1] - u[1]*v_unit[0])\n                R = [list(u), list(v_unit), list(w)]\n                return [[R[0][0], R[1][0], R[2][0]],\n                        [R[0][1], R[1][1], R[2][1]],\n                        [R[0][2], R[1][2], R[2][2]]]\n            else:\n                return None\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                # Uniform global sampling\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) / 2 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            r1 = c_best / 2\n            r2 = max(math.sqrt(abs(c_best**2 - c_min**2)) / 2, 1e-6)\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                val = 0.0\n                for j in range(dim):\n                    val += R[i][j] * sample_ball[j]\n                sample[i] = val + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        def neighbor_radius(n):\n            gamma = self.max_neighbor_radius\n            r = gamma * (math.log(n+1)/(n+1))**(1.0/dim)\n            return min(max(r, self.min_neighbor_radius), self.max_neighbor_radius)\n\n        start_tree_nodes: List[Node] = []\n        goal_tree_nodes: List[Node] = []\n        start_tree_edges: List[Tuple[Node, Node]] = []\n        goal_tree_edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree_nodes.append(start_root)\n        goal_tree_nodes.append(goal_root)\n        grid_insert(start_root)\n        grid_insert(goal_root)\n\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        found_solution = False\n\n        def nearest_node(tree_nodes, p):\n            search_radius = self.step_size * 3\n            nearby = grid_nearby(p, search_radius)\n            tree_set = set(tree_nodes)\n            candidates = [n for n in nearby if n in tree_set]\n            if not candidates:\n                candidates = tree_nodes\n            best = candidates[0]\n            best_dist = dist(p, best.position)\n            for n in candidates[1:]:\n                d = dist(p, n.position)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best, best_dist\n\n        def neighbors(tree_nodes, p, radius):\n            tree_set = set(tree_nodes)\n            nearby = grid_nearby(p, radius)\n            result = [n for n in nearby if n in tree_set and dist(p, n.position) <= radius]\n            if not result:\n                result = [n for n in tree_nodes if dist(p, n.position) <= radius]\n            return result\n\n        def backtrace(node):\n            path_rev = []\n            cur = node\n            while cur is not None:\n                path_rev.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_rev))\n\n        def connect_path(node1, node2):\n            path1 = backtrace(node1)\n            path2 = backtrace(node2)\n            path2.reverse()\n            return path1 + path2\n\n        def shortcut_path(path_pts):\n            if len(path_pts) < 3:\n                return path_pts\n            passes = 0\n            max_passes = 4\n            shortened = path_pts\n            changed = True\n            while changed and passes < max_passes:\n                changed = False\n                new_path = [shortened[0]]\n                i = 0\n                while i < len(shortened)-1:\n                    j = len(shortened)-1\n                    while j > i+1:\n                        if is_free_edge(shortened[i], shortened[j]):\n                            new_path.append(shortened[j])\n                            i = j\n                            changed = True\n                            break\n                        j -= 1\n                    else:\n                        i += 1\n                        if i < len(shortened):\n                            new_path.append(shortened[i])\n                shortened = new_path\n                passes += 1\n            return shortened\n\n        trees = [(start_tree_nodes, start_tree_edges), (goal_tree_nodes, goal_tree_edges)]\n        active_flag = 0\n        no_improve = 0\n        max_no_improve = 300\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > time_limit:\n                break\n\n            active_nodes, active_edges = trees[active_flag]\n            other_nodes, other_edges = trees[1-active_flag]\n\n            c_best = best_cost\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if active_flag == 0 else start_pos\n            else:\n                sample = sample_informed(c_best, start_pos, goal_pos)\n\n            nearest_node_, _ = nearest_node(active_nodes, sample)\n            new_pos = steer(nearest_node_.position, sample, self.step_size)\n\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node_.position, new_pos):\n                active_flag = 1 - active_flag\n                continue\n\n            radius = neighbor_radius(len(active_nodes))\n            nbrs = neighbors(active_nodes, new_pos, radius)\n\n            min_cost = nearest_node_.cost + dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n\n            for nb in nbrs:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            active_nodes.append(new_node)\n            active_edges.append((best_parent, new_node))\n            grid_insert(new_node)\n\n            # Rewire neighbors\n            for nb in nbrs:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            active_edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    active_edges.append((new_node, nb))\n\n            # Try connect new_node to other tree\n            other_radius = neighbor_radius(len(other_nodes))\n            candidate_others = neighbors(other_nodes, new_pos, self.step_size)\n            connected = False\n            for onode in candidate_others:\n                if dist(onode.position, new_pos) <= self.step_size:\n                    if is_free_edge(new_pos, onode.position):\n                        path = connect_path(new_node, onode)\n                        path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            best_path = path\n                            found_solution = True\n                            connected = True\n                            break\n            if connected:\n                break\n\n            active_flag = 1 - active_flag\n\n            if found_solution:\n                no_improve += 1\n                if no_improve > max_no_improve:\n                    break\n\n        # If no path found, try best possible connection fallback\n        if not found_solution:\n            min_pair_dist = float('inf')\n            best_pair = None\n            for snode in start_tree_nodes:\n                candidate_g = neighbors(goal_tree_nodes, snode.position, self.step_size*3)\n                for gnode in candidate_g:\n                    d = dist(snode.position, gnode.position)\n                    if d < min_pair_dist:\n                        if is_free_edge(snode.position, gnode.position):\n                            min_pair_dist = d\n                            best_pair = (snode, gnode)\n            if best_pair is not None:\n                s_node, g_node = best_pair\n                best_path = connect_path(s_node, g_node)\n                found_solution = True\n\n        if not best_path:\n            best_path = [start_pos, goal_pos]\n\n        best_path = shortcut_path(best_path)\n\n        all_nodes = start_tree_nodes + goal_tree_nodes\n        all_edges = start_tree_edges + goal_tree_edges\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )",
          "objective": -32.71539,
          "time_improvement": 51.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1912.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023108863830566408,
                    "num_nodes_avg": 105.1,
                    "path_length_avg": 172.66449789574622,
                    "smoothness_avg": 0.048354144438166144,
                    "success_improvement": 0.0,
                    "time_improvement": 8.033945392854157,
                    "length_improvement": 5.359852659284839,
                    "smoothness_improvement": 656.8473631625741,
                    "objective_score": 8.91033202924002
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02757279872894287,
                    "num_nodes_avg": 211.4,
                    "path_length_avg": 240.99150634693083,
                    "smoothness_avg": 0.1348629974451556,
                    "success_improvement": 0.0,
                    "time_improvement": 82.84513230163655,
                    "length_improvement": 19.550098625492073,
                    "smoothness_improvement": 3370.12206215457,
                    "objective_score": 53.43420917655906
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018747282028198243,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 128.42156536120842,
                    "smoothness_avg": 0.14232407772193445,
                    "success_improvement": 0.0,
                    "time_improvement": 61.415848434440825,
                    "length_improvement": 14.708511064882677,
                    "smoothness_improvement": 1710.351763352359,
                    "objective_score": 35.80161998602365
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An adaptive unidirectional informed RRT* planner integrating efficient KD-tree neighbor queries, adaptive rewiring radius, goal-directed and informed ellipsoidal sampling, early stopping, and iterative path shortcutting to achieve faster planning times, shorter and smoother paths, and robust collision-free navigation. This planner balances exploration and exploitation by adjusting neighbor radius with tree size, focusing sampling within an ellipsoid upon solution discovery, and continually optimizing parent-child connections with pruning and rewiring under strict 30-second time constraint.",
          "planning_mechanism": "A single rapidly-exploring tree expands from start with goal bias and informed ellipsoidal sampling once a solution is found. Nodes steer towards samples with fixed step size, and neighbors within an adaptively computed radius (scaling with tree size) are examined for minimum cost parent selection and rewiring. Efficient KD-tree supports nearest and radius neighbor queries. The search halts early when a goal connection is found. Resulting path undergoes iterative shortcutting to reduce unnecessary segments, producing smooth, short trajectories efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        if child_node not in self.children:\n            self.children.append(child_node)\n            child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float,...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1   # 10% goal bias\n        self.time_limit_sec = 30.0    # Hard 30s limit\n        self.neighbor_radius_factor = 30.0\n        self.max_shortcut_iters = 30\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            distance = dist(fpos, tpos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                new_p = to\n            else:\n                r = self.step_size / d\n                new_p = tuple(fr[i] + (to[i] - fr[i])*r for i in range(dim))\n            # Clamp defensively\n            new_p = tuple(max(0.0, min(new_p[i], bounds[i])) for i in range(dim))\n            return new_p\n\n        def uniform_sample():\n            tries = 0\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not _is_in_obstacle(sample):\n                    return sample\n                tries += 1\n                if tries > 1000:\n                    return start_pos  # fallback\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i]-start_pos[i])/c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = [r1, r2]\n            else: # 3D\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(a1[0])<0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = [a1,b2,b3]\n                r1 = c_best/2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [r1,r_other,r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm > 1e-12:\n                        v = [x/nrm for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                mapped[i] += sum(basis[j][i]*radii[j]*u[j] for j in range(dim))\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if _is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        # KD-tree for efficient nearest and radius queries\n        class KDNode:\n            __slots__ = ('point','node','axis','left','right')\n            def __init__(self, point=None, node=None, axis=0):\n                self.point = point\n                self.node = node\n                self.axis = axis\n                self.left = None\n                self.right = None\n\n        class KDTree:\n            def __init__(self, dim):\n                self.dim = dim\n                self.root = None\n                self.nodes = []\n\n            def _build(self, points, depth=0):\n                if not points:\n                    return None\n                axis = depth % self.dim\n                points.sort(key=lambda x: x[0][axis])\n                median = len(points)//2\n                kdn = KDNode(points[median][0], points[median][1], axis)\n                kdn.left = self._build(points[:median], depth+1)\n                kdn.right = self._build(points[median+1:], depth+1)\n                return kdn\n\n            def build(self, node_list):\n                self.nodes = node_list[:]\n                pts = [(n.position, n) for n in node_list]\n                self.root = self._build(pts)\n\n            def _insert(self, root, point, node, depth=0):\n                if root is None:\n                    return KDNode(point, node, depth % self.dim)\n                axis = root.axis\n                if point[axis] < root.point[axis]:\n                    root.left = self._insert(root.left, point, node, depth+1)\n                else:\n                    root.right = self._insert(root.right, point, node, depth+1)\n                return root\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.root = self._insert(self.root, node.position, node)\n\n            def _nearest(self, root, point, best=None, best_dist=float('inf')):\n                if root is None:\n                    return best, best_dist\n                d = dist(point, root.point)\n                if d < best_dist:\n                    best = root.node\n                    best_dist = d\n                axis = root.axis\n                diff = point[axis] - root.point[axis]\n                close, away = (root.left, root.right) if diff < 0 else (root.right, root.left)\n                best, best_dist = self._nearest(close, point, best, best_dist)\n                if abs(diff) < best_dist:\n                    best, best_dist = self._nearest(away, point, best, best_dist)\n                return best, best_dist\n\n            def nearest(self, point):\n                n, _ = self._nearest(self.root, point)\n                return n\n\n            def _neighbors_radius(self, root, point, r, results):\n                if root is None:\n                    return\n                if dist(root.point, point) <= r:\n                    results.append(root.node)\n                axis = root.axis\n                diff = point[axis] - root.point[axis]\n                if diff <= r:\n                    self._neighbors_radius(root.left, point, r, results)\n                if diff >= -r:\n                    self._neighbors_radius(root.right, point, r, results)\n\n            def neighbors_radius(self, point, r):\n                results = []\n                self._neighbors_radius(self.root, point, r, results)\n                return results\n\n        # Tree initialization\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        kdtree = KDTree(dim)\n        kdtree.insert(root)\n\n        best_cost = float('inf')\n        best_goal_node = None\n        c_min = dist(start_pos, goal_pos)\n        first_solution_found = False\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size*2.0, 2.0)\n            val = self.neighbor_radius_factor * ((math.log(n_nodes)/n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size, 2.0)\n            return max(min_r, min(max_r, val))\n\n        def propagate_cost_children(node: Node):\n            stack = node.children[:]\n            while stack:\n                c = stack.pop()\n                old_cost = c.cost\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-12 < old_cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.max_shortcut_iters):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path)-1:\n                    j = len(path) - 1\n                    while j > i+1:\n                        if not _is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i+1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit_sec:\n                break\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = kdtree.nearest(sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos)) or _is_in_obstacle(new_pos) or _is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = kdtree.neighbors_radius(new_pos, r)\n\n            # Choose best parent among neighbors\n            best_parent = nearest_node\n            best_cost_to_new = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb + 1e-12 < best_cost_to_new and not _is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_to_new = c_through_nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_to_new)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kdtree.insert(new_node)\n\n            # Rewire neighbors if better\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new + 1e-12 < nb.cost and not _is_edge_in_obstacle(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except Exception:\n                        pass\n                    nb.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nb))\n                    propagate_cost_children(nb)\n\n            # Check goal proximity and connect if possible\n            dist_goal = dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not _is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_cost:\n                    best_cost = goal_cost\n                    best_goal_node = goal_node\n                    first_solution_found = True\n                # Early stop when goal connected\n                break\n\n        success_state = False\n        extracted_path: List[Tuple[float,...]] = []\n\n        if first_solution_found and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(extracted_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -32.13033,
          "time_improvement": 43.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1802.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025384402275085448,
                    "num_nodes_avg": 240.9,
                    "path_length_avg": 163.3674267127745,
                    "smoothness_avg": 0.05135528891751323,
                    "success_improvement": 0.0,
                    "time_improvement": -1.0219863216462521,
                    "length_improvement": 10.455724696192076,
                    "smoothness_improvement": 703.8217913539027,
                    "objective_score": 9.485947877990885
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04456143379211426,
                    "num_nodes_avg": 810.3,
                    "path_length_avg": 235.03034507347274,
                    "smoothness_avg": 0.12448244042850828,
                    "success_improvement": 0.0,
                    "time_improvement": 72.27537513808228,
                    "length_improvement": 21.540105841085992,
                    "smoothness_improvement": 3103.022853303231,
                    "objective_score": 50.12179031259244
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02040107250213623,
                    "num_nodes_avg": 489.8,
                    "path_length_avg": 122.00349114013724,
                    "smoothness_avg": 0.13360056480602395,
                    "success_improvement": 0.0,
                    "time_improvement": 58.01214958315546,
                    "length_improvement": 18.971090366665635,
                    "smoothness_improvement": 1599.3893229647215,
                    "objective_score": 36.78324570976963
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner employing uniform random sampling with goal bias, fixed step steering, and adaptive neighbor radius rewiring. The planner alternates expansions between start and goal trees, performs collision checks for nodes and edges, rewires local neighbors to minimize path cost, attempts to connect trees incrementally, and applies iterative path shortcutting to enhance smoothness. It respects map boundaries and obstacles, halts early on success or after a 30-second limit, and returns the best path found.",
          "planning_mechanism": "The planner grows two trees from start and goal by sampling collision-free points biased toward the goal, extends each tree toward the sample with fixed step size, chooses the best parent within a radius minimizing cost, rewires neighbors to reduce costs, tries to connect the trees at each new node, and upon success concatenates and shortcuts the path. The process uses efficient validity checks, alternates tree expansions, and terminates early on timeout or first valid path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def steer(frm, to, max_dist):\n            d = dist(frm, to)\n            if d <= max_dist:\n                return to\n            ratio = max_dist / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(tree, pt, radius):\n            return [n for n in tree if dist(n.position, pt) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_cost = float('inf')\n        best_start = None\n        best_goal = None\n        success = False\n\n        expand_start = True\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start else tree_goal\n            tree_b = tree_goal if expand_start else tree_start\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start = not expand_start\n                continue\n\n            n = len(tree_a)\n            gamma = 40.0\n            min_r = self.step_size * 2.0\n            radius = max(min_r, min(gamma * (math.log(n + 1)/ (n + 1))**(1/dim), self.step_size * 25))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = cost_cand\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect trees\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other in near_other:\n                if is_edge_in_obstacle(new_node.position, other.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start = new_node if expand_start else other\n                    best_goal = other if expand_start else new_node\n\n            if success:\n                path_start = best_start.path_from_root()\n                path_goal = best_goal.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined = path_start + path_goal[::-1]\n                smooth = combined\n                for _ in range(3):\n                    shortcut = shortcut_path(smooth)\n                    if len(shortcut) == len(smooth):\n                        break\n                    smooth = shortcut\n                return PlannerResult(True, smooth, nodes, edges)\n\n            expand_start = not expand_start\n\n        # Partial best path fallback from start tree to goal vicinity\n        min_d = float('inf')\n        best_node = None\n        for n in tree_start:\n            if not n.valid:\n                continue\n            d = dist(n.position, goal_pos)\n            if d < min_d:\n                min_d = d\n                best_node = n\n\n        if best_node:\n            path = best_node.path_from_root()\n            path.append(goal_pos) if dist(path[-1], goal_pos) > 1e-6 else None\n            path = shortcut_path(path)\n            return PlannerResult(False, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -32.08129,
          "time_improvement": 53.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1639.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022298359870910646,
                    "num_nodes_avg": 158.3,
                    "path_length_avg": 181.7084769654688,
                    "smoothness_avg": 0.04667564126699462,
                    "success_improvement": 0.0,
                    "time_improvement": 11.259497802506429,
                    "length_improvement": 0.40270442015063873,
                    "smoothness_improvement": 630.5751436057645,
                    "objective_score": 6.772347710871134
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022975826263427736,
                    "num_nodes_avg": 276.2,
                    "path_length_avg": 234.6754713199423,
                    "smoothness_avg": 0.11471797519117374,
                    "success_improvement": 0.0,
                    "time_improvement": 85.70521390721375,
                    "length_improvement": 21.658572914489095,
                    "smoothness_improvement": 2851.776129686581,
                    "objective_score": 52.96558856929049
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0187744140625,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 123.16041445423828,
                    "smoothness_avg": 0.12069719992337702,
                    "success_improvement": 0.0,
                    "time_improvement": 61.36000745854863,
                    "length_improvement": 18.20271698820786,
                    "smoothness_improvement": 1435.2594740847755,
                    "objective_score": 36.50592980091318
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius decreasing with tree size, efficient KD-tree-like nearest neighbor search replacement for faster queries, goal bias sampling, and post-processing shortcutting to reduce path length and improve smoothness. The planner grows two trees alternately from start and goal, rewires neighbors within an adaptively shrinking radius, tries connections between the two trees, and stops early upon the first valid connection or time limit. A shortcutting step reduces unnecessary waypoints from the final path.",
          "planning_mechanism": "The planner samples points biased toward the goal, extends the active tree toward samples with a fixed step size, rewires nearby nodes to minimize path cost with adaptive radius decreasing as the tree grows, and checks for possible connections to the other tree. Upon connecting the two trees, it extracts the path and applies shortcutting to smooth it. The search alternates between the two trees and halts early on path discovery or timeout, providing incremental improvements over naive rewiring and fixed radius approaches.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1  # 10% sampling bias to goal\n        self.min_rewire_radius = 5.0  # minimal neighbor radius\n        self.max_rewire_radius = 20.0 # maximal neighbor radius for small trees\n        self.shortcut_max_trials = 100  # max shortcut attempts in postprocessing\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Efficient nearest neighbor approximate by linear scan (acceptable for thousands of nodes)\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Near nodes within radius\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def sample_free():\n            # 10% goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def compute_rewire_radius(n_nodes):\n            # Adaptive radius scaling: shrink as tree grows, clipped by min/max values\n            gamma_rrt_star = 2.5  # tuning factor\n            r = gamma_rrt_star * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)\n            r *= max(bounds)  # scale with map size\n            return max(self.min_rewire_radius, min(r, self.max_rewire_radius))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection point\n            if path_start[-1] == path_goal[-1]:\n                # same node (rare if connected)\n                return path_start\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            # Post-processing: try removing unnecessary intermediate nodes\n            if len(path) < 3:\n                return path\n            new_path = path[:1]\n            i = 0\n            trials = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        new_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, add next node\n                    i += 1\n                    if i < len(path):\n                        new_path.append(path[i])\n                trials += 1\n                if trials > self.shortcut_max_trials:\n                    break\n            # If last node missing add it\n            if new_path[-1] != path[-1]:\n                new_path.append(path[-1])\n            return new_path\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_connect = None\n        best_goal_connect = None\n\n        expand_start_tree = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if not in_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius depending on current tree size\n            radius = compute_rewire_radius(len(tree_a))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            # Choose best parent from neighbors (including nearest_node)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improve cost\n            for nb in neighbors:\n                if nb is best_parent or nb is new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    # Remove old edge\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    # Re-parent nb\n                    nb.parent = new_node\n                    nb.cost = alt_cost\n                    new_node.add_child(nb)\n                    edges.append((new_node, nb))\n\n            # Attempt connection to other tree within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_connect = new_node if expand_start_tree else other_node\n                    best_goal_connect = other_node if expand_start_tree else new_node\n\n            if success:\n                raw_path = extract_path(best_start_connect, best_goal_connect)\n                smooth_path = shortcut_path(raw_path)\n                return PlannerResult(\n                    success=True,\n                    path=smooth_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            expand_start_tree = not expand_start_tree\n\n        # On timeout or no full path found, return best partial path from start tree closest to goal\n        def best_partial_node():\n            best_node = None\n            best_distance = float('inf')\n            for node in tree_start:\n                d = dist(node.position, goal_pos)\n                if d < best_distance and node.valid:\n                    best_distance = d\n                    best_node = node\n            return best_node\n\n        partial_node = best_partial_node()\n        if partial_node:\n            partial_path = partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -32.05464,
          "time_improvement": 51.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1412.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02121443748474121,
                    "num_nodes_avg": 118.4,
                    "path_length_avg": 171.52550743084677,
                    "smoothness_avg": 0.04838404034760012,
                    "success_improvement": 0.0,
                    "time_improvement": 15.573170083724882,
                    "length_improvement": 5.984151381555117,
                    "smoothness_improvement": 657.3152990652222,
                    "objective_score": 11.549018349376645
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029667353630065917,
                    "num_nodes_avg": 280.0,
                    "path_length_avg": 234.3081020815085,
                    "smoothness_avg": 0.09131889043355804,
                    "success_improvement": 0.0,
                    "time_improvement": 81.54197071223984,
                    "length_improvement": 21.78121134041552,
                    "smoothness_improvement": 2249.7008251936086,
                    "objective_score": 48.779822143889305
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021467995643615723,
                    "num_nodes_avg": 211.2,
                    "path_length_avg": 119.32217052335159,
                    "smoothness_avg": 0.11224979390718637,
                    "success_improvement": 0.0,
                    "time_improvement": 55.81629398458239,
                    "length_improvement": 20.751895849567465,
                    "smoothness_improvement": 1327.809093081483,
                    "objective_score": 35.83507117052261
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
          "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -31.88223,
          "time_improvement": 70.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 318.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive radius rewiring, goal biasing, and ellipsoidal informed sampling, including a simple path shortcutting step for efficient, smooth, and short path discovery within a fixed time limit.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points biased towards the goal or inside an informed ellipsoid defined by the best cost so far. Nodes are connected by steering toward samples with collision checks, rewiring neighbors within a shrinking radius for path cost improvement. Early stopping occurs upon connecting both trees. The final path is extracted and refined via a simple shortcutting procedure to smooth and shorten it before returning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1,\n                 time_limit=30.0, radius_constant=30.0, shortcut_passes=3, shortcut_attempts=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.radius_constant = radius_constant\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n\n    def _in_bounds(self, p, bounds):\n        return all(0 <= p[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(p1,p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_p, to_p, max_step):\n        dist = math.dist(from_p, to_p)\n        if dist <= max_step:\n            return to_p\n        ratio = max_step / dist\n        return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(len(from_p)))\n\n    def _informed_sample(self, c_best, x_start, x_goal, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        if math.isinf(c_best):\n            # Uniform sampling with collisions avoided\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n        # Ellipsoid sampling\n        c_min = math.dist(x_start, x_goal)\n        if c_min == 0:\n            return x_start\n        center = tuple((x_start[i]+x_goal[i])*0.5 for i in range(dim))\n        unit_vec = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n        # Build orthonormal basis (only 2D or 3D)\n        if dim == 2:\n            x,y = unit_vec\n            R = [[x, -y],\n                 [y,  x]]\n        elif dim == 3:\n            x_axis = unit_vec\n            norm_x = math.sqrt(sum(x_axis[i]*x_axis[i] for i in range(3)))\n            if norm_x < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_axis = tuple(x_axis[i] / norm_x for i in range(3))\n            if abs(x_axis[0]) < 0.9:\n                temp = (1,0,0)\n            else:\n                temp = (0,1,0)\n            dot = sum(x_axis[i]*temp[i] for i in range(3))\n            v = tuple(temp[i] - dot*x_axis[i] for i in range(3))\n            norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n            if norm_v < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            v_unit = tuple(v[i]/norm_v for i in range(3))\n            w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                 x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                 x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n            R = [[x_axis[0], v_unit[0], w[0]],\n                 [x_axis[1], v_unit[1], w[1]],\n                 [x_axis[2], v_unit[2], w[2]]]\n        else:\n            # fallback to uniform sample if dim unsupported\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        r1 = c_best * 0.5\n        rad_sq = c_best*c_best - c_min*c_min\n        if rad_sq > 1e-12:\n            r_rest = math.sqrt(rad_sq)*0.5\n        else:\n            r_rest = max(self.step_size*0.1, 0.001)\n        radii = [r1] + [r_rest]*(dim-1)\n\n        while True:\n            vec = [random.gauss(0,1) for _ in range(dim)]\n            norm_vec = math.sqrt(sum(x*x for x in vec))\n            if norm_vec > 1e-10:\n                break\n        unit_ball = [x/norm_vec for x in vec]\n        scale = random.random() ** (1.0/dim)\n        sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n        sample = [0]*dim\n        for i in range(dim):\n            s=0\n            for j in range(dim):\n                s+= R[i][j]*sample_ball[j]\n            sample[i]=s + center[i]\n\n        clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n        if not self._is_in_obstacle(clipped, obstacles, is_3d):\n            return clipped\n        # fallback uniform sampling\n        for _ in range(15):\n            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return clipped\n\n    def _extract_path(self, node_from_start, node_from_goal):\n        path_start=[]\n        cur = node_from_start\n        while cur:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_start.reverse()\n\n        path_goal=[]\n        cur = node_from_goal\n        while cur:\n            path_goal.append(cur.position)\n            cur = cur.parent\n\n        if path_start and path_goal and path_start[-1] == path_goal[0]:\n            path_goal=path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path)<3:\n            return path[:]\n        new_path = path[:]\n        for _ in range(self.shortcut_passes):\n            improved = False\n            for __ in range(self.shortcut_attempts):\n                if len(new_path)<3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                p1, p2 = new_path[i], new_path[j]\n                if not self._is_edge_in_obstacle(p1,p2, obstacles, is_3d):\n                    new_path[i+1:j] = []\n                    improved = True\n            if not improved:\n                break\n        return new_path\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        # Alternate expansion\n        forward = True\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n            if success:\n                break\n\n            current_tree = tree_start if forward else tree_goal\n            other_tree = tree_goal if forward else tree_start\n\n            # Adaptive neighbor radius (shrinks with total nodes)\n            total_nodes = len(nodes)\n            radius = min(self.radius_constant * (math.log(total_nodes+1)/(total_nodes+1))**(1/dim), self.radius_constant)\n            radius = max(radius, self.step_size)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if forward else start_pos\n            else:\n                sample = self._informed_sample(best_cost, start_pos, goal_pos, bounds, obstacles, is_3d)\n\n            # Nearest neighbor in current tree (linear search)\n            min_d = float('inf')\n            nearest = None\n            for node in current_tree:\n                d = dist(node.position, sample)\n                if d < min_d:\n                    min_d = d\n                    nearest = node\n            if nearest is None:\n                forward = not forward\n                continue\n\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if (not self._in_bounds(new_pos, bounds)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                forward = not forward\n                continue\n\n            # Find neighbors around new_pos\n            neighbors = []\n            for node in current_tree:\n                if dist(node.position, new_pos) <= radius:\n                    neighbors.append(node)\n\n            # Choose best parent among neighbors\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                c_new = nbr.cost + dist(nbr.position, new_pos)\n                if c_new + 1e-12 < min_cost and not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = c_new\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                c_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_thru_new + 1e-12 < nbr.cost and not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, c_thru_new)\n                    edges.append((new_node, nbr))\n\n            # Try to connect to other tree\n            for other_node in other_tree:\n                d = dist(new_node.position, other_node.position)\n                if d <= radius and (new_node.cost + d + other_node.cost) < best_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        best_cost = new_node.cost + d + other_node.cost\n                        best_start_node = new_node if forward else other_node\n                        best_goal_node = other_node if forward else new_node\n                        success = True\n                        break\n\n            forward = not forward\n\n        if success and best_start_node and best_goal_node:\n            path = self._extract_path(best_start_node, best_goal_node)\n        else:\n            # fallback: closest to goal from start tree\n            closest = None\n            min_d = float('inf')\n            for n in tree_start:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    closest = n\n            path = []\n            cur = closest\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            if not path:\n                path = [start_pos]\n\n        path = self._shortcut_path(path, obstacles, is_3d)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -31.80647,
          "time_improvement": 49.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1648.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02377176284790039,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 161.9206406622373,
                    "smoothness_avg": 0.045732915161035406,
                    "success_improvement": 0.0,
                    "time_improvement": 5.395814514843521,
                    "length_improvement": 11.248731056283567,
                    "smoothness_improvement": 615.8194328849977,
                    "objective_score": 11.447080152648185
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028673291206359863,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.85139213111574,
                    "smoothness_avg": 0.11932444318627258,
                    "success_improvement": 0.0,
                    "time_improvement": 82.16044290761737,
                    "length_improvement": 17.927728866674936,
                    "smoothness_improvement": 2970.30386910526,
                    "objective_score": 50.25628953781647
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019787144660949708,
                    "num_nodes_avg": 239.0,
                    "path_length_avg": 127.63087198699722,
                    "smoothness_avg": 0.11467274274392303,
                    "success_improvement": 0.0,
                    "time_improvement": 59.275686603563415,
                    "length_improvement": 15.23365195526133,
                    "smoothness_improvement": 1358.628823441294,
                    "objective_score": 33.71604127143229
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An enhanced bidirectional RRT* planner integrating informed sampling after an initial solution, dynamic rewiring with downstream cost propagation, and adaptive step size control for improved planning efficiency, path optimality, robustness, and smoothness. The planner alternately grows start and goal trees, dynamically adapts sampling and step lengths based on current best solution cost, performs rewiring with consistent cost updates, attempts direct connections between trees for fast convergence, applies aggressive but safe path shortcutting, and enforces a strict 30-second time limit returning the best path found so far.",
          "planning_mechanism": "The planner starts with uniform and goal-bias sampling, switching to ellipsoidal informed sampling once a feasible path is found, focusing search within an informed subset. It alternates incremental expansions of two trees with dynamic step sizes that shrink toward narrower corridors, and uses rewiring with downstream cost updates to ensure globally improved path costs and smoothness. Direct attempts to connect trees when nodes are close further accelerate convergence. The final path is aggressively shortcut and returned as soon as time runs out or the maximum iterations finish.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position                # Tuple[float, ...]\n        self.parent = None                      # Node or None\n        self.cost = 0.0                        # cost from root\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            self.update_parent(parent, cost)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        current = self\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=6.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.07            # initial goal bias sampling fraction\n        self.gamma_rrt_star = 30.0               # rewiring parameter\n        self.max_neighbor_radius = 25.0          # max radius for neighbor search\n        self.improve_tol = 1e-10                  # tolerance for cost improvement\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            distance = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(distance / res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best * 0.5\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0.)) * 0.5\n\n            attempts = 0\n            while attempts < 100:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xi*xi for xi in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    # Rotation of coords from x-axis to e1:\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot + 1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        # Rodrigues' rotation formula\n                        k = (v[1]*e1[2]-v[2]*e1[1], v[2]*e1[0]-v[0]*e1[2], v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x / k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2] - k[2]*v_vec[1],\n                                 k[2]*v_vec[0] - k[0]*v_vec[2],\n                                 k[0]*v_vec[1] - k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i] + rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, point):\n            best = tree_nodes[0]\n            best_d = dist(best.position, point)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near_nodes(tree_nodes, point):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.5, rad))\n            return [node for node in tree_nodes if dist(node.position, point) <= radius]\n\n        def propagate_costs_downstream(node):\n            # BFS cost update downstream\n            from collections import deque\n            q = deque([node])\n            while q:\n                curr = q.popleft()\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + self.improve_tol < c.cost:\n                        c.update_parent(curr, new_cost)\n                        q.append(c)\n\n        def rewire(new_node, neighbors, edges_list):\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(new_node, candidate_cost)\n                        edges_list.append((new_node, nbr))\n                        propagate_costs_downstream(nbr)\n\n        def choose_parent_and_add(tree_nodes, pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, pos)\n            nearest_n = nearest_node(tree_nodes, pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, pos)\n            best_parent = nearest_n\n            for nbr in near_n:\n                if nbr is nearest_n:\n                    continue\n                est_cost = nbr.cost + dist(nbr.position, pos)\n                if est_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, pos):\n                        min_cost = est_cost\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, pos):\n                new_node = Node(pos)\n                new_node.update_parent(best_parent, min_cost)\n                # Update lists\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, edges_list)\n                return new_node\n            return None\n\n        def merge_trees(node_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_a.position)\n            d = dist(node_a.position, nearest_b.position)\n            if d > self.step_size * 1.2:\n                return None\n            if is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return None\n            total_cost = node_a.cost + d + nearest_b.cost\n            path_a = node_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization\n        nodes = []\n        edges = []\n        start_tree = []\n        goal_tree = []\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        start_tree.append(root_start)\n        goal_tree.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        # Adaptive step size: shrink as solution improves\n        def adaptive_step_size(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf'):\n                return self.step_size\n            val = max(1.0, self.step_size * 0.3 + 0.7 * (c_best - c_min) / c_best * self.step_size)\n            return min(val, self.step_size)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            current_step = adaptive_step_size(best_cost)\n            # Sampling with goal bias, switching to informed if solution found\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                sample = (goal_pos if random.random() < self.goal_sample_rate else uniform_sample())\n            if is_in_obstacle(sample):\n                continue\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, current_step)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            # Try direct connection to opposite tree if possible to speed convergence\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                candidate_path, candidate_cost = merged\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    # Early stopping after improvement\n                    # But continue to find better path until timeout or max_iter\n                    # Comment next line to continue searching\n                    break\n\n        if not found_solution:\n            # Heuristic fallback: connect goal directly if reachable\n            nearest_goal_node = nearest_node(start_tree, goal_pos)\n            if nearest_goal_node is not None and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n                found_solution = True\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -31.40894,
          "time_improvement": 48.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1314.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02380661964416504,
                    "num_nodes_avg": 126.1,
                    "path_length_avg": 163.28084530977867,
                    "smoothness_avg": 0.04673685931254487,
                    "success_improvement": 0.0,
                    "time_improvement": 5.257095361352963,
                    "length_improvement": 10.503181335144212,
                    "smoothness_improvement": 631.5333389557396,
                    "objective_score": 11.036704104271113
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02614161968231201,
                    "num_nodes_avg": 248.3,
                    "path_length_avg": 229.72755370620888,
                    "smoothness_avg": 0.08200469681378635,
                    "success_improvement": 0.0,
                    "time_improvement": 83.7355637532632,
                    "length_improvement": 23.310330231865244,
                    "smoothness_improvement": 2010.0399146143882,
                    "objective_score": 49.157066838170046
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02178685665130615,
                    "num_nodes_avg": 207.6,
                    "path_length_avg": 123.01843227319166,
                    "smoothness_avg": 0.11017104553299309,
                    "success_improvement": 0.0,
                    "time_improvement": 55.16003984435187,
                    "length_improvement": 18.297014792394094,
                    "smoothness_improvement": 1301.3675671989888,
                    "objective_score": 34.03305866473696
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "return a hybrid bidirectional RRT* with adaptive informed sampling, dynamic spatial hashing neighbor radius rewiring, downstream cost propagation, goal biasing, early stopping on first connection, and multi-pass path shortcut smoothing for enhanced efficiency, path quality, and smoothness",
          "planning_mechanism": "The planner grows forward and backward trees alternately using goal-biased and informed samples inside an ellipsoid around the best cost, steering towards samples with a capped step size, adding collision-free nodes choosing best parent minimizing cost within a dynamic radius efficiently queried with spatial hashing, rewiring neighbors with downstream cost propagation for optimal cost updates, attempts direct tree connections each iteration with early stopping, and applies multi-pass shortcutting to refine the final concatenated path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start (or goal)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=4.0, goal_sample_rate=0.07, time_limit=30.0,\n                 max_neighbor_radius=25.0, min_neighbor_radius=2.5, shortcut_passes=4, shortcut_attempts=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_free_node(p):\n            return in_bounds(p) and not is_in_obstacle(p)\n\n        def is_edge_in_obstacle(p1,p2, resolution= min(1.0, self.step_size*0.35)):\n            distance = dist(p1,p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p,to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step/d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        # Rotation matrices for informed sampling\n        def build_rotation_matrix(a):\n            if dim == 2:\n                cos_theta, sin_theta = a[0], a[1]\n                return [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                # Choose a vector not colinear with x_axis\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                dot = sum(x_axis[i]*temp[i] for i in range(3))\n                v = tuple(temp[i] - dot*x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(v[i]/norm_v for i in range(3))\n                w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                return [[x_axis[0], v_unit[0], w[0]],\n                        [x_axis[1], v_unit[1], w[1]],\n                        [x_axis[2], v_unit[2], w[2]]]\n            else:\n                return None\n\n        def informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            c_min = dist(x_start, x_goal)\n            if c_min <= 0.0:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i])/2.0 for i in range(dim))\n            unit = tuple((x_goal[i] - x_start[i])/ c_min for i in range(dim))\n            R = build_rotation_matrix(unit)\n            if R is None:\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            r1 = c_best/2.0\n            rad_sq = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(rad_sq)/2.0 if rad_sq > 1e-12 else max(self.min_neighbor_radius*0.1, 0.001)\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            scale = random.random() ** (1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            if is_free_node(clipped):\n                return clipped\n            # fallback uniform + collision free\n            for _ in range(20):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            return clipped\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n) / n) ** (1.0/dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial Hash Grid for neighbor queries\n        class SpatialHashGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.cells = {}\n                self.dim = len(domain)\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d]//self.cell_size) for d in range(self.dim))\n\n            def add(self, node):\n                cc = self._cell_coords(node.position)\n                self.cells.setdefault(cc, []).append(node)\n\n            def remove(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells:\n                    try:\n                        self.cells[cc].remove(node)\n                        if not self.cells[cc]:\n                            del self.cells[cc]\n                    except ValueError:\n                        pass\n\n            def neighbors(self, p, radius):\n                center_cc = self._cell_coords(p)\n                r_cells = int(math.ceil(radius/self.cell_size))\n                nbrs = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            cc = (center_cc[0]+dx, center_cc[1]+dy)\n                            if cc in self.cells:\n                                nbrs.extend(self.cells[cc])\n                elif self.dim == 3:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            for dz in range(-r_cells, r_cells+1):\n                                cc = (center_cc[0]+dx, center_cc[1]+dy, center_cc[2]+dz)\n                                if cc in self.cells:\n                                    nbrs.extend(self.cells[cc])\n                else:\n                    # Fallback linear search if dim unsupported\n                    return []\n                # Filter Euclidean distance\n                r_sq = radius*radius\n                filtered = []\n                for node in nbrs:\n                    sum_sq=0.0\n                    for i_d in range(self.dim):\n                        diff = node.position[i_d] - p[i_d]\n                        sum_sq += diff*diff\n                        if sum_sq > r_sq:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n\n        # Trees initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grid_cell_size = self.max_neighbor_radius\n        grid_start = SpatialHashGrid(bounds, grid_cell_size)\n        grid_goal = SpatialHashGrid(bounds, grid_cell_size)\n        grid_start.add(tree_start[0])\n        grid_goal.add(tree_goal[0])\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        # To propagate downstream cost updates after rewiring\n        def propagate_cost(n):\n            stack = n.children[:]\n            while stack:\n                c = stack.pop()\n                new_cost = c.parent.cost + dist(c.parent.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        # Extract full path by concatenating forward and backward trees\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate pivot node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        # Multi-pass shortcutting to smooth path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(self.shortcut_passes):\n                improved = False\n                for __ in range(self.shortcut_attempts):\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path)-3)\n                    j = random.randint(i+2, len(new_path)-1)\n                    p1, p2 = new_path[i], new_path[j]\n                    if not is_edge_in_obstacle(p1,p2):\n                        # shortcut\n                        del new_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        # Alternate tree expansion sets\n        trees = [(tree_start, grid_start, tree_goal, grid_goal),\n                 (tree_goal, grid_goal, tree_start, grid_start)]\n        expand_forward = True\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            current_tree, current_grid, other_tree, other_grid = trees[0 if expand_forward else 1]\n\n            # Informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_forward else start_pos\n            else:\n                sample = informed_sample(best_cost, start_pos, goal_pos)\n\n            nearest = None\n            min_d = float('inf')\n            # Use spatial grid neighbors with large radius to approximate nearest quickly\n            approx_radius = self.step_size*4.0\n            approx_neighbors = current_grid.neighbors(sample, approx_radius)\n            for node in approx_neighbors:\n                d_ = dist(node.position, sample)\n                if d_ < min_d:\n                    nearest = node\n                    min_d = d_\n            if nearest is None:\n                # fallback linear search\n                for node in current_tree:\n                    d_ = dist(node.position, sample)\n                    if d_ < min_d:\n                        nearest = node\n                        min_d = d_\n            if nearest is None:\n                # isolated, skip iteration\n                expand_forward = not expand_forward\n                continue\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                expand_forward = not expand_forward\n                continue\n\n            radius = neighbor_radius(len(current_tree))\n            nbrs = current_grid.neighbors(new_pos, radius)\n\n            # Find best parent among neighbors minimizing cost if edge collision free\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in nbrs:\n                c_cand = nb.cost + dist(nb.position, new_pos)\n                if c_cand + 1e-12 < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = c_cand\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            current_grid.add(new_node)\n\n            # Rewire neighbors through new_node if cheaper with downstream propagation\n            for nb in nbrs:\n                if nb is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge\n                        if nb.parent is not None:\n                            p_old = nb.parent\n                            nb.parent.remove_child(nb)\n                            try:\n                                edges.remove((p_old, nb))\n                            except ValueError:\n                                pass\n                        # Update parent and cost\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n                        propagate_cost(nb)\n\n            # Attempt connections to opposite tree nodes within radius via spatial grid neighbor query\n            candidates_other = other_grid.neighbors(new_pos, radius)\n            radius_sq = radius*radius\n            for onode in candidates_other:\n                # Skip if path cost already no better\n                path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                if path_cost + 1e-12 >= best_cost:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, onode.position):\n                    # Connected, update best solution\n                    best_cost = path_cost\n                    if expand_forward:\n                        best_start_node = new_node\n                        best_goal_node = onode\n                    else:\n                        best_start_node = onode\n                        best_goal_node = new_node\n                    success = True\n                    # Early stop on first feasible path found\n                    expand_forward = None\n                    break\n            if expand_forward is None:\n                break\n            expand_forward = not expand_forward\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            extracted_path = extract_path(best_start_node, best_goal_node)\n        else:\n            # fallback: closest node in start tree to goal\n            min_dist = float('inf')\n            closest = None\n            for n in tree_start:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_dist:\n                    min_dist = d_\n                    closest = n\n            if closest is not None:\n                # extract path from start to closest\n                extracted_path = []\n                cur = closest\n                while cur is not None:\n                    extracted_path.append(cur.position)\n                    cur = cur.parent\n                extracted_path.reverse()\n            else:\n                extracted_path = [start_pos]\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -30.37323,
          "time_improvement": 45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1451.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025295782089233398,
                    "num_nodes_avg": 118.0,
                    "path_length_avg": 163.64877987889284,
                    "smoothness_avg": 0.04555539867781646,
                    "success_improvement": 0.0,
                    "time_improvement": -0.6693056831206631,
                    "length_improvement": 10.30151056751639,
                    "smoothness_improvement": 613.040914439408,
                    "objective_score": 9.045319207770675
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03927867412567139,
                    "num_nodes_avg": 339.3,
                    "path_length_avg": 234.67176147723148,
                    "smoothness_avg": 0.08988377060089861,
                    "success_improvement": 0.0,
                    "time_improvement": 75.562130467165,
                    "length_improvement": 21.659811366767865,
                    "smoothness_improvement": 2212.774158224248,
                    "objective_score": 46.72839675133146
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01972932815551758,
                    "num_nodes_avg": 217.3,
                    "path_length_avg": 125.75597997811558,
                    "smoothness_avg": 0.1279922908485313,
                    "success_improvement": 0.0,
                    "time_improvement": 59.39467989577659,
                    "length_improvement": 16.478865954797055,
                    "smoothness_improvement": 1528.0524921851381,
                    "objective_score": 35.3459860025369
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with informed sampling, fixed step size, adaptive neighbor radius, goal biasing, and incremental rewiring. It alternates expansions between start and goal trees, attempts fast connections, updates costs downstream after rewiring, and applies post-planning shortcutting for path smoothing and length reduction. Early stopping occurs upon first successful connection or time limit reached, returning the best path found so far.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points mostly within an informed ellipsoidal subset after initial solutions and biasing towards the goal. Each iteration grows one tree towards a sampled point with a fixed step, rewires neighbors within an adaptive radius to minimize cost, and tries to connect the two trees. Upon connection, it stops early. After planning, post-processing shortcutting removes unnecessary waypoints and smooths the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15\n        self.max_neighbor_radius = 15.0\n        self.min_neighbor_radius = 2.0\n        self.shortcut_passes = 3\n        self.shortcut_attempts = 150\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_free_node(p):\n            return in_bounds(p) and (not is_in_obstacle(p))\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def build_rotation_matrix(a):\n            if dim == 2:\n                x, y = a\n                norm = math.sqrt(x*x + y*y)\n                if norm < 1e-12:\n                    return [[1.0, 0.0],[0.0, 1.0]]\n                x /= norm\n                y /= norm\n                return [[x, -y],[y, x]]\n            elif dim == 3:\n                x_axis = a\n                norm_x = math.sqrt(sum(x_axis[i]*x_axis[i] for i in range(3)))\n                if norm_x < 1e-12:\n                    return [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                x_axis = tuple(x_axis[i]/norm_x for i in range(3))\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                dot = sum(x_axis[i]*temp[i] for i in range(3))\n                v = tuple(temp[i] - dot*x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                if norm_v < 1e-12:\n                    return [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                v_unit = tuple(v[i]/norm_v for i in range(3))\n                w = (\n                    x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                    x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                    x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0]\n                )\n                return [\n                    [x_axis[0], v_unit[0], w[0]],\n                    [x_axis[1], v_unit[1], w[1]],\n                    [x_axis[2], v_unit[2], w[2]],\n                ]\n            else:\n                return None\n\n        def informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                for _ in range(40):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = dist(x_start, x_goal)\n            if c_min < 1e-12:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            unit = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            R = build_rotation_matrix(unit)\n            if R is None:\n                for _ in range(40):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            rad_sq = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(max(rad_sq, 0)) / 2.0 if rad_sq > 1e-12 else max(self.min_neighbor_radius*0.2, 0.001)\n            radii = [r1] + [r_rest]*(dim-1)\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            scale = random.random() ** (1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            clipped = tuple(min(max(sample[i], 0.0), bounds[i]) for i in range(dim))\n            if is_free_node(clipped):\n                return clipped\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            return clipped\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n)/n)**(1.0/dim)\n            r = self.max_neighbor_radius * val\n            r_clamped = max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n            return r_clamped\n\n        def linear_nearest(nodes_list, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best_node = n\n            return best_node\n\n        def linear_neighbors(nodes_list, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in nodes_list:\n                s = 0.0\n                for i_d in range(dim):\n                    diff = n.position[i_d] - point[i_d]\n                    s += diff*diff\n                    if s > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def propagate_cost(n):\n            stack = n.children[:]\n            while stack:\n                c = stack.pop()\n                new_cost = c.parent.cost + dist(c.parent.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(self.shortcut_passes):\n                improved = False\n                for __ in range(self.shortcut_attempts):\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path)-3)\n                    j = random.randint(i+2, len(new_path)-1)\n                    p1, p2 = new_path[i], new_path[j]\n                    dist_sum = 0.0\n                    for k in range(i, j):\n                        dist_sum += dist(new_path[k], new_path[k+1])\n                    if dist(p1,p2) >= dist_sum - 1e-7:\n                        continue\n                    if not is_edge_in_obstacle(p1, p2):\n                        del new_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_start_tree = True\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n            if success:\n                break\n\n            current_tree = tree_start if expand_start_tree else tree_goal\n            other_tree = tree_goal if expand_start_tree else tree_start\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_start_tree else start_pos\n            else:\n                sample = informed_sample(best_cost, start_pos, goal_pos)\n\n            if not in_bounds(sample):\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_in_obstacle(sample):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            nearest = linear_nearest(current_tree, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            radius = neighbor_radius(len(current_tree)+1)\n            neighbors = linear_neighbors(current_tree, new_pos, radius)\n\n            best_parent = nearest\n            best_cost_new = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                cost_through = nb.cost + dist(nb.position, new_pos)\n                if cost_through + 1e-12 < best_cost_new and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_new = cost_through\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_new)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n                    propagate_cost(nb)\n\n            # Check connection with other tree\n            other_neighbors = linear_neighbors(other_tree, new_pos, radius)\n            for onode in other_neighbors:\n                if onode.parent is None:\n                    continue\n                path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                if path_cost + 1e-12 >= best_cost:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, onode.position):\n                    best_cost = path_cost\n                    if expand_start_tree:\n                        best_start_node = new_node\n                        best_goal_node = onode\n                    else:\n                        best_start_node = onode\n                        best_goal_node = new_node\n                    success = True\n                    break\n\n            expand_start_tree = not expand_start_tree\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            path = extract_path(best_start_node, best_goal_node)\n            path = shortcut_path(path)\n        else:\n            # fallback: path from closest to goal in start tree\n            best_node = None\n            min_dist_goal = float('inf')\n            for n in tree_start:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_dist_goal:\n                    min_dist_goal = d_\n                    best_node = n\n            path = []\n            cur = best_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -30.11247,
          "time_improvement": 47.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1511.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023033666610717773,
                    "num_nodes_avg": 107.4,
                    "path_length_avg": 167.23843930604272,
                    "smoothness_avg": 0.0494128331217425,
                    "success_improvement": 0.0,
                    "time_improvement": 8.333206822477441,
                    "length_improvement": 8.333961353701884,
                    "smoothness_improvement": 673.4181400398169,
                    "objective_score": 10.867429559163448
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03115828037261963,
                    "num_nodes_avg": 279.8,
                    "path_length_avg": 242.57356148321014,
                    "smoothness_avg": 0.094801458108386,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61436625438647,
                    "length_improvement": 19.021963084069807,
                    "smoothness_improvement": 2339.3097998590383,
                    "objective_score": 47.29403672605301
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023482394218444825,
                    "num_nodes_avg": 267.3,
                    "path_length_avg": 127.81088434439926,
                    "smoothness_avg": 0.12745919691326796,
                    "success_improvement": 0.0,
                    "time_improvement": 51.670420475678746,
                    "length_improvement": 15.114096318742218,
                    "smoothness_improvement": 1521.2715766774893,
                    "objective_score": 32.1759418173364
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "\"A bidirectional RRT* planner enhanced with goal bias sampling, adaptive neighbor radius rewiring, early termination on first solution, and path shortcut smoothing. The planner grows start and goal trees alternately, rewires nodes within a dynamically shrinking radius to optimize cost and smoothness, attempts to connect trees at each iteration, and applies shortcut smoothing after path extraction to improve length and smoothness while respecting a 30-second time limit.\"",
          "planning_mechanism": "The planner samples mostly uniformly but with a small bias toward the goal to speed convergence, grows and rewires two trees alternately using an adaptive neighbor radius based on tree size and dimension, attempts connections after each new node addition, and upon finding a valid path or time expiry, extracts and shortcut-smooths the combined path before returning it. Collision checks ensure validity of new nodes and edges throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        def in_time():\n            return time.monotonic() - time_start < time_limit\n\n        def sample_free():\n            p_goal_bias = 0.05\n            if random.random() < p_goal_bias:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if self._sqdist(n.position, point) <= r2]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            # Choose minimum cost parent\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(near_node.position, new_node.position, obstacles, is_3d)\n                cost_through = near_node.cost + math.dist(near_node.position, new_node.position)\n                if edge_clear and cost_through < min_cost:\n                    min_cost = cost_through\n                    min_parent = near_node\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                        edges.remove((new_node.parent, new_node))\n                    except Exception:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                edges.append((min_parent, new_node))\n            # Now rewire near nodes to new_node if beneficial\n            for near_node in near_nodes:\n                if near_node == new_node or near_node == min_parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                cost_through = new_node.cost + math.dist(new_node.position, near_node.position)\n                if edge_clear and cost_through < near_node.cost:\n                    if near_node.parent:\n                        try:\n                            near_node.parent.children.remove(near_node)\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = cost_through\n                    new_node.children.append(near_node)\n                    edges.append((new_node, near_node))\n\n        def try_connect(tree_a, tree_b):\n            # Attempt to connect a new node in tree_a to nearest in tree_b within step_size, extend incrementally\n            last_node = None\n            for node_a in tree_a[-1:]:  # only last added node\n                nearest_b = nearest(tree_b, node_a.position)\n                dist = math.dist(node_a.position, nearest_b.position)\n                if dist <= self.step_size and not self._is_edge_in_obstacle(node_a.position, nearest_b.position, obstacles, is_3d):\n                    return node_a, nearest_b\n                # Try to incrementally extend tree_b toward node_a\n                from_pos = nearest_b.position\n                to_pos = node_a.position\n                direction_dist = dist\n                steps = int(direction_dist / self.step_size)\n                current_node = nearest_b\n                for step_i in range(steps):\n                    next_pos = steer(from_pos, to_pos)\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, next_pos, obstacles, is_3d):\n                        break\n                    new_node = Node(next_pos, parent=current_node,\n                                    cost=current_node.cost + math.dist(current_node.position, next_pos))\n                    current_node.add_child(new_node)\n                    tree_b.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((current_node, new_node))\n                    from_pos = next_pos\n                    current_node = new_node\n                    if math.dist(next_pos, node_a.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(next_pos, node_a.position, obstacles, is_3d):\n                            return node_a, current_node\n                # else no connection\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Adaptive rewiring radius based on problem dimension and number of nodes\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            from math import log, pi, pow\n            gamma_rrt_star = 2 * (1 + 1/dim)**(1/dim) * pow((pi / 2), 1/dim)\n            r = min(self.step_size * 15.0, gamma_rrt_star * pow(log(n)/n, 1/dim))\n            return max(r, self.step_size)\n\n        for iteration in range(self.max_iter):\n            if not in_time():\n                break\n            sample = sample_free()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos)\n                dist_to_parent = math.dist(nearest_node.position, new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist_to_parent\n                nearest_node.children.append(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                radius = adaptive_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                connected = try_connect(tree_a, tree_b)\n                if connected:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(\n                        success=success_state,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n        # If timeout or max iterations reached return best path if any\n        if success_state:\n            extracted_path = shortcut_path(extracted_path)\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _sqdist(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))",
          "objective": -29.96541,
          "time_improvement": 36.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1980.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012406229972839355,
                    "num_nodes_avg": 103.5,
                    "path_length_avg": 160.7183397829509,
                    "smoothness_avg": 0.05658427722082725,
                    "success_improvement": 0.0,
                    "time_improvement": 50.627082684965195,
                    "length_improvement": 11.907731219897055,
                    "smoothness_improvement": 785.6668132306096,
                    "objective_score": 26.26109760358084
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04006195068359375,
                    "num_nodes_avg": 314.0,
                    "path_length_avg": 238.79163146455207,
                    "smoothness_avg": 0.13025351165853924,
                    "success_improvement": 0.0,
                    "time_improvement": 75.07480214571018,
                    "length_improvement": 20.284480181117733,
                    "smoothness_improvement": 3251.516672786518,
                    "objective_score": 50.95071211631628
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05753490924835205,
                    "num_nodes_avg": 302.3,
                    "path_length_avg": 128.73178230846412,
                    "smoothness_avg": 0.15734441021955675,
                    "success_improvement": 0.0,
                    "time_improvement": -18.413733543350357,
                    "length_improvement": 14.502479739459062,
                    "smoothness_improvement": 1901.4092840364967,
                    "objective_score": 12.684414200852814
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a unidirectional informed RRT* planner with adaptive neighbor radius, goal bias sampling, early stopping immediately after first feasible path is found, and iterative greedy shortcut smoothing to generate efficient, smooth, and short collision-free paths within a hard 30-second time limit. It uses a KD-tree for fast nearest neighbor and radius queries, ensures collision-checking at every new node and edge addition, and dynamically balances exploration and exploitation through informed ellipsoidal sampling after initial solution.",
          "planning_mechanism": "The planner expands a single tree from start using goal bias and informed sampling. It steers nodes towards samples with fixed step size, chooses minimum cost parents in an adaptively sized neighborhood, rewires neighbors for incremental cost improvement, and terminates upon connecting to the goal within step size. After planning, it performs iterative shortcut smoothing on the best path found, returning success status, final path, explored nodes, and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% goal bias\n        self.time_limit_sec = 30.0\n        self.neighbor_radius_factor = 25.0\n        self.max_shortcut_iters = 40\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(fpos, tpos, resolution=1.0):\n            distance = dist(fpos, tpos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(fpos[d] + (tpos[d]-fpos[d])*(i/steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                new_p = to\n            else:\n                r = self.step_size / d\n                new_p = tuple(fr[i] + (to[i] - fr[i])*r for i in range(dim))\n            # Clamp defensively\n            new_p = tuple(max(0.0, min(new_p[i], bounds[i])) for i in range(dim))\n            return new_p\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not _is_in_obstacle(sample):\n                    return sample\n            # fallback if stuck in complex maps\n            return start_pos\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i]+goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i]-start_pos[i])/c_min for i in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n                radii = [r1, r2]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(a1[0])<0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = [a1,b2,b3]\n                r1 = c_best * 0.5\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm > 1e-12:\n                        v = [x/nrm for x in v]\n                        r = random.random()**(1.0/d)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                mapped[i] += sum(basis[j][i]*radii[j]*u[j] for j in range(dim))\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if _is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        # KD-tree implementation for efficient nearest and radius queries\n        class KDNode:\n            __slots__ = ('point', 'node', 'axis', 'left', 'right')\n            def __init__(self, point=None, node=None, axis=0):\n                self.point = point\n                self.node = node\n                self.axis = axis\n                self.left = None\n                self.right = None\n\n        class KDTree:\n            def __init__(self, dim):\n                self.dim = dim\n                self.root = None\n                self.nodes = []\n\n            def _build(self, points, depth=0):\n                if not points:\n                    return None\n                axis = depth % self.dim\n                points.sort(key=lambda x: x[0][axis])\n                median = len(points)//2\n                node = KDNode(points[median][0], points[median][1], axis)\n                node.left = self._build(points[:median], depth+1)\n                node.right = self._build(points[median+1:], depth+1)\n                return node\n\n            def build(self, node_list):\n                self.nodes = node_list[:]\n                pts = [(n.position, n) for n in node_list]\n                self.root = self._build(pts)\n\n            def _insert(self, root, point, node, depth=0):\n                if root is None:\n                    return KDNode(point, node, depth % self.dim)\n                axis = root.axis\n                if point[axis] < root.point[axis]:\n                    root.left = self._insert(root.left, point, node, depth+1)\n                else:\n                    root.right = self._insert(root.right, point, node, depth+1)\n                return root\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.root = self._insert(self.root, node.position, node)\n\n            def _nearest(self, root, point, best=None, best_dist=float('inf')):\n                if root is None:\n                    return best, best_dist\n                d = dist(point, root.point)\n                if d < best_dist:\n                    best, best_dist = root.node, d\n                axis = root.axis\n                diff = point[axis] - root.point[axis]\n                close, away = (root.left, root.right) if diff < 0 else (root.right, root.left)\n                best, best_dist = self._nearest(close, point, best, best_dist)\n                if abs(diff) < best_dist:\n                    best, best_dist = self._nearest(away, point, best, best_dist)\n                return best, best_dist\n\n            def nearest(self, point):\n                n, _ = self._nearest(self.root, point)\n                return n\n\n            def _neighbors_radius(self, root, point, radius, results):\n                if root is None:\n                    return\n                if dist(root.point, point) <= radius:\n                    results.append(root.node)\n                axis = root.axis\n                diff = point[axis] - root.point[axis]\n                if diff <= radius:\n                    self._neighbors_radius(root.left, point, radius, results)\n                if diff >= -radius:\n                    self._neighbors_radius(root.right, point, radius, results)\n\n            def neighbors_radius(self, point, radius):\n                results = []\n                self._neighbors_radius(self.root, point, radius, results)\n                return results\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        kdtree = KDTree(dim)\n        kdtree.insert(root)\n\n        best_cost = float('inf')\n        best_goal_node = None\n        c_min = dist(start_pos, goal_pos)\n        first_solution_found = False\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size*2.0, 2.0)\n            val = self.neighbor_radius_factor * ((math.log(n_nodes)/n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size, 2.0)\n            return max(min_r, min(max_r, val))\n\n        def propagate_cost_children(node):\n            stack = node.children[:]\n            while stack:\n                c = stack.pop()\n                old_cost = c.cost\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-12 < old_cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.max_shortcut_iters):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path)-1:\n                    j = len(path) - 1\n                    while j > i+1:\n                        if not _is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i+1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        for _ in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit_sec:\n                break\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = kdtree.nearest(sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos)) or _is_in_obstacle(new_pos) or _is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = kdtree.neighbors_radius(new_pos, r)\n\n            best_parent = nearest_node\n            best_cost_to_new = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for nb in neighbors:\n                if nb is nearest_node:\n                    continue\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb + 1e-12 < best_cost_to_new and not _is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_to_new = c_through_nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_to_new)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kdtree.insert(new_node)\n\n            # Rewiring nearby neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new + 1e-12 < nb.cost and not _is_edge_in_obstacle(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, c_via_new)\n                    edges.append((new_node, nb))\n                    propagate_cost_children(nb)\n\n            # Check if close enough to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not _is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_cost:\n                    best_cost = goal_cost\n                    best_goal_node = goal_node\n                    first_solution_found = True\n                # Early stop after first feasible path\n                break\n\n        success_state = False\n        extracted_path = []\n\n        if first_solution_found and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(extracted_path)\n            success_state = True\n        elif nodes:\n            # Return best effort path to closest node to goal\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -29.86995,
          "time_improvement": 36.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1969.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022821998596191405,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 167.9935501393857,
                    "smoothness_avg": 0.06064844627839987,
                    "success_improvement": 0.0,
                    "time_improvement": 9.175579356464587,
                    "length_improvement": 7.920073140449742,
                    "smoothness_improvement": 849.2798844659862,
                    "objective_score": 11.751117113539152
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05574941635131836,
                    "num_nodes_avg": 969.4,
                    "path_length_avg": 238.10327929405275,
                    "smoothness_avg": 0.13669443940617246,
                    "success_improvement": 0.0,
                    "time_improvement": 65.31458880291497,
                    "length_improvement": 20.51427194874906,
                    "smoothness_improvement": 3417.2463829458584,
                    "objective_score": 48.98917172485322
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032834196090698244,
                    "num_nodes_avg": 698.9,
                    "path_length_avg": 123.108029455418,
                    "smoothness_avg": 0.13679411146276674,
                    "success_improvement": 0.0,
                    "time_improvement": 32.42329226224649,
                    "length_improvement": 18.2375086101187,
                    "smoothness_improvement": 1640.011000715396,
                    "objective_score": 28.869547848322142
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional informed RRT* algorithm with adaptive rewiring radius, goal-biased and informed sampling, incremental local rewiring, early stopping upon first valid path, and multi-pass intelligent post-processing shortcutting. The planner balances exploration and focused refinement in promising state space regions, dynamically adapts connection radius to node density and problem dimension, and efficiently maintains the dual trees. It enforces strict node and edge collision checks, respects map boundaries, and uses incremental cost propagation for optimized rewiring. The planner halts if the 30-second time limit is reached, returning the best path found so far, enhancing planning time, path length, success rate, and smoothness.",
          "planning_mechanism": "The planner simultaneously grows trees from start and goal with alternating expansions. Samples follow goal bias initially, then switch to informed elliptical sampling around the best path found, improving path refinement. Nodes connect using an adaptive neighbor radius for local rewiring based on the number of nodes and problem dimension. Rewiring minimizes costs with incremental propagation and robust collision checking. Upon connecting the two trees, the combined path is extracted and aggressively shortcut multiple times to improve smoothness and length. The planner respects 3D/2D obstacles and map size, enforces collision free edges and nodes, and stops early on success or timeout, returning a best feasible path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% goal bias initially\n        self.time_limit_sec = 30.0\n        self.gamma_rrt_star = 20.0  # parameter controlling neighbor radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a: Tuple[float,...], b: Tuple[float,...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float,...], to_pos: Tuple[float,...]) -> Tuple[float,...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def is_in_obstacle(pos: Tuple[float,...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(a: Tuple[float,...], b: Tuple[float,...], resolution=1.0) -> bool:\n            return self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution)\n\n        def within_bounds(p: Tuple[float,...]) -> bool:\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def sample_free_informed(start, goal, c_best, c_min, center, rotation_matrix) -> Tuple[float,...]:\n            # Sample uniformly in n-dimensional ellipsoid defined by start, goal and c_best\n            # If no path found yet, uniform free sampling with goal bias is used\n            if c_best == float('inf'):\n                # Use goal bias sampling first\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal):\n                    return goal\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform sampling no check very rare\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                # Sample inside ellipsoid\n                while True:\n                    # Sample unit n-ball point\n                    direction = [random.gauss(0,1) for _ in range(dim)]\n                    norm_dir = math.sqrt(sum(x*x for x in direction))\n                    unit_vector = [x/norm_dir for x in direction]\n                    radius = random.random() ** (1/dim)\n                    sample_unit_ball = [radius*x for x in unit_vector]\n\n                    # Scale by radii lengths of ellipsoid axes\n                    r1 = c_best/2.0\n                    r2 = math.sqrt(c_best*c_best - c_min*c_min)/2.0 if c_best*c_best - c_min*c_min > 0 else 0.0\n                    if dim == 2:\n                        L = [[r1, 0],[0, r2]]\n                    else:  # dim==3\n                        L = [[r1,0,0],[0,r2,0],[0,0,r2]]\n\n                    # multiply L*sample_unit_ball\n                    if dim==2:\n                        p_ellipse = (L[0][0]*sample_unit_ball[0] + L[0][1]*sample_unit_ball[1],\n                                     L[1][0]*sample_unit_ball[0] + L[1][1]*sample_unit_ball[1])\n                    else:\n                        p_ellipse = (L[0][0]*sample_unit_ball[0]+L[0][1]*sample_unit_ball[1]+L[0][2]*sample_unit_ball[2],\n                                     L[1][0]*sample_unit_ball[0]+L[1][1]*sample_unit_ball[1]+L[1][2]*sample_unit_ball[2],\n                                     L[2][0]*sample_unit_ball[0]+L[2][1]*sample_unit_ball[1]+L[2][2]*sample_unit_ball[2])\n\n                    # Rotate by rotation matrix and translate to center\n                    if dim==2:\n                        x = rotation_matrix[0][0]*p_ellipse[0] + rotation_matrix[0][1]*p_ellipse[1] + center[0]\n                        y = rotation_matrix[1][0]*p_ellipse[0] + rotation_matrix[1][1]*p_ellipse[1] + center[1]\n                        p_sample = (x,y)\n                    else:\n                        x = rotation_matrix[0][0]*p_ellipse[0] + rotation_matrix[0][1]*p_ellipse[1] + rotation_matrix[0][2]*p_ellipse[2] + center[0]\n                        y = rotation_matrix[1][0]*p_ellipse[0] + rotation_matrix[1][1]*p_ellipse[1] + rotation_matrix[1][2]*p_ellipse[2] + center[1]\n                        z = rotation_matrix[2][0]*p_ellipse[0] + rotation_matrix[2][1]*p_ellipse[1] + rotation_matrix[2][2]*p_ellipse[2] + center[2]\n                        p_sample = (x,y,z)\n\n                    if within_bounds(p_sample) and not is_in_obstacle(p_sample):\n                        return p_sample\n\n        def nearest(nodes_list: List[Node], point: Tuple[float,...]) -> Node:\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return max(self.step_size*2.0, 5.0)\n            val = self.gamma_rrt_star * ( (math.log(n_nodes) / n_nodes) ** (1/dim))\n            max_r = max(bounds) * 0.3\n            min_r = max(self.step_size, 2.0)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list: List[Node], point: Tuple[float,...], radius: float) -> List[Node]:\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def can_connect_nodes(a: Node, b: Node) -> bool:\n            if not a.valid or not b.valid:\n                return False\n            if is_edge_in_obstacle(a.position, b.position):\n                return False\n            return True\n\n        def propagate_cost(node: Node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost(child)\n\n        def rewire(new_node: Node, neighbors: List[Node], nodes_all: List[Node], edges_all: List[Tuple[Node,Node]]):\n            for nb in neighbors:\n                if nb == new_node:\n                    continue\n                if not nb.valid or not new_node.valid:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Update parent and cost\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_all.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_all.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def add_new_node(tree: List[Node], pos: Tuple[float,...], nodes_all: List[Node], edges_all: List[Tuple[Node,Node]]) -> Tuple[Node, List[Node]]:\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, radius)\n            connectable = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not connectable:\n                # fallback: nearest neighbor connection if exists\n                try:\n                    nearest_node = nearest(tree, pos)\n                    if is_edge_in_obstacle(nearest_node.position, pos):\n                        return None, []\n                    connectable = [nearest_node]\n                except ValueError:\n                    return None, []\n            # choose best parent by cost + dist\n            best_parent = min(connectable, key=lambda p: p.cost + dist(p.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            new_node.cost = new_cost\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def stitch_path(n_start: Node, n_goal: Node, start_tree_expanded: bool) -> List[Tuple[float,...]]:\n            # Join paths from both trees without duplication in meeting node\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            # Reverse goal path (full) for concatenation\n            path_from_goal_rev = path_from_goal[::-1]\n\n            # Detect duplicate points and avoid duplication\n            if path_from_start[-1] == path_from_goal_rev[0]:\n                combined = path_from_start + path_from_goal_rev[1:]\n            elif path_from_start[-1] == path_from_goal_rev[-1]:\n                combined = path_from_start + path_from_goal_rev[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal_rev\n\n            # If the start tree was the goal side, reverse final path for consistent direction\n            if not start_tree_expanded:\n                combined.reverse()\n            return combined\n\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path[:]\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                max_j = i+1\n                for j in range(len(path)-1, i, -1):\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        max_j = j\n                        break\n                shortcut.append(path[max_j])\n                i = max_j\n            return shortcut\n\n        def compute_rotation_matrix(start: Tuple[float,...], goal: Tuple[float,...]) -> List[List[float]]:\n            # Compute rotation matrix aligning x-axis to line start->goal (used for ellipsoidal sampling)\n            # Only for 2D or 3D\n            v = [goal[i] - start[i] for i in range(dim)]\n            norm_v = math.sqrt(sum(x*x for x in v))\n            if norm_v == 0:\n                # Degenerate, return identity\n                if dim == 2:\n                    return [[1,0],[0,1]]\n                else:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n            e1 = [x / norm_v for x in v]\n            if dim == 2:\n                # Orthogonal vector to e1\n                e2 = [-e1[1], e1[0]]\n                R = [e1, e2]\n                # columns of R should be vectors, transpose for row vectors:\n                return [[R[0][0], R[1][0]], [R[0][1], R[1][1]]]\n            else:\n                # 3D: create orthonormal basis with e1, arbitrary e2, e3\n                # Using Gram-Schmidt on standard basis\n                up = [0,0,1] if abs(e1[2]) < 0.9 else [0,1,0]\n                e2 = [up[i] - sum(up[j]*e1[j] for j in range(3))*e1[i] for i in range(3)]\n                norm_e2 = math.sqrt(sum(x*x for x in e2))\n                if norm_e2 == 0:\n                    # If parallel, pick alternate up\n                    up = [0,1,0]\n                    e2 = [up[i] - sum(up[j]*e1[j] for j in range(3))*e1[i] for i in range(3)]\n                    norm_e2 = math.sqrt(sum(x*x for x in e2))\n                e2 = [x/norm_e2 for x in e2]\n                e3 = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                R = [e1, e2, e3]  # rows vectors\n                # transpose for column vectors:\n                Rt = [[R[0][0], R[1][0], R[2][0]],\n                      [R[0][1], R[1][1], R[2][1]],\n                      [R[0][2], R[1][2], R[2][2]]]\n                return Rt\n\n        tree_start: List[Node] = [Node(start_pos, None, 0.0)]\n        tree_goal: List[Node] = [Node(goal_pos, None, 0.0)]\n        nodes_all: List[Node] = [tree_start[0], tree_goal[0]]\n        edges_all: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        success = False\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        # Variables for informed sampling\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        rotation_matrix = compute_rotation_matrix(start_pos, goal_pos)\n        center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n\n        iter_since_improve = 0\n        max_no_improve_iters = 3000  # Terminate early if no improvement for many iterations\n\n        for iteration in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit_sec:\n                # Time limit reached, return best path if available or partial best from start tree\n                if success:\n                    combined_path = stitch_path(best_start_node, best_goal_node, expand_start_tree)\n                    for _ in range(3):\n                        combined_path = shortcut_path(combined_path)\n                    return PlannerResult(True, combined_path, nodes_all, edges_all)\n                # else partial path from start tree closest to goal\n                best_partial_node = None\n                best_dist = float('inf')\n                for node in tree_start:\n                    if node.valid:\n                        d = dist(node.position, goal_pos)\n                        if d < best_dist:\n                            best_dist = d\n                            best_partial_node = node\n                if best_partial_node:\n                    partial_path = best_partial_node.path_from_root()\n                    for _ in range(3):\n                        partial_path = shortcut_path(partial_path)\n                    return PlannerResult(False, partial_path, nodes_all, edges_all)\n                return PlannerResult(False, [], nodes_all, edges_all)\n\n            # Sample point\n            if success:\n                x_rand = sample_free_informed(start_pos, goal_pos, c_best, c_min, center, rotation_matrix)\n            else:\n                # Before solution, uniform with goal bias\n                if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                    x_rand = goal_pos\n                else:\n                    samples_tried = 0\n                    while samples_tried < 100:\n                        p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(p):\n                            x_rand = p\n                            break\n                        samples_tried += 1\n                    else:\n                        x_rand = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            # Alternate expanding between start and goal trees\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n            a_is_start = expand_start_tree\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand)\n            if (not within_bounds(new_pos)\n                or is_in_obstacle(new_pos)\n                or is_edge_in_obstacle(nearest_node.position, new_pos)):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_node, neighbors = add_new_node(tree_a, new_pos, nodes_all, edges_all)\n            if new_node is None:\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Rewire neighbors locally to minimize costs\n            rewire(new_node, neighbors, nodes_all, edges_all)\n\n            # Attempt to connect new_node to opposite tree nodes in radius\n            radius = neighbor_radius(len(tree_b))\n            near_other_nodes = near_nodes(tree_b, new_node.position, radius)\n            connection_found = False\n            for other_node in near_other_nodes:\n                if can_connect_nodes(new_node, other_node):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_start_node = new_node if a_is_start else other_node\n                        best_goal_node = other_node if a_is_start else new_node\n                        c_best = best_cost\n                        iter_since_improve = 0\n                        center = tuple((best_start_node.position[i] + best_goal_node.position[i])/2 for i in range(dim))\n                        connection_found = True\n            if not connection_found:\n                iter_since_improve += 1\n\n            # Early termination if no improvements for large iterations (optional)\n            if iter_since_improve > max_no_improve_iters and success:\n                combined_path = stitch_path(best_start_node, best_goal_node, a_is_start)\n                for _ in range(3):\n                    combined_path = shortcut_path(combined_path)\n                return PlannerResult(True, combined_path, nodes_all, edges_all)\n\n            if success:\n                # Early stop on first valid path (can be commented out to allow more exploration)\n                combined_path = stitch_path(best_start_node, best_goal_node, a_is_start)\n                for _ in range(3):\n                    combined_path = shortcut_path(combined_path)\n                return PlannerResult(True, combined_path, nodes_all, edges_all)\n\n            expand_start_tree = not expand_start_tree\n\n        # Out of iterations final check: return best path if any or best partial path\n        if success:\n            combined_path = stitch_path(best_start_node, best_goal_node, a_is_start)\n            for _ in range(3):\n                combined_path = shortcut_path(combined_path)\n            return PlannerResult(True, combined_path, nodes_all, edges_all)\n        # partial from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            if node.valid:\n                d = dist(node.position, goal_pos)\n                if d < best_dist:\n                    best_dist = d\n                    best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            for _ in range(3):\n                partial_path = shortcut_path(partial_path)\n            return PlannerResult(False, partial_path, nodes_all, edges_all)\n        return PlannerResult(False, [], nodes_all, edges_all)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w_, h_ = obs\n                px, py = pos\n                if x <= px <= x + w_ and y <= py <= y + h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.659,
          "time_improvement": 34.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 2019.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02984492778778076,
                    "num_nodes_avg": 141.1,
                    "path_length_avg": 164.53539712693586,
                    "smoothness_avg": 0.04764004814428365,
                    "success_improvement": 0.0,
                    "time_improvement": -18.77348357762579,
                    "length_improvement": 9.815541604514655,
                    "smoothness_improvement": 645.6702054783914,
                    "objective_score": 3.4856309168130135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02899777889251709,
                    "num_nodes_avg": 283.2,
                    "path_length_avg": 236.75497779463316,
                    "smoothness_avg": 0.15454954610526278,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95855758648992,
                    "length_improvement": 20.964373797962175,
                    "smoothness_improvement": 3876.671138826982,
                    "objective_score": 56.549547248859184
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02905869483947754,
                    "num_nodes_avg": 291.1,
                    "path_length_avg": 127.43783020490011,
                    "smoothness_avg": 0.12840605222708018,
                    "success_improvement": 0.0,
                    "time_improvement": 40.19372598666294,
                    "length_improvement": 15.361861115268379,
                    "smoothness_improvement": 1533.3155063795916,
                    "objective_score": 28.94181199705787
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT*-inspired planner using a fixed rewiring radius, uniform and goal-biased sampling combined with ellipsoidal informed sampling after first solution, efficient neighbor rewiring with downstream cost propagation for global path improvements, and immediate termination on first path found to reduce planning time and improve path smoothness and length. The planner alternates tree growth from start and goal, rewires neighbors within a fixed radius to enhance path quality, attempts direct tree connections for fast convergence, and applies advanced path shortcutting after completion for smooth optimized paths.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points with an initial goal bias. After the first solution is found, sampling switches to ellipsoidal informed sampling within the current best path cost to focus search efficiently. New nodes connect to the best parent found in a neighborhood defined by a fixed radius and rewiring is performed to lower path costs. Downstream cost propagation ensures consistent cost update in subtrees. The trees attempt direct connection when nodes are close, and the algorithm stops immediately after a path is found, returning a shortened and smoothed final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent != new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 40.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n        self.goal_sample_rate = 0.05  # initial goal bias\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            distance = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size*0.5)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            # Limited tries to prevent infinite loops\n            for _ in range(100):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            # fallback to start to avoid endless loop\n            return start_pos\n\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0.0)) / 2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1], v[2]*e1[0]-v[0]*e1[2], v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1], k[2]*v_vec[0]-k[0]*v_vec[2], k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i] + rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree_nodes, pt):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def propagate_costs_downstream(node):\n            # BFS to update costs of descendants with improved cost via node\n            from collections import deque\n            queue = deque([node])\n            while queue:\n                curr = queue.popleft()\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + self.improve_tol < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        queue.append(c)\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n                        propagate_costs_downstream(nbr)\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, new_pos)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                est_cost = nbr.cost + dist(nbr.position, new_pos)\n                if est_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = est_cost\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def merge_trees(node_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_a.position)\n            d = dist(node_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return None\n            total_cost = node_a.cost + d + nearest_b.cost\n            path_a = node_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            # avoid duplicate node at merge\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization of trees and data containers\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling: use goal bias at start, switch to informed sampling after solution\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if is_in_obstacle(sample):\n                continue  # sample rejected\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                candidate_path, candidate_cost = merged\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    break  # early stopping on first path found\n\n        # If no solution found, attempt heuristic fallback\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n                found_solution = True\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = found_solution\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -28.94013,
          "time_improvement": 45.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1369.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023919391632080077,
                    "num_nodes_avg": 136.4,
                    "path_length_avg": 178.50161436538082,
                    "smoothness_avg": 0.04000668691404389,
                    "success_improvement": 0.0,
                    "time_improvement": 4.808298100059972,
                    "length_improvement": 2.1604366272486275,
                    "smoothness_improvement": 526.1915261159178,
                    "objective_score": 5.369709036946757
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028526616096496583,
                    "num_nodes_avg": 278.8,
                    "path_length_avg": 232.46150100985702,
                    "smoothness_avg": 0.09469756943367832,
                    "success_improvement": 0.0,
                    "time_improvement": 82.25169922617549,
                    "length_improvement": 22.397659929597573,
                    "smoothness_improvement": 2336.636669430822,
                    "objective_score": 49.7972890727653
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025488901138305663,
                    "num_nodes_avg": 262.7,
                    "path_length_avg": 122.55435246365639,
                    "smoothness_avg": 0.10578699719970948,
                    "success_improvement": 0.0,
                    "time_improvement": 47.54078893779472,
                    "length_improvement": 18.605234504781638,
                    "smoothness_improvement": 1245.6027959964083,
                    "objective_score": 31.653391364189442
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional, adaptive radius RRT* planner enhanced with ellipsoidal informed sampling after path discovery, efficient spatial hashing for neighbor queries, incremental downstream cost propagation, and multi-pass randomized shortcutting for improved smoothing and path shortening within a hard 30-second limit. The planner alternates tree expansions, dynamically adapts neighbor radius to problem scale, aggressively prunes the search space after an initial solution, and efficiently manages rewiring and path extraction to optimize quality and runtime.",
          "planning_mechanism": "A bidirectional RRT* grows trees from start and goal alternately, using goal bias before and ellipsoidal informed sampling after a solution is found. New samples connect to optimal parents within an adaptive neighborhood radius via efficient spatial hashing. Rewiring with downstream cost updates refines paths, while incremental tree connections check for path completion. Upon solution or timeout, a randomized multi-pass shortcutting smooths and shortens the path before returning. All expansions and connections enforce collision-free checks and domain constraints, terminating early on success or time expiration.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        if parent:\n            parent.children.append(self)\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\n            self._propagate_cost()\n\n    def _propagate_cost(self):\n        stack = self.children[:]\n        while stack:\n            c = stack.pop()\n            new_cost = c.parent.cost + math.dist(c.parent.position, c.position)\n            if new_cost + 1e-12 < c.cost:\n                c.cost = new_cost\n                stack.extend(c.children)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=4.0,\n                 goal_sample_rate=0.12, time_limit=30.0,\n                 max_neighbor_radius=18.0, min_neighbor_radius=3.0,\n                 shortcut_passes=6, shortcut_attempts=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_free_node(p):\n            return in_bounds(p) and (not is_in_obstacle(p))\n\n        def is_edge_in_obstacle(p1, p2, resolution=None):\n            if resolution is None:\n                resolution = min(1.0, self.step_size * 0.25)\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            # fallback without obstacle checking\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def build_rotation_matrix(unit_vec):\n            if dim == 2:\n                cos_theta, sin_theta = unit_vec[0], unit_vec[1]\n                return [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = unit_vec\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1, 0, 0)\n                else:\n                    temp = (0, 1, 0)\n                dot = sum(x_axis[i] * temp[i] for i in range(3))\n                v = tuple(temp[i] - dot * x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                if norm_v < 1e-12:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(v[i] / norm_v for i in range(3))\n                w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                return [[x_axis[0], v_unit[0], w[0]],\n                        [x_axis[1], v_unit[1], w[1]],\n                        [x_axis[2], v_unit[2], w[2]]]\n            else:\n                return None\n\n        def ellipsoidal_informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return uniform_sample()\n            c_min = dist(x_start, x_goal)\n            if c_min < 1e-12:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            unit = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            R = build_rotation_matrix(unit)\n            if R is None:\n                return uniform_sample()\n\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)*0.5 if val > 1e-12 else max(self.min_neighbor_radius*0.15, 0.001)\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            scale = random.random()**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            if is_free_node(clipped):\n                return clipped\n            return uniform_sample()\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n) / n) ** (1.0 / dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        class SpatialHashGrid:\n            def __init__(self, domain, cell_size):\n                self.dim = len(domain)\n                self.domain = domain\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def add(self, node):\n                cc = self._cell_coords(node.position)\n                self.cells.setdefault(cc, []).append(node)\n\n            def remove(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells:\n                    try:\n                        self.cells[cc].remove(node)\n                        if not self.cells[cc]:\n                            del self.cells[cc]\n                    except ValueError:\n                        pass\n\n            def neighbors(self, p, radius):\n                center_cc = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                nbrs = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            cc = (center_cc[0] + dx, center_cc[1] + dy)\n                            if cc in self.cells:\n                                nbrs.extend(self.cells[cc])\n                elif self.dim == 3:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            for dz in range(-r_cells, r_cells + 1):\n                                cc = (center_cc[0] + dx, center_cc[1] + dy, center_cc[2] + dz)\n                                if cc in self.cells:\n                                    nbrs.extend(self.cells[cc])\n                else:\n                    return []\n                r_sq = radius * radius\n                filtered = []\n                for node in nbrs:\n                    sum_sq = 0.0\n                    for i_d in range(self.dim):\n                        diff = node.position[i_d] - p[i_d]\n                        sum_sq += diff * diff\n                        if sum_sq > r_sq:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n\n        def propagate_cost(n):\n            stack = n.children[:]\n            while stack:\n                c = stack.pop()\n                new_cost = c.parent.cost + dist(c.parent.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            curr_path = path[:]\n            for _ in range(self.shortcut_passes):\n                improved = False\n                for __ in range(self.shortcut_attempts):\n                    if len(curr_path) < 3:\n                        break\n                    i = random.randint(0, len(curr_path) - 3)\n                    j = random.randint(i+2, len(curr_path) -1)\n                    p1, p2 = curr_path[i], curr_path[j]\n                    if not is_edge_in_obstacle(p1, p2):\n                        # Remove intermediate nodes i+1 to j-1\n                        del curr_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return curr_path\n\n        # Initialize trees and spatial grids\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges: List[Tuple[Node, Node]] = []\n\n        cell_size = self.max_neighbor_radius\n        grid_start = SpatialHashGrid(bounds, cell_size)\n        grid_goal = SpatialHashGrid(bounds, cell_size)\n        grid_start.add(tree_start[0])\n        grid_goal.add(tree_goal[0])\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_start = True\n\n        for it in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            cur_tree = tree_start if expand_start else tree_goal\n            cur_grid = grid_start if expand_start else grid_goal\n            opp_tree = tree_goal if expand_start else tree_start\n            opp_grid = grid_goal if expand_start else grid_start\n\n            # Sampling: goal bias or ellipsoidal informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_start else start_pos\n            else:\n                sample = ellipsoidal_informed_sample(best_cost, start_pos, goal_pos)\n\n            # Nearest node search (approximate with spatial hash)\n            nearest = None\n            nearest_dist = float('inf')\n            approx_radius = self.step_size * 4.0\n            approx_neighbors = cur_grid.neighbors(sample, approx_radius)\n            for nd in approx_neighbors:\n                d_ = dist(nd.position, sample)\n                if d_ < nearest_dist:\n                    nearest = nd\n                    nearest_dist = d_\n            if nearest is None:\n                # fallback linear scan\n                for nd in cur_tree:\n                    d_ = dist(nd.position, sample)\n                    if d_ < nearest_dist:\n                        nearest = nd\n                        nearest_dist = d_\n            if nearest is None:\n                expand_start = not expand_start\n                continue\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                expand_start = not expand_start\n                continue\n\n            radius = neighbor_radius(len(cur_tree))\n            nbrs = cur_grid.neighbors(new_pos, radius)\n\n            # Choose best parent based on cost + collision free\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nb in nbrs:\n                if nb is nearest:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost + 1e-12 < best_cost_to_new:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, best_cost_to_new)\n            cur_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            cur_grid.add(new_node)\n\n            # Rewire neighbors if better path found via new_node\n            for nb in nbrs:\n                if nb is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, nb))\n                    propagate_cost(nb)\n\n            # Attempt connection between trees within radius\n            opp_candidates = opp_grid.neighbors(new_node.position, radius)\n            for on in opp_candidates:\n                total_cost = new_node.cost + dist(new_node.position, on.position) + on.cost\n                if total_cost + 1e-12 >= best_cost:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, on.position):\n                    best_cost = total_cost\n                    if expand_start:\n                        best_start_node = new_node\n                        best_goal_node = on\n                    else:\n                        best_start_node = on\n                        best_goal_node = new_node\n                    success = True\n                    break\n\n            if success:\n                break\n\n            expand_start = not expand_start\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            raw_path = extract_path(best_start_node, best_goal_node)\n        else:\n            # fallback: closest node in start tree to goal\n            closest = None\n            min_d = float('inf')\n            for n in tree_start:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d:\n                    min_d = d_\n                    closest = n\n            if closest:\n                raw_path = []\n                cur = closest\n                while cur:\n                    raw_path.append(cur.position)\n                    cur = cur.parent\n                raw_path.reverse()\n            else:\n                raw_path = [start_pos]\n\n        smooth_path = shortcut_path(raw_path)\n\n        return PlannerResult(\n            success=success,\n            path=smooth_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -28.63426,
          "time_improvement": 34.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1492.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029888391494750977,
                    "num_nodes_avg": 103.5,
                    "path_length_avg": 155.43132395432522,
                    "smoothness_avg": 0.0518577507450352,
                    "success_improvement": 0.0,
                    "time_improvement": -18.946455545350343,
                    "length_improvement": 14.8056283736938,
                    "smoothness_improvement": 711.6864100679438,
                    "objective_score": 6.757872410950897
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04192595481872559,
                    "num_nodes_avg": 354.7,
                    "path_length_avg": 234.09391875892734,
                    "smoothness_avg": 0.09381139900846555,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9150814861667,
                    "length_improvement": 21.85271189841823,
                    "smoothness_improvement": 2313.8348661073396,
                    "objective_score": 46.855325915437646
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025126171112060548,
                    "num_nodes_avg": 286.9,
                    "path_length_avg": 124.09226186397507,
                    "smoothness_avg": 0.12190451186302384,
                    "success_improvement": 0.0,
                    "time_improvement": 48.28733077191071,
                    "length_improvement": 17.583828308465986,
                    "smoothness_improvement": 1450.6163928425856,
                    "objective_score": 32.28957818086573
               }
          ],
          "success_rate": 1.0
     }
]