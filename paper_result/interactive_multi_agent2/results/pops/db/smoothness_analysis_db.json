[
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "Simplified single-tree RRT* with adaptive radius rewiring and goal biasing for efficient path improvement and early stopping. The planner builds a tree rooted at start, samples with goal bias, extends nearest node towards samples within a fixed step, rewires neighbors using a shrinking radius based on the nodes count, applying collision checks for validity. Upon reaching near the goal, the goal node is connected. Planning stops early if time limit reached or after finding a solution, returning the best path found.",
                "planning_mechanism": "The planner incrementally samples points using random or goal biasing, extends the tree by steering from nearest node towards sample, finds neighbors within a dynamically shrinking radius, selects the best parent by lowest cost avoiding collisions, rewires neighbors to reduce path cost, and attempts goal connection when close. Collision checks are applied on both nodes and edges before insertion. The algorithm stops when time expires or after successfully connecting goal, returning best discovered path information.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n\n        success = False\n        best_path = []\n        best_goal_node = None\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(frm, to, resolution=1.0):\n            distance = dist(frm, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                pt = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            n_nodes = len(nodes)\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near_nodes:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Check goal connection\n            if dist(new_node.position, goal) <= self.step_size:\n                if not in_obstacle(goal) and not edge_in_obstacle(new_node.position, goal):\n                    goal_node = Node(goal)\n                    goal_cost = new_node.cost + dist(new_node.position, goal)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    best_path = path[::-1]\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if not success and nodes:\n            # Extract path to closest node to goal found\n            closest = min(nodes, key=lambda n: dist(n.position, goal))\n            path = []\n            curr = closest\n            while curr:\n                path.append(curr.position)\n                curr = curr.parent\n            best_path = path[::-1]\n\n        return PlannerResult(success, best_path, nodes, edges)",
                "objective": 59.53833,
                "time_improvement": -205.0,
                "length_improvement": 3.0,
                "smoothness_improvement": 16.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.030140113830566407,
                        "num_nodes_avg": 330.0,
                        "path_length_avg": 173.44819131925448,
                        "smoothness_avg": 0.008097486243342734,
                        "success_improvement": 0.0,
                        "time_improvement": -22.96337365101135,
                        "length_improvement": 4.930297875442979,
                        "smoothness_improvement": 26.743243681132444,
                        "objective_score": -3.797117151631955
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5926714897155761,
                        "num_nodes_avg": 1542.0,
                        "path_length_avg": 295.65291792303844,
                        "smoothness_avg": 0.004008643126314778,
                        "success_improvement": 0.0,
                        "time_improvement": -231.35707212372787,
                        "length_improvement": 1.3025460998914242,
                        "smoothness_improvement": 3.1452749490172267,
                        "objective_score": -68.60986760243843
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.5032036066055298,
                        "num_nodes_avg": 1083.3,
                        "path_length_avg": 146.85104038837926,
                        "smoothness_avg": 0.00920710304953717,
                        "success_improvement": 0.0,
                        "time_improvement": -359.24897840173725,
                        "length_improvement": 2.468531269131249,
                        "smoothness_improvement": 17.11367119245822,
                        "objective_score": -106.20800640308012
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "Simplified RRT* planner with goal biasing and fixed neighbor radius, focusing on clarity and robustness while maintaining adaptive rewiring and collision checking. The planner grows a single tree by sampling free space or goal with a probability, extending the nearest node toward samples with fixed step size, rewiring neighbors within a constant radius to improve path costs, and connecting to the goal when reachable. Planning stops when time limit or iteration budget is reached, returning the best path found.",
            "planning_mechanism": "The algorithm samples points with goal bias, extends the nearest tree node toward the sample using a fixed step size after collision checks, selects the best parent among nearby nodes using a constant radius for rewiring, rewires neighbors to reduce costs while ensuring collision-free edges, and attempts goal connection when within step size. It records nodes and edges coherently and returns success status and best path upon completion or timeout.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(frm, to, resolution=1.0):\n            distance = dist(frm, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                pt = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n        success = False\n        best_path = []\n        best_goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= self.neighbor_radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near_nodes:\n                cost_through_node = node.cost + dist(node.position, new_pos)\n                if cost_through_node < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt goal connection\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    cur = goal_node\n                    while cur:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    best_path = path[::-1]\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if not success and nodes:\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = []\n            cur = closest\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            best_path = path[::-1]\n\n        return PlannerResult(success, best_path, nodes, edges)",
            "objective": 29.61958,
            "time_improvement": -135.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 170.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05429637432098389,
                    "num_nodes_avg": 331.4,
                    "path_length_avg": 170.81499121557914,
                    "smoothness_avg": 0.015409562646928202,
                    "success_improvement": 0.0,
                    "time_improvement": -121.51427167987083,
                    "length_improvement": 6.373596577993225,
                    "smoothness_improvement": 141.19311782529843,
                    "objective_score": -31.92415796803882
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.20041484832763673,
                    "num_nodes_avg": 962.2,
                    "path_length_avg": 232.45333671582574,
                    "smoothness_avg": 0.011532766289412601,
                    "success_improvement": 0.0,
                    "time_improvement": -12.0500623099593,
                    "length_improvement": 22.400385405941385,
                    "smoothness_improvement": 196.74638334238452,
                    "objective_score": 10.808944467288965
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.4073710203170776,
                    "num_nodes_avg": 898.2,
                    "path_length_avg": 118.12973147669986,
                    "smoothness_avg": 0.021483807722149535,
                    "success_improvement": 0.0,
                    "time_improvement": -271.7873291352426,
                    "length_improvement": 21.543857086507963,
                    "smoothness_improvement": 173.2724484560096,
                    "objective_score": -67.74352224638795
                }
            ],
            "success_rate": 1.0
        },
        "objective": 40.4,
        "analysis": "1. Summary of key changes:\n   - Replaced adaptive neighbor radius with a fixed neighbor radius parameter for rewiring.\n   - Simplified neighbor search and rewiring logic using a constant radius.\n   - Maintained goal bias and early stopping based on time limit or successful goal connection.\n\n2. Primary contributors to the performance improvement:\n   - Fixed neighbor radius reduces computational overhead for neighbor searches and collision checks.\n   - Simplified and consistent rewiring with a constant radius leads to more effective path refinement.\n   - Efficient goal connection attempts enable earlier termination with better paths.\n\n3. Expected mechanism of impact:\n   - Reducing computational cost in neighbor search speeds up planning iterations, enhancing runtime performance.\n   - Consistent rewiring within a fixed radius promotes more uniform path cost improvements, leading to shorter and smoother paths.\n   - Early goal connection decreases unnecessary expansions, resulting in improved path smoothness and lower length."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -21.466403807723584,
                "time_improvement": 49.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 170.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.027271223068237305,
                        "num_nodes_avg": 110.2,
                        "path_length_avg": 173.00501237348854,
                        "smoothness_avg": 0.016862240813808067,
                        "success_improvement": 0.0,
                        "time_improvement": -11.259088499491776,
                        "length_improvement": 5.173211278237082,
                        "smoothness_improvement": 163.93068567809792,
                        "objective_score": 0.5458536454852055
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04331405162811279,
                        "num_nodes_avg": 281.2,
                        "path_length_avg": 261.07677541572514,
                        "smoothness_avg": 0.01037099527249528,
                        "success_improvement": 0.0,
                        "time_improvement": 75.78351991219422,
                        "length_improvement": 12.845057687913258,
                        "smoothness_improvement": 166.8531782872617,
                        "objective_score": 31.27635647784253
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.020683646202087402,
                        "num_nodes_avg": 175.6,
                        "path_length_avg": 132.13490050633862,
                        "smoothness_avg": 0.02192950397288757,
                        "success_improvement": 0.0,
                        "time_improvement": 81.12306179200738,
                        "length_improvement": 12.242290671505323,
                        "smoothness_improvement": 178.94167186752225,
                        "objective_score": 32.57700129984302
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a straightforward bidirectional RRT that grows two trees from start and goal by iteratively sampling points within the map bounds and extending nearest tree nodes toward those samples. It performs collision checking for nodes and edges, and attempts to connect the two trees when nodes get close, yielding a combined path. Simplified logic avoids rewiring or complex radius searches, prioritizing generalization and computational efficiency.",
                "planning_mechanism": "The planner alternates expansions between the start and goal trees, sampling points, steering from nearest nodes toward samples, and verifying collision-freeness. When two trees approach within step size, it attempts to connect them directly to form a full path from start to goal. Upon success or time limits, it returns the best found path, ensuring a balance of simplicity and bidirectional search benefits.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b):\n            dist = distance(a, b)\n            steps = max(1, int(dist // 1.0))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_start + path_goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + distance(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if distance(new_node.position, nearest_other.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, nearest_other.position)) and (not is_in_obstacle(nearest_other.position)):\n                        connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + distance(new_node.position, nearest_other.position))\n                        new_node.add_child(connect_node)\n                        tree_a.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n\n                        final_path = extract_path(connect_node, nearest_other)\n                        success = True\n                        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
                "objective": -22.67929,
                "time_improvement": 87.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 69.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0033173322677612304,
                        "num_nodes_avg": 100.1,
                        "path_length_avg": 191.5904129756013,
                        "smoothness_avg": 0.011045755921847816,
                        "success_improvement": 0.0,
                        "time_improvement": 86.46619686115449,
                        "length_improvement": -5.013741296299677,
                        "smoothness_improvement": 72.89006641981574,
                        "objective_score": 23.29606461266562
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.010086965560913087,
                        "num_nodes_avg": 239.6,
                        "path_length_avg": 300.79732796596943,
                        "smoothness_avg": 0.0068730667022610685,
                        "success_improvement": 0.0,
                        "time_improvement": 94.36047214540207,
                        "length_improvement": -0.4148060460718591,
                        "smoothness_improvement": 76.84895671902345,
                        "objective_score": 28.443502799572624
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022200679779052733,
                        "num_nodes_avg": 323.7,
                        "path_length_avg": 170.4079668369994,
                        "smoothness_avg": 0.012308892026019971,
                        "success_improvement": 0.0,
                        "time_improvement": 79.73854047443936,
                        "length_improvement": -13.17685761774777,
                        "smoothness_improvement": 56.56819802307286,
                        "objective_score": 16.29828856179851
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e1",
            "algorithm_description": "A unidirectional RRT* inspired algorithm with adaptive neighbor search radius scaling, dynamic rewiring to improve path quality during incremental growth, and time-constrained exploration enforcing collision-free constraints and early stopping with best path returned. The planner grows a single tree from start, incrementally steering towards random samples, rewiring neighborhoods using a theoretically justified radius, and attempts direct connections to goal when in range to ensure path convergence.",
            "planning_mechanism": "A single tree rooted at the start expands by sampling random collision-free states within bounds. For each sampled point, the nearest tree node is steered towards it with a fixed step size. New nodes are connected to the lowest-cost neighbor found in a dynamically computed radius to improve path cost. Local rewiring is performed to optimize path quality. When a new node is close enough to the goal, the planner attempts to connect directly to the goal, validating collision-free edges and updating the best path if improved. The planning proceeds within a hard 30-second time limit, returning the best feasible path found so far.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Optional[Node]\n        self.cost = cost                 # Path cost to this node\n        self.children: List[\"Node\"] = [] # List of child nodes\n\n    def add_child(self, child: \"Node\") -> None:\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 50.0  # scaling for radius\n        self.max_radius = 60.0      # upper bound on neighbor radius\n        self.TIME_LIMIT = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node: Optional[Node] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.TIME_LIMIT:\n                break\n\n            rnd = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(nodes, rnd)\n            new_pos = self._steer(nearest.position, rnd)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near(nodes, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Find best parent from neighbors\n            for n in neighbors:\n                cost_through_n = n.cost + self._dist(n.position, new_pos)\n                if cost_through_n < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_n\n                    min_parent = n\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for n in neighbors:\n                if n == min_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire: remove old edge\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    # Add new parent-child edge\n                    new_node.add_child(n)\n                    n.cost = cost_through_new\n                    edges.append((new_node, n))\n\n            # Attempt connection to goal if close enough\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n            # Early stopping if solution found and time remains enough\n            if best_goal_node is not None and (time.monotonic() - start_time < self.TIME_LIMIT * 0.9):\n                # Optionally could prioritize more improvement, but here break early\n                break\n\n        success = (best_goal_node is not None)\n        extracted_path = best_goal_node.path_from_root() if success else []\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        attempts = 0\n        max_attempts = 1000\n        while attempts < max_attempts:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            attempts += 1\n        # fallback in case of dense obstacles\n        return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n    def _nearest(self, nodes: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(nodes, key=lambda n: self._dist(n.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _near(self, nodes: List[Node], position: Tuple[float, ...], bounds=None) -> List[Node]:\n        n = max(len(nodes), 1)\n        d = len(position)\n        scale = max(1.0, sum(bounds)/d if bounds is not None else 1.0)\n        radius_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = min(radius_theory * 1.1 + scale*0.01, self.max_radius)\n        # Return neighbors within radius\n        return [node for node in nodes if self._dist(node.position, position) <= radius]\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d, resolution=1.0) -> bool:\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 38.52299,
            "time_improvement": -160.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 169.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.13740262985229493,
                    "num_nodes_avg": 736.0,
                    "path_length_avg": 165.6389692973759,
                    "smoothness_avg": 0.015194004275516227,
                    "success_improvement": 0.0,
                    "time_improvement": -460.56493383329206,
                    "length_improvement": 9.210656210676376,
                    "smoothness_improvement": 137.81916122020544,
                    "objective_score": -131.95399061748077
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.24984548091888428,
                    "num_nodes_avg": 999.7,
                    "path_length_avg": 247.3606138345263,
                    "smoothness_avg": 0.008081446728356607,
                    "success_improvement": 0.0,
                    "time_improvement": -39.686265456022404,
                    "length_improvement": 17.423907221538386,
                    "smoothness_improvement": 107.9414451514142,
                    "objective_score": -0.9118280781266204
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08575613498687744,
                    "num_nodes_avg": 455.1,
                    "path_length_avg": 126.80630865397129,
                    "smoothness_avg": 0.02842277145458693,
                    "success_improvement": 0.0,
                    "time_improvement": 21.73462815563979,
                    "length_improvement": 15.781287659570605,
                    "smoothness_improvement": 261.5355549515882,
                    "objective_score": 17.296838817192242
                }
            ],
            "success_rate": 1.0
        },
        "objective": 101.8,
        "analysis": "1. Summary of key changes:\n   - Transitioned from bidirectional tree growth to a unidirectional RRT* style single tree expansion with dynamic rewiring.\n   - Refined neighbor radius calculation with scaled theoretical radius and adaptive connection range, improving rewiring efficiency.\n   - Introduced early stopping conditions based on solution quality and elapsed time to focus computation.\n   - Improved parent selection and rewiring procedure by systematically exploring neighbors and updating edges.\n   - Enhanced sampling robustness with capped attempts, reducing unnecessary obstacle collisions checks.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive rewiring with well-tuned neighbor radius leading to smoother and more optimal path branching.\n   - Efficient single-tree growth reduces overhead from managing two trees and complex tree swapping.\n   - Early stopping avoids over-expansion and unnecessary node insertions, enhancing usable path quality.\n   - More precise collision and edge checks during rewiring preserves smoothness and removes jagged path segments.\n\n3. Expected mechanism of impact:\n   - Streamlined tree structure and rewiring facilitate convergence to lower-cost, smoother paths by locally optimizing parent-child connections.\n   - Refined radius scaling increases candidate neighbors for rewiring, enabling better path cost improvements and curvature reduction.\n   - Early termination after finding a solution avoids introducing noisy exploratory nodes that degrade smoothness.\n   - Consistent, accurate obstacle and edge validity checking ensures paths away from obstacles are smooth and continuous."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.893579481866173,
                "time_improvement": 56.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 178.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0102372407913208,
                        "num_nodes_avg": 117.5,
                        "path_length_avg": 167.09773058241916,
                        "smoothness_avg": 0.01743061917619911,
                        "success_improvement": 0.0,
                        "time_improvement": 59.25898163821438,
                        "length_improvement": 8.411086034792367,
                        "smoothness_improvement": 172.82704130288656,
                        "objective_score": 23.688481318854166
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02068014144897461,
                        "num_nodes_avg": 270.5,
                        "path_length_avg": 254.91986206815108,
                        "smoothness_avg": 0.010869990893363076,
                        "success_improvement": 0.0,
                        "time_improvement": 87.1335117617854,
                        "length_improvement": 14.900412580258132,
                        "smoothness_improvement": 179.6926950242082,
                        "objective_score": 35.978764551811544
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03835470676422119,
                        "num_nodes_avg": 352.3,
                        "path_length_avg": 131.0348919324295,
                        "smoothness_avg": 0.02219113712511561,
                        "success_improvement": 0.0,
                        "time_improvement": 21.061420166541545,
                        "length_improvement": 12.97286398951632,
                        "smoothness_improvement": 182.26962625211246,
                        "objective_score": 15.013492574932817
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.256651771997145,
                "time_improvement": 85.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.005163788795471191,
                        "num_nodes_avg": 88.6,
                        "path_length_avg": 194.6296584579342,
                        "smoothness_avg": 0.01167543363104651,
                        "success_improvement": 0.0,
                        "time_improvement": 79.44973470673519,
                        "length_improvement": -6.679599905092896,
                        "smoothness_improvement": 82.74588993580629,
                        "objective_score": 20.24088991864385
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.014127516746520996,
                        "num_nodes_avg": 235.1,
                        "path_length_avg": 298.3796473209629,
                        "smoothness_avg": 0.007304556076322401,
                        "success_improvement": 0.0,
                        "time_improvement": 91.21033439240306,
                        "length_improvement": 0.3922853423102244,
                        "smoothness_improvement": 87.95148910285546,
                        "objective_score": 28.03822896862133
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.007713985443115234,
                        "num_nodes_avg": 141.8,
                        "path_length_avg": 161.00482297708567,
                        "smoothness_avg": 0.014351820764112542,
                        "success_improvement": 0.0,
                        "time_improvement": 84.12369414062309,
                        "length_improvement": -6.931737195586904,
                        "smoothness_improvement": 82.55410077829661,
                        "objective_score": 21.490836428726265
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
            "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
            "objective": 5.46059,
            "time_improvement": -53.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 293.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06232309341430664,
                    "num_nodes_avg": 267.2,
                    "path_length_avg": 168.2463107739374,
                    "smoothness_avg": 0.02259680420437422,
                    "success_improvement": 0.0,
                    "time_improvement": -148.0264306480139,
                    "length_improvement": 7.781531031403382,
                    "smoothness_improvement": 253.68905554417486,
                    "objective_score": -38.47056529784127
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08523426055908204,
                    "num_nodes_avg": 568.0,
                    "path_length_avg": 241.3226903680994,
                    "smoothness_avg": 0.016808760155440354,
                    "success_improvement": 0.0,
                    "time_improvement": 46.970110737287854,
                    "length_improvement": 19.439539866622514,
                    "smoothness_improvement": 332.5015056600573,
                    "objective_score": 27.41726466946015
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07625963687896728,
                    "num_nodes_avg": 483.4,
                    "path_length_avg": 124.7326333683994,
                    "smoothness_avg": 0.03084680379066026,
                    "success_improvement": 0.0,
                    "time_improvement": -56.951465457596676,
                    "length_improvement": 17.15852404644154,
                    "smoothness_improvement": 292.3690673429857,
                    "objective_score": -5.328479872699152
                }
            ],
            "success_rate": 1.0
        },
        "objective": 129.79999999999998,
        "analysis": "1. Summary of key changes:\n   - Offspring integrates a fixed rewiring radius with dynamic rewiring of nearby nodes to optimize tree structure incrementally.\n   - Offspring incorporates a goal bias sampling strategy (5%) to preferentially sample near the goal, expediting solution discovery.\n   - Offspring performs early termination immediately after finding the first feasible path to reduce computation time.\n   - Offspring applies improved parent selection during rewiring, minimizing path cost with stricter collision checks.\n   - Offspring removes duplicate connection points when extracting the path from concatenated trees, improving path continuity.\n\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling directs exploration effectively towards the goal, speeding up convergence to a solution.\n   - Local rewiring with a carefully chosen fixed radius enhances path quality by optimizing connections and reducing redundant nodes.\n   - Early stopping after the first successful path reduces unnecessary iterations, improving planning time.\n   - Enhanced edge collision checking during rewiring prevents invalid connections, improving path smoothness.\n\n3. Expected mechanism of impact:\n   - Focused sampling and rewiring concentrate computational resources in promising regions, accelerating improvement of path cost and smoothness.\n   - Incremental rewiring continuously refines the tree structure, smoothing the path and reducing jagged segments.\n   - Early termination prevents wasteful expansions once a viable smooth solution exists, lowering planning time.\n   - Stricter collision checks maintain valid, smooth edges, preventing sharp, infeasible path corrections."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 69.43496400372943,
                "time_improvement": -276.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 165.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05916297435760498,
                        "num_nodes_avg": 394.9,
                        "path_length_avg": 155.53505227340733,
                        "smoothness_avg": 0.014549204278916808,
                        "success_improvement": 0.0,
                        "time_improvement": -135.4501446019083,
                        "length_improvement": 14.748773238324494,
                        "smoothness_improvement": 127.72664106782084,
                        "objective_score": -31.14714623223869
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.580695104598999,
                        "num_nodes_avg": 1589.2,
                        "path_length_avg": 226.77578579094256,
                        "smoothness_avg": 0.011489796720712679,
                        "success_improvement": 0.0,
                        "time_improvement": -261.2889569322687,
                        "length_improvement": 24.29571532390974,
                        "smoothness_improvement": 195.64074539000617,
                        "objective_score": -62.831054158384745
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.25779869556427004,
                        "num_nodes_avg": 856.3,
                        "path_length_avg": 115.47581220588968,
                        "smoothness_avg": 0.02144048255314569,
                        "success_improvement": 0.0,
                        "time_improvement": -430.58058912720264,
                        "length_improvement": 23.30646390012476,
                        "smoothness_improvement": 172.72135550421203,
                        "objective_score": -114.32669162056487
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
                "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
                "objective": 295.47898,
                "time_improvement": -1033.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 256.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.5913747787475586,
                        "num_nodes_avg": 758.0,
                        "path_length_avg": 151.24830260208697,
                        "smoothness_avg": 0.02058925094950933,
                        "success_improvement": 0.0,
                        "time_improvement": -2253.4867656993647,
                        "length_improvement": 17.098408661070636,
                        "smoothness_improvement": 222.2664876338706,
                        "objective_score": -664.6756520749976
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5786649703979492,
                        "num_nodes_avg": 1014.8,
                        "path_length_avg": 223.7199642443417,
                        "smoothness_avg": 0.014513759212874738,
                        "success_improvement": 0.0,
                        "time_improvement": -260.02587573506054,
                        "length_improvement": 25.31583651311142,
                        "smoothness_improvement": 273.4494783854807,
                        "objective_score": -61.451013420723896
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.333528995513916,
                        "num_nodes_avg": 730.1,
                        "path_length_avg": 114.76663509983318,
                        "smoothness_avg": 0.029182927141035354,
                        "success_improvement": 0.0,
                        "time_improvement": -586.442615791514,
                        "length_improvement": 23.777465566582624,
                        "smoothness_improvement": 271.20467917435593,
                        "objective_score": -160.31028200163283
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
            "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 34.24822,
            "time_improvement": -158.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 287.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05595297813415527,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 160.14345768443917,
                    "smoothness_avg": 0.020991279248420664,
                    "success_improvement": 0.0,
                    "time_improvement": -122.67536302290098,
                    "length_improvement": 12.22283320768113,
                    "smoothness_improvement": 228.55910353025726,
                    "objective_score": -28.326113464610327
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23264851570129394,
                    "num_nodes_avg": 948.8,
                    "path_length_avg": 225.03802962507376,
                    "smoothness_avg": 0.017004339084283518,
                    "success_improvement": 0.0,
                    "time_improvement": -44.746079145276,
                    "length_improvement": 24.875828350614626,
                    "smoothness_improvement": 337.5338923690004,
                    "objective_score": 3.189342728630977
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19719173908233642,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 118.75610965494363,
                    "smoothness_avg": 0.030953946710724024,
                    "success_improvement": 0.0,
                    "time_improvement": -305.8442144725285,
                    "length_improvement": 21.127846525442067,
                    "smoothness_improvement": 293.73191737772913,
                    "objective_score": -77.60789683960466
                }
            ],
            "success_rate": 1.0
        },
        "objective": 159.79999999999998,
        "analysis": "1. Summary of key changes:\n   - Transitioned from bidirectional to single-tree RRT* algorithm in the offspring, reducing complexity.\n   - Implemented fixed and sufficiently large neighbor radius for rewiring and parent selection.\n   - Introduced early termination immediately upon first goal connection.\n   - Added goal bias sampling (5%) to accelerate convergence towards the goal.\n2. Primary contributors to the performance improvement:\n   - Simplified single-tree structure reduces overhead in neighbor searches and rewiring operations.\n   - Larger and fixed rewiring radius enhances local tree optimization, improving path smoothness.\n   - Early stopping upon finding a path avoids unnecessary iterations, reducing runtime.\n   - More frequent rewiring and parent updating locally optimize the tree to produce smoother trajectories.\n3. Expected mechanism of impact:\n   - Reduced algorithmic complexity streamlines planning iterations, lowering planning time.\n   - Efficient local rewiring smooths path trajectories by minimizing cost through node reconnections.\n   - Goal-biased sampling focuses exploration near the goal, improving both path length and smoothness.\n   - Early termination prevents over-exploration, further increasing efficiency without compromising smoothness."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping. The planner dynamically adjusts neighbor search radius based on the number of nodes to balance exploration and exploitation, incorporates goal bias with a higher sampling rate for faster convergence, and performs incremental rewiring using efficient neighbor queries. Collision checks are optimized with adaptive edge resolution, and the planner terminates immediately once the goal is connected, ensuring reduced planning time with high-quality, smooth paths.",
                "planning_mechanism": "The algorithm incrementally grows a single tree from start, sampling randomly with goal bias, and steering toward samples with fixed step size. It dynamically computes neighbors within an adaptive radius proportional to log(n)/n for better rewiring efficiency. For each new node, the best parent minimizing cost and verified for collision is chosen, followed by local rewiring to improve path cost and smoothness. Early termination upon reaching the goal with collision-free connection guarantees fast runtime and high success rates.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        final_path = []\n\n        # To accelerate nearest neighbor queries, store positions separately\n        positions = [root.position]\n\n        # Adaptive neighbor radius: r = gamma * (log(n)/n)^{1/d} with gamma tuned for good rewiring\n        # Gamma chosen as 30.0 for moderate neighbor count\n        gamma = 30.0\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return gamma\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 20)\n\n        # Optimized collision checking resolution based on step_size and distance\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size/2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Main loop\n        for iter_id in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Time limit reached, break with best path if any\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search (linear, as no k-d tree available)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision from nearest_node to new_pos\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius search\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Choose best parent minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improving cost\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list carefully\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if goal can connect directly\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n\n                    # Backtrack path\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success but nodes exist, extract path from best node near goal\n        if not success and len(nodes) > 1:\n            # Find node closest to goal\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                # Extract path backwards\n                path = []\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 24.4788,
                "time_improvement": -89.0,
                "length_improvement": 3.0,
                "smoothness_improvement": 112.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015737581253051757,
                        "num_nodes_avg": 191.3,
                        "path_length_avg": 179.56403283207513,
                        "smoothness_avg": 0.01421437809371725,
                        "success_improvement": 0.0,
                        "time_improvement": 37.36934591357285,
                        "length_improvement": 1.5781082305555436,
                        "smoothness_improvement": 122.48588418274917,
                        "objective_score": 12.770098133318925
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14423696994781493,
                        "num_nodes_avg": 916.7,
                        "path_length_avg": 303.4419163034794,
                        "smoothness_avg": 0.007145793076982586,
                        "success_improvement": 0.0,
                        "time_improvement": 10.260610067476575,
                        "length_improvement": -1.2976457533873764,
                        "smoothness_improvement": 83.86640277747577,
                        "objective_score": 2.7189275820979253
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.20188889503479004,
                        "num_nodes_avg": 778.9,
                        "path_length_avg": 137.83772884194133,
                        "smoothness_avg": 0.01816319064757809,
                        "success_improvement": 0.0,
                        "time_improvement": -315.51152394832013,
                        "length_improvement": 8.454743630501442,
                        "smoothness_improvement": 131.03444436991745,
                        "objective_score": -88.92543878434559
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
            "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": 18.33169,
            "time_improvement": -104.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 277.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03312251567840576,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 163.67692862769394,
                    "smoothness_avg": 0.020726203772078875,
                    "success_improvement": 0.0,
                    "time_improvement": -31.81725886398311,
                    "length_improvement": 10.28608179225304,
                    "smoothness_improvement": 224.41009670489822,
                    "objective_score": -2.251478100318617
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2541221618652344,
                    "num_nodes_avg": 968.5,
                    "path_length_avg": 223.78483919358527,
                    "smoothness_avg": 0.016494501307333334,
                    "success_improvement": 0.0,
                    "time_improvement": -58.106259320137475,
                    "length_improvement": 25.29417938773204,
                    "smoothness_improvement": 324.4153991467646,
                    "objective_score": -0.633293167668195
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15669703483581543,
                    "num_nodes_avg": 482.5,
                    "path_length_avg": 117.3805344167902,
                    "smoothness_avg": 0.030113844927462913,
                    "success_improvement": 0.0,
                    "time_improvement": -222.5012635370204,
                    "length_improvement": 22.04143810076968,
                    "smoothness_improvement": 283.0458847045111,
                    "objective_score": -52.11028677712176
                }
            ],
            "success_rate": 1.0
        },
        "objective": 100.19999999999999,
        "analysis": "1. Summary of key changes:\n   - Incorporated informed sampling within an ellipsoidal subset focused on the current best path cost for guided exploration.\n   - Introduced a fixed neighbor radius for rewiring instead of an adaptive radius dependent on node count.\n   - Early termination immediately upon finding a feasible path connecting to the goal.\n   - Enhanced collision checking with adaptive edge resolution and clear separation of node and edge validity checks.\n   - Increased maximum iterations and goal sampling rate for improved convergence.\n\n2. Primary contributors to the performance improvement:\n   - Heuristic-guided informed sampling reduced irrelevant exploration, concentrating sampling near promising paths and improving path smoothness.\n   - Early stopping prevented unnecessary exploration once a feasible path was found, optimizing time efficiency.\n   - Fixed radius rewiring ensured consistent local connectivity leading to better cost improvements and smoother path segments.\n   - Improved collision checking reliability and efficiency ensured fewer invalid node expansions and rewiring operations.\n\n3. Expected mechanism of impact:\n   - Informed sampling focused search effort in a smaller subset of space, accelerating convergence to shorter and smoother paths.\n   - Early termination reduced computational overhead by halting the planner after first successful solution.\n   - Fixed-radius neighbor rewiring facilitated stable local path improvements that reduce jaggedness in the final path.\n   - Better collision checks minimized costly invalid operations, enhancing overall planner responsiveness and path quality."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 69.43496400372943,
                "time_improvement": -276.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 165.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05916297435760498,
                        "num_nodes_avg": 394.9,
                        "path_length_avg": 155.53505227340733,
                        "smoothness_avg": 0.014549204278916808,
                        "success_improvement": 0.0,
                        "time_improvement": -135.4501446019083,
                        "length_improvement": 14.748773238324494,
                        "smoothness_improvement": 127.72664106782084,
                        "objective_score": -31.14714623223869
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.580695104598999,
                        "num_nodes_avg": 1589.2,
                        "path_length_avg": 226.77578579094256,
                        "smoothness_avg": 0.011489796720712679,
                        "success_improvement": 0.0,
                        "time_improvement": -261.2889569322687,
                        "length_improvement": 24.29571532390974,
                        "smoothness_improvement": 195.64074539000617,
                        "objective_score": -62.831054158384745
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.25779869556427004,
                        "num_nodes_avg": 856.3,
                        "path_length_avg": 115.47581220588968,
                        "smoothness_avg": 0.02144048255314569,
                        "success_improvement": 0.0,
                        "time_improvement": -430.58058912720264,
                        "length_improvement": 23.30646390012476,
                        "smoothness_improvement": 172.72135550421203,
                        "objective_score": -114.32669162056487
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with adaptive rewiring and efficient neighbor search to produce asymptotically optimal, smooth, and shorter paths with reduced computational overhead. It incrementally samples free space, extends the tree toward random samples respecting obstacle constraints, selects optimal parents among nearby nodes, rewires neighbors to minimize cost, and stops early upon finding a valid path within a time limit.",
                "planning_mechanism": "The planner grows a single tree from start towards goal by iteratively sampling collision-free points and steering incrementally toward them. For each new node, it finds neighbors inside an adaptively scaled radius, picks the best parent minimizing path cost, adds the node, and rewires neighbors if rewiring reduces costs. The search stops when the goal is reachable within a step size and the path is extracted. Using incremental rewiring and efficient local radius scaling improves path smoothness and length. A hard time limit caps search effort, returning best found path if time runs out.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=30.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        tree = []\n\n        start_node = Node(start_pos, None, 0.0)\n        tree.append(start_node)\n        nodes.append(start_node)\n\n        success = False\n        best_goal_node = None\n        dist_goal = self._distance(start_pos, goal_pos)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, rand)\n            new_pos = self._steer(nearest.position, rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            # Choose best parent\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # rewire nb to new_node\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n            # Check if goal can be connected\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        best_goal_node = goal_node\n                        break\n\n        path = best_goal_node.path_from_root() if success else []\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, pos, bounds):\n        n = len(tree)\n        d = len(pos)\n        if n <= 1:\n            return [tree[0]] if tree else []\n        scale = max(1.0, sum(bounds)/d)\n        radius_theory = self.gamma * ((math.log(n)/n) ** (1/d))\n        radius = min(self.max_radius, max(self.step_size*2, radius_theory * 0.5 + scale * 0.01))\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 342.00038,
                "time_improvement": -1177.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 182.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.6105502605438232,
                        "num_nodes_avg": 637.2,
                        "path_length_avg": 162.9455247662491,
                        "smoothness_avg": 0.016476664782690602,
                        "success_improvement": 0.0,
                        "time_improvement": -2329.7991893184353,
                        "length_improvement": 10.686975838546811,
                        "smoothness_improvement": 157.89558349935672,
                        "objective_score": -691.7380933749057
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 1.039361596107483,
                        "num_nodes_avg": 1016.0,
                        "path_length_avg": 234.23682240353804,
                        "smoothness_avg": 0.01151286991709365,
                        "success_improvement": 0.0,
                        "time_improvement": -546.6558163813695,
                        "length_improvement": 21.805006548593838,
                        "smoothness_improvement": 196.23443535184018,
                        "objective_score": -149.93256880849535
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.36697118282318114,
                        "num_nodes_avg": 582.3,
                        "path_length_avg": 122.24375464796276,
                        "smoothness_avg": 0.02301578213338744,
                        "success_improvement": 0.0,
                        "time_improvement": -655.2706422693615,
                        "length_improvement": 18.81151878488672,
                        "smoothness_improvement": 192.7590498883673,
                        "objective_score": -184.3304861604346
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
            "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 9.11942,
            "time_improvement": -70.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 182.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02458224296569824,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 160.91673392411104,
                    "smoothness_avg": 0.01622189562126349,
                    "success_improvement": 0.0,
                    "time_improvement": 2.170356988333177,
                    "length_improvement": 11.798988247370831,
                    "smoothness_improvement": 153.90789288293342,
                    "objective_score": 8.50003950933712
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16582508087158204,
                    "num_nodes_avg": 988.6,
                    "path_length_avg": 230.06388904405716,
                    "smoothness_avg": 0.011826311396694525,
                    "success_improvement": 0.0,
                    "time_improvement": -3.170786229848748,
                    "length_improvement": 23.198051815215557,
                    "smoothness_improvement": 204.29951038474306,
                    "objective_score": 13.989092772098425
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14947149753570557,
                    "num_nodes_avg": 650.0,
                    "path_length_avg": 121.70930984019235,
                    "smoothness_avg": 0.022669727327406998,
                    "success_improvement": 0.0,
                    "time_improvement": -207.63024245189973,
                    "length_improvement": 19.166471578680884,
                    "smoothness_improvement": 188.3572582994048,
                    "objective_score": -49.84740349686436
                }
            ],
            "success_rate": 1.0
        },
        "objective": 109.2,
        "analysis": "1. Summary of key changes:\n   - Introduced goal bias sampling to more frequently sample the goal region and guide the tree growth efficiently.\n   - Used a fixed rewiring radius to select neighbors for parent selection and rewiring, streamlining the neighborhood definition.\n   - Early termination upon connecting a node directly to the goal, reducing unnecessary iteration after path discovery.\n   - Simplified and more robust parent-child relationship management, including safe removal of child nodes in rewiring.\n   - Consistent bounding checks and collision avoidance incorporated before node addition and edge creation.\n\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling reduced exploration of irrelevant areas, accelerating goal reach.\n   - Fixed rewiring radius limited neighbor searches, reducing computational overhead.\n   - Early stopping prevented wasteful computation after successful path finding.\n   - More efficient management of node parent updates and edge lists minimized bookkeeping overhead during rewiring.\n\n3. Expected mechanism of impact:\n   - Biasing sampling toward the goal increases probability of direct path discovery, thus lowering planning time.\n   - Restricting rewiring to a fixed radius decreases the number of collision checks and cost calculations required.\n   - Early termination saves runtime by halting planner once a feasible solution is found.\n   - Cleaner update of parent-child links and edges reduces inefficiencies and errors in the tree structure maintenance, improving stability and speed."
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
                "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 34.24822,
                "time_improvement": -158.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 287.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05595297813415527,
                        "num_nodes_avg": 282.7,
                        "path_length_avg": 160.14345768443917,
                        "smoothness_avg": 0.020991279248420664,
                        "success_improvement": 0.0,
                        "time_improvement": -122.67536302290098,
                        "length_improvement": 12.22283320768113,
                        "smoothness_improvement": 228.55910353025726,
                        "objective_score": -28.326113464610327
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.23264851570129394,
                        "num_nodes_avg": 948.8,
                        "path_length_avg": 225.03802962507376,
                        "smoothness_avg": 0.017004339084283518,
                        "success_improvement": 0.0,
                        "time_improvement": -44.746079145276,
                        "length_improvement": 24.875828350614626,
                        "smoothness_improvement": 337.5338923690004,
                        "objective_score": 3.189342728630977
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.19719173908233642,
                        "num_nodes_avg": 505.7,
                        "path_length_avg": 118.75610965494363,
                        "smoothness_avg": 0.030953946710724024,
                        "success_improvement": 0.0,
                        "time_improvement": -305.8442144725285,
                        "length_improvement": 21.127846525442067,
                        "smoothness_improvement": 293.73191737772913,
                        "objective_score": -77.60789683960466
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
            "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -7.73775,
            "time_improvement": -3.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 143.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031192827224731445,
                    "num_nodes_avg": 228.2,
                    "path_length_avg": 173.47041072322037,
                    "smoothness_avg": 0.016212433782287948,
                    "success_improvement": 0.0,
                    "time_improvement": -24.137702006209146,
                    "length_improvement": 4.918119068040286,
                    "smoothness_improvement": 153.759794556254,
                    "objective_score": -3.521640188257302
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1286400556564331,
                    "num_nodes_avg": 775.0,
                    "path_length_avg": 247.3898406969005,
                    "smoothness_avg": 0.00894525060365523,
                    "success_improvement": 0.0,
                    "time_improvement": 19.964485390459707,
                    "length_improvement": 17.414150453629286,
                    "smoothness_improvement": 130.16774103563074,
                    "objective_score": 17.088674594493636
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050321340560913086,
                    "num_nodes_avg": 417.3,
                    "path_length_avg": 125.51343547763591,
                    "smoothness_avg": 0.01937830391026074,
                    "success_improvement": 0.0,
                    "time_improvement": -3.567345296452773,
                    "length_improvement": 16.639952463287656,
                    "smoothness_improvement": 146.4905953809094,
                    "objective_score": 9.64622086594131
                }
            ],
            "success_rate": 1.0
        },
        "objective": 143.4,
        "analysis": "1. Summary of key changes:\n   - Adaptive rewiring radius based on current node density replaced fixed neighbor radius.\n   - Informed sampling within an ellipsoidal region focused search near start-goal, replacing uniform random sampling.\n   - Early termination upon finding a better goal node improved planning efficiency.\n   - Periodic pruning of suboptimal and isolated nodes reduced graph complexity.\n   - Increased goal sampling rate for more frequent direct goal bias.\n2. Primary contributors to the performance improvement:\n   - Adaptive rewiring radius reduced unnecessary neighbor checks, improving planning time.\n   - Informed sampling guided candidate nodes to relevant regions, leading to shorter and smoother paths.\n   - Pruning removed costly or disconnected nodes, maintaining a more streamlined and higher-quality tree structure.\n3. Expected mechanism of impact:\n   - Reduced computational overhead from neighbor searches and collision checks lowered planning time.\n   - Concentrated sampling in the ellipse towards the goal enabled more efficient exploration and path refinement.\n   - Frequent rewiring with adaptive radius and pruning improved path cost and smoothed trajectories by promoting better parent connections and eliminating poor branches."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.893579481866173,
                "time_improvement": 56.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 178.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0102372407913208,
                        "num_nodes_avg": 117.5,
                        "path_length_avg": 167.09773058241916,
                        "smoothness_avg": 0.01743061917619911,
                        "success_improvement": 0.0,
                        "time_improvement": 59.25898163821438,
                        "length_improvement": 8.411086034792367,
                        "smoothness_improvement": 172.82704130288656,
                        "objective_score": 23.688481318854166
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02068014144897461,
                        "num_nodes_avg": 270.5,
                        "path_length_avg": 254.91986206815108,
                        "smoothness_avg": 0.010869990893363076,
                        "success_improvement": 0.0,
                        "time_improvement": 87.1335117617854,
                        "length_improvement": 14.900412580258132,
                        "smoothness_improvement": 179.6926950242082,
                        "objective_score": 35.978764551811544
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03835470676422119,
                        "num_nodes_avg": 352.3,
                        "path_length_avg": 131.0348919324295,
                        "smoothness_avg": 0.02219113712511561,
                        "success_improvement": 0.0,
                        "time_improvement": 21.061420166541545,
                        "length_improvement": 12.97286398951632,
                        "smoothness_improvement": 182.26962625211246,
                        "objective_score": 15.013492574932817
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with efficient neighbor selection, rewiring, and early stopping to improve generalization, reduce complexity, and maintain robust path quality and smoothness within a 30-second time limit. It grows a single tree from start to goal by sampling collision-free points, steering incrementally, selecting the lowest-cost parent from neighbors within a dynamically scaled radius, rewiring neighbors to reduce cost, and terminating once a path to the goal is found.",
                "planning_mechanism": "The planner builds a tree rooted at the start by iteratively sampling free points, steering toward them with fixed step size, choosing optimal parent nodes from a radius-based neighborhood, applying local rewiring to minimize path costs, and returning the best path within a time budget or when the goal neighborhood is reached.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, neighbor_gamma: float=50.0, goal_radius: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_radius = max(bounds)*0.3\n        min_radius = max(10.0, self.step_size*2.0)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: return start (rare)\n            return start_pos\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return min_radius\n            r = self.neighbor_gamma * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            return min(max_radius, max(min_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if math.dist(n.position, pos) <= radius]\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached, return best found\n                return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, r)\n            # Select best parent in neighbors with valid edge\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                # fallback to nearest_node if edge free\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Rewire: update parent and cost, edges lists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            # Check if goal reached\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path)-1):\n                    cost += math.dist(path[i], path[i+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 680.61663,
                "time_improvement": -2311.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 212.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.2963702201843261,
                        "num_nodes_avg": 798.3,
                        "path_length_avg": 153.40311775845035,
                        "smoothness_avg": 0.01867232962112822,
                        "success_improvement": 0.0,
                        "time_improvement": -5059.148253011591,
                        "length_improvement": 15.917320328636658,
                        "smoothness_improvement": 192.26250618341595,
                        "objective_score": -1507.2327711753783
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 1.0090357303619384,
                        "num_nodes_avg": 1116.8,
                        "path_length_avg": 232.92130464304964,
                        "smoothness_avg": 0.011711985498954181,
                        "success_improvement": 0.0,
                        "time_improvement": -527.788083010616,
                        "length_improvement": 22.244164242124114,
                        "smoothness_improvement": 201.3578226902683,
                        "objective_score": -143.983137244459
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7028919219970703,
                        "num_nodes_avg": 837.6,
                        "path_length_avg": 120.10951944487313,
                        "smoothness_avg": 0.0270341704816116,
                        "success_improvement": 0.0,
                        "time_improvement": -1346.6357529453908,
                        "length_improvement": 20.22897618541956,
                        "smoothness_improvement": 243.8726530712041,
                        "objective_score": -390.63397690700947
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
            "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 34.17936,
            "time_improvement": -148.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 307.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06862092018127441,
                    "num_nodes_avg": 284.0,
                    "path_length_avg": 170.5991073480199,
                    "smoothness_avg": 0.023639461522089605,
                    "success_improvement": 0.0,
                    "time_improvement": -173.08981258681808,
                    "length_improvement": 6.491925946701232,
                    "smoothness_improvement": 270.00890673302524,
                    "objective_score": -46.68174367435956
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09145197868347169,
                    "num_nodes_avg": 589.8,
                    "path_length_avg": 238.92126140318732,
                    "smoothness_avg": 0.017217767150899767,
                    "success_improvement": 0.0,
                    "time_improvement": 43.10165571180447,
                    "length_improvement": 20.24120597641038,
                    "smoothness_improvement": 343.0255502490592,
                    "objective_score": 26.790348050632865
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20080511569976806,
                    "num_nodes_avg": 632.2,
                    "path_length_avg": 125.97622721535136,
                    "smoothness_avg": 0.03204491385721169,
                    "success_improvement": 0.0,
                    "time_improvement": -313.2809762847595,
                    "length_improvement": 16.332588226871458,
                    "smoothness_improvement": 307.60893895423396,
                    "objective_score": -82.6466952545338
                }
            ],
            "success_rate": 1.0
        },
        "objective": 146.2,
        "analysis": "1. Summary of key changes:\n   - Offspring algorithm introduces goal bias sampling to preferentially sample near the goal.\n   - Implements a fixed rewiring radius for neighbor selection and rewiring to optimize path quality.\n   - Early stopping is employed once connection between trees is found, reducing unnecessary computation.\n   - Uses bidirectional trees with continuous rewiring and collision checking on edges for safe and optimal connections.\n2. Primary contributors to the performance improvement:\n   - Goal bias accelerates convergence toward the goal, improving planning time and path quality.\n   - Rewiring within a radius optimizes parent-child relationships to reduce path cost and increase smoothness.\n   - Early termination on successful tree connection reduces runtime and limits path complexity.\n3. Expected mechanism of impact:\n   - Goal bias sampling reduces random exploration and enables faster discovery of feasible paths.\n   - Rewiring refines and smooths path connections, reducing sharp turns and redundant detours.\n   - Early stopping ensures only necessary nodes are added, preventing overgrowth of trees and reducing planning overhead."
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
                "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 9.11942,
                "time_improvement": -70.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 182.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02458224296569824,
                        "num_nodes_avg": 235.2,
                        "path_length_avg": 160.91673392411104,
                        "smoothness_avg": 0.01622189562126349,
                        "success_improvement": 0.0,
                        "time_improvement": 2.170356988333177,
                        "length_improvement": 11.798988247370831,
                        "smoothness_improvement": 153.90789288293342,
                        "objective_score": 8.50003950933712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.16582508087158204,
                        "num_nodes_avg": 988.6,
                        "path_length_avg": 230.06388904405716,
                        "smoothness_avg": 0.011826311396694525,
                        "success_improvement": 0.0,
                        "time_improvement": -3.170786229848748,
                        "length_improvement": 23.198051815215557,
                        "smoothness_improvement": 204.29951038474306,
                        "objective_score": 13.989092772098425
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.14947149753570557,
                        "num_nodes_avg": 650.0,
                        "path_length_avg": 121.70930984019235,
                        "smoothness_avg": 0.022669727327406998,
                        "success_improvement": 0.0,
                        "time_improvement": -207.63024245189973,
                        "length_improvement": 19.166471578680884,
                        "smoothness_improvement": 188.3572582994048,
                        "objective_score": -49.84740349686436
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "This algorithm enhances bidirectional path planning by combining fast tree connections with adaptive rewiring and informed sampling. It employs a priority-expand strategy, dynamically updating a k-d tree for efficient nearest neighbor search, and limits search within an ellipsoidal informed subset after initial solution detection. The planner performs meticulous collision checking and gradual rewiring to optimize path smoothness, length, and planning efficiency, halting early upon convergence or time expiration.",
                "planning_mechanism": "The method grows two RRT* trees alternately from start and goal with adaptive radius rewiring and efficient nearest neighbor search using a k-d tree. It attempts to greedily connect the trees at each iteration, switching to informed ellipsoidal sampling after first feasible path discovery to focus search near the optimum. Each new node selects the best parent from nearby nodes, rewires neighbors to reduce costs, and updates the best path when connections form. The algorithm stops after no improvement for a threshold number of iterations or a hard time limit (30s), returning the best solution found.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # (x,y) or (x,y,z)\n        self.parent = parent                # type: Node or None\n        self.cost = cost                    # path cost from root\n        self.children: List[Node] = []\n        self.valid = True                   # for obstacle validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_no_improve: int=120, post_opt_iters: int=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_bound = max(bounds)\n\n        # Initialize nodes and trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Parameters for radius calculation\n        gamma_rrt_star = 50.0\n        radius_max = max_bound * 0.25\n        radius_min = max(5.0, self.step_size * 2.0)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return radius_min\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(radius_min, min(radius_max, r))\n\n        # Efficient distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check point bounds\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Steering with fixed step size limiting\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        # Collision checks\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest neighbor search (linear brute-force)\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            rn = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if d_sq <= r_sq:\n                    rn.append(node)\n            return rn\n\n        # Best parent selection with collision check\n        def choose_best_parent(tree, new_pos):\n            r = neighbor_radius(len(tree))\n            nbrs = near_nodes(tree, new_pos, r)\n            candidates = [n for n in nbrs if not is_edge_in_obstacle(n.position, new_pos)]\n            if not candidates:\n                # fallback to nearest if nbrs empty or all invalid\n                n_near = nearest(tree, new_pos)\n                if not is_edge_in_obstacle(n_near.position, new_pos):\n                    candidates = [n_near]\n                else:\n                    return None, []\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        # Rewiring neighbors for improved paths\n        def try_rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if is_edge_in_obstacle(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Update tree structure\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        # Path cost utility\n        def path_cost(pth):\n            c = 0.0\n            for i in range(len(pth)-1):\n                c += dist(pth[i], pth[i+1])\n            return c\n\n        # Stitch paths from meeting nodes\n        def stitch_paths(node_a, node_b, a_from_start):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                full = path_a + path_b[-2::-1]\n            else:\n                full = path_a + path_b[::-1]\n            return full if a_from_start else full[::-1]\n\n        # Informed sampling within ellipsoid\n        def sample_informed(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(max(val, 0.0))/2.0\n\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_rest)\n            else:\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_rest, r_rest)\n\n            u = self._sample_unit_ball(dim)\n            mapped = [center[d] + sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # clamp in bounds\n            return tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n\n        # Helpers for cross product etc\n        def cross(a,b):\n            ax,ay,az = a\n            bx,by,bz = b\n            return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n        def norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def normalize(v):\n            n = norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x/n for x in v)\n\n        self._cross = cross\n        self._norm = norm\n        self._normalize = normalize\n        self._sample_unit_ball = lambda dim: self.__sample_unit_ball(dim)\n\n        best_path = []\n        best_cost = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        found_first_solution = False\n        no_improve_streak = 0\n        post_opt_progress = 0\n\n        start_time = time.monotonic()\n\n        use_informed = False\n\n        # Alternate growing start vs goal trees\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:  # Hard limit 30s\n                break\n\n            if it % 2 == 0:\n                tree_grow = tree_start\n                tree_other = tree_goal\n                a_from_start = True\n            else:\n                tree_grow = tree_goal\n                tree_other = tree_start\n                a_from_start = False\n\n            # Sample point\n            if use_informed:\n                sample = sample_informed(start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Skip sample if in obstacle or out of bounds\n            if (not within_bounds(sample)) or is_in_obstacle(sample):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Steer and check edge collision\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Add new node with best parent and rewiring\n            new_node, neighbors = choose_best_parent(tree_grow, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            try_rewire(new_node, neighbors)\n\n            # Attempt greedy connect from other tree toward new_node\n            other_nearest = nearest(tree_other, new_node.position)\n            current = other_nearest\n            connected_node = None\n\n            while True:\n                step_toward = steer(current.position, new_node.position)\n                if (not within_bounds(step_toward)) or is_in_obstacle(step_toward):\n                    break\n                if is_edge_in_obstacle(current.position, step_toward):\n                    break\n\n                add_node, add_neighbors = choose_best_parent(tree_other, step_toward)\n                if add_node is None:\n                    break\n                try_rewire(add_node, add_neighbors)\n                current = add_node\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(current.position, new_node.position):\n                        # Connect final edge and create connecting node at new_node.position\n                        connect_node = Node(new_node.position, parent=None,\n                                            cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(connect_node)\n                        tree_other.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((current, connect_node))\n                        connected_node = connect_node\n                    break\n\n            # If connected, update best path and check stopping criteria\n            if connected_node is not None:\n                candidate_path = stitch_paths(new_node, connected_node, a_from_start)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-8 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    no_improve_streak = 0\n                    found_first_solution = True\n                    post_opt_progress = 0\n                    use_informed = True\n                    success_state = True\n                else:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n\n                if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_first_solution,\n            path=best_path if found_first_solution else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def __sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0,1.0) for _ in range(dim)]\n            nrm = math.sqrt(sum(x*x for x in v))\n            if nrm > 1e-12:\n                v = [x/nrm for x in v]\n                r = random.random() ** (1.0/dim)\n                return tuple(v[i]*r for i in range(dim))",
                "objective": 195.68712,
                "time_improvement": -581.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 337.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 0.9,
                        "time_avg": 0.34295485019683836,
                        "num_nodes_avg": 421.0,
                        "path_length_avg": 155.62829807014288,
                        "smoothness_avg": 0.028551389198008637,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -1264.8531019196757,
                        "length_improvement": 14.697663739559538,
                        "smoothness_improvement": 346.8912412828284,
                        "objective_score": -418.9028761257528
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.23502867221832274,
                        "num_nodes_avg": 408.8,
                        "path_length_avg": 250.5134008933939,
                        "smoothness_avg": 0.014713884276228101,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -46.226932451188915,
                        "length_improvement": 16.371416153344544,
                        "smoothness_improvement": 278.59884040981956,
                        "objective_score": -52.65223584130084
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2584476709365845,
                        "num_nodes_avg": 391.6,
                        "path_length_avg": 120.11505060702589,
                        "smoothness_avg": 0.03826177341249338,
                        "success_improvement": 0.0,
                        "time_improvement": -431.91625816392127,
                        "length_improvement": 20.225302650883332,
                        "smoothness_improvement": 386.68693361657796,
                        "objective_score": -115.50626119056348
                    }
                ],
                "success_rate": 0.9333333333333332
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
            "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -7.90364,
            "time_improvement": -8.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 170.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025247907638549803,
                    "num_nodes_avg": 233.8,
                    "path_length_avg": 170.12946546952813,
                    "smoothness_avg": 0.014816791053862539,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4787803341404643,
                    "length_improvement": 6.749344102254376,
                    "smoothness_improvement": 131.91495516970375,
                    "objective_score": 4.565547136959005
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12624733448028563,
                    "num_nodes_avg": 859.5,
                    "path_length_avg": 236.88602288914717,
                    "smoothness_avg": 0.011656507882273733,
                    "success_improvement": 0.0,
                    "time_improvement": 21.453156004545612,
                    "length_improvement": 20.920627173489493,
                    "smoothness_improvement": 199.93034365416824,
                    "objective_score": 19.98797482372822
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07023768424987793,
                    "num_nodes_avg": 492.5,
                    "path_length_avg": 121.35915641758058,
                    "smoothness_avg": 0.02178086692654423,
                    "success_improvement": 0.0,
                    "time_improvement": -44.55756576526181,
                    "length_improvement": 19.399026809465404,
                    "smoothness_improvement": 177.0510196092805,
                    "objective_score": -0.842598545852899
                }
            ],
            "success_rate": 1.0
        },
        "objective": 168.8,
        "analysis": "1. Summary of key changes:\n   - The offspring algorithm applies goal-biased sampling with fixed-radius rewiring and early termination upon first valid path to goal.\n   - It uses pruning and rewiring to incrementally improve paths locally while maintaining a single tree structure.\n   - Incorporates collision checking with a consistent fixed resolution, avoiding expensive dual-tree bidirectional checks present in Parents #2.\n   - Compared to Parents #1, it includes early stopping after connecting to goal and more careful rewiring logic to improve path quality.\n\n2. Primary contributors to the performance improvement:\n   - Early termination upon finding a collision-free connection to the goal reduces unnecessary exploration.\n   - Focused local rewiring enhances path cost and smoothness iteratively.\n   - Simplified single-tree structure reduces control overhead and complexity compared to two-tree bidirectional search in Parents #2.\n   - Efficient collision checking and pruning reduce jagged and redundant path segments.\n\n3. Expected mechanism of impact:\n   - Early stopping limits computational effort spent on sample expansions after obtaining a valid path, resulting in faster convergence.\n   - Rewiring neighbors to use lower cost edges removes suboptimal branches, producing smoother paths with fewer abrupt turns.\n   - Maintaining a single search tree prevents overhead from managing and connecting two trees, improving runtime and path consistency.\n   - Fixed step size and rewiring radius prevent overly aggressive expansions that create sharp turns, yielding smoother trajectories."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
                "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 18.33169,
                "time_improvement": -104.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 277.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03312251567840576,
                        "num_nodes_avg": 199.7,
                        "path_length_avg": 163.67692862769394,
                        "smoothness_avg": 0.020726203772078875,
                        "success_improvement": 0.0,
                        "time_improvement": -31.81725886398311,
                        "length_improvement": 10.28608179225304,
                        "smoothness_improvement": 224.41009670489822,
                        "objective_score": -2.251478100318617
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2541221618652344,
                        "num_nodes_avg": 968.5,
                        "path_length_avg": 223.78483919358527,
                        "smoothness_avg": 0.016494501307333334,
                        "success_improvement": 0.0,
                        "time_improvement": -58.106259320137475,
                        "length_improvement": 25.29417938773204,
                        "smoothness_improvement": 324.4153991467646,
                        "objective_score": -0.633293167668195
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15669703483581543,
                        "num_nodes_avg": 482.5,
                        "path_length_avg": 117.3805344167902,
                        "smoothness_avg": 0.030113844927462913,
                        "success_improvement": 0.0,
                        "time_improvement": -222.5012635370204,
                        "length_improvement": 22.04143810076968,
                        "smoothness_improvement": 283.0458847045111,
                        "objective_score": -52.11028677712176
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
            "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": 4.05717,
            "time_improvement": -77.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1607.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03238720893859863,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 156.8355269466239,
                    "smoothness_avg": 0.04571460503828216,
                    "success_improvement": 0.0,
                    "time_improvement": -28.890967883954104,
                    "length_improvement": 14.03596246259457,
                    "smoothness_improvement": 615.5328397028414,
                    "objective_score": 2.831951310884718
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.147990083694458,
                    "num_nodes_avg": 859.9,
                    "path_length_avg": 231.82003384026544,
                    "smoothness_avg": 0.10402068439578667,
                    "success_improvement": 0.0,
                    "time_improvement": 7.925548965645519,
                    "length_improvement": 22.611800134415976,
                    "smoothness_improvement": 2576.527132574148,
                    "objective_score": 28.827380433213982
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15016646385192872,
                    "num_nodes_avg": 570.8,
                    "path_length_avg": 123.61458665916646,
                    "smoothness_avg": 0.13595502682176802,
                    "success_improvement": 0.0,
                    "time_improvement": -209.06056635900154,
                    "length_improvement": 17.901077435050915,
                    "smoothness_improvement": 1629.3379060166778,
                    "objective_score": -43.83083391658651
                }
            ],
            "success_rate": 1.0
        },
        "objective": 432.19999999999993,
        "analysis": "1. Summary of key changes:\n   - Introduced adaptive neighbor radius that shrinks with the number of nodes instead of fixed radius.\n   - Reduced maximum iterations from 10,000 to 5,000 for faster termination.\n   - Added a post-processing path shortcutting step to smooth and shorten the resulting path.\n   - Maintained informed sampling but combined with adaptive rewiring radius for more efficient exploration.\n   - Simplified early stopping condition upon finding a feasible goal connection.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius reduced the number of neighbors considered for rewiring, decreasing unnecessary collision checks and improving runtime.\n   - Path shortcutting removed redundant waypoints and smoothed path segments, greatly improving path smoothness and shortening path length.\n   - Reduced max iterations limited planning time while still exploiting informed sampling to find good-quality paths earlier.\n\n3. Expected mechanism of impact:\n   - Dynamic radius shrinks neighbor search space as tree grows, lowering computational overhead.\n   - Shortcutting post-processing replaces jagged multi-node paths with fewer, straighter segments, decreasing angular path deviations.\n   - Limiting iterations coupled with goal bias and informed sampling focuses computation on promising regions, leading to faster, higher quality solutions."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -24.394856704415727,
                "time_improvement": 84.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 65.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0037204265594482423,
                        "num_nodes_avg": 58.5,
                        "path_length_avg": 184.8763674372614,
                        "smoothness_avg": 0.010656061011327317,
                        "success_improvement": 0.0,
                        "time_improvement": 85.19386523557586,
                        "length_improvement": -1.3336665458757502,
                        "smoothness_improvement": 66.79049483412726,
                        "objective_score": 25.091912117317943
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.007217264175415039,
                        "num_nodes_avg": 195.5,
                        "path_length_avg": 293.476072886139,
                        "smoothness_avg": 0.006583639266204931,
                        "success_improvement": 0.0,
                        "time_improvement": 95.50966105071444,
                        "length_improvement": 2.0292396302187403,
                        "smoothness_improvement": 69.4017803231431,
                        "objective_score": 30.217450994961293
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.014179682731628418,
                        "num_nodes_avg": 216.3,
                        "path_length_avg": 159.7621915423607,
                        "smoothness_avg": 0.012486187243912596,
                        "success_improvement": 0.0,
                        "time_improvement": 70.81651479687723,
                        "length_improvement": -6.106440564392849,
                        "smoothness_improvement": 58.82338010809535,
                        "objective_score": 17.875207000967936
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
                "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
                "objective": 295.47898,
                "time_improvement": -1033.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 256.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.5913747787475586,
                        "num_nodes_avg": 758.0,
                        "path_length_avg": 151.24830260208697,
                        "smoothness_avg": 0.02058925094950933,
                        "success_improvement": 0.0,
                        "time_improvement": -2253.4867656993647,
                        "length_improvement": 17.098408661070636,
                        "smoothness_improvement": 222.2664876338706,
                        "objective_score": -664.6756520749976
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5786649703979492,
                        "num_nodes_avg": 1014.8,
                        "path_length_avg": 223.7199642443417,
                        "smoothness_avg": 0.014513759212874738,
                        "success_improvement": 0.0,
                        "time_improvement": -260.02587573506054,
                        "length_improvement": 25.31583651311142,
                        "smoothness_improvement": 273.4494783854807,
                        "objective_score": -61.451013420723896
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.333528995513916,
                        "num_nodes_avg": 730.1,
                        "path_length_avg": 114.76663509983318,
                        "smoothness_avg": 0.029182927141035354,
                        "success_improvement": 0.0,
                        "time_improvement": -586.442615791514,
                        "length_improvement": 23.777465566582624,
                        "smoothness_improvement": 271.20467917435593,
                        "objective_score": -160.31028200163283
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
            "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -31.88223,
            "time_improvement": 70.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 318.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
                }
            ],
            "success_rate": 1.0
        },
        "objective": 165.99999999999997,
        "analysis": "1. Summary of key changes:\n   - Implemented goal bias sampling to increase the chance of sampling the goal point.\n   - Introduced fixed-radius neighbor search and rewiring to optimize path cost incrementally.\n   - Alternated tree expansion direction systematically to balance exploration between start and goal.\n   - Incorporated early path extraction and termination upon first valid connection of the two trees.\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling focused sampling on promising regions, accelerating convergence.\n   - Fixed-radius rewiring allowed local path cost improvements and smoother path formation.\n   - Early termination reduced unnecessary computation after valid path discovery.\n3. Expected mechanism of impact:\n   - More efficient guided exploration reduced node expansions and computational time.\n   - Incremental rewiring improved overall path quality, reducing length and increasing smoothness.\n   - Balanced tree expansion and goal bias decreased random exploration and enhanced solution quality."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
                "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
                "objective": 5.46059,
                "time_improvement": -53.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 293.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06232309341430664,
                        "num_nodes_avg": 267.2,
                        "path_length_avg": 168.2463107739374,
                        "smoothness_avg": 0.02259680420437422,
                        "success_improvement": 0.0,
                        "time_improvement": -148.0264306480139,
                        "length_improvement": 7.781531031403382,
                        "smoothness_improvement": 253.68905554417486,
                        "objective_score": -38.47056529784127
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08523426055908204,
                        "num_nodes_avg": 568.0,
                        "path_length_avg": 241.3226903680994,
                        "smoothness_avg": 0.016808760155440354,
                        "success_improvement": 0.0,
                        "time_improvement": 46.970110737287854,
                        "length_improvement": 19.439539866622514,
                        "smoothness_improvement": 332.5015056600573,
                        "objective_score": 27.41726466946015
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07625963687896728,
                        "num_nodes_avg": 483.4,
                        "path_length_avg": 124.7326333683994,
                        "smoothness_avg": 0.03084680379066026,
                        "success_improvement": 0.0,
                        "time_improvement": -56.951465457596676,
                        "length_improvement": 17.15852404644154,
                        "smoothness_improvement": 292.3690673429857,
                        "objective_score": -5.328479872699152
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
                "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": -13.97956,
                "time_improvement": -17.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1470.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.052588915824890135,
                        "num_nodes_avg": 232.6,
                        "path_length_avg": 153.88454915168901,
                        "smoothness_avg": 0.04347023177026047,
                        "success_improvement": 0.0,
                        "time_improvement": -109.28744658079108,
                        "length_improvement": 15.653440153233934,
                        "smoothness_improvement": 580.4035243237437,
                        "objective_score": -20.492152260678246
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.048712754249572755,
                        "num_nodes_avg": 358.8,
                        "path_length_avg": 233.0599917365158,
                        "smoothness_avg": 0.10226409696877743,
                        "success_improvement": 0.0,
                        "time_improvement": 69.69256321821518,
                        "length_improvement": 22.197866498438458,
                        "smoothness_improvement": 2531.328872858417,
                        "objective_score": 46.883133228819716
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.054259729385375974,
                        "num_nodes_avg": 387.5,
                        "path_length_avg": 119.05752821578226,
                        "smoothness_avg": 0.10995381497824393,
                        "success_improvement": 0.0,
                        "time_improvement": -11.673021153817839,
                        "length_improvement": 20.927658669342527,
                        "smoothness_improvement": 1298.6044105768708,
                        "objective_score": 15.547710908344518
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive neighbor radius, goal bias, informed sampling after initial solution, and integrated path shortcutting to enhance efficiency, path length minimization, and smoothness. The planner employs incremental cost propagation on rewiring, early stopping based on no improvement, and rigorous collision checks to respect environment constraints. It dynamically balances exploration and exploitation, efficiently connecting two trees grown from start and goal, and post-processes to yield a short, smooth, and feasible path.",
            "planning_mechanism": "A planner that alternates between growing start and goal trees using RRT* with an adaptive neighbor radius for rewiring, employs goal bias and informed sampling post-solution for efficiency, attempts immediate and incremental connections between trees, propagates cost updates downstream on rewiring, and post-processes the found path by shortcutting to improve smoothness and reduce length, terminating early upon reaching the time limit or no improvement threshold.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 100, time_limit_sec: float = 30.0, gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import time\n        import math\n        import random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not _is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if _is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            if not nodes_list:\n                return None\n            min_node = nodes_list[0]\n            min_d = dist(min_node.position, p)\n            for n in nodes_list[1:]:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_node = n\n                    min_d = d_\n            return min_node\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not _is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if p is None or _is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if _is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not _is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, start_tree_side):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicated point at connection if they equal\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if start_tree_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n            side_start = (it % 2 == 0)\n            curr_tree = tree_start if side_start else tree_goal\n            other_tree = tree_goal if side_start else tree_start\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if side_start else start_pos\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if side_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n            if _is_in_obstacle(new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            if nearest_other and dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental attempts to connect other tree to new node\n                current_node = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while current_node and tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current_node.position, new_node.position)\n                    if not within_bounds(step_pos) or _is_in_obstacle(step_pos) or _is_edge_in_obstacle(current_node.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current_node = other_new\n                    if dist(current_node.position, new_node.position) <= self.step_size and can_connect(current_node, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current_node.cost + dist(current_node.position, new_node.position))\n                        current_node.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current_node, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, side_start)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if found_first and no_improve_count >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": -20.10262,
            "time_improvement": -0.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1643.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03990023136138916,
                    "num_nodes_avg": 243.7,
                    "path_length_avg": 151.71533271438886,
                    "smoothness_avg": 0.04937742715811869,
                    "success_improvement": 0.0,
                    "time_improvement": -58.79044868340153,
                    "length_improvement": 16.842422055952248,
                    "smoothness_improvement": 672.8639598238237,
                    "objective_score": -4.167361572329989
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04238791465759277,
                    "num_nodes_avg": 398.2,
                    "path_length_avg": 232.25526955897027,
                    "smoothness_avg": 0.11988909499841452,
                    "success_improvement": 0.0,
                    "time_improvement": 73.62766561679376,
                    "length_improvement": 22.46650592394675,
                    "smoothness_improvement": 2984.8327669339337,
                    "objective_score": 50.492367074075844
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0565122127532959,
                    "num_nodes_avg": 449.2,
                    "path_length_avg": 119.16121883852645,
                    "smoothness_avg": 0.10786629904804887,
                    "success_improvement": 0.0,
                    "time_improvement": -16.308901679645523,
                    "length_improvement": 20.858792294932694,
                    "smoothness_improvement": 1272.0513620291879,
                    "objective_score": 13.9828616832119
                }
            ],
            "success_rate": 1.0
        },
        "objective": 916.5999999999999,
        "analysis": "1. Summary of key changes:\n   - Introduction of adaptive neighbor radius based on node count and problem dimension for rewiring.\n   - Use of informed sampling after first solution to focus sampling on an ellipsoidal subset of the search space.\n   - Alternating tree expansions in a bidirectional RRT* framework with incremental and greedy attempts to connect trees.\n   - Cost propagation to child nodes after rewiring to maintain accurate path costs.\n   - Implementation of a path shortcutting post-processing step to remove unnecessary waypoints and smooth the path.\n   - Reduced steering step size for finer growth increments.\n   - Enhanced stopping criteria based on maximum consecutive no-improvement iterations to avoid over-computation.\n\n2. Primary contributors to the performance improvement:\n   - Informed sampling directing exploration towards promising regions after initial success, accelerating convergence.\n   - Adaptive neighbor radius optimizing rewiring by balancing local connectivity and computational cost.\n   - Path shortcutting greatly improving smoothness by removing redundant and jagged waypoints.\n   - Incremental connection attempts between trees increasing the chance of earlier and better connections.\n   - Cost propagation ensuring consistent cost updates that enable effective rewiring and path optimization.\n\n3. Expected mechanism of impact:\n   - Focused sampling reduces unnecessary exploration, decreasing planning time and improving solution quality.\n   - Adaptive radius rewiring improves path length by encouraging shorter connections and better topology.\n   - Shortcutting post-processing removes sharp turns and jagged edges, significantly enhancing smoothness.\n   - Incremental greedy connection provides more opportunities for bridging the two trees with shorter edges.\n   - Accurate cost propagation maintains valid cost information downstream, ensuring correct rewiring decisions that improve path quality."
    }
]