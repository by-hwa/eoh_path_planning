[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.893579481866173,
                "time_improvement": 56.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 178.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0102372407913208,
                        "num_nodes_avg": 117.5,
                        "path_length_avg": 167.09773058241916,
                        "smoothness_avg": 0.01743061917619911,
                        "success_improvement": 0.0,
                        "time_improvement": 59.25898163821438,
                        "length_improvement": 8.411086034792367,
                        "smoothness_improvement": 172.82704130288656,
                        "objective_score": 23.688481318854166
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02068014144897461,
                        "num_nodes_avg": 270.5,
                        "path_length_avg": 254.91986206815108,
                        "smoothness_avg": 0.010869990893363076,
                        "success_improvement": 0.0,
                        "time_improvement": 87.1335117617854,
                        "length_improvement": 14.900412580258132,
                        "smoothness_improvement": 179.6926950242082,
                        "objective_score": 35.978764551811544
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03835470676422119,
                        "num_nodes_avg": 352.3,
                        "path_length_avg": 131.0348919324295,
                        "smoothness_avg": 0.02219113712511561,
                        "success_improvement": 0.0,
                        "time_improvement": 21.061420166541545,
                        "length_improvement": 12.97286398951632,
                        "smoothness_improvement": 182.26962625211246,
                        "objective_score": 15.013492574932817
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.256651771997145,
                "time_improvement": 85.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.005163788795471191,
                        "num_nodes_avg": 88.6,
                        "path_length_avg": 194.6296584579342,
                        "smoothness_avg": 0.01167543363104651,
                        "success_improvement": 0.0,
                        "time_improvement": 79.44973470673519,
                        "length_improvement": -6.679599905092896,
                        "smoothness_improvement": 82.74588993580629,
                        "objective_score": 20.24088991864385
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.014127516746520996,
                        "num_nodes_avg": 235.1,
                        "path_length_avg": 298.3796473209629,
                        "smoothness_avg": 0.007304556076322401,
                        "success_improvement": 0.0,
                        "time_improvement": 91.21033439240306,
                        "length_improvement": 0.3922853423102244,
                        "smoothness_improvement": 87.95148910285546,
                        "objective_score": 28.03822896862133
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.007713985443115234,
                        "num_nodes_avg": 141.8,
                        "path_length_avg": 161.00482297708567,
                        "smoothness_avg": 0.014351820764112542,
                        "success_improvement": 0.0,
                        "time_improvement": 84.12369414062309,
                        "length_improvement": -6.931737195586904,
                        "smoothness_improvement": 82.55410077829661,
                        "objective_score": 21.490836428726265
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
            "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
            "objective": 5.46059,
            "time_improvement": -53.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 293.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06232309341430664,
                    "num_nodes_avg": 267.2,
                    "path_length_avg": 168.2463107739374,
                    "smoothness_avg": 0.02259680420437422,
                    "success_improvement": 0.0,
                    "time_improvement": -148.0264306480139,
                    "length_improvement": 7.781531031403382,
                    "smoothness_improvement": 253.68905554417486,
                    "objective_score": -38.47056529784127
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08523426055908204,
                    "num_nodes_avg": 568.0,
                    "path_length_avg": 241.3226903680994,
                    "smoothness_avg": 0.016808760155440354,
                    "success_improvement": 0.0,
                    "time_improvement": 46.970110737287854,
                    "length_improvement": 19.439539866622514,
                    "smoothness_improvement": 332.5015056600573,
                    "objective_score": 27.41726466946015
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07625963687896728,
                    "num_nodes_avg": 483.4,
                    "path_length_avg": 124.7326333683994,
                    "smoothness_avg": 0.03084680379066026,
                    "success_improvement": 0.0,
                    "time_improvement": -56.951465457596676,
                    "length_improvement": 17.15852404644154,
                    "smoothness_improvement": 292.3690673429857,
                    "objective_score": -5.328479872699152
                }
            ],
            "success_rate": 1.0
        },
        "objective": 23.400000000000006,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a single fixed rewiring radius with dynamic rewiring of nodes around new samples, improving local optimal connections.\n   - Offspring includes a goal bias sampling (5%) to accelerate convergence toward the goal.\n   - Offspring performs early termination upon first solution finding, reducing unnecessary iterations.\n   - Offspring rewires with careful parent selection minimizing cost and edge collision checks while pruning outdated parents.\n   - Offspring better handles path extraction by removing duplicated connection points between the two trees.\n   \n2. Primary contributors to the performance improvement:\n   - The goal bias sampling focused exploration toward the goal, speeding up feasible path discovery.\n   - Efficient local rewiring with radius-based neighbors and cost-based parent reassignment reduced unnecessary expansions and improved path cost.\n   - Early stopping on first valid path cut down the total planning time consumed.\n   - Improved edge collision checking with fixed resolution helped eliminate invalid edges promptly.\n   \n3. Expected mechanism of impact:\n   - By guiding samples preferentially toward the goal and limiting rewiring radius, the planner concentrates efforts on promising regions, thus speeding planning time.\n   - Dynamic candidate parent selection decreases redundant or costly tree structures, producing shorter, smoother paths quicker.\n   - Early termination prevents wasted iterations after a viable solution appears, directly reducing planning runtime.\n   - Collision checks ensure only valid, cost-effective edges are added or rewired, stabilizing incremental improvements."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 69.43496400372943,
                "time_improvement": -276.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 165.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05916297435760498,
                        "num_nodes_avg": 394.9,
                        "path_length_avg": 155.53505227340733,
                        "smoothness_avg": 0.014549204278916808,
                        "success_improvement": 0.0,
                        "time_improvement": -135.4501446019083,
                        "length_improvement": 14.748773238324494,
                        "smoothness_improvement": 127.72664106782084,
                        "objective_score": -31.14714623223869
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.580695104598999,
                        "num_nodes_avg": 1589.2,
                        "path_length_avg": 226.77578579094256,
                        "smoothness_avg": 0.011489796720712679,
                        "success_improvement": 0.0,
                        "time_improvement": -261.2889569322687,
                        "length_improvement": 24.29571532390974,
                        "smoothness_improvement": 195.64074539000617,
                        "objective_score": -62.831054158384745
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.25779869556427004,
                        "num_nodes_avg": 856.3,
                        "path_length_avg": 115.47581220588968,
                        "smoothness_avg": 0.02144048255314569,
                        "success_improvement": 0.0,
                        "time_improvement": -430.58058912720264,
                        "length_improvement": 23.30646390012476,
                        "smoothness_improvement": 172.72135550421203,
                        "objective_score": -114.32669162056487
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
                "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
                "objective": 295.47898,
                "time_improvement": -1033.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 256.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.5913747787475586,
                        "num_nodes_avg": 758.0,
                        "path_length_avg": 151.24830260208697,
                        "smoothness_avg": 0.02058925094950933,
                        "success_improvement": 0.0,
                        "time_improvement": -2253.4867656993647,
                        "length_improvement": 17.098408661070636,
                        "smoothness_improvement": 222.2664876338706,
                        "objective_score": -664.6756520749976
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5786649703979492,
                        "num_nodes_avg": 1014.8,
                        "path_length_avg": 223.7199642443417,
                        "smoothness_avg": 0.014513759212874738,
                        "success_improvement": 0.0,
                        "time_improvement": -260.02587573506054,
                        "length_improvement": 25.31583651311142,
                        "smoothness_improvement": 273.4494783854807,
                        "objective_score": -61.451013420723896
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.333528995513916,
                        "num_nodes_avg": 730.1,
                        "path_length_avg": 114.76663509983318,
                        "smoothness_avg": 0.029182927141035354,
                        "success_improvement": 0.0,
                        "time_improvement": -586.442615791514,
                        "length_improvement": 23.777465566582624,
                        "smoothness_improvement": 271.20467917435593,
                        "objective_score": -160.31028200163283
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
            "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 34.24822,
            "time_improvement": -158.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 287.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05595297813415527,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 160.14345768443917,
                    "smoothness_avg": 0.020991279248420664,
                    "success_improvement": 0.0,
                    "time_improvement": -122.67536302290098,
                    "length_improvement": 12.22283320768113,
                    "smoothness_improvement": 228.55910353025726,
                    "objective_score": -28.326113464610327
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23264851570129394,
                    "num_nodes_avg": 948.8,
                    "path_length_avg": 225.03802962507376,
                    "smoothness_avg": 0.017004339084283518,
                    "success_improvement": 0.0,
                    "time_improvement": -44.746079145276,
                    "length_improvement": 24.875828350614626,
                    "smoothness_improvement": 337.5338923690004,
                    "objective_score": 3.189342728630977
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19719173908233642,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 118.75610965494363,
                    "smoothness_avg": 0.030953946710724024,
                    "success_improvement": 0.0,
                    "time_improvement": -305.8442144725285,
                    "length_improvement": 21.127846525442067,
                    "smoothness_improvement": 293.73191737772913,
                    "objective_score": -77.60789683960466
                }
            ],
            "success_rate": 1.0
        },
        "objective": -142.0,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a single-tree RRT* approach with a fixed neighbor radius for rewiring and simplified parent update methods.\n   - Early termination immediately upon first connection to the goal reduces unnecessary exploration.\n   - Sampling includes a goal bias to expedite convergence.\n2. Primary contributors to the performance improvement:\n   - Reduction from bidirectional to single-tree search decreases overhead and complexity per iteration.\n   - Fixed and sufficiently large neighbor radius improves rewiring efficiency and path cost optimization.\n   - Early stopping on goal connection reduces overall runtime.\n3. Expected mechanism of impact:\n   - Simplifying planning structure lowers computational burden, speeding up each iteration.\n   - Efficient rewiring reduces path length and smoothness metrics by optimizing locally around new nodes.\n   - Goal-biased sampling and early termination focus search near goal, thus improving path quality and reducing planning time."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping. The planner dynamically adjusts neighbor search radius based on the number of nodes to balance exploration and exploitation, incorporates goal bias with a higher sampling rate for faster convergence, and performs incremental rewiring using efficient neighbor queries. Collision checks are optimized with adaptive edge resolution, and the planner terminates immediately once the goal is connected, ensuring reduced planning time with high-quality, smooth paths.",
                "planning_mechanism": "The algorithm incrementally grows a single tree from start, sampling randomly with goal bias, and steering toward samples with fixed step size. It dynamically computes neighbors within an adaptive radius proportional to log(n)/n for better rewiring efficiency. For each new node, the best parent minimizing cost and verified for collision is chosen, followed by local rewiring to improve path cost and smoothness. Early termination upon reaching the goal with collision-free connection guarantees fast runtime and high success rates.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        final_path = []\n\n        # To accelerate nearest neighbor queries, store positions separately\n        positions = [root.position]\n\n        # Adaptive neighbor radius: r = gamma * (log(n)/n)^{1/d} with gamma tuned for good rewiring\n        # Gamma chosen as 30.0 for moderate neighbor count\n        gamma = 30.0\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return gamma\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 20)\n\n        # Optimized collision checking resolution based on step_size and distance\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size/2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Main loop\n        for iter_id in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Time limit reached, break with best path if any\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search (linear, as no k-d tree available)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision from nearest_node to new_pos\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius search\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Choose best parent minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improving cost\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list carefully\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if goal can connect directly\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n\n                    # Backtrack path\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success but nodes exist, extract path from best node near goal\n        if not success and len(nodes) > 1:\n            # Find node closest to goal\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                # Extract path backwards\n                path = []\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 24.4788,
                "time_improvement": -89.0,
                "length_improvement": 3.0,
                "smoothness_improvement": 112.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015737581253051757,
                        "num_nodes_avg": 191.3,
                        "path_length_avg": 179.56403283207513,
                        "smoothness_avg": 0.01421437809371725,
                        "success_improvement": 0.0,
                        "time_improvement": 37.36934591357285,
                        "length_improvement": 1.5781082305555436,
                        "smoothness_improvement": 122.48588418274917,
                        "objective_score": 12.770098133318925
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14423696994781493,
                        "num_nodes_avg": 916.7,
                        "path_length_avg": 303.4419163034794,
                        "smoothness_avg": 0.007145793076982586,
                        "success_improvement": 0.0,
                        "time_improvement": 10.260610067476575,
                        "length_improvement": -1.2976457533873764,
                        "smoothness_improvement": 83.86640277747577,
                        "objective_score": 2.7189275820979253
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.20188889503479004,
                        "num_nodes_avg": 778.9,
                        "path_length_avg": 137.83772884194133,
                        "smoothness_avg": 0.01816319064757809,
                        "success_improvement": 0.0,
                        "time_improvement": -315.51152394832013,
                        "length_improvement": 8.454743630501442,
                        "smoothness_improvement": 131.03444436991745,
                        "objective_score": -88.92543878434559
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
            "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": 18.33169,
            "time_improvement": -104.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 277.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03312251567840576,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 163.67692862769394,
                    "smoothness_avg": 0.020726203772078875,
                    "success_improvement": 0.0,
                    "time_improvement": -31.81725886398311,
                    "length_improvement": 10.28608179225304,
                    "smoothness_improvement": 224.41009670489822,
                    "objective_score": -2.251478100318617
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2541221618652344,
                    "num_nodes_avg": 968.5,
                    "path_length_avg": 223.78483919358527,
                    "smoothness_avg": 0.016494501307333334,
                    "success_improvement": 0.0,
                    "time_improvement": -58.106259320137475,
                    "length_improvement": 25.29417938773204,
                    "smoothness_improvement": 324.4153991467646,
                    "objective_score": -0.633293167668195
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15669703483581543,
                    "num_nodes_avg": 482.5,
                    "path_length_avg": 117.3805344167902,
                    "smoothness_avg": 0.030113844927462913,
                    "success_improvement": 0.0,
                    "time_improvement": -222.5012635370204,
                    "length_improvement": 22.04143810076968,
                    "smoothness_improvement": 283.0458847045111,
                    "objective_score": -52.11028677712176
                }
            ],
            "success_rate": 1.0
        },
        "objective": -56.4,
        "analysis": "1. Summary of key changes:\n   - Introduced informed sampling within an ellipsoidal subset focused on the current best path, improving guided exploration.\n   - Rewiring strategy uses a fixed radius neighbor search with explicit collision checks for parent selection and rewiring.\n   - Early termination upon first feasible goal connection, reducing unnecessary iterations.\n   - Enhanced collision checking with adaptive resolution and combined node and edge feasibility checks.\n   - Increased goal sampling rate and maximum iterations for better convergence opportunities.\n\n2. Primary contributors to the performance improvement:\n   - Informed sampling drastically reduces exploration of irrelevant areas, concentrating search near the optimal path.\n   - Early stopping once a feasible path is found prevents excess computation, decreasing planning time.\n   - More robust and efficient collision checks avoid invalid expansions efficiently and reduce overhead.\n   - Fixed-radius rewiring enables consistent local improvements without costly large neighbor radius calculations.\n\n3. Expected mechanism of impact:\n   - The heuristic-driven sampling reduces the sampling space and focuses computational effort on promising regions, accelerating convergence.\n   - Early termination avoids wasting time on marginal improvements once a path is found.\n   - Adaptive collision checking balances accuracy and speed, minimizing redundant collision queries.\n   - Fixed-radius rewiring stabilizes rewiring costs and simplifies neighbor searches, improving computational efficiency."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 69.43496400372943,
                "time_improvement": -276.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 165.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05916297435760498,
                        "num_nodes_avg": 394.9,
                        "path_length_avg": 155.53505227340733,
                        "smoothness_avg": 0.014549204278916808,
                        "success_improvement": 0.0,
                        "time_improvement": -135.4501446019083,
                        "length_improvement": 14.748773238324494,
                        "smoothness_improvement": 127.72664106782084,
                        "objective_score": -31.14714623223869
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.580695104598999,
                        "num_nodes_avg": 1589.2,
                        "path_length_avg": 226.77578579094256,
                        "smoothness_avg": 0.011489796720712679,
                        "success_improvement": 0.0,
                        "time_improvement": -261.2889569322687,
                        "length_improvement": 24.29571532390974,
                        "smoothness_improvement": 195.64074539000617,
                        "objective_score": -62.831054158384745
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.25779869556427004,
                        "num_nodes_avg": 856.3,
                        "path_length_avg": 115.47581220588968,
                        "smoothness_avg": 0.02144048255314569,
                        "success_improvement": 0.0,
                        "time_improvement": -430.58058912720264,
                        "length_improvement": 23.30646390012476,
                        "smoothness_improvement": 172.72135550421203,
                        "objective_score": -114.32669162056487
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with adaptive rewiring and efficient neighbor search to produce asymptotically optimal, smooth, and shorter paths with reduced computational overhead. It incrementally samples free space, extends the tree toward random samples respecting obstacle constraints, selects optimal parents among nearby nodes, rewires neighbors to minimize cost, and stops early upon finding a valid path within a time limit.",
                "planning_mechanism": "The planner grows a single tree from start towards goal by iteratively sampling collision-free points and steering incrementally toward them. For each new node, it finds neighbors inside an adaptively scaled radius, picks the best parent minimizing path cost, adds the node, and rewires neighbors if rewiring reduces costs. The search stops when the goal is reachable within a step size and the path is extracted. Using incremental rewiring and efficient local radius scaling improves path smoothness and length. A hard time limit caps search effort, returning best found path if time runs out.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=30.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        tree = []\n\n        start_node = Node(start_pos, None, 0.0)\n        tree.append(start_node)\n        nodes.append(start_node)\n\n        success = False\n        best_goal_node = None\n        dist_goal = self._distance(start_pos, goal_pos)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, rand)\n            new_pos = self._steer(nearest.position, rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            # Choose best parent\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # rewire nb to new_node\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n            # Check if goal can be connected\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        best_goal_node = goal_node\n                        break\n\n        path = best_goal_node.path_from_root() if success else []\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, pos, bounds):\n        n = len(tree)\n        d = len(pos)\n        if n <= 1:\n            return [tree[0]] if tree else []\n        scale = max(1.0, sum(bounds)/d)\n        radius_theory = self.gamma * ((math.log(n)/n) ** (1/d))\n        radius = min(self.max_radius, max(self.step_size*2, radius_theory * 0.5 + scale * 0.01))\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 342.00038,
                "time_improvement": -1177.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 182.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.6105502605438232,
                        "num_nodes_avg": 637.2,
                        "path_length_avg": 162.9455247662491,
                        "smoothness_avg": 0.016476664782690602,
                        "success_improvement": 0.0,
                        "time_improvement": -2329.7991893184353,
                        "length_improvement": 10.686975838546811,
                        "smoothness_improvement": 157.89558349935672,
                        "objective_score": -691.7380933749057
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 1.039361596107483,
                        "num_nodes_avg": 1016.0,
                        "path_length_avg": 234.23682240353804,
                        "smoothness_avg": 0.01151286991709365,
                        "success_improvement": 0.0,
                        "time_improvement": -546.6558163813695,
                        "length_improvement": 21.805006548593838,
                        "smoothness_improvement": 196.23443535184018,
                        "objective_score": -149.93256880849535
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.36697118282318114,
                        "num_nodes_avg": 582.3,
                        "path_length_avg": 122.24375464796276,
                        "smoothness_avg": 0.02301578213338744,
                        "success_improvement": 0.0,
                        "time_improvement": -655.2706422693615,
                        "length_improvement": 18.81151878488672,
                        "smoothness_improvement": 192.7590498883673,
                        "objective_score": -184.3304861604346
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
            "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 9.11942,
            "time_improvement": -70.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 182.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02458224296569824,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 160.91673392411104,
                    "smoothness_avg": 0.01622189562126349,
                    "success_improvement": 0.0,
                    "time_improvement": 2.170356988333177,
                    "length_improvement": 11.798988247370831,
                    "smoothness_improvement": 153.90789288293342,
                    "objective_score": 8.50003950933712
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16582508087158204,
                    "num_nodes_avg": 988.6,
                    "path_length_avg": 230.06388904405716,
                    "smoothness_avg": 0.011826311396694525,
                    "success_improvement": 0.0,
                    "time_improvement": -3.170786229848748,
                    "length_improvement": 23.198051815215557,
                    "smoothness_improvement": 204.29951038474306,
                    "objective_score": 13.989092772098425
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14947149753570557,
                    "num_nodes_avg": 650.0,
                    "path_length_avg": 121.70930984019235,
                    "smoothness_avg": 0.022669727327406998,
                    "success_improvement": 0.0,
                    "time_improvement": -207.63024245189973,
                    "length_improvement": 19.166471578680884,
                    "smoothness_improvement": 188.3572582994048,
                    "objective_score": -49.84740349686436
                }
            ],
            "success_rate": 1.0
        },
        "objective": -124.4,
        "analysis": "1. Summary of key changes:\n   - Introduced goal bias sampling in offspring to better guide sampling toward the goal.\n   - Adopted a fixed rewiring radius for neighbor search and rewiring, streamlining neighbor selection.\n   - Simplified parent-child relationship updates with careful error handling during edge removals.\n   - Added early termination on first successful goal connection instead of continuing full iterations.\n   - Encapsulated collision checking and bounding within simple helper functions and used a more consistent structure.\n\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling reduced unnecessary exploration and accelerated discovery of paths.\n   - Fixed rewiring radius controlled neighborhood size, lowering computational overhead in rewiring.\n   - Early stopping upon goal connection significantly cut down runtime in successful cases.\n   - More efficient management of parent-child updates and edge removals minimized overhead.\n   \n3. Expected mechanism of impact:\n   - Sampling bias focused the search toward promising regions, reducing iterations for goal reach.\n   - Limiting neighbor candidates reduced costly collision checks and cost comparisons.\n   - Early termination avoided wasteful iterations beyond path discovery.\n   - Streamlined bookkeeping minimized time spent maintaining tree consistency during rewiring."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.893579481866173,
                "time_improvement": 56.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 178.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0102372407913208,
                        "num_nodes_avg": 117.5,
                        "path_length_avg": 167.09773058241916,
                        "smoothness_avg": 0.01743061917619911,
                        "success_improvement": 0.0,
                        "time_improvement": 59.25898163821438,
                        "length_improvement": 8.411086034792367,
                        "smoothness_improvement": 172.82704130288656,
                        "objective_score": 23.688481318854166
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02068014144897461,
                        "num_nodes_avg": 270.5,
                        "path_length_avg": 254.91986206815108,
                        "smoothness_avg": 0.010869990893363076,
                        "success_improvement": 0.0,
                        "time_improvement": 87.1335117617854,
                        "length_improvement": 14.900412580258132,
                        "smoothness_improvement": 179.6926950242082,
                        "objective_score": 35.978764551811544
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03835470676422119,
                        "num_nodes_avg": 352.3,
                        "path_length_avg": 131.0348919324295,
                        "smoothness_avg": 0.02219113712511561,
                        "success_improvement": 0.0,
                        "time_improvement": 21.061420166541545,
                        "length_improvement": 12.97286398951632,
                        "smoothness_improvement": 182.26962625211246,
                        "objective_score": 15.013492574932817
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with efficient neighbor selection, rewiring, and early stopping to improve generalization, reduce complexity, and maintain robust path quality and smoothness within a 30-second time limit. It grows a single tree from start to goal by sampling collision-free points, steering incrementally, selecting the lowest-cost parent from neighbors within a dynamically scaled radius, rewiring neighbors to reduce cost, and terminating once a path to the goal is found.",
                "planning_mechanism": "The planner builds a tree rooted at the start by iteratively sampling free points, steering toward them with fixed step size, choosing optimal parent nodes from a radius-based neighborhood, applying local rewiring to minimize path costs, and returning the best path within a time budget or when the goal neighborhood is reached.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, neighbor_gamma: float=50.0, goal_radius: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_radius = max(bounds)*0.3\n        min_radius = max(10.0, self.step_size*2.0)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: return start (rare)\n            return start_pos\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return min_radius\n            r = self.neighbor_gamma * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            return min(max_radius, max(min_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if math.dist(n.position, pos) <= radius]\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached, return best found\n                return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, r)\n            # Select best parent in neighbors with valid edge\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                # fallback to nearest_node if edge free\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Rewire: update parent and cost, edges lists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            # Check if goal reached\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path)-1):\n                    cost += math.dist(path[i], path[i+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 680.61663,
                "time_improvement": -2311.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 212.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.2963702201843261,
                        "num_nodes_avg": 798.3,
                        "path_length_avg": 153.40311775845035,
                        "smoothness_avg": 0.01867232962112822,
                        "success_improvement": 0.0,
                        "time_improvement": -5059.148253011591,
                        "length_improvement": 15.917320328636658,
                        "smoothness_improvement": 192.26250618341595,
                        "objective_score": -1507.2327711753783
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 1.0090357303619384,
                        "num_nodes_avg": 1116.8,
                        "path_length_avg": 232.92130464304964,
                        "smoothness_avg": 0.011711985498954181,
                        "success_improvement": 0.0,
                        "time_improvement": -527.788083010616,
                        "length_improvement": 22.244164242124114,
                        "smoothness_improvement": 201.3578226902683,
                        "objective_score": -143.983137244459
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7028919219970703,
                        "num_nodes_avg": 837.6,
                        "path_length_avg": 120.10951944487313,
                        "smoothness_avg": 0.0270341704816116,
                        "success_improvement": 0.0,
                        "time_improvement": -1346.6357529453908,
                        "length_improvement": 20.22897618541956,
                        "smoothness_improvement": 243.8726530712041,
                        "objective_score": -390.63397690700947
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
            "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 34.17936,
            "time_improvement": -148.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 307.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06862092018127441,
                    "num_nodes_avg": 284.0,
                    "path_length_avg": 170.5991073480199,
                    "smoothness_avg": 0.023639461522089605,
                    "success_improvement": 0.0,
                    "time_improvement": -173.08981258681808,
                    "length_improvement": 6.491925946701232,
                    "smoothness_improvement": 270.00890673302524,
                    "objective_score": -46.68174367435956
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09145197868347169,
                    "num_nodes_avg": 589.8,
                    "path_length_avg": 238.92126140318732,
                    "smoothness_avg": 0.017217767150899767,
                    "success_improvement": 0.0,
                    "time_improvement": 43.10165571180447,
                    "length_improvement": 20.24120597641038,
                    "smoothness_improvement": 343.0255502490592,
                    "objective_score": 26.790348050632865
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20080511569976806,
                    "num_nodes_avg": 632.2,
                    "path_length_avg": 125.97622721535136,
                    "smoothness_avg": 0.03204491385721169,
                    "success_improvement": 0.0,
                    "time_improvement": -313.2809762847595,
                    "length_improvement": 16.332588226871458,
                    "smoothness_improvement": 307.60893895423396,
                    "objective_score": -82.6466952545338
                }
            ],
            "success_rate": 1.0
        },
        "objective": -7.199999999999989,
        "analysis": "1. Summary of key changes:\n   - Offspring employs goal bias sampling to guide exploration more efficiently.\n   - Uses a fixed rewiring radius and rewires neighbors to optimize path cost continuously.\n   - Implements early stopping immediately upon connecting the two trees, reducing unnecessary iterations and runtime.\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling reduces wasted samples in free space, accelerating convergence.\n   - Continuous rewiring within a fixed radius improves path quality as the tree grows.\n   - Early stopping on successful connection avoids extraneous computation.\n3. Expected mechanism of impact:\n   - By biasing samples toward the goal, the planner directs growth towards feasible solutions faster, cutting down planning time.\n   - Rewiring neighbors optimizes node parentage, improving path cost and smoothness without extra search.\n   - Early termination prevents prolonged exploration after finding a valid path, significantly reducing runtime."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
                "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 18.33169,
                "time_improvement": -104.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 277.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03312251567840576,
                        "num_nodes_avg": 199.7,
                        "path_length_avg": 163.67692862769394,
                        "smoothness_avg": 0.020726203772078875,
                        "success_improvement": 0.0,
                        "time_improvement": -31.81725886398311,
                        "length_improvement": 10.28608179225304,
                        "smoothness_improvement": 224.41009670489822,
                        "objective_score": -2.251478100318617
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2541221618652344,
                        "num_nodes_avg": 968.5,
                        "path_length_avg": 223.78483919358527,
                        "smoothness_avg": 0.016494501307333334,
                        "success_improvement": 0.0,
                        "time_improvement": -58.106259320137475,
                        "length_improvement": 25.29417938773204,
                        "smoothness_improvement": 324.4153991467646,
                        "objective_score": -0.633293167668195
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15669703483581543,
                        "num_nodes_avg": 482.5,
                        "path_length_avg": 117.3805344167902,
                        "smoothness_avg": 0.030113844927462913,
                        "success_improvement": 0.0,
                        "time_improvement": -222.5012635370204,
                        "length_improvement": 22.04143810076968,
                        "smoothness_improvement": 283.0458847045111,
                        "objective_score": -52.11028677712176
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
            "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": 4.05717,
            "time_improvement": -77.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1607.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03238720893859863,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 156.8355269466239,
                    "smoothness_avg": 0.04571460503828216,
                    "success_improvement": 0.0,
                    "time_improvement": -28.890967883954104,
                    "length_improvement": 14.03596246259457,
                    "smoothness_improvement": 615.5328397028414,
                    "objective_score": 2.831951310884718
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.147990083694458,
                    "num_nodes_avg": 859.9,
                    "path_length_avg": 231.82003384026544,
                    "smoothness_avg": 0.10402068439578667,
                    "success_improvement": 0.0,
                    "time_improvement": 7.925548965645519,
                    "length_improvement": 22.611800134415976,
                    "smoothness_improvement": 2576.527132574148,
                    "objective_score": 28.827380433213982
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15016646385192872,
                    "num_nodes_avg": 570.8,
                    "path_length_avg": 123.61458665916646,
                    "smoothness_avg": 0.13595502682176802,
                    "success_improvement": 0.0,
                    "time_improvement": -209.06056635900154,
                    "length_improvement": 17.901077435050915,
                    "smoothness_improvement": 1629.3379060166778,
                    "objective_score": -43.83083391658651
                }
            ],
            "success_rate": 1.0
        },
        "objective": -57.0,
        "analysis": "1. Summary of key changes:\n   - Introduced adaptive neighbor radius that shrinks with tree size, replacing fixed radius for rewiring.\n   - Added post-processing path shortcutting to smooth and shorten the extracted path.\n   - Reduced maximum iterations from 10,000 to 5,000 to limit planning time.\n   - Maintained informed and goal-biased sampling but combined with adaptive rewiring radius.\n   - Early stopping upon finding a valid path with improved rewiring and path extraction.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius reduced unnecessary neighbor checks, decreasing computational overhead.\n   - Path shortcutting post-processing improved smoothness and shortened path length.\n   - Reduced iterations and focused sampling expedited convergence, reducing planning time.\n   \n3. Expected mechanism of impact:\n   - Shrinking neighbor radius leads to fewer rewiring candidates as tree grows, improving runtime efficiency.\n   - Path shortcutting removes redundant nodes and allows bypassing jagged segments, leading to smoother and shorter paths.\n   - Lower iteration limit combined with focused informed sampling ensures quicker discovery of good paths without excessive computation."
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -24.394856704415727,
                "time_improvement": 84.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 65.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0037204265594482423,
                        "num_nodes_avg": 58.5,
                        "path_length_avg": 184.8763674372614,
                        "smoothness_avg": 0.010656061011327317,
                        "success_improvement": 0.0,
                        "time_improvement": 85.19386523557586,
                        "length_improvement": -1.3336665458757502,
                        "smoothness_improvement": 66.79049483412726,
                        "objective_score": 25.091912117317943
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.007217264175415039,
                        "num_nodes_avg": 195.5,
                        "path_length_avg": 293.476072886139,
                        "smoothness_avg": 0.006583639266204931,
                        "success_improvement": 0.0,
                        "time_improvement": 95.50966105071444,
                        "length_improvement": 2.0292396302187403,
                        "smoothness_improvement": 69.4017803231431,
                        "objective_score": 30.217450994961293
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.014179682731628418,
                        "num_nodes_avg": 216.3,
                        "path_length_avg": 159.7621915423607,
                        "smoothness_avg": 0.012486187243912596,
                        "success_improvement": 0.0,
                        "time_improvement": 70.81651479687723,
                        "length_improvement": -6.106440564392849,
                        "smoothness_improvement": 58.82338010809535,
                        "objective_score": 17.875207000967936
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
                "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
                "objective": 295.47898,
                "time_improvement": -1033.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 256.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.5913747787475586,
                        "num_nodes_avg": 758.0,
                        "path_length_avg": 151.24830260208697,
                        "smoothness_avg": 0.02058925094950933,
                        "success_improvement": 0.0,
                        "time_improvement": -2253.4867656993647,
                        "length_improvement": 17.098408661070636,
                        "smoothness_improvement": 222.2664876338706,
                        "objective_score": -664.6756520749976
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5786649703979492,
                        "num_nodes_avg": 1014.8,
                        "path_length_avg": 223.7199642443417,
                        "smoothness_avg": 0.014513759212874738,
                        "success_improvement": 0.0,
                        "time_improvement": -260.02587573506054,
                        "length_improvement": 25.31583651311142,
                        "smoothness_improvement": 273.4494783854807,
                        "objective_score": -61.451013420723896
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.333528995513916,
                        "num_nodes_avg": 730.1,
                        "path_length_avg": 114.76663509983318,
                        "smoothness_avg": 0.029182927141035354,
                        "success_improvement": 0.0,
                        "time_improvement": -586.442615791514,
                        "length_improvement": 23.777465566582624,
                        "smoothness_improvement": 271.20467917435593,
                        "objective_score": -160.31028200163283
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
            "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": -31.88223,
            "time_improvement": 70.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 318.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
                }
            ],
            "success_rate": 1.0
        },
        "objective": 47.6,
        "analysis": "1. Summary of key changes:\n   - Introduced goal bias sampling to improve convergence speed and reduce unnecessary sampling.\n   - Implemented fixed-radius neighbor rewiring to optimize path costs incrementally.\n   - Alternated tree expansion direction systematically to balance exploration.\n   - Added early termination upon finding a feasible path connecting the two trees.\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling reducing random sampling overhead and focusing growth toward the goal.\n   - Rewiring within a fixed radius enabling cost-efficient local path optimizations during tree expansion.\n   - Early termination preventing excess iterations after a valid path is found.\n3. Expected mechanism of impact:\n   - Faster convergence to valid paths due to goal-directed sampling and informed rewiring.\n   - Lower computational time required by avoiding exhaustive edge checking and linear nearest neighbor searches each iteration.\n   - Reduced exploration redundancy and improved path quality resulting in fewer nodes and edges being processed."
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A structurally enhanced single-tree RRT* planner with adaptive informed sampling restricted to an ellipsoidal subset after first solution, dynamic rewiring radius adapting with node density and planning progress, incremental pruning of outdated nodes, and efficient early stopping based on path improvement and a hard 30-second time limit, aiming to improve planning efficiency, path length, and smoothness simultaneously.",
                "planning_mechanism": "The planner grows a single tree rooted at start by sampling points uniformly before first solution and then within an ellipsoidal informed subset defined by the current best path cost. It steers toward samples with fixed step size, connects only collision-free edges, and uses an adaptive neighbor radius based on the number of nodes and problem dimension to select parents and rewire neighbors, improving path cost and smoothness incrementally. Periodic pruning removes invalid or suboptimal nodes to keep the tree streamlined. Planning halts either on 30-second timeout or when no improvements occur for a threshold number of iterations. The path is extracted from the best goal-connected node.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # hard time limit in seconds\n        self.improve_tol = 1e-5\n        self.max_no_improve = 200\n        self.prune_interval = 500  # iterations between pruning\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min):\n            # If no solution found, uniform sample\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x * x for x in raw))\n                if norm_raw < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align the first axis to e1 (only implemented for 2D/3D)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n\n            while True:  # fallback uniform sample\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def prune_nodes():\n            # Remove invalid or isolated nodes to reduce tree complexity\n            to_remove = []\n            for n in nodes:\n                # Remove nodes marked invalid or disconnected from tree\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            # Remove nodes safely\n            for n in to_remove:\n                # Disconnect from parent\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                # Disconnect all children\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # Remove edges connected to n\n                for edge in list(edges):\n                    if edge[0] == n or edge[1] == n:\n                        edges.remove(edge)\n\n        iteration = 0\n        c_min = dist(start_pos, goal_pos)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min)\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius: theoretical for RRT* with safety margins\n            gamma = 35.0\n            n_nodes = len(nodes) + 1\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_parent_cost = new_cost\n            for near_node in near:\n                if near_node == nearest:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_parent_cost = cost_through\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better path found\n            for near_node in near:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge if present\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to goal if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.cost = goal_cost\n                    goal_node.parent = new_node\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Periodic pruning to improve planning efficiency\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # fallback: closest node to goal\n            closest = nearest_node(nodes, goal_pos)\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": 111.52446,
                "time_improvement": -394.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 83.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.12738897800445556,
                        "num_nodes_avg": 790.2,
                        "path_length_avg": 169.3978892921885,
                        "smoothness_avg": 0.012305547640369511,
                        "success_improvement": 0.0,
                        "time_improvement": -406.9683128259236,
                        "length_improvement": 7.150332597620601,
                        "smoothness_improvement": 92.60854249618313,
                        "objective_score": -117.3372515767238
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.38849313259124757,
                        "num_nodes_avg": 1255.3,
                        "path_length_avg": 264.7068157958746,
                        "smoothness_avg": 0.0060919297753769235,
                        "success_improvement": 0.0,
                        "time_improvement": -141.70735647266443,
                        "length_improvement": 11.633245724100348,
                        "smoothness_improvement": 56.749740960107644,
                        "objective_score": -35.24851080253858
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.356812047958374,
                        "num_nodes_avg": 938.3,
                        "path_length_avg": 130.9430033769814,
                        "smoothness_avg": 0.015733291561431894,
                        "success_improvement": 0.0,
                        "time_improvement": -634.3619260720436,
                        "length_improvement": 13.033891992782134,
                        "smoothness_improvement": 100.1263073506315,
                        "objective_score": -181.98761108919064
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with efficient neighbor selection, rewiring, and early stopping to improve generalization, reduce complexity, and maintain robust path quality and smoothness within a 30-second time limit. It grows a single tree from start to goal by sampling collision-free points, steering incrementally, selecting the lowest-cost parent from neighbors within a dynamically scaled radius, rewiring neighbors to reduce cost, and terminating once a path to the goal is found.",
                "planning_mechanism": "The planner builds a tree rooted at the start by iteratively sampling free points, steering toward them with fixed step size, choosing optimal parent nodes from a radius-based neighborhood, applying local rewiring to minimize path costs, and returning the best path within a time budget or when the goal neighborhood is reached.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, neighbor_gamma: float=50.0, goal_radius: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_radius = max(bounds)*0.3\n        min_radius = max(10.0, self.step_size*2.0)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: return start (rare)\n            return start_pos\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return min_radius\n            r = self.neighbor_gamma * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            return min(max_radius, max(min_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if math.dist(n.position, pos) <= radius]\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached, return best found\n                return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, r)\n            # Select best parent in neighbors with valid edge\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                # fallback to nearest_node if edge free\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Rewire: update parent and cost, edges lists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            # Check if goal reached\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path)-1):\n                    cost += math.dist(path[i], path[i+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": 680.61663,
                "time_improvement": -2311.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 212.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.2963702201843261,
                        "num_nodes_avg": 798.3,
                        "path_length_avg": 153.40311775845035,
                        "smoothness_avg": 0.01867232962112822,
                        "success_improvement": 0.0,
                        "time_improvement": -5059.148253011591,
                        "length_improvement": 15.917320328636658,
                        "smoothness_improvement": 192.26250618341595,
                        "objective_score": -1507.2327711753783
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 1.0090357303619384,
                        "num_nodes_avg": 1116.8,
                        "path_length_avg": 232.92130464304964,
                        "smoothness_avg": 0.011711985498954181,
                        "success_improvement": 0.0,
                        "time_improvement": -527.788083010616,
                        "length_improvement": 22.244164242124114,
                        "smoothness_improvement": 201.3578226902683,
                        "objective_score": -143.983137244459
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7028919219970703,
                        "num_nodes_avg": 837.6,
                        "path_length_avg": 120.10951944487313,
                        "smoothness_avg": 0.0270341704816116,
                        "success_improvement": 0.0,
                        "time_improvement": -1346.6357529453908,
                        "length_improvement": 20.22897618541956,
                        "smoothness_improvement": 243.8726530712041,
                        "objective_score": -390.63397690700947
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid RRT*-based planner combining adaptive ellipsoidal informed sampling after initial solution, progressive goal bias to accelerate convergence, dynamic rewiring radius scaling with node count, and incremental path shortcutting for enhanced smoothness and reduced length. It enforces strict node and edge collision checks, prunes disconnected nodes periodically, and terminates early on time limit or path quality stabilization.",
            "planning_mechanism": "The planner grows a single tree rooted at start by sampling uniformly initially, then biases samples within an informed ellipsoidal region as solutions are found and increasingly towards the goal. It performs fixed-step steering ensuring collision-free nodes and connects new nodes to the cost-optimal neighbor within an adaptively shrinking radius. Rewiring neighbors improves path costs iteratively. Periodic incremental pruning removes invalid/disconnected nodes to maintain efficiency. Upon termination, it extracts the best path and applies local shortcutting to reduce unnecessary waypoints and sharp turns, improving smoothness and path length. Early stopping is triggered either on 30 seconds elapsed or no improvement over a threshold number of iterations.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_every = 400\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # Fallback\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align first axis e1 (only 2D/3D cases)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively capped by max rate\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            # Sample with goal bias (biased towards informed if solution found)\n            prob = random.random()\n            if prob < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius for neighbor search\n            n_nodes = len(nodes) + 1\n            gamma = 30.0  # practical constant between 20 and 40\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n            # Select parent minimizing cost + dist\n            best_parent = nearest\n            best_cost_through = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improves cost\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Check if can connect to goal\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Incremental pruning to keep tree light\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            smoothed_path = shortcut_path(raw_path)\n            extracted_path = smoothed_path\n        else:\n            # fallback: closest to goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": 14.04548,
            "time_improvement": -109.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1717.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05759344100952148,
                    "num_nodes_avg": 482.9,
                    "path_length_avg": 169.84128169423337,
                    "smoothness_avg": 0.04532420523685691,
                    "success_improvement": 0.0,
                    "time_improvement": -129.2038924860142,
                    "length_improvement": 6.907302196057579,
                    "smoothness_improvement": 609.4222350437985,
                    "objective_score": -31.569675252950724
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1714890718460083,
                    "num_nodes_avg": 1146.4,
                    "path_length_avg": 229.8773660277296,
                    "smoothness_avg": 0.11527027308817159,
                    "success_improvement": 0.0,
                    "time_improvement": -6.694730852452992,
                    "length_improvement": 23.260318566833043,
                    "smoothness_improvement": 2865.9871523804313,
                    "objective_score": 26.277707646266084
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1416875123977661,
                    "num_nodes_avg": 753.3,
                    "path_length_avg": 119.78501316134012,
                    "smoothness_avg": 0.13949436748541644,
                    "success_improvement": 0.0,
                    "time_improvement": -191.60986883749686,
                    "length_improvement": 20.444497807613494,
                    "smoothness_improvement": 1674.358058011333,
                    "objective_score": -36.844471676624295
                }
            ],
            "success_rate": 1.0
        },
        "objective": -179.39999999999998,
        "analysis": "1. Summary of key changes:\n   - Introduction of progressive goal bias with increasing sampling rate towards the goal in the offspring.\n   - Incorporation of incremental path shortcutting after path extraction to smooth and shorten the path.\n   - More frequent and incremental pruning of invalid/disconnected nodes maintaining a lighter tree.\n   - Slightly reduced max_no_improve threshold (150 vs 200) and pruning interval (400 vs 500 iterations).\n   - Retained adaptive neighbor radius and ellipsoidal informed sampling with tighter practical tuning (gamma=30).\n\n2. Primary contributors to the performance improvement:\n   - Progressive goal bias accelerating convergence towards the goal reducing wasted sampling and expansion time.\n   - Incremental pruning preventing tree bloat improving collision check efficiency and node management speed.\n   - Path shortcutting drastically improving path smoothness and reducing redundant waypoints, indirectly speeding up processing.\n   - Adaptive rewiring radius and rewiring logic tuned for more practical constants (gamma=30) balancing exploration and rewiring cost.\n\n3. Expected mechanism of impact:\n   - Increased sampling bias towards the goal focuses search efforts, reducing exploration overhead and iteration counts.\n   - Frequent pruning reduces tree complexity, leading to fewer nodes/edges to check for collisions and neighbors.\n   - Shortcutting eliminates unnecessary turns and waypoints, shortening paths and lowering evaluation complexity in subsequent iterations.\n   - Balanced rewiring radius and step size provides an efficient neighborhood search for improved path costs without excessive checks, improving iteration runtime."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
                "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 4.05717,
                "time_improvement": -77.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1607.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03238720893859863,
                        "num_nodes_avg": 240.1,
                        "path_length_avg": 156.8355269466239,
                        "smoothness_avg": 0.04571460503828216,
                        "success_improvement": 0.0,
                        "time_improvement": -28.890967883954104,
                        "length_improvement": 14.03596246259457,
                        "smoothness_improvement": 615.5328397028414,
                        "objective_score": 2.831951310884718
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.147990083694458,
                        "num_nodes_avg": 859.9,
                        "path_length_avg": 231.82003384026544,
                        "smoothness_avg": 0.10402068439578667,
                        "success_improvement": 0.0,
                        "time_improvement": 7.925548965645519,
                        "length_improvement": 22.611800134415976,
                        "smoothness_improvement": 2576.527132574148,
                        "objective_score": 28.827380433213982
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15016646385192872,
                        "num_nodes_avg": 570.8,
                        "path_length_avg": 123.61458665916646,
                        "smoothness_avg": 0.13595502682176802,
                        "success_improvement": 0.0,
                        "time_improvement": -209.06056635900154,
                        "length_improvement": 17.901077435050915,
                        "smoothness_improvement": 1629.3379060166778,
                        "objective_score": -43.83083391658651
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -23.298298969701534,
                "time_improvement": 51.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 174.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016666102409362792,
                        "num_nodes_avg": 78.0,
                        "path_length_avg": 171.93676993008617,
                        "smoothness_avg": 0.017258852621246313,
                        "success_improvement": 0.0,
                        "time_improvement": 33.67412195140466,
                        "length_improvement": 5.758731888850669,
                        "smoothness_improvement": 170.1385217208312,
                        "objective_score": 14.408168327335954
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.026815319061279298,
                        "num_nodes_avg": 207.7,
                        "path_length_avg": 254.55172472875432,
                        "smoothness_avg": 0.010846570009997185,
                        "success_improvement": 0.0,
                        "time_improvement": 83.31641066589374,
                        "length_improvement": 15.023307420394557,
                        "smoothness_improvement": 179.09005882582343,
                        "objective_score": 34.90435794613397
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0310056209564209,
                        "num_nodes_avg": 214.5,
                        "path_length_avg": 128.32906870441866,
                        "smoothness_avg": 0.02145278500029813,
                        "success_improvement": 0.0,
                        "time_improvement": 36.186718876507044,
                        "length_improvement": 14.769942940104954,
                        "smoothness_improvement": 172.8778417239189,
                        "objective_score": 20.58237063563468
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "An improved bi-directional RRT* planner that combines goal bias sampling, adaptive neighbor radius, and continuous rewiring to optimize path cost and smoothness efficiently. The planner grows two trees from start and goal, incrementally connects and rewires nodes within adaptive radii, and employs early stopping once a connection is found. Post-processing shortcutting refines the path for smoothness and shorter length. Efficient collision checking with adaptive resolution and early exits reduce planning time while maintaining robust performance.",
            "planning_mechanism": "The planner alternates growth between two trees started from start and goal. It samples with goal bias to guide exploration, steers incrementally towards samples, and maintains an adaptive neighbor radius for rewiring to locally optimize paths. Trees attempt connection after each iteration, early stopping on success. Periodic shortcutting post-processes the extracted path to improve smoothness and length before returning the final solution within a strict time limit.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=50.0, max_neighbor_radius: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = math.dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], n_nodes: int) -> List[Node]:\n            if n_nodes < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2.0, r))\n            result = [node for node in tree if math.dist(node.position, point) <= radius]\n            return result\n\n        def choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges):\n            nearest_node_ = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos, len(tree))\n            min_cost = nearest_node_.cost + math.dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n            for nb in neighbors:\n                if nb == nearest_node_:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None, []\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path_nodes: List[Node] = []\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling: alternate sampling randomly or goal\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_free()\n\n            # Alternate expansion trees each iteration\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node, neighbors = choose_parent_and_add(tree_a, steer(nearest(tree_a, sample).position, sample, self.step_size),\n                                                       obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect the other tree to new node\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_near_b = math.dist(new_node.position, nearest_in_b.position)\n            last_connect_node = None\n            curr_pos = new_node.position\n\n            while dist_to_near_b > self.step_size:\n                next_pos = steer(curr_pos, nearest_in_b.position, self.step_size)\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_pos, next_pos, obstacles, is_3d):\n                    break\n                chosen_node, nbs = choose_parent_and_add(tree_b, next_pos, obstacles, is_3d, nodes, edges)\n                if chosen_node is None:\n                    break\n                rewire_from(chosen_node, nbs, obstacles, is_3d, edges)\n                curr_pos = chosen_node.position\n                dist_to_near_b = math.dist(curr_pos, nearest_in_b.position)\n                last_connect_node = chosen_node\n\n            # Try to connect directly if within step size\n            if last_connect_node is not None and math.dist(last_connect_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(last_connect_node.position, nearest_in_b.position, obstacles, is_3d) and \\\n                    not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d):\n\n                    final_node = Node(nearest_in_b.position, None,\n                                      last_connect_node.cost + math.dist(last_connect_node.position, nearest_in_b.position))\n                    last_connect_node.children.append(final_node)\n                    final_node.parent = last_connect_node\n                    nodes.append(final_node)\n                    tree_b.append(final_node)\n                    edges.append((last_connect_node, final_node))\n\n                    # Extract combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = final_node.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        # Avoid duplicate at connection point\n                        path_goal = path_goal[:-1]\n                    full_path = path_start + path_goal[::-1]\n\n                    # Update best path if cost better\n                    path_cost = final_node.cost + new_node.cost - math.dist(new_node.position, nearest_in_b.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path_nodes = full_path\n                        success = True\n\n                    # Early stopping on first valid path\n                    break\n\n        # If no path connected, try closest nodes\n        if not best_path_nodes:\n            # Find node closest to goal in start tree\n            goal_nearest_node = min(tree_start, key=lambda n: math.dist(n.position, goal_pos))\n            # Backtrack\n            best_path_nodes = goal_nearest_node.path_from_root()\n            success = False\n\n        # Path shortcutting/post-processing\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        best_path_nodes = shortcut_path(best_path_nodes)\n\n        return PlannerResult(\n            success=success if 'success' in locals() else False,\n            path=best_path_nodes,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 1.81366,
            "time_improvement": -64.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1609.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06511895656585694,
                    "num_nodes_avg": 107.1,
                    "path_length_avg": 167.86838334936317,
                    "smoothness_avg": 0.042074717464123695,
                    "success_improvement": 0.0,
                    "time_improvement": -159.153092051829,
                    "length_improvement": 7.9886790414557955,
                    "smoothness_improvement": 558.5606950248841,
                    "objective_score": -40.15991671555079
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09056892395019531,
                    "num_nodes_avg": 264.7,
                    "path_length_avg": 234.50722182399244,
                    "smoothness_avg": 0.10901757476160132,
                    "success_improvement": 0.0,
                    "time_improvement": 43.651062656985864,
                    "length_improvement": 21.71473943903038,
                    "smoothness_improvement": 2705.100720801212,
                    "objective_score": 39.64966606452005
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08601047992706298,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 124.56625372840308,
                    "smoothness_avg": 0.13072121654165783,
                    "success_improvement": 0.0,
                    "time_improvement": -77.01986819959468,
                    "length_improvement": 17.26902548118002,
                    "smoothness_improvement": 1562.7642255733656,
                    "objective_score": -4.930724043303564
                }
            ],
            "success_rate": 1.0
        },
        "objective": 7.600000000000001,
        "analysis": "1. Summary of key changes:\n   - Offspring employs a bi-directional tree expansion strategy alternating growth between start and goal trees.\n   - Incorporates goal bias sampling with a lower goal sample rate (10%) and balanced random sampling.\n   - Uses an adaptive neighbor radius for rewiring with safeguards on minimum and maximum radius.\n   - Implements iterative rewiring and connection attempts at each step to optimize path connections.\n   - Integrates an efficient combined path extraction from both trees upon successful connection.\n   - Applies shortcutting post-processing on the final path to improve smoothness and reduce length.\n\n2. Primary contributors to the performance improvement:\n   - Bi-directional search reduces the exploration space and leads to faster connection of start and goal.\n   - Adaptive radius and rewiring improve path quality and convergence speed.\n   - Goal bias sampling increases likelihood of quickly finding a feasible path toward the goal.\n   - Incremental rewiring with edge-validity checks reduces redundant expansions and improves connectivity.\n   - Efficient path extraction and early stopping reduces unnecessary iterations once a solution is found.\n\n3. Expected mechanism of impact:\n   - Alternating tree growth cuts down the time spent exploring irrelevant regions by focusing search from both directions.\n   - Adaptive neighbor radius balances exploration and exploitation, enabling efficient rewiring without excess costly checks.\n   - Goal bias guides sampling toward the goal, speeding up convergence to a viable path.\n   - Rewiring and connection checks ensure that the tree maintains near-optimal paths and avoids costly dead-ends.\n   - Early termination upon finding a valid path improves time efficiency by preventing further unnecessary computations."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid anytime RRT* variant leveraging incremental informed sampling, adaptive connection radius, and batch rewiring to improve efficiency and path quality within a 30-second hard limit. The planner initially explores globally with uniform samples, then focuses sampling within an ellipsoidal informed set after finding a solution. It maintains node validity strictly with collision checks, dynamically selects the best parent, rewires neighbors to reduce cost, and terminates early if elapsed time or solution quality stabilizes. The final path is extracted from the best goal node or closest node otherwise, returning a well-optimized, smooth path.",
                "planning_mechanism": "The planner builds a single tree by iteratively sampling states using a goal-biased plus informed ellipsoidal distribution. Each new sample is connected to the lowest-cost parent within an adaptive radius and neighbors are rewired to optimize paths. Collision checks ensure node and edge feasibility. The connection radius shrinks as iterations grow. Early termination occurs if no improvement over a threshold is observed or time limit elapses. The solution path is extracted from the best goal node found or nearest node if no complete path is available.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.batch_size = 50  # batch rewiring frequency\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            # If no solution yet or degenerate, uniform sample\n            if c_best == float('inf') or c_min < 1e-10 or dim not in (2, 3):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n\n            axes = (r1,) + (r_other,) * (dim - 1)\n\n            attempts = 0\n            while attempts < 200:\n                # sample random point on unit ball\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate sample so major axis aligns with vector e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    else:  # dim == 3\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0.0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            # Linear search acceptable due to modest node count; KD-tree could help for performance\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (dist(n.position, point) <= radius)]\n\n        def path_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_counter = 0\n        max_no_improve = 150\n\n        c_min = dist(start_pos, goal_pos)\n\n        for iteration in range(self.max_iter):\n\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n            c_best = best_cost if found_solution else float('inf')\n\n            # Sample: goal biasing and informed sampling after first solution\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            # Reject invalid samples\n            if is_in_obstacle(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius (RRT* radius with lower/upper bounds)\n            rmax = self.step_size * 20.0\n            rmin = self.step_size\n            gamma_rrt_star = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (1 + 1/dim) ) / ( ( (4/3)*math.pi if dim==3 else 1) ) )**(1/dim) )\n            radius = min(rmax, max(rmin, gamma_rrt_star * ( (math.log(len(nodes)+1) / (len(nodes)+1))**(1/dim) )))\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent among neighbors (lowest cost + feasibilty)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + self.improve_tol < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring every batch_size nodes to reduce overhead\n            if (len(nodes) % self.batch_size) == 0:\n                for nbr in neighbors:\n                    if nbr == best_parent or nbr == new_node:\n                        continue\n                    rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if rewired_cost + self.improve_tol < nbr.cost:\n                        if not is_edge_in_obstacle(new_node.position, nbr.position):\n                            # Rewire tree structure and edges\n                            old_parent = nbr.parent\n                            if old_parent:\n                                old_parent.remove_child(nbr)\n                                try:\n                                    edges.remove((old_parent, nbr))\n                                except ValueError:\n                                    pass\n                            new_node.add_child(nbr)\n                            nbr.cost = rewired_cost\n                            edges.append((new_node, nbr))\n\n            # Check goal connection if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_counter = 0\n\n            # Early stopping if solution stable\n            if found_solution:\n                no_improve_counter += 1\n                if no_improve_counter > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # Return path to closest node to goal if no full solution found\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
                "objective": 86.90523,
                "time_improvement": -233.0,
                "length_improvement": -1.0,
                "smoothness_improvement": 61.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 0.9,
                        "time_avg": 0.0693166971206665,
                        "num_nodes_avg": 474.6,
                        "path_length_avg": 189.36555780350008,
                        "smoothness_avg": 0.01005017057735644,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -175.85878731753974,
                        "length_improvement": -3.7942629213847154,
                        "smoothness_improvement": 57.306993830346954,
                        "objective_score": -104.747658978941
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2834985971450806,
                        "num_nodes_avg": 1140.4,
                        "path_length_avg": 305.68179407811465,
                        "smoothness_avg": 0.006235597586945562,
                        "success_improvement": 0.0,
                        "time_improvement": -76.38328899816969,
                        "length_improvement": -2.0453814258676606,
                        "smoothness_improvement": 60.44641723151071,
                        "objective_score": -23.83998346881395
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2649787425994873,
                        "num_nodes_avg": 736.2,
                        "path_length_avg": 147.6887523984348,
                        "smoothness_avg": 0.013082809065717802,
                        "success_improvement": 0.0,
                        "time_improvement": -445.35798579931594,
                        "length_improvement": 1.9121628396116364,
                        "smoothness_improvement": 66.41236564341555,
                        "objective_score": -132.12803620781074
                    }
                ],
                "success_rate": 0.9666666666666667
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -24.394856704415727,
                "time_improvement": 84.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 65.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0037204265594482423,
                        "num_nodes_avg": 58.5,
                        "path_length_avg": 184.8763674372614,
                        "smoothness_avg": 0.010656061011327317,
                        "success_improvement": 0.0,
                        "time_improvement": 85.19386523557586,
                        "length_improvement": -1.3336665458757502,
                        "smoothness_improvement": 66.79049483412726,
                        "objective_score": 25.091912117317943
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.007217264175415039,
                        "num_nodes_avg": 195.5,
                        "path_length_avg": 293.476072886139,
                        "smoothness_avg": 0.006583639266204931,
                        "success_improvement": 0.0,
                        "time_improvement": 95.50966105071444,
                        "length_improvement": 2.0292396302187403,
                        "smoothness_improvement": 69.4017803231431,
                        "objective_score": 30.217450994961293
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.014179682731628418,
                        "num_nodes_avg": 216.3,
                        "path_length_avg": 159.7621915423607,
                        "smoothness_avg": 0.012486187243912596,
                        "success_improvement": 0.0,
                        "time_improvement": 70.81651479687723,
                        "length_improvement": -6.106440564392849,
                        "smoothness_improvement": 58.82338010809535,
                        "objective_score": 17.875207000967936
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified single-tree RRT* planner with goal bias sampling, fixed rewiring radius, early stopping upon finding the first valid path within a 30-second time limit. The planner incrementally builds a tree by sampling points, extending towards them with fixed step size while avoiding obstacles. Upon adding new nodes, neighbors within a fixed radius are rewired to reduce path cost, improving path quality and smoothness. The algorithm prioritizes efficiency and path optimization through adaptive rewiring and goal bias, returning the best found path in time.",
            "planning_mechanism": "The planner samples states biased towards the goal with a fixed goal sample rate. Each sample is steered from the nearest tree node with a fixed step size, checked for collision, and connected if valid. Then, neighbors within a fixed radius are rewired to potentially improve path costs. The planner stops early once a feasible path to the goal is found or after 30 seconds. Finally, the path is extracted from the best goal-reaching node or the closest node to goal if none.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.rewire_radius = 15.0  # Fixed radius for neighbor rewiring\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = uniform_sample()\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find best parent among near nodes\n            neighbors = near_nodes(nodes, new_pos, self.rewire_radius)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better cost\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if rewired_cost < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        old_parent = nbr.parent\n                        if old_parent:\n                            old_parent.remove_child(nbr)\n                            try:\n                                edges.remove((old_parent, nbr))\n                            except ValueError:\n                                pass\n                        new_node.add_child(nbr)\n                        nbr.cost = rewired_cost\n                        edges.append((new_node, nbr))\n\n            # Check if goal can be connected directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        # Early stopping on first path found\n                        break\n\n        success = best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": 19.84466,
            "time_improvement": -109.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 289.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.048426270484924316,
                    "num_nodes_avg": 279.7,
                    "path_length_avg": 160.81894805919956,
                    "smoothness_avg": 0.021476210214576158,
                    "success_improvement": 0.0,
                    "time_improvement": -92.72141929999013,
                    "length_improvement": 11.852586229445006,
                    "smoothness_improvement": 236.1493261950383,
                    "objective_score": -19.52412742135484
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2466820478439331,
                    "num_nodes_avg": 968.6,
                    "path_length_avg": 224.33104868500922,
                    "smoothness_avg": 0.016593750167991854,
                    "success_improvement": 0.0,
                    "time_improvement": -53.47727069439503,
                    "length_improvement": 25.111838937726233,
                    "smoothness_improvement": 326.9691438175732,
                    "objective_score": 0.6587678734050977
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13675882816314697,
                    "num_nodes_avg": 424.7,
                    "path_length_avg": 119.83094620225563,
                    "smoothness_avg": 0.03180515707284166,
                    "success_improvement": 0.0,
                    "time_improvement": -181.46604642946517,
                    "length_improvement": 20.413991268933778,
                    "smoothness_improvement": 304.5592503540521,
                    "objective_score": -40.66862291570902
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.800000000000011,
        "analysis": "1. Summary of key changes:\n   - Offspring uses fixed rewiring radius and rewires neighbors immediately each iteration instead of batch rewiring.\n   - Offspring applies simpler uniform sampling with goal bias, omitting informed sampling to reduce overhead.\n   - Offspring employs early stopping upon first path found, limiting unnecessary iterations.\n   - Simplified collision checking resolution increased to 1.0 to reduce computational cost.\n\n2. Primary contributors to the performance improvement:\n   - Immediate neighbor rewiring reduces overhead compared to batch rewiring, improving runtime.\n   - Fixed rewiring radius avoids costly adaptive radius computations.\n   - Early stopping terminates planning as soon as a feasible path is found, saving time.\n   - Reduced sampling complexity and collision checking resolution decrease per-iteration computation.\n\n3. Expected mechanism of impact:\n   - Faster path discovery via goal bias and early stopping shortens runtime substantially.\n   - Continuous rewiring maintains tree quality efficiently without expensive batch operations.\n   - Simpler sampling and collision checks minimize calculation times per sample.\n   - Fixed radius avoids frequent radius recalculations and neighbor searches over large sets."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
                "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 18.33169,
                "time_improvement": -104.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 277.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03312251567840576,
                        "num_nodes_avg": 199.7,
                        "path_length_avg": 163.67692862769394,
                        "smoothness_avg": 0.020726203772078875,
                        "success_improvement": 0.0,
                        "time_improvement": -31.81725886398311,
                        "length_improvement": 10.28608179225304,
                        "smoothness_improvement": 224.41009670489822,
                        "objective_score": -2.251478100318617
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2541221618652344,
                        "num_nodes_avg": 968.5,
                        "path_length_avg": 223.78483919358527,
                        "smoothness_avg": 0.016494501307333334,
                        "success_improvement": 0.0,
                        "time_improvement": -58.106259320137475,
                        "length_improvement": 25.29417938773204,
                        "smoothness_improvement": 324.4153991467646,
                        "objective_score": -0.633293167668195
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15669703483581543,
                        "num_nodes_avg": 482.5,
                        "path_length_avg": 117.3805344167902,
                        "smoothness_avg": 0.030113844927462913,
                        "success_improvement": 0.0,
                        "time_improvement": -222.5012635370204,
                        "length_improvement": 22.04143810076968,
                        "smoothness_improvement": 283.0458847045111,
                        "objective_score": -52.11028677712176
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An enhanced informed RRT* planner with adaptive neighbor radius decreasing as the tree grows, combined with fast k-nearest neighbor search optimization, intelligent goal biasing, and efficient path shortcutting for improved smoothness and shorter path lengths. It terminates early upon first path discovery within a hard 30-second limit and always maintains valid collision-free nodes and edges.",
            "planning_mechanism": "The planner grows a tree rooted at the start node by sampling points biased towards the goal and within an ellipsoidal informed subset if a solution exists. It adaptively adjusts neighbor radius inversely proportional to the logarithm of the tree size to reduce rewiring overhead and enhances local rewiring quality. After path discovery, it applies an iterative shortcutting pass to remove unnecessary waypoints, improving smoothness. A combination of efficient collision checking and early pruning ensures fast and robust exploration within the time limit.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0, goal_sample_rate=0.2, max_neighbor_radius=20.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float,...], b: Tuple[float,...]) -> float:\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        def sample_informed(c_best, x_start, x_goal):\n            # If no solution yet, sample uniform\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(vi / norm_v for vi in v)\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                val = c_best*c_best - c_min*c_min\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n\n            radii = [r1] + [r2]*(dim - 1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # K-Nearest linear search as a proxy for efficient neighbor search\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                di = dist(nodes[i].position, p)\n                if di < best_d:\n                    best_d = di\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        def radius_adaptive(num_nodes):\n            # Decrease with number of nodes for efficiency but keep lower bound\n            # Formula inspired by theoretical RRT* radius: gamma*(log(n)/n)^(1/d)\n            if num_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(num_nodes)/num_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        def nearby_nodes(p, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in nodes:\n                # squared distance to avoid sqrt cost\n                d2 = 0.0\n                pos = node.position\n                for i in range(dim):\n                    diff = pos[i] - p[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        # Shortcutting to improve smoothness & shorten path after solution found.\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iterations = 200\n            iteration = 0\n            while improved and iteration < max_iterations and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sampling with goal bias and informed sampling if path found\n            if (random.random() < self.goal_sample_rate):\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Nearest node\n            near_node, _ = nearest_node(sample)\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            curr_radius = radius_adaptive(len(nodes))\n\n            neighbors = nearby_nodes(new_pos, curr_radius)\n\n            # Choose best parent among neighbors (including near_node)\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early terminate on first found path\n                    break\n\n        success = False\n        extracted_path = []\n\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n            # Apply shortcutting for smoothness & length improvement\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            min_d = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": 29.88804,
            "time_improvement": -160.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1607.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024425053596496583,
                    "num_nodes_avg": 213.1,
                    "path_length_avg": 166.19028261184675,
                    "smoothness_avg": 0.04801196561764766,
                    "success_improvement": 0.0,
                    "time_improvement": 2.795921543027604,
                    "length_improvement": 8.908472646896378,
                    "smoothness_improvement": 651.4915215682581,
                    "objective_score": 9.441317658887398
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.29114747047424316,
                    "num_nodes_avg": 1011.8,
                    "path_length_avg": 232.2715272372731,
                    "smoothness_avg": 0.09733131184942458,
                    "success_improvement": 0.0,
                    "time_improvement": -81.14216064167789,
                    "length_improvement": 22.461078642977945,
                    "smoothness_improvement": 2404.4047587959576,
                    "objective_score": 1.1560227872631899
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.24303045272827148,
                    "num_nodes_avg": 613.8,
                    "path_length_avg": 123.0584057279423,
                    "smoothness_avg": 0.14673052153342167,
                    "success_improvement": 0.0,
                    "time_improvement": -400.1857767440491,
                    "length_improvement": 18.27046632708009,
                    "smoothness_improvement": 1766.4014033846272,
                    "objective_score": -100.26144621004354
                }
            ],
            "success_rate": 1.0
        },
        "objective": -73.6,
        "analysis": "1. Summary of key changes:\n   - Adaptive neighbor radius decreasing with the number of nodes, bounded by min and max limits, replacing fixed large radius.\n   - Inclusion of path shortcutting post-processing to smooth and shorten the final path.\n   - Slightly higher max iterations and increased goal sampling rate.\n   - Use of squared distance in neighbor search to reduce computational overhead.\n   - Maintained collision checking with adaptive resolution and goal bias combined with informed sampling.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighbor radius reducing neighbor candidate set size, lowering computational cost for neighbor search and rewiring.\n   - Path shortcutting removing unnecessary waypoints, improving path smoothness and length after plan completion.\n   - Efficient distance computations using squared distances in neighbor search reducing CPU load.\n   - More balanced exploration from increased goal sample rate and controlled iteration count.\n\n3. Expected mechanism of impact:\n   - Shrinking neighbor radius accelerates nearest neighbor and rewiring operations, significantly reducing planning time.\n   - Shortcutting streamlines the constructed path, decreasing the overall path length and sharply increasing smoothness metrics.\n   - Reduced computational cost per iteration enables more effective use of allotted planning time.\n   - Increased goal bias improves convergence toward goal, cutting down wasted exploration time and improving solution quality."
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
                "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": -13.97956,
                "time_improvement": -17.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1470.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.052588915824890135,
                        "num_nodes_avg": 232.6,
                        "path_length_avg": 153.88454915168901,
                        "smoothness_avg": 0.04347023177026047,
                        "success_improvement": 0.0,
                        "time_improvement": -109.28744658079108,
                        "length_improvement": 15.653440153233934,
                        "smoothness_improvement": 580.4035243237437,
                        "objective_score": -20.492152260678246
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.048712754249572755,
                        "num_nodes_avg": 358.8,
                        "path_length_avg": 233.0599917365158,
                        "smoothness_avg": 0.10226409696877743,
                        "success_improvement": 0.0,
                        "time_improvement": 69.69256321821518,
                        "length_improvement": 22.197866498438458,
                        "smoothness_improvement": 2531.328872858417,
                        "objective_score": 46.883133228819716
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.054259729385375974,
                        "num_nodes_avg": 387.5,
                        "path_length_avg": 119.05752821578226,
                        "smoothness_avg": 0.10995381497824393,
                        "success_improvement": 0.0,
                        "time_improvement": -11.673021153817839,
                        "length_improvement": 20.927658669342527,
                        "smoothness_improvement": 1298.6044105768708,
                        "objective_score": 15.547710908344518
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius, goal bias, and informed ellipsoidal sampling after first solution. Includes incremental cost propagation and dynamic early stopping once improvement stagnates. Path smoothing is achieved via shortcutting to reduce length and improve smoothness. The dual-tree alternation and cost-aware rewiring enable faster convergence to shorter, smoother paths within time constraints. Adaptive rewiring radius balances exploration and exploitation, while incremental tree connection attempts efficiently link start and goal trees.",
            "planning_mechanism": "A planner grows start and goal trees alternately, sampling either uniformly, goal-biased, or within an ellipsoidal informed set based on current best cost. Each iteration extends a tree with collision-checked edges chosen via cost-minimizing parents within adaptive neighborhood radius. The other tree attempts incremental connections to the new node. Rewiring optimizes downstream costs with cost propagation. Early stopping triggers on no improvement for a set iteration budget. Final path is extracted by stitching trees and shortcut smoothed before returning.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 120,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size  # tuple\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos  # fallback\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped_clamped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped_clamped):\n                return uniform_sample()\n            return mapped_clamped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for node in nodes_list:\n                d_ = dist(node.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = node\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            r_sq = radius * radius\n            for node in nodes_list:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidates = [p]\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(c)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            if not (n1.valid and n2.valid):\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate junction\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found_first = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sample point\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Attempt direct connection if close\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental greedy connection\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                # Calculate cost\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": -11.72122,
            "time_improvement": -28.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1646.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.057636451721191403,
                    "num_nodes_avg": 363.5,
                    "path_length_avg": 154.42405273525654,
                    "smoothness_avg": 0.046313415622482146,
                    "success_improvement": 0.0,
                    "time_improvement": -129.37506167404226,
                    "length_improvement": 15.357729690099218,
                    "smoothness_improvement": 624.9055256835675,
                    "objective_score": -26.47335305973531
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05254173278808594,
                    "num_nodes_avg": 466.7,
                    "path_length_avg": 231.26911156722468,
                    "smoothness_avg": 0.11306651076959359,
                    "success_improvement": 0.0,
                    "time_improvement": 67.31030159530937,
                    "length_improvement": 22.79571384657537,
                    "smoothness_improvement": 2809.282760617581,
                    "objective_score": 47.916932589625944
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05907044410705566,
                    "num_nodes_avg": 478.2,
                    "path_length_avg": 118.753256645699,
                    "smoothness_avg": 0.12601429319298174,
                    "success_improvement": 0.0,
                    "time_improvement": -21.57404817633579,
                    "length_improvement": 21.12974135833665,
                    "smoothness_improvement": 1502.8925080071474,
                    "objective_score": 13.720092902136988
                }
            ],
            "success_rate": 1.0
        },
        "objective": -12.4,
        "analysis": "1. Summary of key changes:\n   - Reduced maximum iterations from 10000 to 5000, decreasing overall runtime.\n   - Decreased step size from 5.0 to 4.0, allowing finer resolution tree growth.\n   - Slightly reduced rewiring constant gamma_rrt_star from 40.0 to 30.0, altering adaptive neighbor radius.\n   - Removed post-optimization iteration parameters, simplifying early stopping to max_no_improve count.\n   - Streamlined no improvement counting and breaking logic in main loop.\n2. Primary contributors to the performance improvement:\n   - Fewer iterations combined with efficient early stopping reduced redundant computations.\n   - Smaller step size improved path quality while balancing exploration, enabling quicker convergence.\n   - Simplified control flow for early stopping decreased overhead and unnecessary continued planning.\n3. Expected mechanism of impact:\n   - Limiting iterations reduces total collision checks and rewiring costs, lowering planning time.\n   - Smaller step size results in more manageable edge checks and better incremental improvements, speeding up solution finding.\n   - Streamlined early termination criteria prompt the algorithm to stop sooner when no improvement occurs, saving time."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
                "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
                "objective": 5.46059,
                "time_improvement": -53.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 293.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06232309341430664,
                        "num_nodes_avg": 267.2,
                        "path_length_avg": 168.2463107739374,
                        "smoothness_avg": 0.02259680420437422,
                        "success_improvement": 0.0,
                        "time_improvement": -148.0264306480139,
                        "length_improvement": 7.781531031403382,
                        "smoothness_improvement": 253.68905554417486,
                        "objective_score": -38.47056529784127
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08523426055908204,
                        "num_nodes_avg": 568.0,
                        "path_length_avg": 241.3226903680994,
                        "smoothness_avg": 0.016808760155440354,
                        "success_improvement": 0.0,
                        "time_improvement": 46.970110737287854,
                        "length_improvement": 19.439539866622514,
                        "smoothness_improvement": 332.5015056600573,
                        "objective_score": 27.41726466946015
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07625963687896728,
                        "num_nodes_avg": 483.4,
                        "path_length_avg": 124.7326333683994,
                        "smoothness_avg": 0.03084680379066026,
                        "success_improvement": 0.0,
                        "time_improvement": -56.951465457596676,
                        "length_improvement": 17.15852404644154,
                        "smoothness_improvement": 292.3690673429857,
                        "objective_score": -5.328479872699152
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
                "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": -13.97956,
                "time_improvement": -17.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1470.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.052588915824890135,
                        "num_nodes_avg": 232.6,
                        "path_length_avg": 153.88454915168901,
                        "smoothness_avg": 0.04347023177026047,
                        "success_improvement": 0.0,
                        "time_improvement": -109.28744658079108,
                        "length_improvement": 15.653440153233934,
                        "smoothness_improvement": 580.4035243237437,
                        "objective_score": -20.492152260678246
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.048712754249572755,
                        "num_nodes_avg": 358.8,
                        "path_length_avg": 233.0599917365158,
                        "smoothness_avg": 0.10226409696877743,
                        "success_improvement": 0.0,
                        "time_improvement": 69.69256321821518,
                        "length_improvement": 22.197866498438458,
                        "smoothness_improvement": 2531.328872858417,
                        "objective_score": 46.883133228819716
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.054259729385375974,
                        "num_nodes_avg": 387.5,
                        "path_length_avg": 119.05752821578226,
                        "smoothness_avg": 0.10995381497824393,
                        "success_improvement": 0.0,
                        "time_improvement": -11.673021153817839,
                        "length_improvement": 20.927658669342527,
                        "smoothness_improvement": 1298.6044105768708,
                        "objective_score": 15.547710908344518
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive neighbor radius, goal bias, informed sampling after initial solution, and integrated path shortcutting to enhance efficiency, path length minimization, and smoothness. The planner employs incremental cost propagation on rewiring, early stopping based on no improvement, and rigorous collision checks to respect environment constraints. It dynamically balances exploration and exploitation, efficiently connecting two trees grown from start and goal, and post-processes to yield a short, smooth, and feasible path.",
            "planning_mechanism": "A planner that alternates between growing start and goal trees using RRT* with an adaptive neighbor radius for rewiring, employs goal bias and informed sampling post-solution for efficiency, attempts immediate and incremental connections between trees, propagates cost updates downstream on rewiring, and post-processes the found path by shortcutting to improve smoothness and reduce length, terminating early upon reaching the time limit or no improvement threshold.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 100, time_limit_sec: float = 30.0, gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import time\n        import math\n        import random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not _is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if _is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            if not nodes_list:\n                return None\n            min_node = nodes_list[0]\n            min_d = dist(min_node.position, p)\n            for n in nodes_list[1:]:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_node = n\n                    min_d = d_\n            return min_node\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not _is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if p is None or _is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if _is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not _is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, start_tree_side):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicated point at connection if they equal\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if start_tree_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n            side_start = (it % 2 == 0)\n            curr_tree = tree_start if side_start else tree_goal\n            other_tree = tree_goal if side_start else tree_start\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if side_start else start_pos\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if side_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n            if _is_in_obstacle(new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            if nearest_other and dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental attempts to connect other tree to new node\n                current_node = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while current_node and tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current_node.position, new_node.position)\n                    if not within_bounds(step_pos) or _is_in_obstacle(step_pos) or _is_edge_in_obstacle(current_node.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current_node = other_new\n                    if dist(current_node.position, new_node.position) <= self.step_size and can_connect(current_node, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current_node.cost + dist(current_node.position, new_node.position))\n                        current_node.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current_node, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, side_start)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if found_first and no_improve_count >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": -20.10262,
            "time_improvement": -0.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1643.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03990023136138916,
                    "num_nodes_avg": 243.7,
                    "path_length_avg": 151.71533271438886,
                    "smoothness_avg": 0.04937742715811869,
                    "success_improvement": 0.0,
                    "time_improvement": -58.79044868340153,
                    "length_improvement": 16.842422055952248,
                    "smoothness_improvement": 672.8639598238237,
                    "objective_score": -4.167361572329989
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04238791465759277,
                    "num_nodes_avg": 398.2,
                    "path_length_avg": 232.25526955897027,
                    "smoothness_avg": 0.11988909499841452,
                    "success_improvement": 0.0,
                    "time_improvement": 73.62766561679376,
                    "length_improvement": 22.46650592394675,
                    "smoothness_improvement": 2984.8327669339337,
                    "objective_score": 50.492367074075844
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0565122127532959,
                    "num_nodes_avg": 449.2,
                    "path_length_avg": 119.16121883852645,
                    "smoothness_avg": 0.10786629904804887,
                    "success_improvement": 0.0,
                    "time_improvement": -16.308901679645523,
                    "length_improvement": 20.858792294932694,
                    "smoothness_improvement": 1272.0513620291879,
                    "objective_score": 13.9828616832119
                }
            ],
            "success_rate": 1.0
        },
        "objective": -6.800000000000001,
        "analysis": "1. Summary of key changes:\n   - Introduction of an adaptive neighbor radius for rewiring based on the number of nodes and dimension (gamma_rrt_star parameter).\n   - Use of goal bias combined with informed sampling after the initial solution to focus exploration near the current best path.\n   - Incremental and greedy connection attempts between trees with multiple intermediate nodes allowing more flexible and earlier tree connection.\n   - Implementation of a path shortcutting post-processing step to improve path length and smoothness.\n   - Balanced alternating expansion between start and goal trees with early stopping criteria based on no improvement thresholds.\n   - Cost propagation updates when rewiring improves node costs to maintain correct path costs.\n   - Reduction of steering step size for finer incremental growth leading to improved path quality.\n\n2. Primary contributors to the performance improvement:\n   - More efficient sampling strategy with informed sampling and goal bias improving convergence speed.\n   - Adaptive neighbor radius enhancing rewiring efficiency and quality of connections.\n   - Enhanced connecting logic between trees enabling faster discovery of shorter, feasible paths.\n   - Post-processing shortcutting greatly improving path smoothness and reducing length.\n   - More robust stopping criteria preventing unnecessary iterations after plateauing.\n\n3. Expected mechanism of impact:\n   - Adaptive radius rewiring reduces redundant computations, focusing rewiring on meaningful neighbors to expedite convergence.\n   - Informed sampling refines the exploration region toward promising areas, decreasing planning time.\n   - Greedy incremental connections between bidirectional trees improve rapid discovery of feasible paths, reducing time.\n   - Shortcutting removes unnecessary waypoints and reduces path length and sharp turns, improving smoothness metrics.\n   - Cost propagation ensures accurate cost estimates downstream, enabling effective optimization and early pruning."
    }
]