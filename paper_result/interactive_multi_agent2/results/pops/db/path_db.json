[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
        "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 70.02349,
        "time_improvement": -295.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1330.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.18990304470062255,
                "num_nodes_avg": 574.6,
                "path_length_avg": 151.92005163885307,
                "smoothness_avg": 0.0438427966152012,
                "success_improvement": 0.0,
                "time_improvement": -655.754757440736,
                "length_improvement": 16.73021236947447,
                "smoothness_improvement": 586.234973184576,
                "objective_score": -183.7571249446132
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06414504051208496,
                "num_nodes_avg": 382.5,
                "path_length_avg": 235.82771215538,
                "smoothness_avg": 0.09195275777999899,
                "success_improvement": 0.0,
                "time_improvement": 60.0911139159804,
                "length_improvement": 21.273921758206445,
                "smoothness_improvement": 2266.01068857373,
                "objective_score": 42.12174067258664
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.18937287330627442,
                "num_nodes_avg": 510.0,
                "path_length_avg": 118.45844668308948,
                "smoothness_avg": 0.09740963788912176,
                "success_improvement": 0.0,
                "time_improvement": -289.7520523276069,
                "length_improvement": 21.32554009816004,
                "smoothness_improvement": 1139.043403918075,
                "objective_score": -68.43507461979567
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
        "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": -13.97956,
        "time_improvement": -17.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1470.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.052588915824890135,
                "num_nodes_avg": 232.6,
                "path_length_avg": 153.88454915168901,
                "smoothness_avg": 0.04347023177026047,
                "success_improvement": 0.0,
                "time_improvement": -109.28744658079108,
                "length_improvement": 15.653440153233934,
                "smoothness_improvement": 580.4035243237437,
                "objective_score": -20.492152260678246
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.048712754249572755,
                "num_nodes_avg": 358.8,
                "path_length_avg": 233.0599917365158,
                "smoothness_avg": 0.10226409696877743,
                "success_improvement": 0.0,
                "time_improvement": 69.69256321821518,
                "length_improvement": 22.197866498438458,
                "smoothness_improvement": 2531.328872858417,
                "objective_score": 46.883133228819716
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.054259729385375974,
                "num_nodes_avg": 387.5,
                "path_length_avg": 119.05752821578226,
                "smoothness_avg": 0.10995381497824393,
                "success_improvement": 0.0,
                "time_improvement": -11.673021153817839,
                "length_improvement": 20.927658669342527,
                "smoothness_improvement": 1298.6044105768708,
                "objective_score": 15.547710908344518
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional RRT* planner integrating dynamic informed sampling, adaptive neighbor radius for rewiring, early goal-biased sampling, and incremental path shortcutting to minimize planning time and path length while improving smoothness. The planner alternates tree expansions from start and goal, uses ellipsoidal heuristic sampling after the first solution to focus search near optimum, and applies a fast shortcutting post-processing upon termination or timeout. Adaptive rewiring radius and thorough rewiring ensure quality paths with reduced unnecessary collision checks. Early stopping with best-path tracking guarantees efficient anytime performance under a strict 30-second limit.",
        "planning_mechanism": "The planner grows two RRT* trees bidirectionally with goal bias and uniform sampling initially, switching to ellipsoidal informed sampling after the first path is found to focus search. It uses an adaptive neighbor radius for rewiring to optimize local connections incrementally. After each expansion, it attempts greedy connections between the trees to find better solutions. The process is time-limited and interrupts as soon as a good path is found, followed by shortcut smoothing of the path to reduce jaggedness. The combination of adaptive radius, heuristic sampling, and path shortcutting reduces planning time and improves final path length and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Ellipsoidal informed sampling around the line connecting start and goal\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edge\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Try to connect newly added node with nearest in other tree greedily up to step_size*4 steps\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy = 20\n            steps_taken = 0\n            while steps_taken < max_greedy:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if not within_bounds(step_pt) or is_in_obstacle(step_pt) or is_edge_in_obstacle(current.position, step_pt):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                if first_solution_found:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 44.20259,
        "time_improvement": -210.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1438.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.15432941913604736,
                "num_nodes_avg": 476.4,
                "path_length_avg": 153.09921531325637,
                "smoothness_avg": 0.04706276199143273,
                "success_improvement": 0.0,
                "time_improvement": -514.1828474051357,
                "length_improvement": 16.08389407448989,
                "smoothness_improvement": 636.634423589329,
                "objective_score": -141.42134565890012
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06530447006225586,
                "num_nodes_avg": 391.7,
                "path_length_avg": 233.4809007688147,
                "smoothness_avg": 0.0966391206414232,
                "success_improvement": 0.0,
                "time_improvement": 59.369755858197294,
                "length_improvement": 22.057354948262333,
                "smoothness_improvement": 2386.594180448907,
                "objective_score": 42.97831062866112
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.13431777954101562,
                "num_nodes_avg": 430.3,
                "path_length_avg": 119.64756150983757,
                "smoothness_avg": 0.10922111748703889,
                "success_improvement": 0.0,
                "time_improvement": -176.44207602812656,
                "length_improvement": 20.535786649797195,
                "smoothness_improvement": 1289.284552570846,
                "objective_score": -34.16472805570542
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, adaptive rewiring radius, goal bias, and iterative path shortcutting for minimizing path length and smoothness. The planner grows two trees from start and goal, alternates expansions, uses ellipsoidal sampling focused on the current best path cost after first solution, and rewires neighbors with adaptive radius to improve path quality. A best path is continuously tracked, and upon termination or timeout, iterative shortcutting is applied for smoothing and length reduction. The algorithm respects collision and boundary constraints, operates under a hard 30-second limit, and returns the best feasible path found.",
        "planning_mechanism": "Grows two RRT* trees bidirectionally with dynamic goal bias and uniform then ellipsoidal informed sampling. Uses an adaptive neighbor radius for efficient rewiring improving path costs. Attempts greedy incremental connection between trees to find better solutions. Maintains anytime best solution with early stopping criteria and applies iterative shortcutting smoothing post-planning. Terminates on time limit or after no improvement period to balance runtime and solution quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n        self.valid = True             # Collision validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            # linear scan; no spatial structures used as per constraints\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = []\n            for n in neighbors:\n                if not is_edge_in_obstacle(n.position, pos):\n                    candidate_parents.append(n)\n            if not candidate_parents:  # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidate_parents = [p]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            # Iterative shortcutting until no improvement or 20 iterations max\n            for _ in range(20):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        no_improve_count = 0\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt incremental greedy connection from other_tree towards new_node (up to max steps)\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy_steps = 20\n            steps_taken = 0\n            while steps_taken < max_greedy_steps:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if (not within_bounds(step_pt) or is_in_obstacle(step_pt)\n                        or is_edge_in_obstacle(current.position, step_pt)):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 65.01104,
        "time_improvement": -284.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1596.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.16463057994842528,
                "num_nodes_avg": 550.7,
                "path_length_avg": 148.1804923955482,
                "smoothness_avg": 0.04324773945034862,
                "success_improvement": 0.0,
                "time_improvement": -555.1782474704154,
                "length_improvement": 18.779924047838108,
                "smoothness_improvement": 576.9210363673175,
                "objective_score": -152.40091463058516
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07044672966003418,
                "num_nodes_avg": 429.2,
                "path_length_avg": 233.7470795074309,
                "smoothness_avg": 0.11325018422881583,
                "success_improvement": 0.0,
                "time_improvement": 56.17041494479452,
                "length_improvement": 21.968496823782065,
                "smoothness_improvement": 2814.0088110180145,
                "objective_score": 44.102266632797665
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.22057127952575684,
                "num_nodes_avg": 549.4,
                "path_length_avg": 119.2811616079309,
                "smoothness_avg": 0.1177158100875653,
                "success_improvement": 0.0,
                "time_improvement": -353.96210861020745,
                "length_improvement": 20.77913201855518,
                "smoothness_improvement": 1397.336415436557,
                "objective_score": -86.73447129474633
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive informed sampling, spatial hashing for efficient neighbor search, dynamic rewiring radius, and iterative shortcutting smoothing to improve solution quality. The planner balances exploration and exploitation by alternating tree expansions from start and goal, sampling within an informed ellipsoid after the first solution, and employing early termination on stagnation or timeout. Spatial hashing accelerates neighbor lookups, while the rewiring propagates cost improvements locally. The final path is iteratively smoothed by shortcutting to enhance smoothness and reduce length.",
        "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focusing on promising regions, adds new nodes by connecting to minimum-cost parents within a dynamic radius found efficiently via spatial hashing, rewires neighbors incrementally with downstream cost propagation, attempts incremental greedy connections between trees, and returns the best smooth path found within a 30-second time limit.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=12000, step_size=4.0, goal_sample_rate=0.05,\n                 max_no_improve=120, time_limit_sec=30.0, gamma_rrt_star=35.0, cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n        self.cell_size = cell_size  # for spatial hashing\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            for i in range(dim):\n                if p[i] < 0.0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while trials < 500:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n            return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            p = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    p[i] += basis[j][i] * radii[j] * u[j]\n            clipped = tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size * 2.0, 3.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.15\n            min_r = max(3.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        # spatial hashing for neighbors: buckets keyed by tuple indices\n        def to_cell(pos):\n            return tuple(int(p // self.cell_size) for p in pos)\n\n        spatial_hash_start = dict()\n        spatial_hash_goal = dict()\n\n        def add_to_spatial_hash(spatial_hash, node):\n            c = to_cell(node.position)\n            if c not in spatial_hash:\n                spatial_hash[c] = []\n            spatial_hash[c].append(node)\n\n        def get_near_nodes(spatial_hash, pos, radius):\n            r_c = int(math.ceil(radius / self.cell_size))\n            c = to_cell(pos)\n            neighbors = []\n            for dx in range(-r_c, r_c + 1):\n                for dy in range(-r_c, r_c + 1):\n                    if dim == 3:\n                        for dz in range(-r_c, r_c + 1):\n                            bucket = (c[0] + dx, c[1] + dy, c[2] + dz)\n                            if bucket in spatial_hash:\n                                neighbors.extend(spatial_hash[bucket])\n                    else:\n                        bucket = (c[0] + dx, c[1] + dy)\n                        if bucket in spatial_hash:\n                            neighbors.extend(spatial_hash[bucket])\n            r_sq = radius * radius\n            filtered = [n for n in neighbors if sum((n.position[i] - pos[i])**2 for i in range(dim)) <= r_sq]\n            return filtered\n\n        def nearest_node(spatial_hash, pos):\n            # Search only close cells around pos\n            c = to_cell(pos)\n            search_r = 1\n            best = None\n            best_d = float('inf')\n            while search_r < 10 and best is None:\n                candidates = []\n                for dx in range(-search_r, search_r + 1):\n                    for dy in range(-search_r, search_r + 1):\n                        if dim == 3:\n                            for dz in range(-search_r, search_r + 1):\n                                bucket = (c[0] + dx, c[1] + dy, c[2] + dz)\n                                candidates.extend(spatial_hash.get(bucket, []))\n                        else:\n                            bucket = (c[0] + dx, c[1] + dy)\n                            candidates.extend(spatial_hash.get(bucket, []))\n                for n in candidates:\n                    d_ = dist(n.position, pos)\n                    if d_ < best_d:\n                        best_d = d_\n                        best = n\n                if best is not None:\n                    break\n                search_r += 1\n            return best\n\n        def add_node_rrt_star(tree, spatial_hash, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = get_near_nodes(spatial_hash, pos, r)\n            candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                fallback = nearest_node(spatial_hash, pos)\n                if fallback is None or is_edge_in_obstacle(fallback.position, pos):\n                    return None, []\n                candidates = [fallback]\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            add_to_spatial_hash(spatial_hash, new_node)\n            return new_node, neighbors\n\n        def propagate_cost(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost(child)\n\n        def rewire(tree, spatial_hash, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, start_tree_first):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                combined = path_start + path_goal[-2::-1]\n            else:\n                combined = path_start + path_goal[::-1]\n            return combined if start_tree_first else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        def iterative_shortcut_path(path, iterations=3):\n            # Iteratively shortcut multiple times for better smoothing\n            pth = path\n            for _ in range(iterations):\n                pth = shortcut_path(pth)\n            return pth\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        spatial_hash_start.clear()\n        spatial_hash_goal.clear()\n        add_to_spatial_hash(spatial_hash_start, tree_start[0])\n        add_to_spatial_hash(spatial_hash_goal, tree_goal[0])\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_counter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_curr = tree_start if expand_start_tree else tree_goal\n            tree_other = tree_goal if expand_start_tree else tree_start\n            spatial_hash_curr = spatial_hash_start if expand_start_tree else spatial_hash_goal\n            spatial_hash_other = spatial_hash_goal if expand_start_tree else spatial_hash_start\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_n = nearest_node(spatial_hash_curr, sample)\n            if nearest_n is None:\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n\n            new_pos = steer(nearest_n.position, sample)\n\n            if not within_bounds(new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(tree_curr, spatial_hash_curr, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            rewire(tree_curr, spatial_hash_curr, new_node, neighbors, edges)\n\n            # Incremental greedy connect attempt from tree_other to new_node.position\n            connected_node = None\n            nearest_other = nearest_node(spatial_hash_other, new_node.position)\n            if nearest_other and dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                conn_cost = nearest_other.cost + dist(nearest_other.position, new_node.position)\n                final_node = Node(new_node.position, cost=conn_cost)\n                nearest_other.add_child(final_node)\n                tree_other.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                add_to_spatial_hash(spatial_hash_other, final_node)\n                connected_node = final_node\n            else:\n                current = nearest_other\n                max_connect_steps = 10\n                for _ in range(max_connect_steps):\n                    if current is None:\n                        break\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos):\n                        break\n                    if is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(tree_other, spatial_hash_other, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(tree_other, spatial_hash_other, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        add_to_spatial_hash(spatial_hash_other, final_node)\n                        connected_node = final_node\n                        break\n\n            if connected_node is not None:\n                candidate_path = stitch_path(new_node, connected_node, expand_start_tree)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + 1e-6 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_counter = 0\n                else:\n                    no_improve_counter += 1\n            else:\n                no_improve_counter += 1\n\n            if found_first and no_improve_counter >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = iterative_shortcut_path(best_path, iterations=4)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax = a[0]\n        ay = a[1]\n        az = a[2] if len(a) > 2 else 0.0\n        bx = b[0]\n        by = b[1]\n        bz = b[2] if len(b) > 2 else 0.0\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": -2.33558,
        "time_improvement": -59.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1528.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.07636876106262207,
                "num_nodes_avg": 366.2,
                "path_length_avg": 151.63664638373353,
                "smoothness_avg": 0.04130734076297089,
                "success_improvement": 0.0,
                "time_improvement": -203.92379745105927,
                "length_improvement": 16.885551280649135,
                "smoothness_improvement": 546.5495832666647,
                "objective_score": -48.313060550594976
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07082192897796631,
                "num_nodes_avg": 434.3,
                "path_length_avg": 230.71207038552546,
                "smoothness_avg": 0.10502756173665322,
                "success_improvement": 0.0,
                "time_improvement": 55.9369785525401,
                "length_improvement": 22.98167022656798,
                "smoothness_improvement": 2602.434811779079,
                "objective_score": 43.582269760598216
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06211984157562256,
                "num_nodes_avg": 646.7,
                "path_length_avg": 118.16772832654556,
                "smoothness_avg": 0.12077696801484047,
                "success_improvement": 0.0,
                "time_improvement": -27.85007335875128,
                "length_improvement": 21.518621388056005,
                "smoothness_improvement": 1436.2741183203227,
                "objective_score": 11.73752141680983
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius that shrinks based on the number of nodes, combined with ellipsoidal informed sampling after first path discovery. It alternates expansions from start and goal trees, performs incremental rewiring with cost updates, attempts greedy incremental connections between trees, and applies iterative path shortcutting smoothing before returning. It respects collisions and map bounds, leverages a 30-second hard time limit with early stopping after stagnation, and maintains the best path found to balance speed and path quality.",
        "planning_mechanism": "A planner growing two trees with alternating expansions using adaptive neighborhood rewiring radius, biased goal and informed ellipsoidal sampling, maintaining anytime best solution with incremental tree connections, and smoothing the best path via iterative shortcutting on termination or timeout.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # 3D case\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, all_nodes, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidate_parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidate_parents = [p]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if not path_start or not path_goal:\n                return []\n            if path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(20):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy_steps = 20\n            steps_taken = 0\n            while steps_taken < max_greedy_steps:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if (not within_bounds(step_pt) or is_in_obstacle(step_pt)\n                        or is_edge_in_obstacle(current.position, step_pt)):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )",
        "objective": 61.75465,
        "time_improvement": -270.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1439.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.1683267593383789,
                "num_nodes_avg": 527.3,
                "path_length_avg": 151.97475901804586,
                "smoothness_avg": 0.046278857897239865,
                "success_improvement": 0.0,
                "time_improvement": -569.8878860795044,
                "length_improvement": 16.700226388045003,
                "smoothness_improvement": 624.3646222402243,
                "objective_score": -157.8244068798232
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08442981243133545,
                "num_nodes_avg": 510.0,
                "path_length_avg": 233.94225648641594,
                "smoothness_avg": 0.09681302304007958,
                "success_improvement": 0.0,
                "time_improvement": 47.47061129718217,
                "length_improvement": 21.903341130339008,
                "smoothness_improvement": 2391.068814423171,
                "objective_score": 39.33853213947391
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.18793764114379882,
                "num_nodes_avg": 491.1,
                "path_length_avg": 118.54564564652279,
                "smoothness_avg": 0.11007612188824092,
                "success_improvement": 0.0,
                "time_improvement": -286.79817265558677,
                "length_improvement": 21.26762669861607,
                "smoothness_improvement": 1300.160145444276,
                "objective_score": -66.77807505028501
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified, goal-biased, single-tree RRT* planner with fixed radius rewiring and early stopping upon first feasible path discovery, prioritizing collision checking efficiency and adaptive local rewiring for improving path length and smoothness. Post-planning path smoothing via shortcutting is applied to reduce jagged turns and redundant nodes, maintaining a strict 30-second time limit.",
        "planning_mechanism": "The planner samples randomly with a small goal bias, extends the tree towards the samples using fixed step sizes while checking collisions, and locally rewires nearby nodes within a fixed radius for better path costs. It stops after a valid path reaches the goal or upon timeout. Finally, the path is extracted and smoothed by shortcutting to improve quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(50):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, dim == 3):\n                    return s\n            return goal_pos\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes = [Node(start_pos, cost=0.0)]\n        edges = []\n        success = False\n        best_goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            q_rand = sample()\n            nearest = min(nodes, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, dim == 3):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, dim == 3):\n                continue\n\n            radius = self.rewire_radius\n            near_nodes = neighbors_within_radius(nodes, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in near_nodes:\n                cost_via_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_via_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, dim == 3):\n                        min_cost = cost_via_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in near_nodes:\n                if nb is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, dim == 3):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, nb))\n\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, dim == 3):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist(new_node.position, goal_pos))\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        path = []\n        if success and best_goal_node:\n            path = best_goal_node.path_from_root()\n            path = self._shortcut_path(path, obstacles, dim == 3, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 9.61183,
        "time_improvement": -93.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1227.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03583109378814697,
                "num_nodes_avg": 253.5,
                "path_length_avg": 160.7000938711168,
                "smoothness_avg": 0.048553861787706744,
                "success_improvement": 0.0,
                "time_improvement": -42.59655308522024,
                "length_improvement": 11.9177320932983,
                "smoothness_improvement": 659.9733733760505,
                "objective_score": -2.328459802706841
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16780226230621337,
                "num_nodes_avg": 889.0,
                "path_length_avg": 223.86852548377175,
                "smoothness_avg": 0.07722416418174848,
                "success_improvement": 0.0,
                "time_improvement": -4.4009219973563525,
                "length_improvement": 25.266242495291486,
                "smoothness_improvement": 1887.0333667135774,
                "objective_score": 23.274635731535874
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.16127386093139648,
                "num_nodes_avg": 658.7,
                "path_length_avg": 115.12421984387166,
                "smoothness_avg": 0.0970230573459941,
                "success_improvement": 0.0,
                "time_improvement": -231.92091975681203,
                "length_improvement": 23.539974805947985,
                "smoothness_improvement": 1134.1261279438986,
                "objective_score": -49.78166040375533
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "A streamlined goal-biased RRT* planner using fixed radius rewiring, uniform sampling within bounds, and an efficient grid-based neighbor search. The planner employs early stopping upon first goal reach or 30 seconds timeout, balances simplicity to minimize overhead, and updates subtree costs on rewiring to improve path quality and smoothness.",
        "planning_mechanism": "The planner incrementally builds a single tree from the start, samples points mostly uniformly with goal bias, steers with fixed step size, validates collision-free expansions. The grid spatial index enables fast nearest and neighbor queries with a fixed radius for rewiring neighbors, propagating cost changes downstream for accurate path costs. Upon reaching the goal within step size, it terminates immediately or after timeout, returning the best found path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, grid_cell_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = 1.0  # simpler fixed resolution for improved speed\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def grid_key(pos):\n            return tuple(int(pos[i] // self.grid_cell_size) for i in range(dim))\n\n        grid = dict()\n\n        def grid_insert(node_idx, pos):\n            key = grid_key(pos)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node_idx)\n\n        def neighbors_in_radius(pos, radius):\n            base_key = grid_key(pos)\n            range_cells = int(math.ceil(radius / self.grid_cell_size))\n            candidates = set()\n            def neighbors_1d(c):\n                return [c + i for i in range(-range_cells, range_cells + 1)]\n            if dim == 2:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        k = (dx, dy)\n                        if k in grid:\n                            candidates.update(grid[k])\n            elif dim == 3:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        for dz in neighbors_1d(base_key[2]):\n                            k = (dx, dy, dz)\n                            if k in grid:\n                                candidates.update(grid[k])\n            else:\n                candidates.update(range(len(nodes)))\n            result = []\n            for idx in candidates:\n                if dist(positions[idx], pos) <= radius:\n                    result.append(nodes[idx])\n            return result\n\n        def nearest_node(pos):\n            radius = self.step_size * 2.0\n            max_radius = max(bounds) * (dim ** 0.5)\n            search_radius = radius\n            while True:\n                nbrs = neighbors_in_radius(pos, search_radius)\n                if nbrs or search_radius >= max_radius:\n                    break\n                search_radius *= 2.0\n                if search_radius > max_radius:\n                    search_radius = max_radius\n            if not nbrs:\n                # rare fallback linear search\n                best = None\n                best_dist = float('inf')\n                for n in nodes:\n                    d = dist(n.position, pos)\n                    if d < best_dist:\n                        best = n\n                        best_dist = d\n                return best, best_dist\n            best = None\n            best_dist = float('inf')\n            for n in nbrs:\n                d = dist(n.position, pos)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best, best_dist\n\n        # Propagate cost changes downstream after rewiring\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_costs(c)\n\n        nodes = []\n        positions = []\n        edges = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n        positions.append(start_pos)\n        grid_insert(0, start_pos)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias or uniform random\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Fixed radius neighborhood\n            neighbors = neighbors_in_radius(new_pos, self.neighbor_radius)\n\n            # Choose best parent minimizing cost with collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            nodes.append(new_node)\n            positions.append(new_pos)\n            grid_insert(len(nodes) - 1, new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free; update costs downstream\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost and is_free_edge(new_node.position, nbr.position):\n                    # Remove old edge\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nbr))\n                    propagate_costs(nbr)\n\n            # Try connecting goal directly if within step_size\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    grid_insert(len(nodes) - 1, goal_pos)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_goal_cost:\n                        best_goal_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        # Early stop on first path found\n                        break\n\n        success = False\n        path = []\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # Extract path to closest node to goal if no solution found\n            closest_dist = float('inf')\n            closest_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = n\n            if closest_node is not None:\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
        "objective": -2.46515,
        "time_improvement": -38.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 292.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06125349998474121,
                "num_nodes_avg": 250.4,
                "path_length_avg": 158.2769019751662,
                "smoothness_avg": 0.021230489071534048,
                "success_improvement": 0.0,
                "time_improvement": -143.76978313509082,
                "length_improvement": 13.245921969401609,
                "smoothness_improvement": 232.3032567144267,
                "objective_score": -34.02186547531415
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16160283088684083,
                "num_nodes_avg": 995.0,
                "path_length_avg": 221.17221911453004,
                "smoothness_avg": 0.016669237287272237,
                "success_improvement": 0.0,
                "time_improvement": -0.5438443444890495,
                "length_improvement": 26.166347170220067,
                "smoothness_improvement": 328.9114817678318,
                "objective_score": 17.181212407624486
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.033482813835144044,
                "num_nodes_avg": 341.3,
                "path_length_avg": 117.11814972091506,
                "smoothness_avg": 0.03270722264153734,
                "success_improvement": 0.0,
                "time_improvement": 31.088359266510622,
                "length_improvement": 22.215701522353378,
                "smoothness_improvement": 316.033457804307,
                "objective_score": 24.236095982386747
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "An improved unidirectional RRT* variant using a fixed rewiring radius, goal bias sampling, early stopping upon first valid solution, fixed neighbor radius for efficient rewiring, and fast incremental path shortcutting to produce shorter and smoother paths within a 30-second time limit. The planner samples with a 5% goal bias, connects new samples via cost-optimizing parent selection without redundant edges, rewires neighbors within a fixed radius if beneficial, and terminates immediately once a feasible path to the goal is found. It ensures collision-free nodes and edges, prunes invalid nodes efficiently, and returns the best path found when time expires.",
        "planning_mechanism": "The planner samples points inside the map bounds with a fixed 5% probability toward the goal, extends the tree by stepping toward the sample, connects new samples by selecting the lowest cost parent within a fixed radius if collision-free, rewires neighbors to reduce costs, and stops at the first successful connection to the goal. A fast shortcutting is applied to smooth the final extracted path. The fixed neighbor radius and early stopping reduce runtime, while goal bias and rewiring improve path length and smoothness.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.05          # Fixed 5% goal bias\n        self.fixed_neighbor_radius = 15.0     # Fixed rewiring radius for all nodes\n        self.improve_tol = 1e-6               # Tolerance for cost improvements\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        found_solution = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample():\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n            return start_pos\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def rewire(node, near, edges):\n            for nb in near:\n                if nb == node or nb == node.parent:\n                    continue\n                new_cost = node.cost + math.dist(node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if not is_edge_in_obstacle(node.position, nb.position):\n                        # Remove old edge from parent if any\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Reassign parent and cost\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def prune_invalid_nodes():\n            to_remove = [n for n in nodes if not n.valid or (n.parent is None and n != root)]\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            sample_pos = sample()\n            if not within_bounds(sample_pos):\n                continue\n\n            nearest = nearest_node(nodes, sample_pos)\n            new_pos = steer(nearest.position, sample_pos)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius for rewiring and parent selection\n            near = near_nodes(nodes, new_pos, self.fixed_neighbor_radius)\n\n            # Select best parent (lowest cost) avoiding collision\n            best_parent = nearest\n            best_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if profitable\n            rewire(new_node, near, edges)\n\n            # Check if goal can be connected directly from new node\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                    goal_cost = new_node.cost + dist_goal\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    found_solution = True\n                    # Early stop upon first solution\n                    break\n\n            # Small prune to keep tree clean every 500 iterations\n            if iteration % 500 == 0:\n                prune_invalid_nodes()\n\n        if found_solution and best_goal_node is not None:\n            raw_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n            success = True\n        else:\n            # Return best reachable path toward goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n            success = False\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
        "objective": 27.32182,
        "time_improvement": -151.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1192.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04816446304321289,
                "num_nodes_avg": 275.0,
                "path_length_avg": 162.509664448828,
                "smoothness_avg": 0.04646132878012289,
                "success_improvement": 0.0,
                "time_improvement": -91.67950751854016,
                "length_improvement": 10.925877785174016,
                "smoothness_improvement": 627.220687799208,
                "objective_score": -17.812222145461597
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.20136358737945556,
                "num_nodes_avg": 1020.1,
                "path_length_avg": 222.21454506385945,
                "smoothness_avg": 0.07672167462570378,
                "success_improvement": 0.0,
                "time_improvement": -25.2816493066552,
                "length_improvement": 25.81838876664495,
                "smoothness_improvement": 1874.1039485079493,
                "objective_score": 17.277058210530157
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.21229140758514403,
                "num_nodes_avg": 615.8,
                "path_length_avg": 114.74175648069794,
                "smoothness_avg": 0.09229075367084426,
                "success_improvement": 0.0,
                "time_improvement": -336.92114056910685,
                "length_improvement": 23.793988760819712,
                "smoothness_improvement": 1073.9315744983153,
                "objective_score": -81.43029104174865
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner that incorporates adaptive informed sampling, variable step size based on local node density, batch rewiring with downstream cost updates, and iterative multiscale shortcutting for enhanced planning speed, path length, and smoothness under a strict 30-second time limit. The planner grows two trees from start and goal, alternately sampling using a combination of uniform, goal-biased, and ellipsoidal informed distributions. It employs an adaptive rewiring radius and steers with dynamic step sizes modulated by local node density to balance global exploration and local refinement efficiently. Batch rewiring is performed periodically for optimal parent selection and cost propagation. The search stops early upon convergence or timeout, returning the best path found, which is further refined via multi-resolution progressive shortcutting.",
        "planning_mechanism": "The planner builds two trees alternately from start and goal configurations. Initially, samples are drawn uniformly or toward the goal to explore broadly. After finding a first feasible path, ellipsoidal informed sampling restricts new samples to the subset that can improve the solution. The neighbor radius decreases as the tree grows to speed rewiring while ensuring path quality. Step sizes adapt to neighbor density, allowing finer expansions in congested regions. Batch rewiring updates subtree costs efficiently. Once time limit is reached or no improvement is observed, the best complete path joining both trees is extracted and smoothed through iterative progressive shortcutting removing redundant waypoints and reducing path length and angular discontinuities.}\n\n```python\nimport math\nimport random\nimport time\nfrom typing import List, Tuple, NamedTuple\n\nclass Node:\n    def __init__(self, position: Tuple[float,...], parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...], e.g. 2D or 3D coords\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from root\n        self.children = []             # List of children nodes\n        self.valid = True              # For collision validity if needed\n\n    def add_child(self, child:'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -",
        "code": "class Node:\n    def __init__(self, position: Tuple[float,...], parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...], e.g. 2D or 3D coords\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from root\n        self.children = []             # List of children nodes\n        self.valid = True              # For collision validity if needed\n\n    def add_child(self, child:'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float,...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, base_step_size: float=5.0, goal_sample_rate: float=0.10,\n                 rewire_batch_size: int=50, max_stagnation: int=150, shortcut_iters: int=200,\n                 gamma_rrt_star: float=50.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_batch_size = rewire_batch_size\n        self.max_stagnation = max_stagnation\n        self.shortcut_iters = shortcut_iters\n        self.gamma_rrt_star = gamma_rrt_star\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            dist_ab = dist(a,b)\n            steps = max(1,int(dist_ab / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(dim))\n                if is_in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(fr,to, max_step=None):\n            d = dist(fr,to)\n            step = max_step if max_step is not None else self.base_step_size\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def uniform_sample():\n            tries = 0\n            while tries < 100:\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n                tries += 1\n            # fallback if stuck\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def ellipsoidal_informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-6:\n                return uniform_sample()\n\n            center = tuple( (s+g)*0.5 for s,g in zip(start, goal) )\n            unit_vec = tuple( (g - s)/c_min for s,g in zip(start, goal) )\n\n            if dim == 2:\n                # orthonormal basis: unit_vec, perp\n                perp = (-unit_vec[1], unit_vec[0])\n                basis = (unit_vec, perp)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = (r1,r2)\n            else:\n                # 3D: unit_vec and two orthogonal vectors\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0])<0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(unit_vec, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(unit_vec, ref))\n                b3 = self._cross(unit_vec,b2)\n                basis = (unit_vec,b2,b3)\n                r1 = c_best/2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min,0.0))/2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            r_sq = radius * radius\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.base_step_size*2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(2.0,self.base_step_size)\n            return max(min_r, min(max_r,val))\n\n        def set_cost_and_parent(child, new_parent, new_cost, edges_list):\n            if child.parent:\n                try:\n                    edges_list.remove((child.parent, child))\n                except ValueError:\n                    pass\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges_list.append((new_parent, child))\n\n        def propagate_cost_descendants(node, edges_list):\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    new_cost = cur.cost + dist(cur.position, ch.position)\n                    if ch.cost > new_cost + 1e-9:\n                        ch.cost = new_cost\n                        if ch.parent != cur:\n                            # Correct parent and edge if mismatch\n                            set_cost_and_parent(ch, cur, new_cost, edges_list)\n                        stack.append(ch)\n\n        def batch_rewire(tree, edges_list):\n            for new_node in tree[-self.rewire_batch_size:]:\n                r = neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_node.position, r)\n                for nb in neighbors:\n                    if nb is new_node:\n                        continue\n                    if is_edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if alt_cost + 1e-9 < nb.cost:\n                        set_cost_and_parent(nb, new_node, alt_cost, edges_list)\n                        propagate_cost_descendants(nb, edges_list)\n\n        def dynamic_step_size(node, tree):\n            # Use neighbor count in radius to adjust step size (smaller step in dense region)\n            r = neighbor_radius(len(tree))\n            count_near = len(near_nodes(tree, node.position, r))\n            if count_near == 0:\n                return self.base_step_size\n            # heuristic: step size inversely proportional to sqrt of neighbors count\n            factor = max(0.3, min(1.0, 5.0 / (math.sqrt(count_near)+1e-5)))\n            return self.base_step_size * factor\n\n        def combine_paths(n_start:Node, n_goal:Node) -> List[Tuple[float,...]]:\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Avoid duplicated meeting point if overlap\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            elif path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal[::-1]\n\n        def progressive_shortcut(path) -> List[Tuple[float,...]]:\n            # Perform iterative multi-resolution shortcutting to reduce detours and angle changes\n            if len(path) < 3:\n                return path[:]\n            for resolution in [3,2,1]:\n                for _ in range(self.shortcut_iters // resolution):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = i + random.randint(2, max(2, resolution*3))\n                    if j >= len(path):\n                        j = len(path)-1\n                    if j - i < 2:\n                        continue\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        found_solution = False\n\n        c_min = dist(start_pos, goal_pos)\n        no_improve_counter = 0\n\n        expand_start_tree = True\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n            # Choose tree to expand\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Sample\n            if found_solution:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = ellipsoidal_informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            # Nearest node in tree\n            nearest_node = nearest(tree_a, sample)\n\n            # Adaptive dynamic step size by neighbor density\n            step_sz = dynamic_step_size(nearest_node, tree_a)\n\n            new_pos = steer(nearest_node.position, sample, step_sz)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                no_improve_counter += 1\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_counter += 1\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            r_rewire = neighbor_radius(len(tree_a))\n            neighbors = near_nodes(tree_a, new_pos, r_rewire)\n            feasible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, new_pos)]\n\n            if len(feasible_parents) == 0:\n                # Fallback to nearest_node only if edge collision-free\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    no_improve_counter += 1\n                    expand_start_tree = not expand_start_tree\n                    continue\n                best_parent = nearest_node\n            else:\n                best_parent = min(feasible_parents, key=lambda n: n.cost + dist(n.position, new_pos))\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent.cost + dist(best_parent.position, new_pos)\n            best_parent.add_child(new_node)\n\n            # Add node and edge\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire periodically\n            if (len(tree_a) % self.rewire_batch_size) == 0:\n                batch_rewire(tree_a, edges)\n\n            # Attempt direct connection to nearby nodes in other tree for early solution\n            neighbors_b = near_nodes(tree_b, new_pos, r_rewire)\n            connection_made = False\n            for nb in neighbors_b:\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, nb.position) + nb.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_start_tree else nb\n                    best_goal_node = nb if expand_start_tree else new_node\n                    found_solution = True\n                    connection_made = True\n\n            if connection_made:\n                no_improve_counter = 0\n            else:\n                no_improve_counter += 1\n\n            if found_solution and no_improve_counter > self.max_stagnation:\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        if found_solution:\n            final_path = combine_paths(best_start_node, best_goal_node)\n            final_path = progressive_shortcut(final_path)\n            return PlannerResult(True, final_path, nodes, edges)\n\n        # If no full path found, return best partial from start tree closest to goal\n        best_partial_node = None\n        best_partial_dist = float('inf')\n        for node in tree_start:\n            if not node.valid:\n                continue\n            d_to_goal = dist(node.position, goal_pos)\n            if d_to_goal < best_partial_dist:\n                best_partial_dist = d_to_goal\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            partial_path = progressive_shortcut(partial_path)\n            return PlannerResult(False, partial_path, nodes, edges)\n\n        # No path or partial found\n        return PlannerResult(False, [], nodes, edges)\n\n    # Vector ops needed\n    def _cross(self,a,b):\n        ax,ay,az = a\n        bx,by,bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self,v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self,v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 27.9513,
        "time_improvement": -155.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1319.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11870105266571045,
                "num_nodes_avg": 200.7,
                "path_length_avg": 150.91862178659736,
                "smoothness_avg": 0.04204053323890232,
                "success_improvement": 0.0,
                "time_improvement": -372.3930856756818,
                "length_improvement": 17.27911194016732,
                "smoothness_improvement": 558.0256376679363,
                "objective_score": -98.56033035026446
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.09938943386077881,
                "num_nodes_avg": 373.8,
                "path_length_avg": 231.25559523132816,
                "smoothness_avg": 0.0817196398653705,
                "success_improvement": 0.0,
                "time_improvement": 38.16323815154927,
                "length_improvement": 22.80022598854379,
                "smoothness_improvement": 2002.7051940134274,
                "objective_score": 35.142633008658194
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.11264376640319824,
                "num_nodes_avg": 304.0,
                "path_length_avg": 120.12971077054394,
                "smoothness_avg": 0.11768585150632557,
                "success_improvement": 0.0,
                "time_improvement": -131.83436133723927,
                "length_improvement": 20.21556606831662,
                "smoothness_improvement": 1396.9553444945002,
                "objective_score": -20.43619203770931
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified unidirectional RRT* planner with fixed neighbor radius and goal-biased sampling to guide exploration. The planner grows a single tree from start towards the goal, choosing parents and rewiring neighbors within a constant radius to locally optimize path costs. It performs strict collision checks on nodes and edges, enforces a 30-second planning limit, and applies a single-pass shortcutting step at the end to smooth and shorten the found path. The design emphasizes clarity and generalization while maintaining core RRT* benefits.",
        "planning_mechanism": "The planner grows one tree from start using goal bias to sample near the goal occasionally, extends by fixed step size towards random samples, selects parents minimizing cost within a fixed radius, and rewires neighbors to optimize cost. It terminates early if goal is reached or time expires, then extracts and shortcuts the path before returning results.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1  # 10% goal bias\n        self.neighbor_radius = 15.0   # fixed neighbor radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b):\n            distance = dist(a,b)\n            steps = max(1, int(distance))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortcut.append(path[i+1])\n                    i += 1\n            return shortcut\n\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            x_rand = sample_free()\n            nearest_node = nearest(nodes, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if not is_in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            neighbors = near_nodes(nodes, new_pos, self.neighbor_radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative_cost\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    # Remove old edge if exists\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    nb.parent = new_node\n                    nb.cost = alt_cost\n                    new_node.add_child(nb)\n                    edges.append((new_node, nb))\n\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = new_node\n                    goal_node.cost = new_node.cost + dist(new_node.position, goal_pos)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            path = goal_node.path_from_root()\n            path = shortcut_path(path)\n        else:\n            # No full path, return closest node path to goal\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = closest.path_from_root()\n\n        return PlannerResult(success, path, nodes, edges)",
        "objective": 55.78124,
        "time_improvement": -250.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1261.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05596280097961426,
                "num_nodes_avg": 297.8,
                "path_length_avg": 157.62577900413402,
                "smoothness_avg": 0.04588491103001609,
                "success_improvement": 0.0,
                "time_improvement": -122.71445487737303,
                "length_improvement": 13.602812787528084,
                "smoothness_improvement": 618.1984982988578,
                "objective_score": -25.56165629920077
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.27630226612091063,
                "num_nodes_avg": 984.0,
                "path_length_avg": 221.16011962648253,
                "smoothness_avg": 0.07743491533999532,
                "success_improvement": 0.0,
                "time_improvement": -71.90597395130513,
                "length_improvement": 26.17038632759478,
                "smoothness_improvement": 1892.4561458131923,
                "objective_score": 3.592720340231292
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.3183507680892944,
                "num_nodes_avg": 671.9,
                "path_length_avg": 113.35279699081329,
                "smoothness_avg": 0.10780793826239196,
                "success_improvement": 0.0,
                "time_improvement": -555.2040060257222,
                "length_improvement": 24.716469518857625,
                "smoothness_improvement": 1271.309017143377,
                "objective_score": -145.37477501068517
            }
        ],
        "success_rate": 1.0
    }
]