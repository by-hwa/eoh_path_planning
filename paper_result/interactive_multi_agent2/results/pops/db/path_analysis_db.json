[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
                "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 71.35259809409325,
                "time_improvement": -285.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 406.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.15097854137420655,
                        "num_nodes_avg": 375.4,
                        "path_length_avg": 150.76257022061387,
                        "smoothness_avg": 0.03392657193105306,
                        "success_improvement": 0.0,
                        "time_improvement": -500.847401340509,
                        "length_improvement": 17.364646276278172,
                        "smoothness_improvement": 431.0245234511015,
                        "objective_score": -137.6803100191303
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.1728947401046753,
                        "num_nodes_avg": 649.8,
                        "path_length_avg": 238.74738839156012,
                        "smoothness_avg": 0.016703858220063185,
                        "success_improvement": 0.0,
                        "time_improvement": -7.569290350104155,
                        "length_improvement": 20.29924979234869,
                        "smoothness_improvement": 329.8023033049928,
                        "objective_score": 11.55777428690293
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.21681342124938965,
                        "num_nodes_avg": 472.1,
                        "path_length_avg": 116.30409151558926,
                        "smoothness_avg": 0.04370027229081557,
                        "success_improvement": 0.0,
                        "time_improvement": -346.2279862409406,
                        "length_improvement": 22.756360221044645,
                        "smoothness_improvement": 455.8642379206061,
                        "objective_score": -87.93525855005237
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional informed RRT* planner with goal bias and adaptive rewiring radius. It alternates growth of start and goal trees, uses ellipsoidal informed sampling after finding initial path, applies goal-biased sampling to accelerate convergence, and features efficient rewiring and dynamic radius reduction. Early stopping occurs after no improvement or time limit. Path stitching includes shortcutting for smoothness.",
                "planning_mechanism": "The planner maintains two RRT* trees grown alternately. Sampling is uniform initially, then uses informed ellipsoid around best path cost. To accelerate progress, samples near goal are biased. Nodes are added by best-parent selection within a shrinking neighbor radius, followed by rewiring neighbors to improve costs. Connections between trees are attempted greedily each iteration. The best path found is stitched and shortcut to reduce unnecessary waypoints for better smoothness. The process respects collision constraints and time limit, returning best feasible path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0,\n                 goal_sample_rate=0.15,  # goal bias\n                 post_opt_iters=500,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = 50.0  # constant for neighbor radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))  # unit axis\n            # orthonormal basis\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.5, self.step_size * 2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.5, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Select best parent candidate with collision free edge\n            parent_candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parent_candidates:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parent_candidates = [p]\n            best_parent = min(parent_candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list, nodes_all):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # rewire nb\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            # simple shortcutting smoothing: try to connect nodes directly and skip intermediates\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n\n        use_informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sampling: goal bias + informed sampling after first found path\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            # Rewire neighbors with new node\n            rewire(curr_tree, new_node, neighbors, edges, nodes)\n\n            # Try connecting other tree greedily toward new_node\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            while True:\n                tries += 1\n                if tries > 20:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges, nodes)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            # If connected, update best path\n            if connected_other is not None:\n                path_candidate = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(path_candidate) - 1):\n                    cost_candidate += dist(path_candidate[i], path_candidate[i+1])\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                    use_informed_sampling = True\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        # Final path smoothing by shortcutting to improve smoothness\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": 7.8919,
                "time_improvement": -88.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1619.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.09003095626831055,
                        "num_nodes_avg": 267.5,
                        "path_length_avg": 161.63330626011182,
                        "smoothness_avg": 0.04679719999052493,
                        "success_improvement": 0.0,
                        "time_improvement": -258.29506379942467,
                        "length_improvement": 11.406223595193513,
                        "smoothness_improvement": 632.477801598007,
                        "objective_score": -67.48239597472127
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.07056128978729248,
                        "num_nodes_avg": 391.4,
                        "path_length_avg": 233.9831879924015,
                        "smoothness_avg": 0.11503521981583464,
                        "success_improvement": 0.0,
                        "time_improvement": 56.0991394879233,
                        "length_improvement": 21.889677015492953,
                        "smoothness_improvement": 2859.939062381173,
                        "objective_score": 44.263243367578625
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07899618148803711,
                        "num_nodes_avg": 394.7,
                        "path_length_avg": 121.73083260912676,
                        "smoothness_avg": 0.11520848273010573,
                        "success_improvement": 0.0,
                        "time_improvement": -62.58360198829204,
                        "length_improvement": 19.152177180358766,
                        "smoothness_improvement": 1365.4433965213254,
                        "objective_score": -0.4565573056657257
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
            "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": 70.02349,
            "time_improvement": -295.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1330.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.18990304470062255,
                    "num_nodes_avg": 574.6,
                    "path_length_avg": 151.92005163885307,
                    "smoothness_avg": 0.0438427966152012,
                    "success_improvement": 0.0,
                    "time_improvement": -655.754757440736,
                    "length_improvement": 16.73021236947447,
                    "smoothness_improvement": 586.234973184576,
                    "objective_score": -183.7571249446132
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06414504051208496,
                    "num_nodes_avg": 382.5,
                    "path_length_avg": 235.82771215538,
                    "smoothness_avg": 0.09195275777999899,
                    "success_improvement": 0.0,
                    "time_improvement": 60.0911139159804,
                    "length_improvement": 21.273921758206445,
                    "smoothness_improvement": 2266.01068857373,
                    "objective_score": 42.12174067258664
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.18937287330627442,
                    "num_nodes_avg": 510.0,
                    "path_length_avg": 118.45844668308948,
                    "smoothness_avg": 0.09740963788912176,
                    "success_improvement": 0.0,
                    "time_improvement": -289.7520523276069,
                    "length_improvement": 21.32554009816004,
                    "smoothness_improvement": 1139.043403918075,
                    "objective_score": -68.43507461979567
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.0,
        "analysis": "1. Summary of key changes:\n   - Introduction of informed sampling after the first solution, focusing sampling within an ellipsoidal region to accelerate convergence.\n   - Enhanced rewiring with consistent updates to edges list and reconnection of nodes for better path cost optimization.\n   - Implementation of a post-planning shortcutting smoothing step reducing sharp turns and jagged path segments.\n   - Use of adaptive neighbor radius based on node count and problem dimension to improve connection efficiency.\n   - Increased maximum iterations and refined parameters for termination based on no improvement streaks.\n2. Primary contributors to the performance improvement:\n   - Informed sampling concentrating samples near the optimal path region, reducing redundant exploration and leading to shorter paths.\n   - Shortcutting smoothing significantly improving path smoothness by eliminating unnecessary waypoints.\n   - More precise rewiring maintaining lower-cost connections and thus shorter, smoother path trees.\n3. Expected mechanism of impact:\n   - Informed sampling narrows the search domain to relevant space, speeding up discovery of improved paths and reducing planning time.\n   - Shortcutting post-processing removes detours and zigzagging in the discovered path, lowering path length and greatly enhancing smoothness.\n   - Adaptive rewiring ensures better parent-child relationships, decreasing overall path cost while increasing path quality and smoothness."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
                "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": 70.02349,
                "time_improvement": -295.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1330.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.18990304470062255,
                        "num_nodes_avg": 574.6,
                        "path_length_avg": 151.92005163885307,
                        "smoothness_avg": 0.0438427966152012,
                        "success_improvement": 0.0,
                        "time_improvement": -655.754757440736,
                        "length_improvement": 16.73021236947447,
                        "smoothness_improvement": 586.234973184576,
                        "objective_score": -183.7571249446132
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06414504051208496,
                        "num_nodes_avg": 382.5,
                        "path_length_avg": 235.82771215538,
                        "smoothness_avg": 0.09195275777999899,
                        "success_improvement": 0.0,
                        "time_improvement": 60.0911139159804,
                        "length_improvement": 21.273921758206445,
                        "smoothness_improvement": 2266.01068857373,
                        "objective_score": 42.12174067258664
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.18937287330627442,
                        "num_nodes_avg": 510.0,
                        "path_length_avg": 118.45844668308948,
                        "smoothness_avg": 0.09740963788912176,
                        "success_improvement": 0.0,
                        "time_improvement": -289.7520523276069,
                        "length_improvement": 21.32554009816004,
                        "smoothness_improvement": 1139.043403918075,
                        "objective_score": -68.43507461979567
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
            "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": -13.97956,
            "time_improvement": -17.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1470.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052588915824890135,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 153.88454915168901,
                    "smoothness_avg": 0.04347023177026047,
                    "success_improvement": 0.0,
                    "time_improvement": -109.28744658079108,
                    "length_improvement": 15.653440153233934,
                    "smoothness_improvement": 580.4035243237437,
                    "objective_score": -20.492152260678246
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048712754249572755,
                    "num_nodes_avg": 358.8,
                    "path_length_avg": 233.0599917365158,
                    "smoothness_avg": 0.10226409696877743,
                    "success_improvement": 0.0,
                    "time_improvement": 69.69256321821518,
                    "length_improvement": 22.197866498438458,
                    "smoothness_improvement": 2531.328872858417,
                    "objective_score": 46.883133228819716
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.054259729385375974,
                    "num_nodes_avg": 387.5,
                    "path_length_avg": 119.05752821578226,
                    "smoothness_avg": 0.10995381497824393,
                    "success_improvement": 0.0,
                    "time_improvement": -11.673021153817839,
                    "length_improvement": 20.927658669342527,
                    "smoothness_improvement": 1298.6044105768708,
                    "objective_score": 15.547710908344518
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.0,
        "analysis": "1. Summary of key changes:\n   - Added downstream cost propagation during rewiring to update children node costs consistently.\n   - Modified goal sampling rate to lower value (from 0.15 to 0.05), increasing more diverse exploration.\n   - Included an immediate direct connection attempt between trees when nodes are within step size before incremental connection.\n   - Improved fallback in uniform sampling to avoid infinite loops by limiting trials and fallback to start.\n   - Simplified and optimized neighbor search and rewiring using fixed radius with consistent cost updates.\n2. Primary contributors to the performance improvement:\n   - Downstream cost propagation enabling true optimal rewiring and improved path cost minimization.\n   - Direct edge attempts between tree branches reducing unnecessary incremental extensions and accelerating convergence.\n   - Reduced goal bias improving sample diversity and better exploration of the space.\n3. Expected mechanism of impact:\n   - Propagation of cost updates leads to more accurate subtree cost corrections, reducing overall path length.\n   - Direct connection checking reduces extra node expansions and shortens final path length by connecting trees sooner.\n   - Lower goal sample rate allows exploration of alternative lower-cost routes, ultimately improving solution quality and length."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
                "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
                "objective": 5.46059,
                "time_improvement": -53.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 293.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06232309341430664,
                        "num_nodes_avg": 267.2,
                        "path_length_avg": 168.2463107739374,
                        "smoothness_avg": 0.02259680420437422,
                        "success_improvement": 0.0,
                        "time_improvement": -148.0264306480139,
                        "length_improvement": 7.781531031403382,
                        "smoothness_improvement": 253.68905554417486,
                        "objective_score": -38.47056529784127
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08523426055908204,
                        "num_nodes_avg": 568.0,
                        "path_length_avg": 241.3226903680994,
                        "smoothness_avg": 0.016808760155440354,
                        "success_improvement": 0.0,
                        "time_improvement": 46.970110737287854,
                        "length_improvement": 19.439539866622514,
                        "smoothness_improvement": 332.5015056600573,
                        "objective_score": 27.41726466946015
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07625963687896728,
                        "num_nodes_avg": 483.4,
                        "path_length_avg": 124.7326333683994,
                        "smoothness_avg": 0.03084680379066026,
                        "success_improvement": 0.0,
                        "time_improvement": -56.951465457596676,
                        "length_improvement": 17.15852404644154,
                        "smoothness_improvement": 292.3690673429857,
                        "objective_score": -5.328479872699152
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
                "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": 70.02349,
                "time_improvement": -295.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1330.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.18990304470062255,
                        "num_nodes_avg": 574.6,
                        "path_length_avg": 151.92005163885307,
                        "smoothness_avg": 0.0438427966152012,
                        "success_improvement": 0.0,
                        "time_improvement": -655.754757440736,
                        "length_improvement": 16.73021236947447,
                        "smoothness_improvement": 586.234973184576,
                        "objective_score": -183.7571249446132
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06414504051208496,
                        "num_nodes_avg": 382.5,
                        "path_length_avg": 235.82771215538,
                        "smoothness_avg": 0.09195275777999899,
                        "success_improvement": 0.0,
                        "time_improvement": 60.0911139159804,
                        "length_improvement": 21.273921758206445,
                        "smoothness_improvement": 2266.01068857373,
                        "objective_score": 42.12174067258664
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.18937287330627442,
                        "num_nodes_avg": 510.0,
                        "path_length_avg": 118.45844668308948,
                        "smoothness_avg": 0.09740963788912176,
                        "success_improvement": 0.0,
                        "time_improvement": -289.7520523276069,
                        "length_improvement": 21.32554009816004,
                        "smoothness_improvement": 1139.043403918075,
                        "objective_score": -68.43507461979567
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A bidirectional RRT* planner integrating dynamic informed sampling, adaptive neighbor radius for rewiring, early goal-biased sampling, and incremental path shortcutting to minimize planning time and path length while improving smoothness. The planner alternates tree expansions from start and goal, uses ellipsoidal heuristic sampling after the first solution to focus search near optimum, and applies a fast shortcutting post-processing upon termination or timeout. Adaptive rewiring radius and thorough rewiring ensure quality paths with reduced unnecessary collision checks. Early stopping with best-path tracking guarantees efficient anytime performance under a strict 30-second limit.",
            "planning_mechanism": "The planner grows two RRT* trees bidirectionally with goal bias and uniform sampling initially, switching to ellipsoidal informed sampling after the first path is found to focus search. It uses an adaptive neighbor radius for rewiring to optimize local connections incrementally. After each expansion, it attempts greedy connections between the trees to find better solutions. The process is time-limited and interrupts as soon as a good path is found, followed by shortcut smoothing of the path to reduce jaggedness. The combination of adaptive radius, heuristic sampling, and path shortcutting reduces planning time and improves final path length and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Ellipsoidal informed sampling around the line connecting start and goal\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edge\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Try to connect newly added node with nearest in other tree greedily up to step_size*4 steps\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy = 20\n            steps_taken = 0\n            while steps_taken < max_greedy:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if not within_bounds(step_pt) or is_in_obstacle(step_pt) or is_edge_in_obstacle(current.position, step_pt):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                if first_solution_found:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": 44.20259,
            "time_improvement": -210.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1438.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15432941913604736,
                    "num_nodes_avg": 476.4,
                    "path_length_avg": 153.09921531325637,
                    "smoothness_avg": 0.04706276199143273,
                    "success_improvement": 0.0,
                    "time_improvement": -514.1828474051357,
                    "length_improvement": 16.08389407448989,
                    "smoothness_improvement": 636.634423589329,
                    "objective_score": -141.42134565890012
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06530447006225586,
                    "num_nodes_avg": 391.7,
                    "path_length_avg": 233.4809007688147,
                    "smoothness_avg": 0.0966391206414232,
                    "success_improvement": 0.0,
                    "time_improvement": 59.369755858197294,
                    "length_improvement": 22.057354948262333,
                    "smoothness_improvement": 2386.594180448907,
                    "objective_score": 42.97831062866112
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13431777954101562,
                    "num_nodes_avg": 430.3,
                    "path_length_avg": 119.64756150983757,
                    "smoothness_avg": 0.10922111748703889,
                    "success_improvement": 0.0,
                    "time_improvement": -176.44207602812656,
                    "length_improvement": 20.535786649797195,
                    "smoothness_improvement": 1289.284552570846,
                    "objective_score": -34.16472805570542
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.0,
        "analysis": "1. Summary of key changes:\n   - Introduced ellipsoidal informed sampling after first solution to focus exploration around promising regions.\n   - Applied adaptive neighbor radius for rewiring based on the number of nodes and problem dimension.\n   - Implemented bidirectional tree expansion alternating between start and goal with greedy attempts to connect trees with multiple small steps.\n   - Added post-processing shortcut path smoothing to reduce unnecessary intermediate nodes and sharp turns.\n   - Incorporated early stopping criteria based on no improvement for better anytime performance.\n\n2. Primary contributors to the performance improvement:\n   - Informed sampling concentrates sampling efforts, improving solution path length and convergence speed.\n   - Adaptive rewiring radius optimizes neighborhood search reducing redundant collision checks and improving rewiring efficiency.\n   - Shortcut path smoothing significantly reduces path length by bypassing extraneous waypoints.\n   - Greedy incremental connections between trees enhance the chance of faster tree merging and better path cost reductions.\n\n3. Expected mechanism of impact:\n   - Focused sampling reduces wasted exploration over non-promising space, leading to quicker identification of shorter paths.\n   - More efficient rewiring with adaptive radius balances exploration and exploitation, minimizing collision checks and improving solution refinement.\n   - Path shortcutting removes unnecessary detours and sharp angle changes, directly lowering the path length and smoothness cost metrics.\n   - Alternating bidirectional expansion with small incremental connections facilitates faster tree confluence, thereby improving planning speed and solution quality."
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "A bidirectional RRT* planner integrating dynamic informed sampling, adaptive neighbor radius for rewiring, early goal-biased sampling, and incremental path shortcutting to minimize planning time and path length while improving smoothness. The planner alternates tree expansions from start and goal, uses ellipsoidal heuristic sampling after the first solution to focus search near optimum, and applies a fast shortcutting post-processing upon termination or timeout. Adaptive rewiring radius and thorough rewiring ensure quality paths with reduced unnecessary collision checks. Early stopping with best-path tracking guarantees efficient anytime performance under a strict 30-second limit.",
                "planning_mechanism": "The planner grows two RRT* trees bidirectionally with goal bias and uniform sampling initially, switching to ellipsoidal informed sampling after the first path is found to focus search. It uses an adaptive neighbor radius for rewiring to optimize local connections incrementally. After each expansion, it attempts greedy connections between the trees to find better solutions. The process is time-limited and interrupts as soon as a good path is found, followed by shortcut smoothing of the path to reduce jaggedness. The combination of adaptive radius, heuristic sampling, and path shortcutting reduces planning time and improves final path length and smoothness.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Ellipsoidal informed sampling around the line connecting start and goal\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edge\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Try to connect newly added node with nearest in other tree greedily up to step_size*4 steps\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy = 20\n            steps_taken = 0\n            while steps_taken < max_greedy:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if not within_bounds(step_pt) or is_in_obstacle(step_pt) or is_edge_in_obstacle(current.position, step_pt):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                if first_solution_found:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": 44.20259,
                "time_improvement": -210.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1438.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.15432941913604736,
                        "num_nodes_avg": 476.4,
                        "path_length_avg": 153.09921531325637,
                        "smoothness_avg": 0.04706276199143273,
                        "success_improvement": 0.0,
                        "time_improvement": -514.1828474051357,
                        "length_improvement": 16.08389407448989,
                        "smoothness_improvement": 636.634423589329,
                        "objective_score": -141.42134565890012
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06530447006225586,
                        "num_nodes_avg": 391.7,
                        "path_length_avg": 233.4809007688147,
                        "smoothness_avg": 0.0966391206414232,
                        "success_improvement": 0.0,
                        "time_improvement": 59.369755858197294,
                        "length_improvement": 22.057354948262333,
                        "smoothness_improvement": 2386.594180448907,
                        "objective_score": 42.97831062866112
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.13431777954101562,
                        "num_nodes_avg": 430.3,
                        "path_length_avg": 119.64756150983757,
                        "smoothness_avg": 0.10922111748703889,
                        "success_improvement": 0.0,
                        "time_improvement": -176.44207602812656,
                        "length_improvement": 20.535786649797195,
                        "smoothness_improvement": 1289.284552570846,
                        "objective_score": -34.16472805570542
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, adaptive rewiring radius, goal bias, and iterative path shortcutting for minimizing path length and smoothness. The planner grows two trees from start and goal, alternates expansions, uses ellipsoidal sampling focused on the current best path cost after first solution, and rewires neighbors with adaptive radius to improve path quality. A best path is continuously tracked, and upon termination or timeout, iterative shortcutting is applied for smoothing and length reduction. The algorithm respects collision and boundary constraints, operates under a hard 30-second limit, and returns the best feasible path found.",
            "planning_mechanism": "Grows two RRT* trees bidirectionally with dynamic goal bias and uniform then ellipsoidal informed sampling. Uses an adaptive neighbor radius for efficient rewiring improving path costs. Attempts greedy incremental connection between trees to find better solutions. Maintains anytime best solution with early stopping criteria and applies iterative shortcutting smoothing post-planning. Terminates on time limit or after no improvement period to balance runtime and solution quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n        self.valid = True             # Collision validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            # linear scan; no spatial structures used as per constraints\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = []\n            for n in neighbors:\n                if not is_edge_in_obstacle(n.position, pos):\n                    candidate_parents.append(n)\n            if not candidate_parents:  # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidate_parents = [p]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            # Iterative shortcutting until no improvement or 20 iterations max\n            for _ in range(20):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        no_improve_count = 0\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt incremental greedy connection from other_tree towards new_node (up to max steps)\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy_steps = 20\n            steps_taken = 0\n            while steps_taken < max_greedy_steps:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if (not within_bounds(step_pt) or is_in_obstacle(step_pt)\n                        or is_edge_in_obstacle(current.position, step_pt)):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
            "objective": 65.01104,
            "time_improvement": -284.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1596.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.16463057994842528,
                    "num_nodes_avg": 550.7,
                    "path_length_avg": 148.1804923955482,
                    "smoothness_avg": 0.04324773945034862,
                    "success_improvement": 0.0,
                    "time_improvement": -555.1782474704154,
                    "length_improvement": 18.779924047838108,
                    "smoothness_improvement": 576.9210363673175,
                    "objective_score": -152.40091463058516
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07044672966003418,
                    "num_nodes_avg": 429.2,
                    "path_length_avg": 233.7470795074309,
                    "smoothness_avg": 0.11325018422881583,
                    "success_improvement": 0.0,
                    "time_improvement": 56.17041494479452,
                    "length_improvement": 21.968496823782065,
                    "smoothness_improvement": 2814.0088110180145,
                    "objective_score": 44.102266632797665
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.22057127952575684,
                    "num_nodes_avg": 549.4,
                    "path_length_avg": 119.2811616079309,
                    "smoothness_avg": 0.1177158100875653,
                    "success_improvement": 0.0,
                    "time_improvement": -353.96210861020745,
                    "length_improvement": 20.77913201855518,
                    "smoothness_improvement": 1397.336415436557,
                    "objective_score": -86.73447129474633
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.2,
        "analysis": "1. Summary of key changes:\n   - Offspring uses iterative shortcutting up to 20 iterations for path smoothing, unlike the single-pass shortcutting in parents.\n   - Simplified and unified post-solution termination condition based on a single no-improvement counter instead of separate post iteration and no improve counters.\n   - Slightly reduced maximum iterations from 8000 to 6000 and tuned no-improve thresholds, improving efficiency.\n2. Primary contributors to the performance improvement:\n   - More aggressive and iterative shortcutting effectively reduces path length by removing unnecessary waypoints repetitively.\n   - Streamlined termination conditions reduce wasted computation on marginal improvements.\n3. Expected mechanism of impact:\n   - Iterative shortcutting progressively removes redundant detours and smooths jagged edges, leading to shorter and smoother paths.\n   - Improved termination logic helps focus computation on meaningful improvements, allowing earlier convergence on better solutions."
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A hybrid bidirectional path planner combining adaptive informed sampling of ellipsoidal RRT* with efficient fixed-radius rewiring from simplified RRT*. It uses goal biasing, dynamic radius adjustment, local rewiring with downstream cost propagation, and incremental greedy tree connections. Early termination occurs on stagnation or timeout. The planner balances exploration and exploitation to find shorter, smoother paths efficiently within 30 seconds.",
                "planning_mechanism": "The algorithm alternates expansions of two trees from start and goal, sampling uniformly before best solution and within an informed ellipsoid afterward. New nodes connect to minimum-cost parents found within an adaptive radius and trigger rewiring of neighbors with propagated cost updates. Attempts incremental greedy connections between trees, shortcutting the best path found, and halting early on convergence or timeout.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position   # tuple (x,y) or (x,y,z)\n        self.parent = parent       # parent Node or None\n        self.cost = cost           # cost from root to this node\n        self.children = []         # list of child Nodes\n        self.valid = True          # always True here, can be used for pruning\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=4.0, goal_sample_rate=0.05,\n                 max_no_improve=150, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while trials < 1000:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n            return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # For 3D build orthonormal basis\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            p = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    p[i] += basis[j][i] * radii[j] * u[j]\n            clipped = tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.2\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if sum((n.position[i]-p[i])**2 for i in range(dim)) <= r_sq]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            possible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not possible_parents:\n                fallback = nearest(tree, pos)\n                if fallback is None or is_edge_in_obstacle(fallback.position, pos):\n                    return None, []\n                possible_parents = [fallback]\n            best_parent = min(possible_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, start_tree_start):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Avoid duplicate middle node\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                combined = path_start + path_goal[-2::-1]\n            else:\n                combined = path_start + path_goal[::-1]\n            return combined if start_tree_start else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.)]\n        tree_goal = [Node(goal_pos, cost=0.)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_counter = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            start_tree_expand = (it % 2 == 0)\n            tree_curr = tree_start if start_tree_expand else tree_goal\n            tree_other = tree_goal if start_tree_expand else tree_start\n\n            # Sampling strategy\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if start_tree_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if start_tree_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree_curr, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Collision checks for new node and edge from nearest node\n            if not within_bounds(new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n\n            # Add new node with RRT* rewiring\n            new_node, neighbors = add_node_rrt_star(tree_curr, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            rewire(tree_curr, new_node, neighbors, edges)\n\n            # Try to connect other tree greedily incrementally up to max steps\n            connected_node = None\n            nearest_other = nearest(tree_other, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                conn_cost = nearest_other.cost + dist(nearest_other.position, new_node.position)\n                final_node = Node(new_node.position, cost=conn_cost)\n                nearest_other.add_child(final_node)\n                tree_other.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_node = final_node\n            else:\n                current = nearest_other\n                max_connect_steps = 10\n                for _ in range(max_connect_steps):\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos):\n                        break\n                    if is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(tree_other, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(tree_other, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_node = final_node\n                        break\n\n            # Check for path improvement\n            if connected_node is not None:\n                candidate_path = stitch_path(new_node, connected_node, start_tree_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n                if candidate_cost + 1e-6 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_counter = 0\n                else:\n                    no_improve_counter += 1\n            else:\n                no_improve_counter += 1\n\n            # Early stop on stagnation after first solution\n            if found_first and no_improve_counter >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a[0], a[1], a[2] if len(a)>2 else 0.0, 0.0\n        bx, by, bz = b[0], b[1], b[2] if len(b)>2 else 0.0, 0.0\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": 82.42863,
                "time_improvement": -339.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1406.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.14577348232269288,
                        "num_nodes_avg": 460.0,
                        "path_length_avg": 149.12424043236524,
                        "smoothness_avg": 0.04302569505876686,
                        "success_improvement": 0.0,
                        "time_improvement": -480.1328933285766,
                        "length_improvement": 18.26264079421406,
                        "smoothness_improvement": 573.4455594619491,
                        "objective_score": -130.21505572473478
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.12413969039916992,
                        "num_nodes_avg": 503.4,
                        "path_length_avg": 230.912228105496,
                        "smoothness_avg": 0.0921875744644283,
                        "success_improvement": 0.0,
                        "time_improvement": 22.764461241355903,
                        "length_improvement": 22.914851818421283,
                        "smoothness_improvement": 2272.0526909957175,
                        "objective_score": 31.93851291843813
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.3201060056686401,
                        "num_nodes_avg": 560.2,
                        "path_length_avg": 121.03197090225005,
                        "smoothness_avg": 0.1158150460745325,
                        "success_improvement": 0.0,
                        "time_improvement": -558.8164951691176,
                        "length_improvement": 19.616327849847938,
                        "smoothness_improvement": 1373.158837490585,
                        "objective_score": -149.00935765337357
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive informed sampling, spatial hashing for efficient neighbor search, dynamic rewiring radius, and iterative shortcutting smoothing to improve solution quality. The planner balances exploration and exploitation by alternating tree expansions from start and goal, sampling within an informed ellipsoid after the first solution, and employing early termination on stagnation or timeout. Spatial hashing accelerates neighbor lookups, while the rewiring propagates cost improvements locally. The final path is iteratively smoothed by shortcutting to enhance smoothness and reduce length.",
            "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focusing on promising regions, adds new nodes by connecting to minimum-cost parents within a dynamic radius found efficiently via spatial hashing, rewires neighbors incrementally with downstream cost propagation, attempts incremental greedy connections between trees, and returns the best smooth path found within a 30-second time limit.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=12000, step_size=4.0, goal_sample_rate=0.05,\n                 max_no_improve=120, time_limit_sec=30.0, gamma_rrt_star=35.0, cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n        self.cell_size = cell_size  # for spatial hashing\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            for i in range(dim):\n                if p[i] < 0.0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while trials < 500:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n            return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            p = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    p[i] += basis[j][i] * radii[j] * u[j]\n            clipped = tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size * 2.0, 3.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.15\n            min_r = max(3.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        # spatial hashing for neighbors: buckets keyed by tuple indices\n        def to_cell(pos):\n            return tuple(int(p // self.cell_size) for p in pos)\n\n        spatial_hash_start = dict()\n        spatial_hash_goal = dict()\n\n        def add_to_spatial_hash(spatial_hash, node):\n            c = to_cell(node.position)\n            if c not in spatial_hash:\n                spatial_hash[c] = []\n            spatial_hash[c].append(node)\n\n        def get_near_nodes(spatial_hash, pos, radius):\n            r_c = int(math.ceil(radius / self.cell_size))\n            c = to_cell(pos)\n            neighbors = []\n            for dx in range(-r_c, r_c + 1):\n                for dy in range(-r_c, r_c + 1):\n                    if dim == 3:\n                        for dz in range(-r_c, r_c + 1):\n                            bucket = (c[0] + dx, c[1] + dy, c[2] + dz)\n                            if bucket in spatial_hash:\n                                neighbors.extend(spatial_hash[bucket])\n                    else:\n                        bucket = (c[0] + dx, c[1] + dy)\n                        if bucket in spatial_hash:\n                            neighbors.extend(spatial_hash[bucket])\n            r_sq = radius * radius\n            filtered = [n for n in neighbors if sum((n.position[i] - pos[i])**2 for i in range(dim)) <= r_sq]\n            return filtered\n\n        def nearest_node(spatial_hash, pos):\n            # Search only close cells around pos\n            c = to_cell(pos)\n            search_r = 1\n            best = None\n            best_d = float('inf')\n            while search_r < 10 and best is None:\n                candidates = []\n                for dx in range(-search_r, search_r + 1):\n                    for dy in range(-search_r, search_r + 1):\n                        if dim == 3:\n                            for dz in range(-search_r, search_r + 1):\n                                bucket = (c[0] + dx, c[1] + dy, c[2] + dz)\n                                candidates.extend(spatial_hash.get(bucket, []))\n                        else:\n                            bucket = (c[0] + dx, c[1] + dy)\n                            candidates.extend(spatial_hash.get(bucket, []))\n                for n in candidates:\n                    d_ = dist(n.position, pos)\n                    if d_ < best_d:\n                        best_d = d_\n                        best = n\n                if best is not None:\n                    break\n                search_r += 1\n            return best\n\n        def add_node_rrt_star(tree, spatial_hash, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = get_near_nodes(spatial_hash, pos, r)\n            candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                fallback = nearest_node(spatial_hash, pos)\n                if fallback is None or is_edge_in_obstacle(fallback.position, pos):\n                    return None, []\n                candidates = [fallback]\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            add_to_spatial_hash(spatial_hash, new_node)\n            return new_node, neighbors\n\n        def propagate_cost(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost(child)\n\n        def rewire(tree, spatial_hash, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, start_tree_first):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                combined = path_start + path_goal[-2::-1]\n            else:\n                combined = path_start + path_goal[::-1]\n            return combined if start_tree_first else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        def iterative_shortcut_path(path, iterations=3):\n            # Iteratively shortcut multiple times for better smoothing\n            pth = path\n            for _ in range(iterations):\n                pth = shortcut_path(pth)\n            return pth\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        spatial_hash_start.clear()\n        spatial_hash_goal.clear()\n        add_to_spatial_hash(spatial_hash_start, tree_start[0])\n        add_to_spatial_hash(spatial_hash_goal, tree_goal[0])\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_counter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_curr = tree_start if expand_start_tree else tree_goal\n            tree_other = tree_goal if expand_start_tree else tree_start\n            spatial_hash_curr = spatial_hash_start if expand_start_tree else spatial_hash_goal\n            spatial_hash_other = spatial_hash_goal if expand_start_tree else spatial_hash_start\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_n = nearest_node(spatial_hash_curr, sample)\n            if nearest_n is None:\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n\n            new_pos = steer(nearest_n.position, sample)\n\n            if not within_bounds(new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(tree_curr, spatial_hash_curr, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_counter += 1\n                if found_first and no_improve_counter >= self.max_no_improve:\n                    break\n                continue\n            rewire(tree_curr, spatial_hash_curr, new_node, neighbors, edges)\n\n            # Incremental greedy connect attempt from tree_other to new_node.position\n            connected_node = None\n            nearest_other = nearest_node(spatial_hash_other, new_node.position)\n            if nearest_other and dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                conn_cost = nearest_other.cost + dist(nearest_other.position, new_node.position)\n                final_node = Node(new_node.position, cost=conn_cost)\n                nearest_other.add_child(final_node)\n                tree_other.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                add_to_spatial_hash(spatial_hash_other, final_node)\n                connected_node = final_node\n            else:\n                current = nearest_other\n                max_connect_steps = 10\n                for _ in range(max_connect_steps):\n                    if current is None:\n                        break\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos):\n                        break\n                    if is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(tree_other, spatial_hash_other, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(tree_other, spatial_hash_other, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        add_to_spatial_hash(spatial_hash_other, final_node)\n                        connected_node = final_node\n                        break\n\n            if connected_node is not None:\n                candidate_path = stitch_path(new_node, connected_node, expand_start_tree)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + 1e-6 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_counter = 0\n                else:\n                    no_improve_counter += 1\n            else:\n                no_improve_counter += 1\n\n            if found_first and no_improve_counter >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = iterative_shortcut_path(best_path, iterations=4)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax = a[0]\n        ay = a[1]\n        az = a[2] if len(a) > 2 else 0.0\n        bx = b[0]\n        by = b[1]\n        bz = b[2] if len(b) > 2 else 0.0\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": -2.33558,
            "time_improvement": -59.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1528.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07636876106262207,
                    "num_nodes_avg": 366.2,
                    "path_length_avg": 151.63664638373353,
                    "smoothness_avg": 0.04130734076297089,
                    "success_improvement": 0.0,
                    "time_improvement": -203.92379745105927,
                    "length_improvement": 16.885551280649135,
                    "smoothness_improvement": 546.5495832666647,
                    "objective_score": -48.313060550594976
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07082192897796631,
                    "num_nodes_avg": 434.3,
                    "path_length_avg": 230.71207038552546,
                    "smoothness_avg": 0.10502756173665322,
                    "success_improvement": 0.0,
                    "time_improvement": 55.9369785525401,
                    "length_improvement": 22.98167022656798,
                    "smoothness_improvement": 2602.434811779079,
                    "objective_score": 43.582269760598216
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06211984157562256,
                    "num_nodes_avg": 646.7,
                    "path_length_avg": 118.16772832654556,
                    "smoothness_avg": 0.12077696801484047,
                    "success_improvement": 0.0,
                    "time_improvement": -27.85007335875128,
                    "length_improvement": 21.518621388056005,
                    "smoothness_improvement": 1436.2741183203227,
                    "objective_score": 11.73752141680983
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.0,
        "analysis": "1. Summary of key changes:\n   - Introduction of spatial hashing for neighbor and nearest node searches instead of naive O(n) linear scans.\n   - Reduced maximum iterations (12000 vs 15000) and adjusted early stopping parameters.\n   - Decreased rewiring neighbor search radius with dynamic bounds to focus rewiring.\n   - More efficient incremental greedy connection with spatial hashing support.\n   - Added iterative shortcutting smoothing (4 iterations) instead of a single-pass shortcut.\n\n2. Primary contributors to the performance improvement:\n   - Spatial hashing dramatically speeds up neighbor and nearest searches, reducing planning overhead and allowing more focused rewiring.\n   - Iterative shortcutting refines the path more thoroughly, reducing path length.\n   - Slightly shortened planning horizon and early stopping prevent wasted computation on marginal improvements.\n\n3. Expected mechanism of impact:\n   - Efficient spatial hashing lowers computational complexity from O(n) to near constant-time neighborhood queries, enabling faster exploration and rewiring.\n   - Better path smoothing from iterative shortcutting removes redundant detours and sharply reduces total path length.\n   - Early termination avoids diminishing returns, freeing time to optimize existing solutions rather than prolonged exploration."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
                "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": 18.33169,
                "time_improvement": -104.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 277.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03312251567840576,
                        "num_nodes_avg": 199.7,
                        "path_length_avg": 163.67692862769394,
                        "smoothness_avg": 0.020726203772078875,
                        "success_improvement": 0.0,
                        "time_improvement": -31.81725886398311,
                        "length_improvement": 10.28608179225304,
                        "smoothness_improvement": 224.41009670489822,
                        "objective_score": -2.251478100318617
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2541221618652344,
                        "num_nodes_avg": 968.5,
                        "path_length_avg": 223.78483919358527,
                        "smoothness_avg": 0.016494501307333334,
                        "success_improvement": 0.0,
                        "time_improvement": -58.106259320137475,
                        "length_improvement": 25.29417938773204,
                        "smoothness_improvement": 324.4153991467646,
                        "objective_score": -0.633293167668195
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15669703483581543,
                        "num_nodes_avg": 482.5,
                        "path_length_avg": 117.3805344167902,
                        "smoothness_avg": 0.030113844927462913,
                        "success_improvement": 0.0,
                        "time_improvement": -222.5012635370204,
                        "length_improvement": 22.04143810076968,
                        "smoothness_improvement": 283.0458847045111,
                        "objective_score": -52.11028677712176
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, adaptive rewiring radius, goal bias, and iterative path shortcutting for minimizing path length and smoothness. The planner grows two trees from start and goal, alternates expansions, uses ellipsoidal sampling focused on the current best path cost after first solution, and rewires neighbors with adaptive radius to improve path quality. A best path is continuously tracked, and upon termination or timeout, iterative shortcutting is applied for smoothing and length reduction. The algorithm respects collision and boundary constraints, operates under a hard 30-second limit, and returns the best feasible path found.",
                "planning_mechanism": "Grows two RRT* trees bidirectionally with dynamic goal bias and uniform then ellipsoidal informed sampling. Uses an adaptive neighbor radius for efficient rewiring improving path costs. Attempts greedy incremental connection between trees to find better solutions. Maintains anytime best solution with early stopping criteria and applies iterative shortcutting smoothing post-planning. Terminates on time limit or after no improvement period to balance runtime and solution quality.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n        self.valid = True             # Collision validity flag\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            # linear scan; no spatial structures used as per constraints\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = []\n            for n in neighbors:\n                if not is_edge_in_obstacle(n.position, pos):\n                    candidate_parents.append(n)\n            if not candidate_parents:  # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidate_parents = [p]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            # Iterative shortcutting until no improvement or 20 iterations max\n            for _ in range(20):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        no_improve_count = 0\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt incremental greedy connection from other_tree towards new_node (up to max steps)\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy_steps = 20\n            steps_taken = 0\n            while steps_taken < max_greedy_steps:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if (not within_bounds(step_pt) or is_in_obstacle(step_pt)\n                        or is_edge_in_obstacle(current.position, step_pt)):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
                "objective": 65.01104,
                "time_improvement": -284.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1596.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.16463057994842528,
                        "num_nodes_avg": 550.7,
                        "path_length_avg": 148.1804923955482,
                        "smoothness_avg": 0.04324773945034862,
                        "success_improvement": 0.0,
                        "time_improvement": -555.1782474704154,
                        "length_improvement": 18.779924047838108,
                        "smoothness_improvement": 576.9210363673175,
                        "objective_score": -152.40091463058516
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.07044672966003418,
                        "num_nodes_avg": 429.2,
                        "path_length_avg": 233.7470795074309,
                        "smoothness_avg": 0.11325018422881583,
                        "success_improvement": 0.0,
                        "time_improvement": 56.17041494479452,
                        "length_improvement": 21.968496823782065,
                        "smoothness_improvement": 2814.0088110180145,
                        "objective_score": 44.102266632797665
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.22057127952575684,
                        "num_nodes_avg": 549.4,
                        "path_length_avg": 119.2811616079309,
                        "smoothness_avg": 0.1177158100875653,
                        "success_improvement": 0.0,
                        "time_improvement": -353.96210861020745,
                        "length_improvement": 20.77913201855518,
                        "smoothness_improvement": 1397.336415436557,
                        "objective_score": -86.73447129474633
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius that shrinks based on the number of nodes, combined with ellipsoidal informed sampling after first path discovery. It alternates expansions from start and goal trees, performs incremental rewiring with cost updates, attempts greedy incremental connections between trees, and applies iterative path shortcutting smoothing before returning. It respects collisions and map bounds, leverages a 30-second hard time limit with early stopping after stagnation, and maintains the best path found to balance speed and path quality.",
            "planning_mechanism": "A planner growing two trees with alternating expansions using adaptive neighborhood rewiring radius, biased goal and informed ellipsoidal sampling, maintaining anytime best solution with incremental tree connections, and smoothing the best path via iterative shortcutting on termination or timeout.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # 3D case\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, all_nodes, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidate_parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                candidate_parents = [p]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if not path_start or not path_goal:\n                return []\n            if path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(20):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            # Sampling\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy_steps = 20\n            steps_taken = 0\n            while steps_taken < max_greedy_steps:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if (not within_bounds(step_pt) or is_in_obstacle(step_pt)\n                        or is_edge_in_obstacle(current.position, step_pt)):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )",
            "objective": 61.75465,
            "time_improvement": -270.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1439.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1683267593383789,
                    "num_nodes_avg": 527.3,
                    "path_length_avg": 151.97475901804586,
                    "smoothness_avg": 0.046278857897239865,
                    "success_improvement": 0.0,
                    "time_improvement": -569.8878860795044,
                    "length_improvement": 16.700226388045003,
                    "smoothness_improvement": 624.3646222402243,
                    "objective_score": -157.8244068798232
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08442981243133545,
                    "num_nodes_avg": 510.0,
                    "path_length_avg": 233.94225648641594,
                    "smoothness_avg": 0.09681302304007958,
                    "success_improvement": 0.0,
                    "time_improvement": 47.47061129718217,
                    "length_improvement": 21.903341130339008,
                    "smoothness_improvement": 2391.068814423171,
                    "objective_score": 39.33853213947391
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.18793764114379882,
                    "num_nodes_avg": 491.1,
                    "path_length_avg": 118.54564564652279,
                    "smoothness_avg": 0.11007612188824092,
                    "success_improvement": 0.0,
                    "time_improvement": -286.79817265558677,
                    "length_improvement": 21.26762669861607,
                    "smoothness_improvement": 1300.160145444276,
                    "objective_score": -66.77807505028501
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.4,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a bidirectional RRT* approach with two trees grown alternately from start and goal, unlike parents where at least parent #1 uses a single tree.\n   - Adaptive neighbor radius based on node count and problem dimension replaces fixed neighbor radius from parents.\n   - Incorporation of iterative shortcut path smoothing post-planning to improve path smoothness and length.\n   - Adaptive early stopping criteria via `max_no_improve` iteration limits after first solution found.\n   - More efficient incremental rewiring with cost updates and greedy incremental attempts to connect trees.\n   - Informed sampling used after first solution found, combined with goal biasing, and fallback uniform sampling to better focus exploration.\n   - Consistent and rigorous collision checking with collision-validity flags and pruning.\n\n2. Primary contributors to the performance improvement:\n   - Bidirectional search reducing search space and faster convergence to paths near the goal.\n   - Adaptive neighbor radius optimizing rewiring efforts and balancing exploration/exploitation.\n   - Post-processing shortcut smoothing significantly reducing path length and improving smoothness.\n   - Early stopping after stagnation limiting wasted computational effort and improving runtime.\n   - Iterative rewiring and cost-aware parenting produce more cost-effective tree structures and shorter paths.\n   - More robust sampling strategy combining goal bias and informed ellipsoidal sampling focusing efforts on promising areas.\n\n3. Expected mechanism of impact:\n   - Bidirectional growth accelerates path discovery and reduces iteration count needed, shortening runtime.\n   - Shrinking neighbor radius prevents excessive rewiring overhead as tree grows, improving time efficiency.\n   - Shortcut smoothing removes unnecessary waypoints and jagged segments, reducing length and increasing smoothness.\n   - Early stopping terminates planning after no improvement, preventing wasteful exploration and thus improves effective runtime.\n   - Cost-aware rewiring and incremental connection of trees yield globally better paths rather than first feasible solutions.\n   - Informed sampling focuses samples within ellipsoidal regions defined by current best cost, concentrating search efforts and improving quality and speed."
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT* planner with goal bias sampling, adaptive rewiring radius, early stopping upon path connection, and basic path shortcutting post-processing within a strict 30-second time limit. The planner alternately grows start and goal trees by sampling free space points biased toward the goal, extends trees with collision-checked edges using fixed step size steering, rewires locally for minimum cost, and attempts greedy connection of trees each iteration to find a shortest feasible path efficiently. Once connected or time expires, it extracts and smooths the path by shortcutting to provide improved path length and smoothness while reducing planning time.",
                "planning_mechanism": "The planner grows two trees from start and goal points alternately using goal-biased random sampling within map bounds and obstacle free space. Each sampled point extends the respective tree using a fixed step size and adaptive radius neighbor search to choose the best parent minimizing path cost while performing collision checks on nodes and edges. Local rewiring optimizes cost-to-come values dynamically. After extension, it attempts to connect the two trees greedily. The planner terminates early upon successful connection or after 30 seconds, returning the best path found with shortcut smoothing applied.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return goal_pos\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_from, tree_to = nodes_start, nodes_goal\n            else:\n                tree_from, tree_to = nodes_goal, nodes_start\n\n            q_rand = sample()\n            nearest_node = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = neighbors_within_radius(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = c_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                        nb.update_parent(new_node, c_via_new)\n                        edges.append((new_node, nb))\n\n            # Try connection from tree_to to new_node\n            nearest_other = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                steered_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(steered_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, steered_pos, obstacles, is_3d):\n                    break\n\n                new_to_node = Node(steered_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, steered_pos))\n                tree_to.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n\n                if dist(steered_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(steered_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, steered_pos))\n                        tree_to.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_start_node = new_node if tree_from is nodes_start else final_node\n                            best_goal_node = final_node if tree_to is nodes_goal else new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n\n            if connected:\n                break\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shorthand = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shorthand.append(path[j])\n            i = j\n        return shorthand\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -35.47883,
                "time_improvement": 50.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1917.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01217057704925537,
                        "num_nodes_avg": 83.6,
                        "path_length_avg": 152.90926987361797,
                        "smoothness_avg": 0.04401612878654404,
                        "success_improvement": 0.0,
                        "time_improvement": 51.56490765972629,
                        "length_improvement": 16.188006179833796,
                        "smoothness_improvement": 588.9479980629259,
                        "objective_score": 28.12701599613279
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02094416618347168,
                        "num_nodes_avg": 271.3,
                        "path_length_avg": 235.2451134926445,
                        "smoothness_avg": 0.14098320673972334,
                        "success_improvement": 0.0,
                        "time_improvement": 86.96924445494005,
                        "length_improvement": 21.468409961000273,
                        "smoothness_improvement": 3527.5994555123716,
                        "objective_score": 56.60981659064404
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.043598508834838866,
                        "num_nodes_avg": 369.6,
                        "path_length_avg": 124.37076435048513,
                        "smoothness_avg": 0.13647305078069294,
                        "success_improvement": 0.0,
                        "time_improvement": 10.26904751389891,
                        "length_improvement": 17.398860217789284,
                        "smoothness_improvement": 1635.9271325376515,
                        "objective_score": 21.6996660475315
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified, goal-biased, single-tree RRT* planner with fixed radius rewiring and early stopping upon first feasible path discovery, prioritizing collision checking efficiency and adaptive local rewiring for improving path length and smoothness. Post-planning path smoothing via shortcutting is applied to reduce jagged turns and redundant nodes, maintaining a strict 30-second time limit.",
            "planning_mechanism": "The planner samples randomly with a small goal bias, extends the tree towards the samples using fixed step sizes while checking collisions, and locally rewires nearby nodes within a fixed radius for better path costs. It stops after a valid path reaches the goal or upon timeout. Finally, the path is extracted and smoothed by shortcutting to improve quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(50):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, dim == 3):\n                    return s\n            return goal_pos\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes = [Node(start_pos, cost=0.0)]\n        edges = []\n        success = False\n        best_goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            q_rand = sample()\n            nearest = min(nodes, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, dim == 3):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, dim == 3):\n                continue\n\n            radius = self.rewire_radius\n            near_nodes = neighbors_within_radius(nodes, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in near_nodes:\n                cost_via_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_via_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, dim == 3):\n                        min_cost = cost_via_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in near_nodes:\n                if nb is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, dim == 3):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, nb))\n\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, dim == 3):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist(new_node.position, goal_pos))\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        path = []\n        if success and best_goal_node:\n            path = best_goal_node.path_from_root()\n            path = self._shortcut_path(path, obstacles, dim == 3, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": 9.61183,
            "time_improvement": -93.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1227.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03583109378814697,
                    "num_nodes_avg": 253.5,
                    "path_length_avg": 160.7000938711168,
                    "smoothness_avg": 0.048553861787706744,
                    "success_improvement": 0.0,
                    "time_improvement": -42.59655308522024,
                    "length_improvement": 11.9177320932983,
                    "smoothness_improvement": 659.9733733760505,
                    "objective_score": -2.328459802706841
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16780226230621337,
                    "num_nodes_avg": 889.0,
                    "path_length_avg": 223.86852548377175,
                    "smoothness_avg": 0.07722416418174848,
                    "success_improvement": 0.0,
                    "time_improvement": -4.4009219973563525,
                    "length_improvement": 25.266242495291486,
                    "smoothness_improvement": 1887.0333667135774,
                    "objective_score": 23.274635731535874
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.16127386093139648,
                    "num_nodes_avg": 658.7,
                    "path_length_avg": 115.12421984387166,
                    "smoothness_avg": 0.0970230573459941,
                    "success_improvement": 0.0,
                    "time_improvement": -231.92091975681203,
                    "length_improvement": 23.539974805947985,
                    "smoothness_improvement": 1134.1261279438986,
                    "objective_score": -49.78166040375533
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": "1. Summary of key changes:\n   - The offspring algorithm uses a single-tree RRT* approach instead of bidirectional two-tree growth.\n   - It employs a fixed rewire radius instead of an adaptive radius based on node count and dimension.\n   - The goal sampling rate is reduced from 0.1 to 0.05, slightly lowering goal bias.\n   - The offspring terminates immediately upon reaching the goal within step size, skipping incremental greedy connection attempts.\n   - The rewiring and parent updating logic remains similar, but simplified without managing two separate trees.\n2. Primary contributors to the performance improvement:\n   - Simplified single-tree structure reduces complexity, allowing more focused rewiring and path refinement within one consistent tree.\n   - Fixed rewire radius enables consistent local optimization of path cost without overhead of adaptive radius calculation.\n   - Early termination on connecting to goal prevents redundant expansions, reducing elongated or unnecessary branches.\n   - Reduced goal bias and simplified sampling avoid over-exploration toward the goal, facilitating better intermediate node distribution.\n3. Expected mechanism of impact:\n   - Single-tree rewiring ensures path length improvements propagate efficiently across the entire structure without inter-tree connection overhead.\n   - Consistent rewiring radius balances exploration and exploitation, improving cost minimization for added nodes.\n   - Immediate goal edge addition prevents suboptimal incremental connections, delivering a more direct and consequently shorter path.\n   - More uniform node distribution allows better parent selection and rewiring choices, yielding shorter and more direct paths."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An improved informed RRT* planner with goal bias and adaptive rewiring radius using a KD-tree-like grid spatial index for fast nearest neighbor queries. The planner employs ellipsoidal informed sampling focused around the current best path cost to direct exploration, and performs dynamic neighbor selection with rewiring to continuously optimize path cost and smoothness. Early termination occurs if a path reaching the goal is found or after 30 seconds to reduce planning time while returning the best solution so far. This planner balances efficient spatial queries, collision-aware edge checking, and heuristic-driven sampling to improve planning time, path quality, and smoothness.",
                "planning_mechanism": "The planner builds a single tree from the start node, using informed sampling within the ellipsoidal subset defined by the best path cost to the goal. It uses a spatial hashing grid acceleration structure for rapid nearest neighbor and radius searches. In each iteration, it samples points with goal bias, steers towards them, checks node and edge collisions, rewires neighbors within a dynamic radius for cost optimization, and updates the best path if connected to the goal. Planning terminates early if a feasible path is found or at the 30-second timeout limit, returning the best path identified so far.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float=0.15, base_neighbor_radius: float=20.0, grid_cell_size: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                # Tuple[int, ...]\n        start_pos = map.start            # Tuple[float, ...]\n        goal_pos = map.goal              # Tuple[float, ...]\n        obstacles = map.obstacles        # List of tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Utility definitions\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Adaptive edge collision check resolution proportional to step size\n            distance = dist(p1,p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # --- Spatial hashing grid for fast neighbor search ---\n        # Positions bucketed into grid cells for O(1) neighbor lookup approx\n        # grid_cell_size chosen as ~step_size or configurable\n        grid_cell_size = self.grid_cell_size\n\n        def grid_key(pos):\n            return tuple(int(pos[i] // grid_cell_size) for i in range(dim))\n\n        # Map from grid_key -> list of node indices\n        grid = dict()\n\n        def grid_insert(node_idx, pos):\n            key = grid_key(pos)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node_idx)\n\n        def grid_nearby_nodes(pos, radius):\n            # Iterate over keys in radius neighborhood\n            base_key = grid_key(pos)\n            range_cells = int(math.ceil(radius/grid_cell_size))\n            candidates = set()\n            # Generate neighbor indices in each dimension\n            def neighbors_1d(c):\n                return [c+i for i in range(-range_cells, range_cells+1)]\n            if dim==2:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        k = (dx,dy)\n                        if k in grid:\n                            candidates.update(grid[k])\n            elif dim==3:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        for dz in neighbors_1d(base_key[2]):\n                            k = (dx,dy,dz)\n                            if k in grid:\n                                candidates.update(grid[k])\n            else:\n                # fallback all nodes if dim unexpected\n                candidates.update(range(len(nodes)))\n            # Filter by actual distance\n            result = []\n            for idx in candidates:\n                if dist(positions[idx], pos) <= radius:\n                    result.append(nodes[idx])\n            return result\n\n        def nearest_node(pos):\n            # Brute force with spatial grid neighbors fallback:\n            # Search within larger radius around pos to find nearest neighbor\n            radius = self.step_size * 2.0\n            search_radius = radius\n            # progressively expand radius until found neighbors or max radius\n            max_radius = max(bounds)*math.sqrt(dim)\n            while True:\n                neighbors = grid_nearby_nodes(pos, search_radius)\n                if neighbors or search_radius >= max_radius:\n                    break\n                search_radius *= 2.0\n                if search_radius > max_radius:\n                    search_radius = max_radius\n            if not neighbors:\n                # fallback to linear search all nodes (very rare)\n                best_node = None\n                best_distance = float('inf')\n                for n in nodes:\n                    d = dist(n.position, pos)\n                    if d < best_distance:\n                        best_distance = d\n                        best_node = n\n                return best_node, best_distance\n            best_node = None\n            best_distance = float('inf')\n            for n in neighbors:\n                d = dist(n.position, pos)\n                if d < best_distance:\n                    best_distance = d\n                    best_node = n\n            return best_node, best_distance\n\n        # Heuristic cost for informed sampling (Euclidean)\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        def build_rotation_matrix(a):\n            # a: unit vector of dim dims, build rotation matrix aligning x-axis unit vector to a\n            # support only dim=2 or dim=3\n            if dim == 2:\n                cos_theta = a[0]\n                sin_theta = a[1]\n                return [[cos_theta, -sin_theta],\n                        [sin_theta,  cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                # Choose arbitary vector to orthogonalize against x_axis\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(v[i]/norm_v for i in range(3))\n                w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                R = [list(x_axis), list(v_unit), list(w)]\n                return [[R[0][0],R[1][0],R[2][0]],\n                        [R[0][1],R[1][1],R[2][1]],\n                        [R[0][2],R[1][2],R[2][2]]]\n            else:\n                return None\n\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path yet, uniform random in bounds\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal, trivial\n                return x_start\n\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sampling\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                val = c_best**2 - c_min**2\n                if val < 0:\n                    val = 0\n                r2 = math.sqrt(val)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                gauss = [random.gauss(0,1) for _ in range(dim)]\n                norm_gauss = math.sqrt(sum(x*x for x in gauss))\n                if norm_gauss > 1e-10:\n                    break\n            unit_ball = [x/norm_gauss for x in gauss]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            # Clamp inside bounds\n            clipped = tuple(max(0.0,min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        nodes: List[Node] = []\n        positions: List[Tuple[float,...]] = []\n        edges: List[Tuple[Node,Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions.append(start_pos)\n        grid_insert(0, start_pos)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Precompute max radius for neighbor search scaling with log(n)/n in high density scenario\n        # We'll use self.base_neighbor_radius but decrease it as tree grows (adaptive radius)\n        def neighbor_radius(n_nodes):\n            gamma_rrt = self.base_neighbor_radius\n            val = gamma_rrt * (math.log(n_nodes+1) / (n_nodes+1))**(1.0/dim)\n            return max(val, self.step_size*1.5)\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample goal point with probability goal_sample_rate, else informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos\n            else:\n                sample_pt = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Nearest node search via spatial hashing\n            nearest, _ = nearest_node(sample_pt)\n\n            # Steer towards sampled point\n            new_pos = steer(nearest.position, sample_pt, self.step_size)\n\n            # Node collision check + bounds\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision nearest->new_pos\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Add new node after rewiring neighbors within radius\n            nradius = neighbor_radius(len(nodes))\n            neighbors = grid_nearby_nodes(new_pos, nradius)\n\n            # Determine best parent with minimal cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost:\n                    if is_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            nodes.append(new_node)\n            positions.append(new_pos)\n            grid_insert(len(nodes)-1, new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost:\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nbr))\n\n            # Check if new_node can connect directly to goal for improved path\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    grid_insert(len(nodes)-1, goal_pos)\n                    edges.append((new_node, goal_node))\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        best_goal_node = goal_node\n                        # Early termination on first found path\n                        break\n\n        # Extract path from best_goal_node if exists\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No goal reached, extract from closest node to goal\n            min_dist = float('inf')\n            closest = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    closest = n\n            if closest is not None:\n                current = closest\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": -11.67906,
                "time_improvement": 17.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 97.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.030892300605773925,
                        "num_nodes_avg": 250.8,
                        "path_length_avg": 172.8223959302965,
                        "smoothness_avg": 0.011826902640376145,
                        "success_improvement": 0.0,
                        "time_improvement": -22.94170000227719,
                        "length_improvement": 5.273306244493363,
                        "smoothness_improvement": 85.11670885203338,
                        "objective_score": -3.292942709726973
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.09835076332092285,
                        "num_nodes_avg": 982.7,
                        "path_length_avg": 247.72707600463454,
                        "smoothness_avg": 0.00824493977827406,
                        "success_improvement": 0.0,
                        "time_improvement": 38.80946401598113,
                        "length_improvement": 17.30157160112754,
                        "smoothness_improvement": 112.14823908507424,
                        "objective_score": 22.584523360896235
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03158433437347412,
                        "num_nodes_avg": 420.6,
                        "path_length_avg": 138.564029335853,
                        "smoothness_avg": 0.015149031435232588,
                        "success_improvement": 0.0,
                        "time_improvement": 34.99565735820171,
                        "length_improvement": 7.972369425158277,
                        "smoothness_improvement": 92.69456167097287,
                        "objective_score": 15.745591670910343
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "A streamlined goal-biased RRT* planner using fixed radius rewiring, uniform sampling within bounds, and an efficient grid-based neighbor search. The planner employs early stopping upon first goal reach or 30 seconds timeout, balances simplicity to minimize overhead, and updates subtree costs on rewiring to improve path quality and smoothness.",
            "planning_mechanism": "The planner incrementally builds a single tree from the start, samples points mostly uniformly with goal bias, steers with fixed step size, validates collision-free expansions. The grid spatial index enables fast nearest and neighbor queries with a fixed radius for rewiring neighbors, propagating cost changes downstream for accurate path costs. Upon reaching the goal within step size, it terminates immediately or after timeout, returning the best found path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0, grid_cell_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = 1.0  # simpler fixed resolution for improved speed\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def grid_key(pos):\n            return tuple(int(pos[i] // self.grid_cell_size) for i in range(dim))\n\n        grid = dict()\n\n        def grid_insert(node_idx, pos):\n            key = grid_key(pos)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node_idx)\n\n        def neighbors_in_radius(pos, radius):\n            base_key = grid_key(pos)\n            range_cells = int(math.ceil(radius / self.grid_cell_size))\n            candidates = set()\n            def neighbors_1d(c):\n                return [c + i for i in range(-range_cells, range_cells + 1)]\n            if dim == 2:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        k = (dx, dy)\n                        if k in grid:\n                            candidates.update(grid[k])\n            elif dim == 3:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        for dz in neighbors_1d(base_key[2]):\n                            k = (dx, dy, dz)\n                            if k in grid:\n                                candidates.update(grid[k])\n            else:\n                candidates.update(range(len(nodes)))\n            result = []\n            for idx in candidates:\n                if dist(positions[idx], pos) <= radius:\n                    result.append(nodes[idx])\n            return result\n\n        def nearest_node(pos):\n            radius = self.step_size * 2.0\n            max_radius = max(bounds) * (dim ** 0.5)\n            search_radius = radius\n            while True:\n                nbrs = neighbors_in_radius(pos, search_radius)\n                if nbrs or search_radius >= max_radius:\n                    break\n                search_radius *= 2.0\n                if search_radius > max_radius:\n                    search_radius = max_radius\n            if not nbrs:\n                # rare fallback linear search\n                best = None\n                best_dist = float('inf')\n                for n in nodes:\n                    d = dist(n.position, pos)\n                    if d < best_dist:\n                        best = n\n                        best_dist = d\n                return best, best_dist\n            best = None\n            best_dist = float('inf')\n            for n in nbrs:\n                d = dist(n.position, pos)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best, best_dist\n\n        # Propagate cost changes downstream after rewiring\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_costs(c)\n\n        nodes = []\n        positions = []\n        edges = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n        positions.append(start_pos)\n        grid_insert(0, start_pos)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias or uniform random\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Fixed radius neighborhood\n            neighbors = neighbors_in_radius(new_pos, self.neighbor_radius)\n\n            # Choose best parent minimizing cost with collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                if nbr is nearest:\n                    continue\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nbr.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            nodes.append(new_node)\n            positions.append(new_pos)\n            grid_insert(len(nodes) - 1, new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free; update costs downstream\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost and is_free_edge(new_node.position, nbr.position):\n                    # Remove old edge\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nbr))\n                    propagate_costs(nbr)\n\n            # Try connecting goal directly if within step_size\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    grid_insert(len(nodes) - 1, goal_pos)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_goal_cost:\n                        best_goal_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        # Early stop on first path found\n                        break\n\n        success = False\n        path = []\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # Extract path to closest node to goal if no solution found\n            closest_dist = float('inf')\n            closest_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = n\n            if closest_node is not None:\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
            "objective": -2.46515,
            "time_improvement": -38.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 292.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06125349998474121,
                    "num_nodes_avg": 250.4,
                    "path_length_avg": 158.2769019751662,
                    "smoothness_avg": 0.021230489071534048,
                    "success_improvement": 0.0,
                    "time_improvement": -143.76978313509082,
                    "length_improvement": 13.245921969401609,
                    "smoothness_improvement": 232.3032567144267,
                    "objective_score": -34.02186547531415
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16160283088684083,
                    "num_nodes_avg": 995.0,
                    "path_length_avg": 221.17221911453004,
                    "smoothness_avg": 0.016669237287272237,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5438443444890495,
                    "length_improvement": 26.166347170220067,
                    "smoothness_improvement": 328.9114817678318,
                    "objective_score": 17.181212407624486
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.033482813835144044,
                    "num_nodes_avg": 341.3,
                    "path_length_avg": 117.11814972091506,
                    "smoothness_avg": 0.03270722264153734,
                    "success_improvement": 0.0,
                    "time_improvement": 31.088359266510622,
                    "length_improvement": 22.215701522353378,
                    "smoothness_improvement": 316.033457804307,
                    "objective_score": 24.236095982386747
                }
            ],
            "success_rate": 1.0
        },
        "objective": 8.2,
        "analysis": "1. Summary of key changes:\n   - Fixed radius neighbor search in offspring replacing adaptive radius based on tree size.\n   - Simpler and fixed edge collision checking resolution for faster checks.\n   - Lower goal sample rate in offspring (0.1 vs 0.15) and pure uniform random sampling instead of informed sampling.\n   - Added downstream cost propagation after rewiring to ensure accurate cost updates.\n   - Smaller grid cell size in offspring (5.0 vs 10.0) improving spatial indexing granularity.\n\n2. Primary contributors to the performance improvement:\n   - More consistent and stable rewiring with fixed neighbor radius allowing better local optimization.\n   - More precise cost updates via propagation preventing cost underestimation.\n   - Faster edge collision checks allowing more iterations and thus better exploration.\n   - Improved spatial indexing granularity leading to better neighbor selection.\n\n3. Expected mechanism of impact:\n   - Fixed radius neighbor selection and cost propagation enhance path cost optimization yielding shorter path lengths.\n   - Faster collision checks reduce planning overhead enabling more rewiring and refinement within time limits.\n   - Finer spatial grid enables more accurate neighbor queries, improving rewiring quality and thus path smoothness and length."
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "A unidirectional RRT*-based planner utilizing a progressive goal bias with dynamically increasing sampling probability towards the goal, adaptive rewiring radius proportional to the tree size, and continuous ellipsoidal informed sampling after the first solution. The algorithm incrementally prunes unreachable nodes to maintain tree efficiency, rewires to improve path cost, and applies a fast iterative path shortcutting method upon termination. It adheres to a strict 30-second wall-clock limit, immediately returning the best path found.",
                "planning_mechanism": "The planner grows a single tree from the start, initially sampling uniformly and progressively biasing samples toward the goal. Once a solution is found, subsequent samples are constrained within an ellipsoidal informed set to focus refinement efforts. The rewiring radius adapts to the current tree size and problem dimension to balance exploration and exploitation efficiently. The planner performs rewiring to optimize path costs locally and periodically prunes invalid or disconnected nodes to reduce computational overhead. Upon expiry or stagnation, it extracts the best path and applies shortcutting to reduce path length and enhance smoothness.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.prune_every = 200\n        self.max_no_improve = 150\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.3\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best, c_min_):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min_**2, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best**2 - c_min_**2, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x/norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            rotated = [0.0]*3\n                            for i in range(3):\n                                rotated[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            prob = random.random()\n            if prob < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            gamma = 30.0  # tuned constant\n            radius = min(gamma * (math.log(n_nodes)/n_nodes)**(1.0/dim), self.step_size*20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_cost_through = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success = found_solution and (best_goal_node is not None)\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n        else:\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
                "objective": 44.01246,
                "time_improvement": -211.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1745.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06414153575897216,
                        "num_nodes_avg": 533.8,
                        "path_length_avg": 164.73372793222322,
                        "smoothness_avg": 0.059289813169988916,
                        "success_improvement": 0.0,
                        "time_improvement": -155.2632627655779,
                        "length_improvement": 9.706833347383933,
                        "smoothness_improvement": 828.0143260003385,
                        "objective_score": -36.61480719124132
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.21828715801239013,
                        "num_nodes_avg": 1227.7,
                        "path_length_avg": 231.35713711539378,
                        "smoothness_avg": 0.11222208238614007,
                        "success_improvement": 0.0,
                        "time_improvement": -35.81092557077104,
                        "length_improvement": 22.766328384921604,
                        "smoothness_improvement": 2787.5550100941414,
                        "objective_score": 16.85429441019236
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.26305649280548093,
                        "num_nodes_avg": 820.5,
                        "path_length_avg": 120.35447939559413,
                        "smoothness_avg": 0.13528231560711504,
                        "success_improvement": 0.0,
                        "time_improvement": -441.4017655169706,
                        "length_improvement": 20.066285449890046,
                        "smoothness_improvement": 1620.7810690206684,
                        "objective_score": -112.27685304005381
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -24.394856704415727,
                "time_improvement": 84.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 65.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0037204265594482423,
                        "num_nodes_avg": 58.5,
                        "path_length_avg": 184.8763674372614,
                        "smoothness_avg": 0.010656061011327317,
                        "success_improvement": 0.0,
                        "time_improvement": 85.19386523557586,
                        "length_improvement": -1.3336665458757502,
                        "smoothness_improvement": 66.79049483412726,
                        "objective_score": 25.091912117317943
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.007217264175415039,
                        "num_nodes_avg": 195.5,
                        "path_length_avg": 293.476072886139,
                        "smoothness_avg": 0.006583639266204931,
                        "success_improvement": 0.0,
                        "time_improvement": 95.50966105071444,
                        "length_improvement": 2.0292396302187403,
                        "smoothness_improvement": 69.4017803231431,
                        "objective_score": 30.217450994961293
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.014179682731628418,
                        "num_nodes_avg": 216.3,
                        "path_length_avg": 159.7621915423607,
                        "smoothness_avg": 0.012486187243912596,
                        "success_improvement": 0.0,
                        "time_improvement": 70.81651479687723,
                        "length_improvement": -6.106440564392849,
                        "smoothness_improvement": 58.82338010809535,
                        "objective_score": 17.875207000967936
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "An improved unidirectional RRT* variant using a fixed rewiring radius, goal bias sampling, early stopping upon first valid solution, fixed neighbor radius for efficient rewiring, and fast incremental path shortcutting to produce shorter and smoother paths within a 30-second time limit. The planner samples with a 5% goal bias, connects new samples via cost-optimizing parent selection without redundant edges, rewires neighbors within a fixed radius if beneficial, and terminates immediately once a feasible path to the goal is found. It ensures collision-free nodes and edges, prunes invalid nodes efficiently, and returns the best path found when time expires.",
            "planning_mechanism": "The planner samples points inside the map bounds with a fixed 5% probability toward the goal, extends the tree by stepping toward the sample, connects new samples by selecting the lowest cost parent within a fixed radius if collision-free, rewires neighbors to reduce costs, and stops at the first successful connection to the goal. A fast shortcutting is applied to smooth the final extracted path. The fixed neighbor radius and early stopping reduce runtime, while goal bias and rewiring improve path length and smoothness.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 100000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.05          # Fixed 5% goal bias\n        self.fixed_neighbor_radius = 15.0     # Fixed rewiring radius for all nodes\n        self.improve_tol = 1e-6               # Tolerance for cost improvements\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        found_solution = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample():\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n            return start_pos\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def rewire(node, near, edges):\n            for nb in near:\n                if nb == node or nb == node.parent:\n                    continue\n                new_cost = node.cost + math.dist(node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if not is_edge_in_obstacle(node.position, nb.position):\n                        # Remove old edge from parent if any\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        # Reassign parent and cost\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def prune_invalid_nodes():\n            to_remove = [n for n in nodes if not n.valid or (n.parent is None and n != root)]\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            sample_pos = sample()\n            if not within_bounds(sample_pos):\n                continue\n\n            nearest = nearest_node(nodes, sample_pos)\n            new_pos = steer(nearest.position, sample_pos)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius for rewiring and parent selection\n            near = near_nodes(nodes, new_pos, self.fixed_neighbor_radius)\n\n            # Select best parent (lowest cost) avoiding collision\n            best_parent = nearest\n            best_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if profitable\n            rewire(new_node, near, edges)\n\n            # Check if goal can be connected directly from new node\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                    goal_cost = new_node.cost + dist_goal\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    found_solution = True\n                    # Early stop upon first solution\n                    break\n\n            # Small prune to keep tree clean every 500 iterations\n            if iteration % 500 == 0:\n                prune_invalid_nodes()\n\n        if found_solution and best_goal_node is not None:\n            raw_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n            success = True\n        else:\n            # Return best reachable path toward goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n            success = False\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
            "objective": 27.32182,
            "time_improvement": -151.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1192.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04816446304321289,
                    "num_nodes_avg": 275.0,
                    "path_length_avg": 162.509664448828,
                    "smoothness_avg": 0.04646132878012289,
                    "success_improvement": 0.0,
                    "time_improvement": -91.67950751854016,
                    "length_improvement": 10.925877785174016,
                    "smoothness_improvement": 627.220687799208,
                    "objective_score": -17.812222145461597
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.20136358737945556,
                    "num_nodes_avg": 1020.1,
                    "path_length_avg": 222.21454506385945,
                    "smoothness_avg": 0.07672167462570378,
                    "success_improvement": 0.0,
                    "time_improvement": -25.2816493066552,
                    "length_improvement": 25.81838876664495,
                    "smoothness_improvement": 1874.1039485079493,
                    "objective_score": 17.277058210530157
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21229140758514403,
                    "num_nodes_avg": 615.8,
                    "path_length_avg": 114.74175648069794,
                    "smoothness_avg": 0.09229075367084426,
                    "success_improvement": 0.0,
                    "time_improvement": -336.92114056910685,
                    "length_improvement": 23.793988760819712,
                    "smoothness_improvement": 1073.9315744983153,
                    "objective_score": -81.43029104174865
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a fixed rewiring radius for neighbor search and parent selection instead of a variable radius based on node count.\n   - Offspring employs a fixed low goal sample rate (5%) rather than dynamically increasing it over iterations.\n   - Offspring applies early stopping immediately upon first valid path to the goal, unlike parent #1 which continues to seek improvements.\n   - Offspring simplifies pruning by running it less frequently (every 500 iterations) with a smaller scope, reducing overhead.\n   - Parent selection and rewiring in offspring are streamlined with a small improvement tolerance and simpler edge collision checks.\n\n2. Primary contributors to the performance improvement:\n   - Using a fixed neighbor radius optimizes the rewiring step, balancing connection quality and computation.\n   - Early stopping reduces unnecessary iterations after first feasible solution, saving planning time.\n   - Fixed goal sample rate with consistent sampling reduces computational overhead compared to adaptive sampling.\n   - Streamlined pruning and rewiring reduce expensive tree manipulations, improving runtime efficiency.\n\n3. Expected mechanism of impact:\n   - Fixed radius neighbor search ensures relevant local optimizations without excessive nearest neighbor computations, improving path length and smoothness.\n   - Early termination preserves planning time for initial path quality, resulting in faster convergence on shorter paths.\n   - Consistent goal bias sampling prevents costly sampling attempts and focuses search near the goal.\n   - Reduced pruning complexity prevents excessive overhead from node and edge removals, sustaining efficiency during growth of the tree."
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "A unidirectional RRT* planner with adaptive neighbor radius, ellipsoidal informed sampling after first solution, efficient rewiring with downstream cost updates, and iterative randomized shortcutting for improved path length, smoothness, and planning efficiency under a strict 30-second time limit. The planner grows a single tree from start toward goal, alternates between uniform, goal-biased, and informed samples for focused exploration, rewires with parent cost propagation to minimize global cost, and terminates early on stagnation or time limit.",
                "planning_mechanism": "The planner samples states within bounds, steering towards samples with a fixed step size. It adapts neighbor radius logarithmically for rewiring efficiency. After first solution, informed ellipsoidal sampling concentrates exploration near the optimal path. Cost improvements propagate downstream for global optimality. Shortcutting post-processes the best path to reduce detours. Early stopping ensures time-constrained usability.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position    # Tuple[float,...]\n        self.parent = parent        # Node or None\n        self.cost = cost            # cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float,...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 max_no_improve: int=150,\n                 shortcut_iters: int=100,\n                 gamma_rrt_star: float=50.0,\n                 time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.shortcut_iters = shortcut_iters\n        self.gamma_rrt_star = gamma_rrt_star\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n            unit_vector = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Build orthonormal basis {unit_vector, perp}\n                perp = (-unit_vector[1], unit_vector[0])\n                basis = (unit_vector, perp)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # 3D basis: unit_vector and two orthogonal vectors\n                ref = (1.0, 0.0, 0.0) if abs(unit_vector[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(unit_vector, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(unit_vector, ref))\n                b3 = self._cross(unit_vector, b2)\n                basis = (unit_vector, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.))* 0.5\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            # Clamp to bounds\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_descendants(node, edges_list):\n            # Recursively update cost of children after rewiring\n            for child in node.children:\n                prev_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                # Update edges (remove old, add new)\n                try:\n                    edges_list.remove((node, child))\n                except ValueError:\n                    pass\n                edges_list.append((node, child))\n                if abs(child.cost - prev_cost) > 1e-9:\n                    propagate_cost_to_descendants(child, edges_list)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_descendants(nb, edges_list)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_time = time.monotonic()\n        tree = [Node(start_pos, cost=0.0)]\n        nodes = [tree[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Sampling: goal bias and informed sampling after solution\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n            # Check if new node close enough to goal to connect\n            if dist(new_node.position, goal_pos) <= self.step_size and \\\n               not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_node = Node(goal_pos, parent=None, cost=new_node.cost + dist(new_node.position, goal_pos))\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                # Extract path cost and path\n                candidate_path = goal_node.path_from_root()\n                candidate_cost = 0.0\n                for k in range(len(candidate_path)-1):\n                    candidate_cost += dist(candidate_path[k], candidate_path[k+1])\n\n                if candidate_cost + 1e-9 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_iter = 0\n                    c_min = dist(start_pos, goal_pos)\n                else:\n                    no_improve_iter += 1\n                    if no_improve_iter > self.max_no_improve:\n                        break\n            else:\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n\n        if best_path:\n            # Post-processing to improve path smoothness and length\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
                "objective": 127.75644,
                "time_improvement": -485.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1309.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.17356514930725098,
                        "num_nodes_avg": 478.0,
                        "path_length_avg": 161.1263523407774,
                        "smoothness_avg": 0.04756566345540762,
                        "success_improvement": 0.0,
                        "time_improvement": -590.7350407238445,
                        "length_improvement": 11.684093071579628,
                        "smoothness_improvement": 644.5059235685443,
                        "objective_score": -166.98752675636283
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.8589968681335449,
                        "num_nodes_avg": 1323.9,
                        "path_length_avg": 228.59673782987915,
                        "smoothness_avg": 0.09037868046413763,
                        "success_improvement": 0.0,
                        "time_improvement": -434.4389509024096,
                        "length_improvement": 23.687829120114394,
                        "smoothness_improvement": 2225.5085454745536,
                        "objective_score": -104.99144507128148
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.25744583606719973,
                        "num_nodes_avg": 636.7,
                        "path_length_avg": 119.51068863450095,
                        "smoothness_avg": 0.09103730825978568,
                        "success_improvement": 0.0,
                        "time_improvement": -429.8543620242109,
                        "length_improvement": 20.626691096409843,
                        "smoothness_improvement": 1057.9878413893664,
                        "objective_score": -111.29035474247053
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "A bidirectional RRT* inspired planner with goal bias sampling, adaptive neighbor radius based on tree size and dimension, incremental rewiring, early stopping immediately after first path found, and final path shortcutting for improved smoothness and length. The algorithm alternately expands start and goal trees, rewires locally to optimize path cost, and efficiently connects trees upon proximity. It enforces strict collision checks for nodes and edges at every addition, respects map bounds, and robustly handles 2D/3D rectangular obstacles under a strict 30-second time limit. Final path extraction merges two parent chains cleanly and applies shortcutting to smooth and shorten the path.",
                "planning_mechanism": "The planner grows two trees alternately from start and goal with goal-biased sampling, chooses parent nodes by minimizing path cost within an adaptive radius, rewires neighbors upon discovery of better costs, attempts incremental connections between trees, and stops early on finding a valid connection. It applies shortcutting to the final path to improve smoothness and length before returning results with all explored nodes and edges.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10  # 10% chance sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback uniform sample without obstacle check\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            # Remove unnecessary waypoints by attempting direct connections skipping intermediate points\n            if len(path) <= 2:\n                return path[:]\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, proceed next node\n                    shortcut_path.append(path[i+1])\n                    i += 1\n            return shortcut_path\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius for neighbor search (approximate RRT* radius)\n            n = len(tree_a)\n            min_radius = self.step_size * 2.5\n            gamma_rrt = 50.0  # tuning constant, increased slightly for larger graphs\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n+1) / (n+1))**(1/dim)), self.step_size * 30))\n\n            # Choose best parent in radius neighbors\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with new_node if better cost found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect to opposing tree within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path, removing duplicate connection point if overlapping\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicate middle point\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Apply shortcutting to smooth path and reduce length\n                smooth_path = shortcut_path(combined_path)\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # Time limit or max_iter reached with no full path\n        # Return best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
                "objective": -37.37284,
                "time_improvement": 65.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1594.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013492751121520995,
                        "num_nodes_avg": 116.9,
                        "path_length_avg": 167.48639160694592,
                        "smoothness_avg": 0.046124220571561826,
                        "success_improvement": 0.0,
                        "time_improvement": 46.30306814127721,
                        "length_improvement": 8.198054768521205,
                        "smoothness_improvement": 621.9442122930357,
                        "objective_score": 21.91947436496106
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023199057579040526,
                        "num_nodes_avg": 285.8,
                        "path_length_avg": 234.67161709331359,
                        "smoothness_avg": 0.11706785284768806,
                        "success_improvement": 0.0,
                        "time_improvement": 85.56632689312731,
                        "length_improvement": 21.659859566275518,
                        "smoothness_improvement": 2912.240174337157,
                        "objective_score": 53.227014679389285
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0182589054107666,
                        "num_nodes_avg": 226.6,
                        "path_length_avg": 120.43817791147322,
                        "smoothness_avg": 0.10596483217621462,
                        "success_improvement": 0.0,
                        "time_improvement": 62.42098600050051,
                        "length_improvement": 20.010696880938188,
                        "smoothness_improvement": 1247.864843771141,
                        "objective_score": 36.972038147568774
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A hybrid bidirectional RRT* planner that incorporates adaptive informed sampling, variable step size based on local node density, batch rewiring with downstream cost updates, and iterative multiscale shortcutting for enhanced planning speed, path length, and smoothness under a strict 30-second time limit. The planner grows two trees from start and goal, alternately sampling using a combination of uniform, goal-biased, and ellipsoidal informed distributions. It employs an adaptive rewiring radius and steers with dynamic step sizes modulated by local node density to balance global exploration and local refinement efficiently. Batch rewiring is performed periodically for optimal parent selection and cost propagation. The search stops early upon convergence or timeout, returning the best path found, which is further refined via multi-resolution progressive shortcutting.",
            "planning_mechanism": "The planner builds two trees alternately from start and goal configurations. Initially, samples are drawn uniformly or toward the goal to explore broadly. After finding a first feasible path, ellipsoidal informed sampling restricts new samples to the subset that can improve the solution. The neighbor radius decreases as the tree grows to speed rewiring while ensuring path quality. Step sizes adapt to neighbor density, allowing finer expansions in congested regions. Batch rewiring updates subtree costs efficiently. Once time limit is reached or no improvement is observed, the best complete path joining both trees is extracted and smoothed through iterative progressive shortcutting removing redundant waypoints and reducing path length and angular discontinuities.}\n\n```python\nimport math\nimport random\nimport time\nfrom typing import List, Tuple, NamedTuple\n\nclass Node:\n    def __init__(self, position: Tuple[float,...], parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...], e.g. 2D or 3D coords\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from root\n        self.children = []             # List of children nodes\n        self.valid = True              # For collision validity if needed\n\n    def add_child(self, child:'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -",
            "code": "class Node:\n    def __init__(self, position: Tuple[float,...], parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...], e.g. 2D or 3D coords\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from root\n        self.children = []             # List of children nodes\n        self.valid = True              # For collision validity if needed\n\n    def add_child(self, child:'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child:'Node'):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float,...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=10000, base_step_size: float=5.0, goal_sample_rate: float=0.10,\n                 rewire_batch_size: int=50, max_stagnation: int=150, shortcut_iters: int=200,\n                 gamma_rrt_star: float=50.0, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_batch_size = rewire_batch_size\n        self.max_stagnation = max_stagnation\n        self.shortcut_iters = shortcut_iters\n        self.gamma_rrt_star = gamma_rrt_star\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            dist_ab = dist(a,b)\n            steps = max(1,int(dist_ab / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(dim))\n                if is_in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(fr,to, max_step=None):\n            d = dist(fr,to)\n            step = max_step if max_step is not None else self.base_step_size\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def uniform_sample():\n            tries = 0\n            while tries < 100:\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n                tries += 1\n            # fallback if stuck\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def ellipsoidal_informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-6:\n                return uniform_sample()\n\n            center = tuple( (s+g)*0.5 for s,g in zip(start, goal) )\n            unit_vec = tuple( (g - s)/c_min for s,g in zip(start, goal) )\n\n            if dim == 2:\n                # orthonormal basis: unit_vec, perp\n                perp = (-unit_vec[1], unit_vec[0])\n                basis = (unit_vec, perp)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = (r1,r2)\n            else:\n                # 3D: unit_vec and two orthogonal vectors\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0])<0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(unit_vec, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(unit_vec, ref))\n                b3 = self._cross(unit_vec,b2)\n                basis = (unit_vec,b2,b3)\n                r1 = c_best/2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min,0.0))/2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            r_sq = radius * radius\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.base_step_size*2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(2.0,self.base_step_size)\n            return max(min_r, min(max_r,val))\n\n        def set_cost_and_parent(child, new_parent, new_cost, edges_list):\n            if child.parent:\n                try:\n                    edges_list.remove((child.parent, child))\n                except ValueError:\n                    pass\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges_list.append((new_parent, child))\n\n        def propagate_cost_descendants(node, edges_list):\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    new_cost = cur.cost + dist(cur.position, ch.position)\n                    if ch.cost > new_cost + 1e-9:\n                        ch.cost = new_cost\n                        if ch.parent != cur:\n                            # Correct parent and edge if mismatch\n                            set_cost_and_parent(ch, cur, new_cost, edges_list)\n                        stack.append(ch)\n\n        def batch_rewire(tree, edges_list):\n            for new_node in tree[-self.rewire_batch_size:]:\n                r = neighbor_radius(len(tree))\n                neighbors = near_nodes(tree, new_node.position, r)\n                for nb in neighbors:\n                    if nb is new_node:\n                        continue\n                    if is_edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if alt_cost + 1e-9 < nb.cost:\n                        set_cost_and_parent(nb, new_node, alt_cost, edges_list)\n                        propagate_cost_descendants(nb, edges_list)\n\n        def dynamic_step_size(node, tree):\n            # Use neighbor count in radius to adjust step size (smaller step in dense region)\n            r = neighbor_radius(len(tree))\n            count_near = len(near_nodes(tree, node.position, r))\n            if count_near == 0:\n                return self.base_step_size\n            # heuristic: step size inversely proportional to sqrt of neighbors count\n            factor = max(0.3, min(1.0, 5.0 / (math.sqrt(count_near)+1e-5)))\n            return self.base_step_size * factor\n\n        def combine_paths(n_start:Node, n_goal:Node) -> List[Tuple[float,...]]:\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Avoid duplicated meeting point if overlap\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            elif path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal[::-1]\n\n        def progressive_shortcut(path) -> List[Tuple[float,...]]:\n            # Perform iterative multi-resolution shortcutting to reduce detours and angle changes\n            if len(path) < 3:\n                return path[:]\n            for resolution in [3,2,1]:\n                for _ in range(self.shortcut_iters // resolution):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = i + random.randint(2, max(2, resolution*3))\n                    if j >= len(path):\n                        j = len(path)-1\n                    if j - i < 2:\n                        continue\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        found_solution = False\n\n        c_min = dist(start_pos, goal_pos)\n        no_improve_counter = 0\n\n        expand_start_tree = True\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n            # Choose tree to expand\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Sample\n            if found_solution:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = ellipsoidal_informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    sample = uniform_sample()\n\n            # Nearest node in tree\n            nearest_node = nearest(tree_a, sample)\n\n            # Adaptive dynamic step size by neighbor density\n            step_sz = dynamic_step_size(nearest_node, tree_a)\n\n            new_pos = steer(nearest_node.position, sample, step_sz)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                no_improve_counter += 1\n                expand_start_tree = not expand_start_tree\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_counter += 1\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n\n            r_rewire = neighbor_radius(len(tree_a))\n            neighbors = near_nodes(tree_a, new_pos, r_rewire)\n            feasible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, new_pos)]\n\n            if len(feasible_parents) == 0:\n                # Fallback to nearest_node only if edge collision-free\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    no_improve_counter += 1\n                    expand_start_tree = not expand_start_tree\n                    continue\n                best_parent = nearest_node\n            else:\n                best_parent = min(feasible_parents, key=lambda n: n.cost + dist(n.position, new_pos))\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent.cost + dist(best_parent.position, new_pos)\n            best_parent.add_child(new_node)\n\n            # Add node and edge\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire periodically\n            if (len(tree_a) % self.rewire_batch_size) == 0:\n                batch_rewire(tree_a, edges)\n\n            # Attempt direct connection to nearby nodes in other tree for early solution\n            neighbors_b = near_nodes(tree_b, new_pos, r_rewire)\n            connection_made = False\n            for nb in neighbors_b:\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, nb.position) + nb.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_start_tree else nb\n                    best_goal_node = nb if expand_start_tree else new_node\n                    found_solution = True\n                    connection_made = True\n\n            if connection_made:\n                no_improve_counter = 0\n            else:\n                no_improve_counter += 1\n\n            if found_solution and no_improve_counter > self.max_stagnation:\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        if found_solution:\n            final_path = combine_paths(best_start_node, best_goal_node)\n            final_path = progressive_shortcut(final_path)\n            return PlannerResult(True, final_path, nodes, edges)\n\n        # If no full path found, return best partial from start tree closest to goal\n        best_partial_node = None\n        best_partial_dist = float('inf')\n        for node in tree_start:\n            if not node.valid:\n                continue\n            d_to_goal = dist(node.position, goal_pos)\n            if d_to_goal < best_partial_dist:\n                best_partial_dist = d_to_goal\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            partial_path = progressive_shortcut(partial_path)\n            return PlannerResult(False, partial_path, nodes, edges)\n\n        # No path or partial found\n        return PlannerResult(False, [], nodes, edges)\n\n    # Vector ops needed\n    def _cross(self,a,b):\n        ax,ay,az = a\n        bx,by,bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self,v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self,v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
            "objective": 27.9513,
            "time_improvement": -155.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1319.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11870105266571045,
                    "num_nodes_avg": 200.7,
                    "path_length_avg": 150.91862178659736,
                    "smoothness_avg": 0.04204053323890232,
                    "success_improvement": 0.0,
                    "time_improvement": -372.3930856756818,
                    "length_improvement": 17.27911194016732,
                    "smoothness_improvement": 558.0256376679363,
                    "objective_score": -98.56033035026446
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09938943386077881,
                    "num_nodes_avg": 373.8,
                    "path_length_avg": 231.25559523132816,
                    "smoothness_avg": 0.0817196398653705,
                    "success_improvement": 0.0,
                    "time_improvement": 38.16323815154927,
                    "length_improvement": 22.80022598854379,
                    "smoothness_improvement": 2002.7051940134274,
                    "objective_score": 35.142633008658194
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11264376640319824,
                    "num_nodes_avg": 304.0,
                    "path_length_avg": 120.12971077054394,
                    "smoothness_avg": 0.11768585150632557,
                    "success_improvement": 0.0,
                    "time_improvement": -131.83436133723927,
                    "length_improvement": 20.21556606831662,
                    "smoothness_improvement": 1396.9553444945002,
                    "objective_score": -20.43619203770931
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.6,
        "analysis": "1. Summary of key changes:\n   - Introduced batch rewiring with periodic cost and parent updates, improving subtree optimization.\n   - Implemented adaptive dynamic step size based on local node density for finer expansions in dense areas.\n   - Adopted ellipsoidal informed sampling after first solution, focusing samples on promising subsets.\n   - Applied multi-resolution progressive path shortcutting for more effective smoothing and length reduction.\n   - Employed early termination on stagnation to reduce unnecessary computation.\n2. Primary contributors to the performance improvement:\n   - Adaptive step sizing leading to more efficient node expansions and better path refinement.\n   - Batch rewiring reducing redundant and costly rewiring calls while optimizing parents globally.\n   - Focused ellipsoidal informed sampling increasing likelihood of generating better-quality nodes.\n   - More advanced, iterative shortcutting effectively pruning unnecessary waypoints and reducing detours.\n3. Expected mechanism of impact:\n   - Adaptive step sizes reduce overshooting and inefficient node expansions, improving tree density where needed.\n   - Batch rewiring minimizes redundant rewiring overhead yet propagates cost updates effectively, leading to shorter paths.\n   - Informed sampling confines exploration within the ellipsoidal subset determined by current best cost, accelerating convergence to shorter paths.\n   - Progressive shortcutting removes suboptimal detours and small angular variations, directly shortening and smoothing the final solution path."
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "A bidirectional RRT* inspired planner with goal bias sampling, adaptive neighbor radius based on tree size and dimension, incremental rewiring, early stopping immediately after first path found, and final path shortcutting for improved smoothness and length. The algorithm alternately expands start and goal trees, rewires locally to optimize path cost, and efficiently connects trees upon proximity. It enforces strict collision checks for nodes and edges at every addition, respects map bounds, and robustly handles 2D/3D rectangular obstacles under a strict 30-second time limit. Final path extraction merges two parent chains cleanly and applies shortcutting to smooth and shorten the path.",
                "planning_mechanism": "The planner grows two trees alternately from start and goal with goal-biased sampling, chooses parent nodes by minimizing path cost within an adaptive radius, rewires neighbors upon discovery of better costs, attempts incremental connections between trees, and stops early on finding a valid connection. It applies shortcutting to the final path to improve smoothness and length before returning results with all explored nodes and edges.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10  # 10% chance sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback uniform sample without obstacle check\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            # Remove unnecessary waypoints by attempting direct connections skipping intermediate points\n            if len(path) <= 2:\n                return path[:]\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, proceed next node\n                    shortcut_path.append(path[i+1])\n                    i += 1\n            return shortcut_path\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius for neighbor search (approximate RRT* radius)\n            n = len(tree_a)\n            min_radius = self.step_size * 2.5\n            gamma_rrt = 50.0  # tuning constant, increased slightly for larger graphs\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n+1) / (n+1))**(1/dim)), self.step_size * 30))\n\n            # Choose best parent in radius neighbors\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with new_node if better cost found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect to opposing tree within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path, removing duplicate connection point if overlapping\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicate middle point\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Apply shortcutting to smooth path and reduce length\n                smooth_path = shortcut_path(combined_path)\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # Time limit or max_iter reached with no full path\n        # Return best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
                "objective": -37.37284,
                "time_improvement": 65.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1594.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013492751121520995,
                        "num_nodes_avg": 116.9,
                        "path_length_avg": 167.48639160694592,
                        "smoothness_avg": 0.046124220571561826,
                        "success_improvement": 0.0,
                        "time_improvement": 46.30306814127721,
                        "length_improvement": 8.198054768521205,
                        "smoothness_improvement": 621.9442122930357,
                        "objective_score": 21.91947436496106
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023199057579040526,
                        "num_nodes_avg": 285.8,
                        "path_length_avg": 234.67161709331359,
                        "smoothness_avg": 0.11706785284768806,
                        "success_improvement": 0.0,
                        "time_improvement": 85.56632689312731,
                        "length_improvement": 21.659859566275518,
                        "smoothness_improvement": 2912.240174337157,
                        "objective_score": 53.227014679389285
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0182589054107666,
                        "num_nodes_avg": 226.6,
                        "path_length_avg": 120.43817791147322,
                        "smoothness_avg": 0.10596483217621462,
                        "success_improvement": 0.0,
                        "time_improvement": 62.42098600050051,
                        "length_improvement": 20.010696880938188,
                        "smoothness_improvement": 1247.864843771141,
                        "objective_score": 36.972038147568774
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "An incremental single-tree Informed RRT* planner with adaptive, shrinking neighbor radius, accelerated nearest neighbor search using spatial hashing, combined with multi-pass iterative path shortcutting. The algorithm employs goal bias and ellipsoidal informed sampling post first solution to focus search, carefully balances exploration and exploitation, and enforces strict 30-second runtime constraint with immediate best-path return on timeout. It dynamically rewires locally to optimize path cost continuously while efficiently pruning unnecessary computations to minimize planning time.",
                "planning_mechanism": "The planner grows a tree from the start node, uses uniform random sampling initially and switches to ellipsoidal informed sampling after the first solution. Nearest neighbors and rewiring candidates are found efficiently via a spatial grid indexed structure with adaptive cell size. The neighbor search radius shrinks adaptively with the number of nodes to reduce computational overhead. Each new node chooses the parent minimizing cost with feasibility checks, then rewires nearby nodes to reduce their costs. The search terminates early if the goal is reached or time runs out, returning the best path found. A multi-pass shortcutting procedure iteratively improves path smoothness and length by attempting to bypass intermediate points where collision-free edges exist.",
                "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 max_neighbor_radius: float=20.0, min_neighbor_radius: float=2.0,\n                 shortcut_iters: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & boundary check\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Collision check with adaptive resolution (0.5 * step_size)\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling function\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                # No current solution: sample uniform random in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min < 1e-12:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            # Build rotation matrix aligning x-axis to a1\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim ==3:\n                    x_axis = a\n                    # Orthonormal basis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-12:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            r1 = c_best * 0.5\n            val = abs(c_best * c_best - c_min * c_min)\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0001\n            r2 = max(r2, 0.001)\n            radii = [r1] + [r2]*(dim -1)\n\n            while True:\n                # Sample unit ball point\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Spatial grid for neighbor search acceleration\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = dict()  # key: cell tuple to list of nodes\n\n            def _cell_coords(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n            def insert(self, node):\n                c = self._cell_coords(node.position)\n                if c not in self.grid:\n                    self.grid[c] = []\n                self.grid[c].append(node)\n\n            def remove(self, node):\n                c = self._cell_coords(node.position)\n                if c in self.grid and node in self.grid[c]:\n                    self.grid[c].remove(node)\n                    if not self.grid[c]:\n                        del self.grid[c]\n\n            def nearby_nodes(self, pos, radius):\n                cell_r = int(math.ceil(radius / self.cell_size))\n                center_cell = self._cell_coords(pos)\n                candidates = []\n                def rec(dim_idx, prefix):\n                    if dim_idx == self.dim:\n                        c = tuple(prefix)\n                        if c in self.grid:\n                            candidates.extend(self.grid[c])\n                        return\n                    for offset in range(-cell_r, cell_r+1):\n                        recursive_prefix = prefix + [center_cell[dim_idx]+offset]\n                        rec(dim_idx+1, recursive_prefix)\n                rec(0, [])\n                return candidates\n\n        def nearest_node(p):\n            # Use spatial grid for candidates\n            candidate_radius = search_radius * 1.2\n            candidates = grid.nearby_nodes(p, candidate_radius)\n            best = None\n            best_dist = float(\"inf\")\n            for node in candidates:\n                dcur = dist(node.position, p)\n                if dcur < best_dist:\n                    best_dist = dcur\n                    best = node\n            if best is None and nodes:\n                # fallback linear search\n                best = nodes[0]\n                best_dist = dist(best.position, p)\n                for n in nodes[1:]:\n                    dcur = dist(n.position, p)\n                    if dcur < best_dist:\n                        best_dist = dcur\n                        best = n\n            return best, best_dist\n\n        def neighbor_radius(n_count):\n            if n_count <= 1:\n                return self.max_neighbor_radius\n            g_rrt_star = self.max_neighbor_radius\n            r = g_rrt_star * ((math.log(n_count)/n_count) ** (1.0/dim))\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # Initialize tree\n        root = Node(start_pos)\n        nodes.append(root)\n        grid_cell = max(self.step_size * 1.5, 1.0)\n        grid = SpatialGrid(bounds, cell_size=grid_cell)\n        grid.insert(root)\n        best_goal_node = None\n        best_goal_cost = float(\"inf\")\n        success = False\n        search_radius = self.max_neighbor_radius\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if success:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            search_radius = neighbor_radius(n_nodes)\n            nbr_candidates = grid.nearby_nodes(new_pos, search_radius)\n            neighbors = [node for node in nbr_candidates if dist(node.position, new_pos) <= search_radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid.insert(new_node)\n\n            # Rewire neighbors via new node if cheaper and feasible\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    grid.insert(goal_node)\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        best_goal_node = goal_node\n                        success = True\n                    break  # Early termination on goal reached\n\n        # Extract path from best goal node if any\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No goal reached: choose closest node to goal\n            min_dist = float(\"inf\")\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Multi-pass iterative shortcutting for path smoothing\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points[:]\n            shortened = path_points[:]\n            for _ in range(self.shortcut_iters):\n                if len(shortened) < 3:\n                    break\n                made_change = False\n                i = 0\n                while i < len(shortened) - 2:\n                    j = len(shortened) -1\n                    shortcut_done = False\n                    while j > i + 1:\n                        if is_free_edge(shortened[i], shortened[j]):\n                            # remove intermediate points between i and j\n                            shortened = shortened[:i+1] + shortened[j:]\n                            made_change = True\n                            shortcut_done = True\n                            break\n                        j -= 1\n                    if not shortcut_done:\n                        i += 1\n                    # else do not increment i to check again after change\n                if not made_change:\n                    break\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
                "objective": -28.07313,
                "time_improvement": 32.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 2053.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02738652229309082,
                        "num_nodes_avg": 227.4,
                        "path_length_avg": 170.97848126600815,
                        "smoothness_avg": 0.05401776278360369,
                        "success_improvement": 0.0,
                        "time_improvement": -8.989798164580494,
                        "length_improvement": 6.2839850906874535,
                        "smoothness_improvement": 745.4952890127571,
                        "objective_score": 4.80092805010211
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.07412786483764648,
                        "num_nodes_avg": 974.3,
                        "path_length_avg": 250.76320477184095,
                        "smoothness_avg": 0.15370043973610845,
                        "success_improvement": 0.0,
                        "time_improvement": 53.88013648693731,
                        "length_improvement": 16.288024428512955,
                        "smoothness_improvement": 3854.823020362044,
                        "objective_score": 45.210970704999184
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02376887798309326,
                        "num_nodes_avg": 441.3,
                        "path_length_avg": 122.74150903327116,
                        "smoothness_avg": 0.13042050290840068,
                        "success_improvement": 0.0,
                        "time_improvement": 51.0808025790876,
                        "length_improvement": 18.48093402268165,
                        "smoothness_improvement": 1558.9391703547062,
                        "objective_score": 34.2074970391088
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A simplified unidirectional RRT* planner with fixed neighbor radius and goal-biased sampling to guide exploration. The planner grows a single tree from start towards the goal, choosing parents and rewiring neighbors within a constant radius to locally optimize path costs. It performs strict collision checks on nodes and edges, enforces a 30-second planning limit, and applies a single-pass shortcutting step at the end to smooth and shorten the found path. The design emphasizes clarity and generalization while maintaining core RRT* benefits.",
            "planning_mechanism": "The planner grows one tree from start using goal bias to sample near the goal occasionally, extends by fixed step size towards random samples, selects parents minimizing cost within a fixed radius, and rewires neighbors to optimize cost. It terminates early if goal is reached or time expires, then extracts and shortcuts the path before returning results.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1  # 10% goal bias\n        self.neighbor_radius = 15.0   # fixed neighbor radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b):\n            distance = dist(a,b)\n            steps = max(1, int(distance))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortcut.append(path[i+1])\n                    i += 1\n            return shortcut\n\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            x_rand = sample_free()\n            nearest_node = nearest(nodes, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if not is_in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            neighbors = near_nodes(nodes, new_pos, self.neighbor_radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative_cost\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    # Remove old edge if exists\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    nb.parent = new_node\n                    nb.cost = alt_cost\n                    new_node.add_child(nb)\n                    edges.append((new_node, nb))\n\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = new_node\n                    goal_node.cost = new_node.cost + dist(new_node.position, goal_pos)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            path = goal_node.path_from_root()\n            path = shortcut_path(path)\n        else:\n            # No full path, return closest node path to goal\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = closest.path_from_root()\n\n        return PlannerResult(success, path, nodes, edges)",
            "objective": 55.78124,
            "time_improvement": -250.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1261.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05596280097961426,
                    "num_nodes_avg": 297.8,
                    "path_length_avg": 157.62577900413402,
                    "smoothness_avg": 0.04588491103001609,
                    "success_improvement": 0.0,
                    "time_improvement": -122.71445487737303,
                    "length_improvement": 13.602812787528084,
                    "smoothness_improvement": 618.1984982988578,
                    "objective_score": -25.56165629920077
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.27630226612091063,
                    "num_nodes_avg": 984.0,
                    "path_length_avg": 221.16011962648253,
                    "smoothness_avg": 0.07743491533999532,
                    "success_improvement": 0.0,
                    "time_improvement": -71.90597395130513,
                    "length_improvement": 26.17038632759478,
                    "smoothness_improvement": 1892.4561458131923,
                    "objective_score": 3.592720340231292
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3183507680892944,
                    "num_nodes_avg": 671.9,
                    "path_length_avg": 113.35279699081329,
                    "smoothness_avg": 0.10780793826239196,
                    "success_improvement": 0.0,
                    "time_improvement": -555.2040060257222,
                    "length_improvement": 24.716469518857625,
                    "smoothness_improvement": 1271.309017143377,
                    "objective_score": -145.37477501068517
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.0,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a unidirectional RRT* approach instead of bidirectional tree growth.\n   - Fixed neighbor radius for rewiring replaces adaptive shrinking radius from parents.\n   - Goal bias is maintained at 10%, with simpler uniform obstacle-free sampling fallback.\n   - Omission of complex bidirectional tree connection logic reduces overhead.\n   - Simplified nearest and neighbor search without spatial acceleration structures.\n   - Single-pass shortcutting applied only once after path extraction.\n2. Primary contributors to the performance improvement:\n   - Fixed neighbor radius enables more stable and consistent rewiring, improving path length.\n   - Avoiding bidirectional connection attempts reduces redundant computations and costly collision checks.\n   - Simpler sampling strategy reduces overhead and improves incremental expansion efficiency.\n3. Expected mechanism of impact:\n   - More consistent rewiring leads to better local path cost improvements and shorter paths.\n   - Reduced complexity in neighbor search and rewiring lowers computational load, freeing time for deeper tree expansion.\n   - Early termination upon reaching goal with direct edge reduces unnecessary exploration, enhancing path quality."
    }
]