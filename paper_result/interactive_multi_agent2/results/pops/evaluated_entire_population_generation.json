{
    "operator": "m1",
    "algorithm_description": "An advanced bidirectional RRT* with adaptive neighborhood radius, combined with informed elliptical sampling post-first-solution and iterative path shortcutting smoothing to improve planning speed, path length, and smoothness while enforcing strict collision avoidance and a 30-second hard time limit. The planner interleaves growth of two trees, rewires locally with dynamic radius, uses ellipsoidal informed sampling once a solution is found to focus search in promising regions, and performs aggressive path shortcutting to smooth the extracted path before returning.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal, alternately extending them by steering toward samples which are uniformly random initially, and after the first path is found switch to informed ellipsoidal sampling reducing the search space focused on improving the shortest path found. It uses an adaptive rewiring radius that shrinks as the tree grows to balance exploration and exploitation. Whenever trees connect, it updates the best path cost and continues to optimize for a limited budget or until no improvements. After termination (or time limit), the extracted path is aggressively shortcut to reduce unnecessary waypoints and improve smoothness, while maintaining strict collision checks.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float,...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root to this node\n        self.children = []        # list of child nodes\n        self.valid = True         # For collision/traversal status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=600,\n                 max_no_improve=150, improve_tol=1e-6, neighbor_gamma=50.0, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        def clamped(pt):\n            return tuple(min(max(0.0, pt[d]), bounds[d]) for d in range(dim))\n\n        # Utilities for ellipsoidal informed sampling after first solution\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def dist(u, v):\n            return math.dist(u, v)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return clamped(to_p)\n            ratio = self.step_size / d\n            return clamped(tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim)))\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d_):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w) and (y <= py <= y + h):\n                        return True\n            return False\n\n        def is_edge_in_collision(fr, to, resolution=0.5):\n            seg_len = dist(fr, to)\n            steps = max(1, int(seg_len / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[d] + (to[d] - fr[d]) * (i / steps) for d in range(dim))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        # Compute adaptive neighbor radius for rewiring (RRT* radius theory)\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(10.0, self.step_size * 2.0)\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            return max(self.step_size * 2.0, min(max_r, r_theory))\n\n        # Ellipsoidal informed sampler post first solution\n        def informed_sample(c_best):\n            # c_min is euclidean dist between start and goal, fixed\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float(\"inf\") or c_best < c_min:\n                return sample_uniform()\n\n            # Following sampling from an n-dimensional prolate hyperspheroid\n            import numpy as np\n\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return sample_uniform()\n            a1 = a1 / norm_a1\n\n            # Create orthonormal basis with a1 as first vector via SVD trick\n            dim_np = dim\n            I = np.eye(dim_np)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, np.dot(np.diag([1] * (dim_np - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n            # Define lengths\n            L_diags = np.array([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim_np - 1))\n            L = np.diag(L_diags)\n\n            while True:\n                # Sample unit n-ball using Gaussian then normalize\n                x_ball = np.random.normal(0, 1, dim_np)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-10:\n                    continue\n                x_ball = x_ball / norm_x * (random.random() ** (1.0 / dim_np))\n\n                x_rand = np.dot(C, np.dot(L, x_ball)) + center\n                x_rand_clamped = tuple(max(0.0, min(bounds[d], x_rand[d])) for d in range(dim_np))\n                # Validate boundary\n                if all(0.0 <= x_rand[d] <= bounds[d] for d in range(dim_np)):\n                    return x_rand_clamped\n\n        # Initialization of trees\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        found_first_solution = False\n        post_iters = 0\n        no_improve_streak = 0\n\n        start_time = time.monotonic()\n\n        def nearest(tree, query_pos):\n            # Linear search - consider using kd-tree if permitted\n            best = tree[0]\n            best_dist = dist(tree[0].position, query_pos)\n            for node in tree[1:]:\n                d_ = dist(node.position, query_pos)\n                if d_ < best_dist:\n                    best = node\n                    best_dist = d_\n            return best\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            r_sq = radius * radius\n            for n in tree:\n                d_ = dist(n.position, pos)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_with_best_parent(tree, new_pos):\n            n_nodes = len(tree)\n            r = neighbor_radius(n_nodes)\n            neighborhood = near_nodes(tree, new_pos, r)\n\n            candidates = []\n            for node in neighborhood:\n                if not is_edge_in_collision(node.position, new_pos) and not is_in_collision(new_pos):\n                    cost_val = node.cost + dist(node.position, new_pos)\n                    candidates.append((cost_val, node))\n            if not candidates:\n                # fallback: nearest with free edge if any\n                nearest_node = nearest(tree, new_pos)\n                if is_edge_in_collision(nearest_node.position, new_pos) or is_in_collision(new_pos):\n                    return None, []\n                parent_node = nearest_node\n                cost_val = parent_node.cost + dist(parent_node.position, new_pos)\n            else:\n                candidates.sort(key=lambda x: x[0])\n                cost_val, parent_node = candidates[0]\n\n            new_node = Node(new_pos)\n            new_node.parent = parent_node\n            new_node.cost = cost_val\n            parent_node.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n            return new_node, neighborhood\n\n        def rewire(tree, pivot_node, neighbors):\n            r = neighbor_radius(len(tree))\n            for nbr in neighbors:\n                if nbr is pivot_node:\n                    continue\n                if is_edge_in_collision(pivot_node.position, nbr.position):\n                    continue\n                alternative_cost = pivot_node.cost + dist(pivot_node.position, nbr.position)\n                if alternative_cost + 1e-12 < nbr.cost:\n                    # Remove old edge\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        if nbr in nbr.parent.children:\n                            nbr.parent.children.remove(nbr)\n                    # Reassign parent to pivot_node and update cost\n                    nbr.parent = pivot_node\n                    nbr.cost = alternative_cost\n                    pivot_node.children.append(nbr)\n                    edges.append((pivot_node, nbr))\n\n                    # Recursively update descendants cost to maintain correctness\n                    update_costs_downstream(nbr)\n\n        def update_costs_downstream(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    update_costs_downstream(c)\n\n        def try_connect_trees(new_node, other_tree):\n            # Find nearest node in other tree\n            near = nearest(other_tree, new_node.position)\n            if dist(new_node.position, near.position) > self.step_size:\n                # Try stepwise connect with rewiring to approach new_node\n                cur = near\n                prev = None\n                while True:\n                    next_pos = steer(cur.position, new_node.position)\n                    if is_in_collision(next_pos) or is_edge_in_collision(cur.position, next_pos):\n                        break\n                    add_new, neighbors = add_node_with_best_parent(other_tree, next_pos)\n                    if add_new is None:\n                        break\n                    rewire(other_tree, add_new, neighbors)\n                    prev = cur\n                    cur = add_new\n                    # Check if close enough to new_node to connect\n                    if dist(cur.position, new_node.position) <= self.step_size:\n                        if not is_edge_in_collision(cur.position, new_node.position) and new_node.valid:\n                            # Connect by adding a special connecting node (reuse new_node for consistency)\n                            # But don't duplicate new_node, create a liaison node duplicating new_node position\n                            conn_node = Node(new_node.position)\n                            conn_node.cost = cur.cost + dist(cur.position, new_node.position)\n                            conn_node.parent = cur\n                            cur.children.append(conn_node)\n                            other_tree.append(conn_node)\n                            nodes.append(conn_node)\n                            edges.append((cur, conn_node))\n                            return conn_node\n                        break\n                return None\n            else:\n                if not is_edge_in_collision(new_node.position, near.position):\n                    return near\n                else:\n                    return None\n\n        def stitch_path(node_start, node_goal, start_side=True):\n            path_start = node_start.path_from_root() if node_start else []\n            path_goal = node_goal.path_from_root() if node_goal else []\n            if not path_start or not path_goal:\n                return []\n            if path_start[-1] == path_goal[-1]:\n                stitched = path_start + path_goal[-2::-1]\n            else:\n                stitched = path_start + path_goal[::-1]\n            return stitched if start_side else stitched[::-1]\n\n        def path_length(path_pts):\n            total = 0.0\n            for k in range(len(path_pts) - 1):\n                total += dist(path_pts[k], path_pts[k + 1])\n            return total\n\n        def shortcut_path(path):\n            if not path or len(path) < 3:\n                return path\n            max_attempts = 500\n            i = 0\n            path = list(path)\n            while i < max_attempts and len(path) > 2:\n                if len(path) < 3:\n                    break\n                idx1 = random.randint(0, len(path) - 3)\n                idx2 = random.randint(idx1 + 2, len(path) - 1)\n                p1 = path[idx1]\n                p2 = path[idx2]\n                if not is_edge_in_collision(p1, p2):\n                    # Remove waypoints between idx1+1 and idx2-1\n                    del path[idx1 + 1:idx2]\n                i += 1\n            return path\n\n        # Main loop starts here\n        for itr in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                # Time limit hit: return best found path so far\n                break\n\n            # Alternate which tree grows\n            if itr % 2 == 0:\n                active_tree = tree_start\n                other_tree = tree_goal\n                start_side = True\n            else:\n                active_tree = tree_goal\n                other_tree = tree_start\n                start_side = False\n\n            # Sample point: uniform until first solution, then informed ellipsoid sampling\n            if found_first_solution:\n                x_rand = informed_sample(best_cost)\n            else:\n                x_rand = sample_uniform()\n\n            # Nearest in active tree\n            nearest_node = nearest(active_tree, x_rand)\n            new_pos = steer(nearest_node.position, x_rand)\n\n            if not (0.0 <= min(new_pos) <= max(bounds)):\n                # Clamp already done, but double check boundaries not violated\n                continue\n\n            if is_in_collision(new_pos):\n                if found_first_solution:\n                    post_iters += 1\n                    no_improve_streak += 1\n                    if post_iters >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            if is_edge_in_collision(nearest_node.position, new_pos):\n                if found_first_solution:\n                    post_iters += 1\n                    no_improve_streak += 1\n                    if post_iters >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, near_nodes_list = add_node_with_best_parent(active_tree, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_iters += 1\n                    no_improve_streak += 1\n                    if post_iters >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Rewire neighbors\n            rewire(active_tree, new_node, near_nodes_list)\n\n            # Attempt to connect to other tree greedily, with stepwise rewiring\n            connected_node_other = try_connect_trees(new_node, other_tree)\n            if connected_node_other is not None:\n                candidate_path = stitch_path(new_node, connected_node_other, start_side)\n                candidate_cost = path_length(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if post_iters >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iters += 1\n                    no_improve_streak += 1\n                    if post_iters >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_path:\n            # Perform aggressive shortcut smoothing before returning\n            smoothed_path = shortcut_path(best_path)\n            extracted_path = smoothed_path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 137.03592,
    "time_improvement": -410.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1352.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.24670190811157228,
            "num_nodes_avg": 262.9,
            "path_length_avg": 154.21859803303246,
            "smoothness_avg": 0.04783105936904323,
            "success_improvement": -9.999999999999998,
            "time_improvement": -906.4759236833531,
            "length_improvement": 15.470342668026326,
            "smoothness_improvement": 648.6599459333922,
            "objective_score": -309.41727177452316
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.49414193630218506,
            "num_nodes_avg": 584.0,
            "path_length_avg": 225.67938349318064,
            "smoothness_avg": 0.08652970278636692,
            "success_improvement": -9.999999999999998,
            "time_improvement": -176.270122771081,
            "length_improvement": 24.66172596909302,
            "smoothness_improvement": 2126.4715775189493,
            "objective_score": -77.45164336227371
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2705139398574829,
            "num_nodes_avg": 344.3,
            "path_length_avg": 116.87921803066051,
            "smoothness_avg": 0.10852147954206841,
            "success_improvement": 0.0,
            "time_improvement": -146.88465840104095,
            "length_improvement": 22.374388574315994,
            "smoothness_improvement": 1280.3852095527227,
            "objective_score": -24.238838327959073
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a single-tree RRT* variant with parameter tuning focusing on moderate step size and neighbor radius to balance exploration speed and rewiring benefits. It uses a moderate goal-sample rate for faster convergence and restricts neighbor radius proportional to log of number of nodes for scalability. The planner incrementally builds a tree improving path quality by rewiring with collision checks and stops early when the goal is reached.",
    "planning_mechanism": "The planner builds a tree rooted at start, samples points with goal biasing, extends nearest node towards samples by limited step size, finds neighbor nodes within shrinking radius for optimal parent selection, then rewires neighbors through the new node to reduce costs, performs collision checks for nodes and edges, and upon reaching the goal vicinity adds goal node and constructs the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 2.5, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        start_time = time.monotonic()\n\n        root = Node(start_position)\n        nodes = [root]\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > 30.0:\n                # Timeout reached, return best path found so far if any\n                if success_state and extracted_path:\n                    return PlannerResult(success=True, path=extracted_path, nodes=nodes, edges=edges)\n                else:\n                    return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Dynamic neighbor radius: gamma * (log(n)/n)^(1/d), simplified with gamma=20, dimension = d\n            n = len(nodes)\n            d = len(bounds)\n            neighbor_radius = 20.0 * ((math.log(n + 1) / (n + 1)) ** (1 / d))\n\n            new_node = Node(new_pos)\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= neighbor_radius]\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + dist(near.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near.parent, near))\n                    except ValueError:\n                        pass\n                    near.update_parent(new_node, new_cost)\n                    edges.append((new_node, near))\n\n            if dist(new_node.position, goal_position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist(new_node.position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    node = goal_node\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    extracted_path = path[::-1]\n                    break\n\n        if not success_state and len(nodes) > 1:\n            # Extract closest to goal path found so far (heuristic)\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_position))\n            path = []\n            node = closest_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 118.69415,
    "time_improvement": -403.0,
    "length_improvement": 4.0,
    "smoothness_improvement": 0.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05903947353363037,
            "num_nodes_avg": 459.1,
            "path_length_avg": 176.0187311821093,
            "smoothness_avg": 0.006962517864615147,
            "success_improvement": 0.0,
            "time_improvement": -140.8648117616734,
            "length_improvement": 3.521344243801515,
            "smoothness_improvement": 8.978523930763645,
            "objective_score": -40.101744362567295
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.162108063697815,
            "num_nodes_avg": 2014.3,
            "path_length_avg": 299.5297083823483,
            "smoothness_avg": 0.0032896916848287835,
            "success_improvement": 0.0,
            "time_improvement": -549.7237207463438,
            "length_improvement": 0.008361857347543659,
            "smoothness_improvement": -15.353863480209478,
            "objective_score": -164.98886842689566
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6785196304321289,
            "num_nodes_avg": 1236.4,
            "path_length_avg": 138.6526767907181,
            "smoothness_avg": 0.008418685011270775,
            "success_improvement": 0.0,
            "time_improvement": -519.2512196077237,
            "length_improvement": 7.913494006575073,
            "smoothness_improvement": 7.085051940675738,
            "objective_score": -150.99184421866866
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a simplified bidirectional RRT that grows two trees from start and goal by sampling and extending toward random samples. It performs basic nearest neighbor extension and attempts to directly connect trees for early success detection, without rewiring or complex radius search, thus enhancing generalization and reducing overhead.",
    "planning_mechanism": "The planner alternates expanding start and goal trees toward random samples, checking collisions, and tries to connect the two trees when nodes get close; upon connection, it extracts the combined path. The approach favors simplicity and efficiency, reducing computational costs while maintaining bidirectional search benefits.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step_size):\n            dist = distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b):\n            dist = distance(a, b)\n            steps = max(1, int(dist / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_from_start = []\n            cur = node_start\n            while cur:\n                path_from_start.append(cur.position)\n                cur = cur.parent\n            path_from_start.reverse()\n\n            path_from_goal = []\n            cur = node_goal\n            while cur:\n                path_from_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_from_start + path_from_goal\n\n        success = False\n        final_path = []\n\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]  # alternate\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                # Time limit reached: return best path if exists or empty\n                return (\n                    PlannerResult(\n                        success=success,\n                        path=final_path,\n                        nodes=nodes,\n                        edges=edges,\n                    )\n                )\n\n            rand_point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, rand_point)\n                new_pos = steer(nearest_node.position, rand_point, self.step_size)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(\n                    new_pos,\n                    parent=nearest_node,\n                    cost=nearest_node.cost + distance(nearest_node.position, new_pos),\n                )\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Attempt connection with other tree\n                nearest_other = nearest(tree_b, new_node.position)\n                if distance(new_node.position, nearest_other.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, nearest_other.position)) and (not is_in_obstacle(nearest_other.position)):\n                        # Connect trees\n                        connect_node = Node(\n                            nearest_other.position,\n                            parent=new_node,\n                            cost=new_node.cost + distance(new_node.position, nearest_other.position),\n                        )\n                        new_node.add_child(connect_node)\n                        tree_a.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n\n                        # Extract path\n                        final_path = extract_path(connect_node, nearest_other)\n                        success = True\n                        return (\n                            PlannerResult(\n                                success=success,\n                                path=final_path,\n                                nodes=nodes,\n                                edges=edges,\n                            )\n                        )\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": -19.53168,
    "time_improvement": 79.0,
    "length_improvement": -7.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004683661460876465,
            "num_nodes_avg": 105.1,
            "path_length_avg": 199.2864156234268,
            "smoothness_avg": 0.010491750796461101,
            "success_improvement": 0.0,
            "time_improvement": 80.89194959560737,
            "length_improvement": -9.23204229853878,
            "smoothness_improvement": 64.21868316612853,
            "objective_score": 19.049452915389587
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.00905301570892334,
            "num_nodes_avg": 253.6,
            "path_length_avg": 308.92247043484383,
            "smoothness_avg": 0.006639106162288607,
            "success_improvement": 0.0,
            "time_improvement": 94.93854381178593,
            "length_improvement": -3.127212471440868,
            "smoothness_improvement": 70.82898351056647,
            "objective_score": 26.959380578224092
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04277422428131104,
            "num_nodes_avg": 397.6,
            "path_length_avg": 165.66345842234503,
            "smoothness_avg": 0.012783908742165442,
            "success_improvement": 0.0,
            "time_improvement": 60.9620866280512,
            "length_improvement": -10.025781037946944,
            "smoothness_improvement": 62.61037559035646,
            "objective_score": 12.586209243598978
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a straightforward bidirectional RRT that grows two trees from start and goal by iteratively sampling points within the map bounds and extending nearest tree nodes toward those samples. It performs collision checking for nodes and edges, and attempts to connect the two trees when nodes get close, yielding a combined path. Simplified logic avoids rewiring or complex radius searches, prioritizing generalization and computational efficiency.",
    "planning_mechanism": "The planner alternates expansions between the start and goal trees, sampling points, steering from nearest nodes toward samples, and verifying collision-freeness. When two trees approach within step size, it attempts to connect them directly to form a full path from start to goal. Upon success or time limits, it returns the best found path, ensuring a balance of simplicity and bidirectional search benefits.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b):\n            dist = distance(a, b)\n            steps = max(1, int(dist // 1.0))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_start + path_goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + distance(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if distance(new_node.position, nearest_other.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, nearest_other.position)) and (not is_in_obstacle(nearest_other.position)):\n                        connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + distance(new_node.position, nearest_other.position))\n                        new_node.add_child(connect_node)\n                        tree_a.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n\n                        final_path = extract_path(connect_node, nearest_other)\n                        success = True\n                        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
    "objective": -22.67929,
    "time_improvement": 87.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 69.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0033173322677612304,
            "num_nodes_avg": 100.1,
            "path_length_avg": 191.5904129756013,
            "smoothness_avg": 0.011045755921847816,
            "success_improvement": 0.0,
            "time_improvement": 86.46619686115449,
            "length_improvement": -5.013741296299677,
            "smoothness_improvement": 72.89006641981574,
            "objective_score": 23.29606461266562
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.010086965560913087,
            "num_nodes_avg": 239.6,
            "path_length_avg": 300.79732796596943,
            "smoothness_avg": 0.0068730667022610685,
            "success_improvement": 0.0,
            "time_improvement": 94.36047214540207,
            "length_improvement": -0.4148060460718591,
            "smoothness_improvement": 76.84895671902345,
            "objective_score": 28.443502799572624
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.022200679779052733,
            "num_nodes_avg": 323.7,
            "path_length_avg": 170.4079668369994,
            "smoothness_avg": 0.012308892026019971,
            "success_improvement": 0.0,
            "time_improvement": 79.73854047443936,
            "length_improvement": -13.17685761774777,
            "smoothness_improvement": 56.56819802307286,
            "objective_score": 16.29828856179851
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a minimalistic bidirectional RRT that grows two trees from start and goal points by sampling random points within the map bounds and extending nearest nodes towards the samples by a fixed step size. It performs straightforward collision checking for nodes and edges, attempts connection when trees approach, and returns the first found feasible path or best-so-far within a 30-second limit, focusing on simplicity and general applicability.",
    "planning_mechanism": "The planner alternates between the start and goal trees expanding toward random samples. It adds collision-free extensions, tries to connect the two trees when close, and maintains minimal bookkeeping, stopping upon success or time limit with the best found path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b):\n            length = dist(a, b)\n            steps = max(1, int(length // 1.0))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n            path_g = []\n            cur = node_g\n            while cur:\n                path_g.append(cur.position)\n                cur = cur.parent\n            return path_s + path_g\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        # Alternate expansions between start and goal trees\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in trees:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(near.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=near, cost=near.cost + dist(near.position, new_pos))\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((near, new_node))\n\n                near_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, near_other.position) <= self.step_size:\n                    if (not edge_in_obstacle(new_node.position, near_other.position)) and (not in_obstacle(near_other.position)):\n                        connect_node = Node(near_other.position, parent=new_node, cost=new_node.cost + dist(new_node.position, near_other.position))\n                        new_node.add_child(connect_node)\n                        tree_a.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n\n                        final_path = extract_path(connect_node, near_other)\n                        success = True\n                        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
    "objective": -23.80765,
    "time_improvement": 86.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 73.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006884860992431641,
            "num_nodes_avg": 123.9,
            "path_length_avg": 189.79501147625723,
            "smoothness_avg": 0.011094823123562903,
            "success_improvement": 0.0,
            "time_improvement": 71.91166100079273,
            "length_improvement": -4.029653284551833,
            "smoothness_improvement": 73.65807467779078,
            "objective_score": 19.523996702895676
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013615870475769043,
            "num_nodes_avg": 275.9,
            "path_length_avg": 303.55013721857154,
            "smoothness_avg": 0.0068291973288048865,
            "success_improvement": 0.0,
            "time_improvement": 92.38749449980813,
            "length_improvement": -1.333773009811462,
            "smoothness_improvement": 75.72016614216336,
            "objective_score": 27.294585374766374
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.008009886741638184,
            "num_nodes_avg": 212.7,
            "path_length_avg": 159.46843750534575,
            "smoothness_avg": 0.013274552718604653,
            "success_improvement": 0.0,
            "time_improvement": 92.68977357291752,
            "length_improvement": -5.911343120071585,
            "smoothness_improvement": 68.85133075509208,
            "objective_score": 24.604382853607763
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* inspired planner that uses bidirectional tree growth combined with incremental rewiring for path optimization and adaptive step sizing. The planner grows one tree from start and one from goal, alternates extensions toward informed samples biased with goal bias and heuristic pruning, performs collision-checked incremental extensions and connects trees when close. It includes local rewiring to improve path cost and path shortcutting at connection for smoothness. It enforces a 30-second limit, returns the best path found so far, and adapts step size for finer path quality near the goal.",
    "planning_mechanism": "The planner initializes two trees from start and goal, alternately samples from the free space with a bias towards goal and the best path cost estimate. It finds the nearest node, attempts incremental collision-free extensions with adaptive step size, adds nodes and edges, and attempts connection between trees. Upon connection, it extracts the combined path and performs shortcut smoothing. The planner also rewires near nodes within a radius to minimize cost, thus incrementally optimizing the path. The best path found is tracked continuously, returning early if connected or at 30 seconds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Trees: lists of nodes\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d=obs\n                    px,py,pz=pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h=obs\n                    px,py=pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b,resolution=0.5):\n            dist = distance(a,b)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            result = []\n            r2 = radius*radius\n            for node in tree:\n                sqdist = sum((node.position[d] - point[d])**2 for d in range(dim))\n                if sqdist <= r2:\n                    result.append(node)\n            return result\n\n        def path_from_node(node):\n            p = []\n            cur = node\n            while cur:\n                p.append(cur.position)\n                cur = cur.parent\n            return p[::-1]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_start + path_goal\n\n        def can_connect(n1, n2):\n            if is_in_obstacle(n1.position) or is_in_obstacle(n2.position):\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def connect_nodes(parent_node, new_pos):\n            cost = parent_node.cost + distance(parent_node.position,new_pos)\n            return Node(new_pos, parent=parent_node, cost=cost)\n\n        # Adaptive step sizing: smaller near goal regions for smoother paths\n        def adaptive_step_size(pos):\n            dist_goal = distance(pos, goal_position)\n            if dist_goal < self.step_size*5:\n                return max(self.step_size * 0.3, 0.5)\n            return self.step_size\n\n        def try_rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                # Check if going through new_node reduces cost\n                if new_node.cost + distance(new_node.position, neighbor.position) < neighbor.cost:\n                    if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                        old_parent = neighbor.parent\n                        if old_parent:\n                            try:\n                                old_parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_node.cost + distance(new_node.position, neighbor.position)\n                        new_node.add_child(neighbor)\n\n        # Simple path shortcutting for smoothness: try to shortcut segments if collision free\n        def shortcut_path(path, max_attempts=30):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path)<3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1]+path[j:]\n            return path\n\n        def best_informed_sample():\n            # Sample biased to circle/ellipse defined by best_cost from start to goal\n            # If no best_cost, uniform sample in bounds\n            if best_cost == float('inf'):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                c = best_cost\n                start = start_position\n                goal = goal_position\n                center = tuple((start[d]+goal[d])/2 for d in range(dim))\n                radius = c/2\n                # Sample in hyperball with radius c/2 around center\n                while True:\n                    if is_3d:\n                        rx = random.uniform(-radius, radius)\n                        ry = random.uniform(-radius, radius)\n                        rz = random.uniform(-radius, radius)\n                        sample = (center[0]+rx, center[1]+ry, center[2]+rz)\n                    else:\n                        rx = random.uniform(-radius,radius)\n                        ry = random.uniform(-radius,radius)\n                        sample = (center[0]+rx, center[1]+ry)\n                    # Check bounds\n                    inside_bounds = all(0 <= sample[d] <= bounds[d] for d in range(dim))\n                    if not inside_bounds:\n                        continue\n                    # Check if inside ellipse/hyperellipsoid approximate: sum of distances to start and goal <= c\n                    d_sum = distance(sample,start)+distance(sample,goal)\n                    if d_sum <= c:\n                        return sample\n\n        # Alternate tree roles for bidirectional growth\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        current_tree_idx = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            tree_a, tree_b = trees[current_tree_idx]\n            current_tree_idx = 1 - current_tree_idx\n\n            # Sample with goal bias and informed sampling\n            p_goal_bias = 0.1\n            if random.random() < p_goal_bias:\n                sample = goal_position\n            else:\n                sample = best_informed_sample()\n\n            nearest_node = nearest(tree_a, sample)\n            step = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            # Check collisions\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos, resolution=step*0.3):\n                continue\n\n            new_node = connect_nodes(nearest_node, new_pos)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring with adaptive radius\n            radius = min(step*3.0, 5.0)\n            try_rewire(tree_a, new_node, radius)\n\n            # Try connecting to other tree within step size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_other = distance(new_node.position, nearest_other.position)\n            if dist_other <= step:\n                if can_connect(new_node, nearest_other):\n                    conn_node = connect_nodes(new_node, nearest_other.position)\n                    new_node.add_child(conn_node)\n                    tree_a.append(conn_node)\n                    nodes.append(conn_node)\n                    edges.append((new_node, conn_node))\n\n                    # Extract combined path\n                    candidate_path = extract_path(conn_node, nearest_other)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path)-1):\n                        candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                    # Shortcut for smoothness\n                    candidate_path = shortcut_path(candidate_path, max_attempts=50)\n\n                    if candidate_cost < best_cost:\n                        best_path = candidate_path\n                        best_cost = candidate_cost\n                        success = True\n\n                    # Stop early on success\n                    break\n\n        # If no connection found but some path found, finalize best path found\n        if not success and best_path:\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 15.07472,
    "time_improvement": 19.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 788.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012694692611694336,
            "num_nodes_avg": 146.1,
            "path_length_avg": 168.91462752289368,
            "smoothness_avg": 0.01746848328307994,
            "success_improvement": 0.0,
            "time_improvement": 48.2091461309133,
            "length_improvement": 7.415216031143866,
            "smoothness_improvement": 173.4196967987957,
            "objective_score": 19.778971941954286
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05804111957550049,
            "num_nodes_avg": 428.1,
            "path_length_avg": 244.61897285860832,
            "smoothness_avg": 0.05942915144310954,
            "success_improvement": 0.0,
            "time_improvement": 67.54975432587342,
            "length_improvement": 18.339145893059808,
            "smoothness_improvement": 1429.1548717187984,
            "objective_score": 38.4141881921919
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.17409141063690187,
            "num_nodes_avg": 746.9,
            "path_length_avg": 124.36256537690369,
            "smoothness_avg": 0.06769668098651908,
            "success_improvement": -19.999999999999996,
            "time_improvement": -58.88459747505299,
            "length_improvement": 17.404305585648913,
            "smoothness_improvement": 761.0967852993102,
            "objective_score": -103.41731196462999
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm combines bidirectional RRT's rapid exploration with RRT*'s rewiring for path optimality. It grows two trees from start and goal positions, using goal bias sampling and adaptive step sizes. Each new node is connected optimally within a dynamically computed neighbor radius from both trees with rewiring to reduce path cost. The planner attempts connections between the two trees continuously, using efficient collision checks and incremental best path updates. If a path is found, it returns the shortest one; otherwise, it returns the best path found within a 30-second limit.",
    "planning_mechanism": "The planner alternately extends both trees towards randomly sampled points biased towards the goal, rewires both trees locally for cost improvement, and attempts connection between trees after each extension. The neighbor radius shrinks with growing nodes to balance exploration and refinement. Collisions are carefully checked for nodes and edges, and the path is extracted from the best connected nodes, ensuring continuous improvements and early stopping on time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float = 3.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=None):\n            length = dist(a, b)\n            res = resolution if resolution is not None else max(self.step_size / 3.0, 0.5)\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes_start = start_tree\n        nodes_goal = goal_tree\n\n        edges = []\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n\n        # Predefine a function to attempt rewiring for a single tree given a new node and its neighbors\n        def rewire(tree_nodes, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Update edges list\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n        # Alternate expansions between the two trees\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Alternate between start and goal tree expansions\n            for (tree_from, tree_to) in [(nodes_start, nodes_goal), (nodes_goal, nodes_start)]:\n                nearest_node = nearest(tree_from, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Compute neighbor radius (shrinking with number of nodes)\n                n_total = len(tree_from) + len(tree_to)\n                gamma = 18.0\n                radius = gamma * ((math.log(n_total + 1) / (n_total + 1)) ** (1 / dim))\n                radius = min(radius, self.step_size * 5.0)\n\n                new_node = Node(new_pos)\n\n                # Find near neighbors for rewiring\n                neighbors = near_nodes(tree_from, new_pos, radius)\n\n                # Choose best parent among neighbors (including nearest_node)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for neighbor in neighbors:\n                    cost_temp = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_temp < min_cost and not edge_in_obstacle(neighbor.position, new_pos):\n                        min_cost = cost_temp\n                        best_parent = neighbor\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_from.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                rewire(tree_from, new_node, neighbors)\n\n                # Try to connect to other tree\n                neighbors_other = near_nodes(tree_to, new_node.position, radius)\n                for other_node in neighbors_other:\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost >= best_cost:\n                        continue\n                    if edge_in_obstacle(new_node.position, other_node.position):\n                        continue\n\n                    # Connection candidate found for best path\n                    best_cost = total_cost\n                    best_pair = (new_node, other_node)\n                    success = True\n\n            if success:\n                path = extract_path(best_pair[0], best_pair[1])\n                return PlannerResult(success=True, path=path, nodes=nodes_start + nodes_goal, edges=edges)\n\n        # If no success, attempt to find best connectable pair for partial path\n        if not success and len(nodes_start) > 0 and len(nodes_goal) > 0:\n            best_cost = float('inf')\n            best_pair = None\n            for node_s in nodes_start:\n                for node_g in nodes_goal:\n                    d = dist(node_s.position, node_g.position)\n                    if d <= self.step_size * 5.0 and not edge_in_obstacle(node_s.position, node_g.position):\n                        cost = node_s.cost + d + node_g.cost\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pair = (node_s, node_g)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                return PlannerResult(success=False, path=path, nodes=nodes_start + nodes_goal, edges=edges)\n\n        # No path found, return empty\n        return PlannerResult(success=False, path=[], nodes=nodes_start + nodes_goal, edges=edges)",
    "objective": -19.16871,
    "time_improvement": 63.0,
    "length_improvement": 0.0,
    "smoothness_improvement": 12.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011350393295288086,
            "num_nodes_avg": 181.2,
            "path_length_avg": 175.7563540002625,
            "smoothness_avg": 0.008056497518620347,
            "success_improvement": 0.0,
            "time_improvement": 53.69351755934577,
            "length_improvement": 3.6651573348042525,
            "smoothness_improvement": 26.10168113078673,
            "objective_score": 18.437658074340217
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05651669502258301,
            "num_nodes_avg": 600.3,
            "path_length_avg": 305.90146719805944,
            "smoothness_avg": 0.003948977168194402,
            "success_improvement": 0.0,
            "time_improvement": 68.40204579811999,
            "length_improvement": -2.118714636245403,
            "smoothness_improvement": 1.610026870927407,
            "objective_score": 19.25743509204339
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03535096645355225,
            "num_nodes_avg": 464.9,
            "path_length_avg": 151.94349914470192,
            "smoothness_avg": 0.008461426053921733,
            "success_improvement": 0.0,
            "time_improvement": 67.7369259357579,
            "length_improvement": -0.9136373599908727,
            "smoothness_improvement": 7.628714848380325,
            "objective_score": 19.811038938974743
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned and optimized bidirectional RRT that grows two trees from start and goal points, alternating expansions with an adaptive step size and controlled sampling strategy. The step size is reduced to improve path smoothness and avoid overshooting near obstacles. Direct tree-to-tree connection is attempted when nodes are close, improving convergence speed. Collision checks use a finer resolution for edge testing. The planner respects a 30-second limit, returns the best path found so far, and maintains coherent node and edge bookkeeping.",
    "planning_mechanism": "The planner alternates between growing two trees rooted at start and goal points, sampling points within map bounds and extending nearest nodes towards them with a reduced step size (2.5). When trees approach within two step sizes, it tries a direct collision-free connection. A finer edge collision resolution (0.5) is used for better safety near obstacles. The planner stops on success or time limit and returns the best path found, ensuring coherent parent/child links and cost accumulation.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b):\n            length = dist(a, b)\n            steps = max(1, int(length / 0.5))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n            path_g = []\n            cur = node_g\n            while cur:\n                path_g.append(cur.position)\n                cur = cur.parent\n            return path_s + path_g\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success = False\n        final_path = []\n\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            for tree_a, tree_b in trees:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(near.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=near, cost=near.cost + dist(near.position, new_pos))\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((near, new_node))\n\n                near_other = nearest(tree_b, new_node.position)\n                d = dist(new_node.position, near_other.position)\n                if d <= self.step_size * 2:\n                    if not edge_in_obstacle(new_node.position, near_other.position) and not in_obstacle(near_other.position):\n                        connect_node = Node(near_other.position, parent=new_node, cost=new_node.cost + d)\n                        new_node.add_child(connect_node)\n                        tree_a.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((new_node, connect_node))\n\n                        final_path = extract_path(connect_node, near_other)\n                        success = True\n                        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n        if not success and nodes:\n            # Attempt to return best partial path by connecting closest nodes between trees if possible\n            best_d = float('inf')\n            best_pair = None\n            for n_start in start_tree:\n                near_goal = nearest(goal_tree, n_start.position)\n                d = dist(n_start.position, near_goal.position)\n                if d < best_d and d <= self.step_size * 2:\n                    if (not edge_in_obstacle(n_start.position, near_goal.position)) and (not in_obstacle(n_start.position)) and (not in_obstacle(near_goal.position)):\n                        best_d = d\n                        best_pair = (n_start, near_goal)\n            if best_pair:\n                n_s, n_g = best_pair\n                connect_node = Node(n_g.position, parent=n_s, cost=n_s.cost + best_d)\n                n_s.add_child(connect_node)\n                nodes.append(connect_node)\n                edges.append((n_s, connect_node))\n                final_path = extract_path(connect_node, n_g)\n                success = True\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
    "objective": -12.85743,
    "time_improvement": 50.0,
    "length_improvement": -3.0,
    "smoothness_improvement": -16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009255647659301758,
            "num_nodes_avg": 178.6,
            "path_length_avg": 189.8719599856193,
            "smoothness_avg": 0.005385850250737869,
            "success_improvement": 0.0,
            "time_improvement": 62.23950354299499,
            "length_improvement": -4.0718299818603425,
            "smoothness_improvement": -15.69974801493893,
            "objective_score": 16.150254333707597
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03980169296264648,
            "num_nodes_avg": 546.6,
            "path_length_avg": 306.1207701679267,
            "smoothness_avg": 0.003276832494539678,
            "success_improvement": 0.0,
            "time_improvement": 77.74724670491685,
            "length_improvement": -2.1919242798730916,
            "smoothness_improvement": -15.684739708448555,
            "objective_score": 21.930595745008958
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09977760314941406,
            "num_nodes_avg": 754.6,
            "path_length_avg": 155.86832299977567,
            "smoothness_avg": 0.00663940081174757,
            "success_improvement": 0.0,
            "time_improvement": 8.937929473817062,
            "length_improvement": -3.520318484502573,
            "smoothness_improvement": -15.54731174416123,
            "objective_score": 0.49145119272276866
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This improved bidirectional RRT planner employs adaptive step size and variable edge resolution to balance exploration speed, collision checking efficiency, and path quality. It alternates tree expansions from start and goal nodes, attempts direct tree connections when close enough, and dynamically adjusts step size based on distance to samples and target nodes to reduce overshooting and improve smoothness. Edge collision checks use finer resolution near obstacles and coarser resolution otherwise to save computation. The planner enforces a strict 30-second time limit and always returns the best path found so far.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal, sampling random points within map bounds. For each sampled point, it finds the nearest node in the current tree and chooses an adaptive step size proportional to distance to that sample. It steers toward the sample, verifies node and edge collision with adaptive resolution, and adds the new node if valid. It then attempts to connect the new node directly to the other tree if within twice its adaptive step size, again verifying collisions. The process alternates expansions between start and goal trees until a connection is found or time expires. On completion or timeout, it extracts and returns the concatenated path corresponding to the best connection found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, base_step_size: float = 3.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size  # max stepping distance\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b):\n            length = dist(a, b)\n            # Adaptive resolution: finer steps if edge shorter or near obstacles\n            res = 0.3\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            # simple linear search nearest\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_pair = None\n        best_cost = float('inf')\n        final_path = []\n        success = False\n\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        tree_index = 0\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample random within bounds\n            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            tree_a, tree_b = trees[tree_index]\n            tree_index = (tree_index + 1) % 2\n\n            nearest_node = nearest(tree_a, sample)\n            dist_to_sample = dist(nearest_node.position, sample)\n            # Adaptive step size capped by base step size, but smaller near sample\n            step_size = min(self.base_step_size, max(0.5, dist_to_sample))\n\n            new_pos = steer(nearest_node.position, sample, step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_to_other = dist(new_node.position, nearest_other.position)\n            connect_step = min(self.base_step_size, max(0.5, dist_to_other))\n\n            if dist_to_other <= connect_step * 2:\n                if not edge_in_obstacle(new_node.position, nearest_other.position) and not in_obstacle(nearest_other.position):\n                    connect_cost = new_node.cost + dist_to_other\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=connect_cost)\n                    new_node.add_child(connect_node)\n                    tree_a.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    total_cost = connect_node.cost + nearest_other.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pair = (connect_node, nearest_other)\n                        final_path = extract_path(connect_node, nearest_other)\n                        success = True\n                        # Optionally break early on first connection found to save time\n                        break\n\n        if not success and nodes:\n            # Attempt to connect closest nodes between trees for best partial path\n            best_d = float('inf')\n            best_nstart = None\n            best_ngoal = None\n            for n_start in start_tree:\n                near_goal = nearest(goal_tree, n_start.position)\n                d = dist(n_start.position, near_goal.position)\n                if d < best_d and d <= self.base_step_size * 2:\n                    if (not edge_in_obstacle(n_start.position, near_goal.position)) and (not in_obstacle(n_start.position)) and (not in_obstacle(near_goal.position)):\n                        best_d = d\n                        best_nstart = n_start\n                        best_ngoal = near_goal\n            if best_nstart and best_ngoal:\n                connect_node = Node(best_ngoal.position, parent=best_nstart, cost=best_nstart.cost + best_d)\n                best_nstart.add_child(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_nstart, connect_node))\n                final_path = extract_path(connect_node, best_ngoal)\n                success = True\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
    "objective": -13.66924,
    "time_improvement": 55.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 0.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012370109558105469,
            "num_nodes_avg": 178.1,
            "path_length_avg": 193.64237773510916,
            "smoothness_avg": 0.006397071261114967,
            "success_improvement": 0.0,
            "time_improvement": 49.53335570502439,
            "length_improvement": -6.138455696448307,
            "smoothness_improvement": 0.12805669903331204,
            "objective_score": 11.177573577133499
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030281686782836915,
            "num_nodes_avg": 451.7,
            "path_length_avg": 304.71444192077183,
            "smoothness_avg": 0.00396146710650493,
            "success_improvement": 0.0,
            "time_improvement": 83.06979288620077,
            "length_improvement": -1.7224514320586148,
            "smoothness_improvement": 1.9314019797962168,
            "objective_score": 23.897124016524042
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07541787624359131,
            "num_nodes_avg": 651.4,
            "path_length_avg": 159.12489348823217,
            "smoothness_avg": 0.007735566271738778,
            "success_improvement": 0.0,
            "time_improvement": 31.169844247063583,
            "length_improvement": -5.683177541712899,
            "smoothness_improvement": -1.6041680035909172,
            "objective_score": 5.93302590907338
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "Simplified single-tree RRT* with adaptive radius rewiring and goal biasing for efficient path improvement and early stopping. The planner builds a tree rooted at start, samples with goal bias, extends nearest node towards samples within a fixed step, rewires neighbors using a shrinking radius based on the nodes count, applying collision checks for validity. Upon reaching near the goal, the goal node is connected. Planning stops early if time limit reached or after finding a solution, returning the best path found.",
    "planning_mechanism": "The planner incrementally samples points using random or goal biasing, extends the tree by steering from nearest node towards sample, finds neighbors within a dynamically shrinking radius, selects the best parent by lowest cost avoiding collisions, rewires neighbors to reduce path cost, and attempts goal connection when close. Collision checks are applied on both nodes and edges before insertion. The algorithm stops when time expires or after successfully connecting goal, returning best discovered path information.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=3.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n\n        success = False\n        best_path = []\n        best_goal_node = None\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(frm, to, resolution=1.0):\n            distance = dist(frm, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                pt = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            n_nodes = len(nodes)\n            gamma = 20.0\n            radius = gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near_nodes:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Check goal connection\n            if dist(new_node.position, goal) <= self.step_size:\n                if not in_obstacle(goal) and not edge_in_obstacle(new_node.position, goal):\n                    goal_node = Node(goal)\n                    goal_cost = new_node.cost + dist(new_node.position, goal)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    best_path = path[::-1]\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if not success and nodes:\n            # Extract path to closest node to goal found\n            closest = min(nodes, key=lambda n: dist(n.position, goal))\n            path = []\n            curr = closest\n            while curr:\n                path.append(curr.position)\n                curr = curr.parent\n            best_path = path[::-1]\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 59.53833,
    "time_improvement": -205.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030140113830566407,
            "num_nodes_avg": 330.0,
            "path_length_avg": 173.44819131925448,
            "smoothness_avg": 0.008097486243342734,
            "success_improvement": 0.0,
            "time_improvement": -22.96337365101135,
            "length_improvement": 4.930297875442979,
            "smoothness_improvement": 26.743243681132444,
            "objective_score": -3.797117151631955
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5926714897155761,
            "num_nodes_avg": 1542.0,
            "path_length_avg": 295.65291792303844,
            "smoothness_avg": 0.004008643126314778,
            "success_improvement": 0.0,
            "time_improvement": -231.35707212372787,
            "length_improvement": 1.3025460998914242,
            "smoothness_improvement": 3.1452749490172267,
            "objective_score": -68.60986760243843
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5032036066055298,
            "num_nodes_avg": 1083.3,
            "path_length_avg": 146.85104038837926,
            "smoothness_avg": 0.00920710304953717,
            "success_improvement": 0.0,
            "time_improvement": -359.24897840173725,
            "length_improvement": 2.468531269131249,
            "smoothness_improvement": 17.11367119245822,
            "objective_score": -106.20800640308012
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "Simplified RRT* planner with goal biasing and fixed neighbor radius, focusing on clarity and robustness while maintaining adaptive rewiring and collision checking. The planner grows a single tree by sampling free space or goal with a probability, extending the nearest node toward samples with fixed step size, rewiring neighbors within a constant radius to improve path costs, and connecting to the goal when reachable. Planning stops when time limit or iteration budget is reached, returning the best path found.",
    "planning_mechanism": "The algorithm samples points with goal bias, extends the nearest tree node toward the sample using a fixed step size after collision checks, selects the best parent among nearby nodes using a constant radius for rewiring, rewires neighbors to reduce costs while ensuring collision-free edges, and attempts goal connection when within step size. It records nodes and edges coherently and returns success status and best path upon completion or timeout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(frm, to, resolution=1.0):\n            distance = dist(frm, to)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                pt = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n        success = False\n        best_path = []\n        best_goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= self.neighbor_radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for node in near_nodes:\n                cost_through_node = node.cost + dist(node.position, new_pos)\n                if cost_through_node < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt goal connection\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Extract path\n                    path = []\n                    cur = goal_node\n                    while cur:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    best_path = path[::-1]\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        if not success and nodes:\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = []\n            cur = closest\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            best_path = path[::-1]\n\n        return PlannerResult(success, best_path, nodes, edges)",
    "objective": 29.61958,
    "time_improvement": -135.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 170.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05429637432098389,
            "num_nodes_avg": 331.4,
            "path_length_avg": 170.81499121557914,
            "smoothness_avg": 0.015409562646928202,
            "success_improvement": 0.0,
            "time_improvement": -121.51427167987083,
            "length_improvement": 6.373596577993225,
            "smoothness_improvement": 141.19311782529843,
            "objective_score": -31.92415796803882
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.20041484832763673,
            "num_nodes_avg": 962.2,
            "path_length_avg": 232.45333671582574,
            "smoothness_avg": 0.011532766289412601,
            "success_improvement": 0.0,
            "time_improvement": -12.0500623099593,
            "length_improvement": 22.400385405941385,
            "smoothness_improvement": 196.74638334238452,
            "objective_score": 10.808944467288965
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4073710203170776,
            "num_nodes_avg": 898.2,
            "path_length_avg": 118.12973147669986,
            "smoothness_avg": 0.021483807722149535,
            "success_improvement": 0.0,
            "time_improvement": -271.7873291352426,
            "length_improvement": 21.543857086507963,
            "smoothness_improvement": 173.2724484560096,
            "objective_score": -67.74352224638795
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional RRT* inspired algorithm with adaptive neighbor search radius scaling, dynamic rewiring to improve path quality during incremental growth, and time-constrained exploration enforcing collision-free constraints and early stopping with best path returned. The planner grows a single tree from start, incrementally steering towards random samples, rewiring neighborhoods using a theoretically justified radius, and attempts direct connections to goal when in range to ensure path convergence.",
    "planning_mechanism": "A single tree rooted at the start expands by sampling random collision-free states within bounds. For each sampled point, the nearest tree node is steered towards it with a fixed step size. New nodes are connected to the lowest-cost neighbor found in a dynamically computed radius to improve path cost. Local rewiring is performed to optimize path quality. When a new node is close enough to the goal, the planner attempts to connect directly to the goal, validating collision-free edges and updating the best path if improved. The planning proceeds within a hard 30-second time limit, returning the best feasible path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Optional[Node]\n        self.cost = cost                 # Path cost to this node\n        self.children: List[\"Node\"] = [] # List of child nodes\n\n    def add_child(self, child: \"Node\") -> None:\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = 50.0  # scaling for radius\n        self.max_radius = 60.0      # upper bound on neighbor radius\n        self.TIME_LIMIT = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node: Optional[Node] = None\n        best_cost = math.inf\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.TIME_LIMIT:\n                break\n\n            rnd = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(nodes, rnd)\n            new_pos = self._steer(nearest.position, rnd)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near(nodes, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Find best parent from neighbors\n            for n in neighbors:\n                cost_through_n = n.cost + self._dist(n.position, new_pos)\n                if cost_through_n < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_n\n                    min_parent = n\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for n in neighbors:\n                if n == min_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire: remove old edge\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    # Add new parent-child edge\n                    new_node.add_child(n)\n                    n.cost = cost_through_new\n                    edges.append((new_node, n))\n\n            # Attempt connection to goal if close enough\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n\n            # Early stopping if solution found and time remains enough\n            if best_goal_node is not None and (time.monotonic() - start_time < self.TIME_LIMIT * 0.9):\n                # Optionally could prioritize more improvement, but here break early\n                break\n\n        success = (best_goal_node is not None)\n        extracted_path = best_goal_node.path_from_root() if success else []\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        attempts = 0\n        max_attempts = 1000\n        while attempts < max_attempts:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            attempts += 1\n        # fallback in case of dense obstacles\n        return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n    def _nearest(self, nodes: List[Node], point: Tuple[float, ...]) -> Node:\n        return min(nodes, key=lambda n: self._dist(n.position, point))\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n        return math.dist(a, b)\n\n    def _near(self, nodes: List[Node], position: Tuple[float, ...], bounds=None) -> List[Node]:\n        n = max(len(nodes), 1)\n        d = len(position)\n        scale = max(1.0, sum(bounds)/d if bounds is not None else 1.0)\n        radius_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = min(radius_theory * 1.1 + scale*0.01, self.max_radius)\n        # Return neighbors within radius\n        return [node for node in nodes if self._dist(node.position, position) <= radius]\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d, resolution=1.0) -> bool:\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 38.52299,
    "time_improvement": -160.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 169.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.13740262985229493,
            "num_nodes_avg": 736.0,
            "path_length_avg": 165.6389692973759,
            "smoothness_avg": 0.015194004275516227,
            "success_improvement": 0.0,
            "time_improvement": -460.56493383329206,
            "length_improvement": 9.210656210676376,
            "smoothness_improvement": 137.81916122020544,
            "objective_score": -131.95399061748077
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.24984548091888428,
            "num_nodes_avg": 999.7,
            "path_length_avg": 247.3606138345263,
            "smoothness_avg": 0.008081446728356607,
            "success_improvement": 0.0,
            "time_improvement": -39.686265456022404,
            "length_improvement": 17.423907221538386,
            "smoothness_improvement": 107.9414451514142,
            "objective_score": -0.9118280781266204
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08575613498687744,
            "num_nodes_avg": 455.1,
            "path_length_avg": 126.80630865397129,
            "smoothness_avg": 0.02842277145458693,
            "success_improvement": 0.0,
            "time_improvement": 21.73462815563979,
            "length_improvement": 15.781287659570605,
            "smoothness_improvement": 261.5355549515882,
            "objective_score": 17.296838817192242
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid RRT* inspired bidirectional planner with adaptive sampling, rewiring, and efficient nearest neighbor searches to improve path smoothness, length, and planning time. Both trees grow alternately with local rewiring inside a dynamically computed neighbor radius for smoother and shorter paths. The algorithm respects map bounds and obstacles with fine collision checking and stops early on time limit or attaining a good path.",
    "planning_mechanism": "The planner grows two trees bidirectionally in the map space with adaptive random sampling restricted near the connection frontier. Each new sample extends the nearest node within a fixed step, then rewires local neighbors to improve cost. When nodes from opposite trees come close enough, it attempts a direct collision-free connection. The resulting connected path is extracted by concatenating paths from both trees. The planner maintains efficient node/edge bookkeeping, enforces strict collision checks, adapts neighbor search radius proportional to tree size, and respects a hard 30-second limit, returning the best feasible solution found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, step):\n            d = dist(frm, to)\n            if d <= step:\n                return to\n            ratio = step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def neighbors(tree, new_pos, radius):\n            result = []\n            r_sq = radius * radius\n            for node in tree:\n                if (node.position[0] - new_pos[0]) ** 2 + (node.position[1] - new_pos[1]) ** 2 > r_sq:\n                    continue\n                if dim == 3:\n                    dx = node.position[0] - new_pos[0]\n                    dy = node.position[1] - new_pos[1]\n                    dz = node.position[2] - new_pos[2]\n                    if dx*dx + dy*dy + dz*dz > r_sq:\n                        continue\n                result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal\n\n        def try_connect_nodes(n1, tree2):\n            near_other = nearest(tree2, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d <= self.step_size * 1.7:\n                if (not edge_in_obstacle(n1.position, near_other.position)) and (not in_obstacle(near_other.position)):\n                    connect_node = Node(near_other.position, parent=n1, cost=n1.cost + d)\n                    n1.add_child(connect_node)\n                    return connect_node, near_other\n            return None, None\n\n        def rewire(tree, new_node, radius):\n            nbrs = neighbors(tree, new_node.position, radius)\n            improved = False\n            for nbr in nbrs:\n                if nbr == new_node.parent:\n                    continue\n                if edge_in_obstacle(new_node.position, nbr.position):\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new < nbr.cost:\n                    # Rewire nbr to new_node\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = cost_thru_new\n                    new_node.add_child(nbr)\n                    improved = True\n            return improved\n\n        success = False\n        final_path = []\n\n        # For balanced iteration between trees\n        trees = [(nodes_start, nodes_goal), (nodes_goal, nodes_start)]\n\n        iteration = 0\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        while iteration < self.max_iter and (time.monotonic() - start_time) < TIME_LIMIT:\n            iteration += 1\n\n            # Adaptive sampling: bias sampling near start or goal with some probability to encourage connectivity\n            if random.random() < 0.1:\n                sample = start_pos if iteration % 2 == 0 else goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            for tree_a, tree_b in trees:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Dynamic rewiring radius per RRT* theory: gamma * (log(n)/n)^(1/d)*unit ball volume^-1/d approximated,\n                # Here simplified to gamma * (log(n)/n)^{1/d} scaled by step_size\n                n_nodes = len(tree_a)\n                gamma = 30.0  # constant factor, tuned\n                if n_nodes > 1:\n                    radius = min(self.step_size * 10.0, gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n                    radius = max(radius, self.step_size * 1.5)\n                else:\n                    radius = self.step_size * 5.0\n\n                # Try choosing better parent among neighbors (RRT* style)\n                nbrs = neighbors(tree_a, new_pos, radius)\n                best_parent = nearest_node\n                best_cost_parent = new_cost\n                for nbr in nbrs:\n                    if edge_in_obstacle(nbr.position, new_pos):\n                        continue\n                    potential_cost = nbr.cost + dist(nbr.position, new_pos)\n                    if potential_cost < best_cost_parent:\n                        best_cost_parent = potential_cost\n                        best_parent = nbr\n                if best_parent != nearest_node:\n                    # Reassign parent and costs\n                    new_node.parent.children.remove(new_node)\n                    new_node.parent = best_parent\n                    best_parent.add_child(new_node)\n                    new_node.cost = best_cost_parent\n                    edges.pop()  # remove last edge before append corrected\n                    edges.append((best_parent, new_node))\n\n                # Rewire neighbors to new_node if improves cost\n                rewire(tree_a, new_node, radius)\n\n                # Try to connect trees\n                connect_result, near_other_node = try_connect_nodes(new_node, tree_b)\n                if connect_result and near_other_node:\n                    tree_a.append(connect_result)\n                    all_nodes.append(connect_result)\n                    edges.append((new_node, connect_result))\n                    # Extract full path\n                    final_path = extract_path(connect_result, near_other_node)\n                    success = True\n                    return PlannerResult(success=success, path=final_path, nodes=all_nodes, edges=edges)\n\n                # Keep track of best partial connection for time-limited return\n                near_other = nearest(tree_b, new_node.position)\n                d = dist(new_node.position, near_other.position)\n                if d < best_cost and not edge_in_obstacle(new_node.position, near_other.position) and not in_obstacle(near_other.position):\n                    best_cost = d\n                    best_pair = (new_node, near_other)\n\n            # Terminate early if path found with good cost and sufficient iteration\n            if success:\n                break\n\n        # If no solution found, return best partial path if exists\n        if not success and best_pair[0] and best_pair[1]:\n            connect_node = Node(best_pair[1].position, parent=best_pair[0], cost=best_pair[0].cost + dist(best_pair[0].position, best_pair[1].position))\n            best_pair[0].add_child(connect_node)\n            all_nodes.append(connect_node)\n            edges.append((best_pair[0], connect_node))\n            final_path = extract_path(connect_node, best_pair[1])\n            success = True\n\n        return PlannerResult(success=success, path=final_path, nodes=all_nodes, edges=edges)",
    "objective": 58.31033,
    "time_improvement": -211.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 102.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1257535696029663,
            "num_nodes_avg": 193.2,
            "path_length_avg": 173.1832459440851,
            "smoothness_avg": 0.016161426955683032,
            "success_improvement": 0.0,
            "time_improvement": -413.03997237582496,
            "length_improvement": 5.075518633901454,
            "smoothness_improvement": 152.9614269567903,
            "objective_score": -120.10187339762265
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2152959108352661,
            "num_nodes_avg": 499.7,
            "path_length_avg": 276.0790055435315,
            "smoothness_avg": 0.0061100893942989416,
            "success_improvement": 0.0,
            "time_improvement": -20.369924810827396,
            "length_improvement": 7.83688145599992,
            "smoothness_improvement": 57.217001034815986,
            "objective_score": -1.1227635644741871
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3291374683380127,
            "num_nodes_avg": 460.8,
            "path_length_avg": 135.70339621308108,
            "smoothness_avg": 0.015511481540126739,
            "success_improvement": 0.0,
            "time_improvement": -200.38744576499107,
            "length_improvement": 9.872265736592215,
            "smoothness_improvement": 97.30490025194264,
            "objective_score": -53.706349786282274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid planner combining bidirectional RRT with adaptive informed sampling and local rewiring to balance exploration efficiency and path optimality. The algorithm grows two trees from start and goal positions alternately, attempts to connect them frequently, and after first solution found, it restricts sampling to an informed ellipsoidal region around the best path and performs local rewiring to optimize the path incrementally while respecting a 30-second hard time limit.",
    "planning_mechanism": "The planner alternates growing start and goal trees toward sampled points, connecting them when possible; once a feasible path is found, sampling switches to an adaptive prolate hyperspheroid to focus search; local rewiring among nearby nodes reduces path cost; the search stops upon timeout or no further improvement, outputting the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, post_opt_iters=1000, max_no_improve=200, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard limit\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree.copy()\n        nodes.extend(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        best_cost = float(\"inf\")\n        best_start_node = None\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        c_best = float(\"inf\")\n        found_first_solution = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            distance = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if distance <= step:\n                return to_pos\n            ratio = step / distance\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def nearest_multiple(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Informed sampling inside ellipsoid after first solution is found\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sampling\n            if c_best == float(\"inf\"):\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n            # Sample in prolate hyperspheroid\n            # Use rejection sampling without numpy\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            a1 = tuple(g - s for s, g in zip(start, goal))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case, sample uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            e1 = tuple(x / length_a1 for x in a1)  # unit vector along start->goal\n\n            # Compute axes lengths\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n                r = (r1, r_side, r_side)\n            else:\n                # Higher dim not supported explicitly, fallback uniform\n                while True:\n                    samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(samp):\n                        return samp\n\n            for _ in range(200):\n                # Sample point from unit n-ball by normal deviate then normalize then scale by random radius\n                # Generate random point on unit n-ball surface\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                # Scale radius by random^(1/dim)\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * r[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate x_scaled so that its first axis aligns with e1\n                # Rotation matrix that maps unit vector (1,0,...0) to e1:\n                # This can be done by constructing an orthonormal basis with e1\n                # For performance, we'll implement a quick formula:\n                v = [0]*dim\n                v[0] = 1.0\n                u = e1\n                dot = sum(v[i]*u[i] for i in range(dim))\n                # If they are parallel (dot = 1 or -1), no rotation needed or invert axis\n                if abs(dot - 1.0) < 1e-10:\n                    # No rotation needed, x_rot = x_scaled\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    # Opposite vectors, invert first axis\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    # Rodrigues' rotation formula for axis k = cross(v,u)\n                    # k = v cross u\n                    k = [0]*dim\n                    if dim == 2:\n                        k[0] = 0\n                        k[1] = 0\n                        # We approximate here: since dim==2\n                        # Cross product scalar k = v0*u1 - v1*u0\n                        k_scalar = v[0]*u[1] - v[1]*u[0]\n                        # Rotation axis k for 2D is perpendicular to the plane, cross = scalar\n                        # Rodrigues rotation reduces to 2D rotation by angle theta = acos(dot)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0 = x_scaled[0]\n                        x1 = x_scaled[1]\n                        # Rotation matrix in 2D:\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        # Cross product k = v x u\n                        k = [v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            # Rodrigues rotation formula: v_rot = v*cos_a + (k x v)*sin_a + k*(k\u00b7v)*(1 - cos_a)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0,0,0]\n                            for i in range(dim):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        # For higher dims: skip rotation, fallback uniform\n                        x_rot = x_scaled\n                # Translate by center\n                x_final = tuple(center[i] + x_rot[i] for i in range(dim))\n                # Check in bounds and not obstacle\n                if all(0 <= x_final[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(x_final):\n                        return x_final\n            # Fallback uniform random if informed sampling fails\n            while True:\n                samp = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(samp):\n                    return samp\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            # Avoid duplicate connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        iter_count = 0\n        extend_start_to_goal = True  # Alternate growth direction\n        no_improve_streak = 0\n        post_opt_count = 0\n\n        radius_constant = 30.0 * (math.log(self.max_iter + 1) / (iter_count + 1)) ** (1.0 / dim) if dim>0 else 30.0\n        neighbor_radius = lambda n: min(radius_constant * ((math.log(len(start_tree) + len(goal_tree) + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 5.0) if dim>0 else self.step_size*5.0\n\n        while iter_count < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Choose which tree to expand\n            tree_a = start_tree if extend_start_to_goal else goal_tree\n            tree_b = goal_tree if extend_start_to_goal else start_tree\n            root_start_nodes = start_tree\n            root_goal_nodes = goal_tree\n\n            # Sample point: informed sampling after first solution, else uniform\n            if found_first_solution:\n                x_rand = informed_sample(start, goal, c_best, c_min)\n            else:\n                # Uniform sampling\n                for _ in range(50):\n                    x_sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(x_sample):\n                        x_rand = x_sample\n                        break\n                else:\n                    x_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback if unlucky\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_count += 1\n                extend_start_to_goal = not extend_start_to_goal\n                continue\n\n            # Create new node with cost update\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Select best parent among near nodes in tree_a including nearest_node\n            radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_nodes = nearest_multiple(tree_a, new_pos, radius)\n\n            best_parent = nearest_node\n            min_cost = new_cost\n            for candidate in near_nodes:\n                if candidate == nearest_node:\n                    continue\n                potential_cost = candidate.cost + dist(candidate.position, new_pos)\n                if potential_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(candidate.position, new_pos):\n                        best_parent = candidate\n                        min_cost = potential_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node in tree_a\n            for near_node in near_nodes:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Rewire near_node to new_node as parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect new_node to the other tree tree_b nodes near new_node within radius\n            connect_radius = max(self.step_size * 2.5, 30.0 * ((math.log(len(tree_b) + 1) / (len(tree_b) + 1)) ** (1.0 / dim))) if dim>0 else self.step_size*2.5\n            near_opposite = nearest_multiple(tree_b, new_node.position, connect_radius)\n\n            connection_made = False\n            for other_node in near_opposite:\n                if not is_edge_in_obstacle(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        # Connect two trees by creating a new connection edge (virtual)\n                        best_cost = total_cost\n                        success_state = True\n                        best_start_node = new_node if extend_start_to_goal else other_node\n                        best_goal_node = other_node if extend_start_to_goal else new_node\n                        c_best = best_cost\n                        found_first_solution = True\n                        extracted_path = extract_path(best_start_node, best_goal_node)\n                        no_improve_streak = 0\n                        connection_made = True\n                        # Do not break here to find possibly better connection\n            if not connection_made and found_first_solution:\n                no_improve_streak += 1\n                post_opt_count += 1\n                if post_opt_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n\n            iter_count += 1\n            extend_start_to_goal = not extend_start_to_goal\n\n            # Enforce hard time limit safety\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n        if success_state and best_start_node and best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            # No solution found: try to return path closest to goal in start_tree or a partial path\n            best_node = None\n            min_goal_dist = float(\"inf\")\n            for node in start_tree:\n                d = dist(node.position, goal)\n                if d < min_goal_dist and node.valid:\n                    min_goal_dist = d\n                    best_node = node\n            if best_node:\n                partial_path = best_node.path_from_root()\n                return PlannerResult(\n                    success=False,\n                    path=partial_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n            # else empty path\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
    "objective": 295.47898,
    "time_improvement": -1033.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 256.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5913747787475586,
            "num_nodes_avg": 758.0,
            "path_length_avg": 151.24830260208697,
            "smoothness_avg": 0.02058925094950933,
            "success_improvement": 0.0,
            "time_improvement": -2253.4867656993647,
            "length_improvement": 17.098408661070636,
            "smoothness_improvement": 222.2664876338706,
            "objective_score": -664.6756520749976
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5786649703979492,
            "num_nodes_avg": 1014.8,
            "path_length_avg": 223.7199642443417,
            "smoothness_avg": 0.014513759212874738,
            "success_improvement": 0.0,
            "time_improvement": -260.02587573506054,
            "length_improvement": 25.31583651311142,
            "smoothness_improvement": 273.4494783854807,
            "objective_score": -61.451013420723896
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.333528995513916,
            "num_nodes_avg": 730.1,
            "path_length_avg": 114.76663509983318,
            "smoothness_avg": 0.029182927141035354,
            "success_improvement": 0.0,
            "time_improvement": -586.442615791514,
            "length_improvement": 23.777465566582624,
            "smoothness_improvement": 271.20467917435593,
            "objective_score": -160.31028200163283
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with adaptive rewiring and efficient neighbor search to produce asymptotically optimal, smooth, and shorter paths with reduced computational overhead. It incrementally samples free space, extends the tree toward random samples respecting obstacle constraints, selects optimal parents among nearby nodes, rewires neighbors to minimize cost, and stops early upon finding a valid path within a time limit.",
    "planning_mechanism": "The planner grows a single tree from start towards goal by iteratively sampling collision-free points and steering incrementally toward them. For each new node, it finds neighbors inside an adaptively scaled radius, picks the best parent minimizing path cost, adds the node, and rewires neighbors if rewiring reduces costs. The search stops when the goal is reachable within a step size and the path is extracted. Using incremental rewiring and efficient local radius scaling improves path smoothness and length. A hard time limit caps search effort, returning best found path if time runs out.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=30.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        tree = []\n\n        start_node = Node(start_pos, None, 0.0)\n        tree.append(start_node)\n        nodes.append(start_node)\n\n        success = False\n        best_goal_node = None\n        dist_goal = self._distance(start_pos, goal_pos)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            nearest = self._nearest(tree, rand)\n            new_pos = self._steer(nearest.position, rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            # Choose best parent\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # rewire nb to new_node\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n            # Check if goal can be connected\n            dist_to_goal = self._distance(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        new_node.add_child(goal_node)\n                        tree.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        best_goal_node = goal_node\n                        break\n\n        path = best_goal_node.path_from_root() if success else []\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, pos, bounds):\n        n = len(tree)\n        d = len(pos)\n        if n <= 1:\n            return [tree[0]] if tree else []\n        scale = max(1.0, sum(bounds)/d)\n        radius_theory = self.gamma * ((math.log(n)/n) ** (1/d))\n        radius = min(self.max_radius, max(self.step_size*2, radius_theory * 0.5 + scale * 0.01))\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 342.00038,
    "time_improvement": -1177.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 182.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.6105502605438232,
            "num_nodes_avg": 637.2,
            "path_length_avg": 162.9455247662491,
            "smoothness_avg": 0.016476664782690602,
            "success_improvement": 0.0,
            "time_improvement": -2329.7991893184353,
            "length_improvement": 10.686975838546811,
            "smoothness_improvement": 157.89558349935672,
            "objective_score": -691.7380933749057
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.039361596107483,
            "num_nodes_avg": 1016.0,
            "path_length_avg": 234.23682240353804,
            "smoothness_avg": 0.01151286991709365,
            "success_improvement": 0.0,
            "time_improvement": -546.6558163813695,
            "length_improvement": 21.805006548593838,
            "smoothness_improvement": 196.23443535184018,
            "objective_score": -149.93256880849535
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.36697118282318114,
            "num_nodes_avg": 582.3,
            "path_length_avg": 122.24375464796276,
            "smoothness_avg": 0.02301578213338744,
            "success_improvement": 0.0,
            "time_improvement": -655.2706422693615,
            "length_improvement": 18.81151878488672,
            "smoothness_improvement": 192.7590498883673,
            "objective_score": -184.3304861604346
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified unidirectional RRT* planner with efficient neighbor selection, rewiring, and early stopping to improve generalization, reduce complexity, and maintain robust path quality and smoothness within a 30-second time limit. It grows a single tree from start to goal by sampling collision-free points, steering incrementally, selecting the lowest-cost parent from neighbors within a dynamically scaled radius, rewiring neighbors to reduce cost, and terminating once a path to the goal is found.",
    "planning_mechanism": "The planner builds a tree rooted at the start by iteratively sampling free points, steering toward them with fixed step size, choosing optimal parent nodes from a radius-based neighborhood, applying local rewiring to minimize path costs, and returning the best path within a time budget or when the goal neighborhood is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, neighbor_gamma: float=50.0, goal_radius: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_radius = max(bounds)*0.3\n        min_radius = max(10.0, self.step_size*2.0)\n\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: return start (rare)\n            return start_pos\n\n        def neighbor_radius(num_nodes):\n            if num_nodes < 2:\n                return min_radius\n            r = self.neighbor_gamma * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            return min(max_radius, max(min_radius, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            return [n for n in tree_nodes if math.dist(n.position, pos) <= radius]\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached, return best found\n                return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            r = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, r)\n            # Select best parent in neighbors with valid edge\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                # fallback to nearest_node if edge free\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost possible via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Rewire: update parent and cost, edges lists\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            # Check if goal reached\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path)-1):\n                    cost += math.dist(path[i], path[i+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 680.61663,
    "time_improvement": -2311.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 212.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.2963702201843261,
            "num_nodes_avg": 798.3,
            "path_length_avg": 153.40311775845035,
            "smoothness_avg": 0.01867232962112822,
            "success_improvement": 0.0,
            "time_improvement": -5059.148253011591,
            "length_improvement": 15.917320328636658,
            "smoothness_improvement": 192.26250618341595,
            "objective_score": -1507.2327711753783
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0090357303619384,
            "num_nodes_avg": 1116.8,
            "path_length_avg": 232.92130464304964,
            "smoothness_avg": 0.011711985498954181,
            "success_improvement": 0.0,
            "time_improvement": -527.788083010616,
            "length_improvement": 22.244164242124114,
            "smoothness_improvement": 201.3578226902683,
            "objective_score": -143.983137244459
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7028919219970703,
            "num_nodes_avg": 837.6,
            "path_length_avg": 120.10951944487313,
            "smoothness_avg": 0.0270341704816116,
            "success_improvement": 0.0,
            "time_improvement": -1346.6357529453908,
            "length_improvement": 20.22897618541956,
            "smoothness_improvement": 243.8726530712041,
            "objective_score": -390.63397690700947
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid adaptive RRT* planner integrating dynamic informed sampling, incremental rewiring with adaptive neighborhood radius, and early stopping based on path quality and time limit to efficiently generate smooth, short paths. The algorithm grows a single tree from start to goal, uses heuristic-guided sampling within an informed prolate hyperspheroid after a first solution is found, incrementally rewires neighboring nodes for path cost improvement and smoothness, and respects a hard 30-second planning time cap while always ensuring obstacle-free nodes and edges.",
    "planning_mechanism": "A single RRT* tree rooted at the start expands by sampling free space points, steering with fixed step size, and connecting nodes avoiding collisions. Upon first solution to the goal, sampling is restricted to an informed ellipsoidal region to focus search on improving path quality. Rewiring is performed within an adaptively scaled radius, recalculating parents of nearby nodes if more optimal connections are found. Early termination occurs if the time limit is reached or path improvement stalls. Path extraction follows parent links from the best goal node found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cost to arrive at this node from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.improve_tol = 1e-5\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = math.dist(start_pos, goal_pos) + 1e-6  # c_min baseline\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200  # stop after no improvement streak\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            # If no valid solution yet, uniform sample in bounds\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            # Ellipsoidal informed sampling in prolate hyperspheroid\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                # Degenerate case fallback to uniform\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2,0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                # fallback\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            attempts = 0\n            while attempts < 200:\n                # Sample point in unit n-ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n                # Rotation: align first axis to e1\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        # Higher dim no rotation\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            # fallback uniform\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            # naive linear search\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for iteration in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best_now = best_cost if found_solution else float('inf')\n            sample = informed_sample(c_best_now, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Determine radius for neighbors (theoretical for RRT*)\n            gamma_rrt_star = 30.0\n            radius = min(gamma_rrt_star * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1.0 / dim)), self.step_size * 15.0)\n            radius = max(radius, self.step_size)\n\n            near_nodes_list = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent in near nodes including nearest node\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for near_nd in near_nodes_list:\n                if near_nd == nearest_nd:\n                    continue\n                cost_to_new = near_nd.cost + dist(near_nd.position, new_pos)\n                if cost_to_new + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_parent_cost = cost_to_new\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if routing via new_node improves cost\n            for near_nd in near_nodes_list:\n                if near_nd == best_parent or near_nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        # Rewire near_nd parent to new_node\n                        if near_nd.parent:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            if near_nd in near_nd.parent.children:\n                                near_nd.parent.children.remove(near_nd)\n                        near_nd.parent = new_node\n                        near_nd.cost = alt_cost\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            # Check if new_node close enough to goal to connect\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n            # Track improvements or no improvement\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        path = []\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            # Fallback: closest node to goal in tree\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 143.08918,
    "time_improvement": -500.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 73.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.15224921703338623,
            "num_nodes_avg": 866.9,
            "path_length_avg": 169.0294006259298,
            "smoothness_avg": 0.010714219749564683,
            "success_improvement": 0.0,
            "time_improvement": -505.9042932724056,
            "length_improvement": 7.352307074673563,
            "smoothness_improvement": 67.70080538126352,
            "objective_score": -147.02139971001122
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4202205896377563,
            "num_nodes_avg": 1270.0,
            "path_length_avg": 260.6344910421428,
            "smoothness_avg": 0.006124877639116277,
            "success_improvement": 0.0,
            "time_improvement": -161.44711279515343,
            "length_improvement": 12.992704942264869,
            "smoothness_improvement": 57.59751322550824,
            "objective_score": -40.35052330705956
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.45266926288604736,
            "num_nodes_avg": 1011.5,
            "path_length_avg": 132.66717919553537,
            "smoothness_avg": 0.015179209348280523,
            "success_improvement": 0.0,
            "time_improvement": -831.6475541358143,
            "length_improvement": 11.888776510528306,
            "smoothness_improvement": 93.07842249744077,
            "objective_score": -241.8956082219401
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid single-tree RRT* planner with adaptive informed sampling and dynamic rewiring radius, implementing early stopping on time limit and solution stagnation to generate efficient, robust, and smooth paths. The planner grows one tree from start, restricts sampling to an informed ellipsoidal subset after the first solution, and rewires neighbors within a theoretically derived radius to minimize path cost while ensuring collision-free nodes and edges. It also tracks the best path and stops when improvements plateau or time limit is reached.",
    "planning_mechanism": "A single RRT* tree rooted at start iteratively samples feasible points, steers towards them with a fixed step size, and connects nodes if collision free. After the first solution, sampling is biased within an ellipsoid shaped by the current best path cost to goal. Each new node selects the lowest-cost parent within an adaptive neighborhood, followed by rewiring neighbors to update cost and parents when beneficial. The planner stops if a time limit or stagnation threshold is reached and returns the best found path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n                # Rotation of first axis to e1\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            c_best_now = best_cost if found_solution else float('inf')\n            sample = informed_sample(c_best_now, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            cost_to_new = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n\n            # Adaptive neighbor radius (from RRT* theory)\n            gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ( (math.prod(bounds) / math.pi ** (dim/2)) ** (1/dim) )\n            radius = min(gamma_rrt_star * ((math.log(len(nodes)+1) / (len(nodes)+1)) ** (1/dim)), self.step_size*20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent to minimize cost\n            best_parent = nearest_nd\n            best_parent_cost = cost_to_new\n            for nnode in near:\n                c_candidate = nnode.cost + dist(nnode.position, new_pos)\n                if c_candidate + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nnode.position, new_pos):\n                        best_parent = nnode\n                        best_parent_cost = c_candidate\n\n            new_node = Node(new_pos)\n            new_node.cost = best_parent_cost\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nnode in near:\n                if nnode == best_parent or nnode == new_node:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nnode.position)\n                if cost_via_new + self.improve_tol < nnode.cost:\n                    if not is_edge_in_obstacle(new_node.position, nnode.position):\n                        if nnode.parent:\n                            try:\n                                edges.remove((nnode.parent, nnode))\n                            except ValueError:\n                                pass\n                            if nnode in nnode.parent.children:\n                                nnode.parent.children.remove(nnode)\n                        nnode.parent = new_node\n                        nnode.cost = cost_via_new\n                        new_node.add_child(nnode)\n                        edges.append((new_node, nnode))\n\n            # Try connecting to goal if close enough\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            # fallback: path to closest node\n            if nodes:\n                closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n                path = path_to_root(closest_node)\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 257.56996,
    "time_improvement": -909.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 301.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.4373145580291748,
            "num_nodes_avg": 1002.3,
            "path_length_avg": 151.07054252215133,
            "smoothness_avg": 0.0236199372445812,
            "success_improvement": 0.0,
            "time_improvement": -1640.3752438496745,
            "length_improvement": 17.195841777672076,
            "smoothness_improvement": 269.7033093923715,
            "objective_score": -480.4465515413372
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7815186023712158,
            "num_nodes_avg": 1373.1,
            "path_length_avg": 222.11429982871505,
            "smoothness_avg": 0.014854219353823398,
            "success_improvement": 0.0,
            "time_improvement": -386.23458065630086,
            "length_improvement": 25.851853511535257,
            "smoothness_improvement": 282.20976303561724,
            "objective_score": -98.948213274791
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3884615898132324,
            "num_nodes_avg": 883.1,
            "path_length_avg": 113.48823850962461,
            "smoothness_avg": 0.03552079119676564,
            "success_improvement": 0.0,
            "time_improvement": -699.500473519699,
            "length_improvement": 24.626515711095205,
            "smoothness_improvement": 351.82184215078297,
            "objective_score": -193.31512341849864
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm enhances bidirectional path planning by combining fast tree connections with adaptive rewiring and informed sampling. It employs a priority-expand strategy, dynamically updating a k-d tree for efficient nearest neighbor search, and limits search within an ellipsoidal informed subset after initial solution detection. The planner performs meticulous collision checking and gradual rewiring to optimize path smoothness, length, and planning efficiency, halting early upon convergence or time expiration.",
    "planning_mechanism": "The method grows two RRT* trees alternately from start and goal with adaptive radius rewiring and efficient nearest neighbor search using a k-d tree. It attempts to greedily connect the trees at each iteration, switching to informed ellipsoidal sampling after first feasible path discovery to focus search near the optimum. Each new node selects the best parent from nearby nodes, rewires neighbors to reduce costs, and updates the best path when connections form. The algorithm stops after no improvement for a threshold number of iterations or a hard time limit (30s), returning the best solution found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position            # (x,y) or (x,y,z)\n        self.parent = parent                # type: Node or None\n        self.cost = cost                    # path cost from root\n        self.children: List[Node] = []\n        self.valid = True                   # for obstacle validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, max_no_improve: int=120, post_opt_iters: int=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        max_bound = max(bounds)\n\n        # Initialize nodes and trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Parameters for radius calculation\n        gamma_rrt_star = 50.0\n        radius_max = max_bound * 0.25\n        radius_min = max(5.0, self.step_size * 2.0)\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return radius_min\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes)**(1.0/dim))\n            return max(radius_min, min(radius_max, r))\n\n        # Efficient distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check point bounds\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Steering with fixed step size limiting\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        # Collision checks\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest neighbor search (linear brute-force)\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            rn = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if d_sq <= r_sq:\n                    rn.append(node)\n            return rn\n\n        # Best parent selection with collision check\n        def choose_best_parent(tree, new_pos):\n            r = neighbor_radius(len(tree))\n            nbrs = near_nodes(tree, new_pos, r)\n            candidates = [n for n in nbrs if not is_edge_in_obstacle(n.position, new_pos)]\n            if not candidates:\n                # fallback to nearest if nbrs empty or all invalid\n                n_near = nearest(tree, new_pos)\n                if not is_edge_in_obstacle(n_near.position, new_pos):\n                    candidates = [n_near]\n                else:\n                    return None, []\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        # Rewiring neighbors for improved paths\n        def try_rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if is_edge_in_obstacle(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Update tree structure\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        # Path cost utility\n        def path_cost(pth):\n            c = 0.0\n            for i in range(len(pth)-1):\n                c += dist(pth[i], pth[i+1])\n            return c\n\n        # Stitch paths from meeting nodes\n        def stitch_paths(node_a, node_b, a_from_start):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                full = path_a + path_b[-2::-1]\n            else:\n                full = path_a + path_b[::-1]\n            return full if a_from_start else full[::-1]\n\n        # Informed sampling within ellipsoid\n        def sample_informed(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(max(val, 0.0))/2.0\n\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = tuple((goal[d]-start[d])/c_min for d in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_rest)\n            else:\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_rest, r_rest)\n\n            u = self._sample_unit_ball(dim)\n            mapped = [center[d] + sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # clamp in bounds\n            return tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n\n        # Helpers for cross product etc\n        def cross(a,b):\n            ax,ay,az = a\n            bx,by,bz = b\n            return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n        def norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def normalize(v):\n            n = norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x/n for x in v)\n\n        self._cross = cross\n        self._norm = norm\n        self._normalize = normalize\n        self._sample_unit_ball = lambda dim: self.__sample_unit_ball(dim)\n\n        best_path = []\n        best_cost = float(\"inf\")\n        c_min = dist(start_pos, goal_pos)\n\n        found_first_solution = False\n        no_improve_streak = 0\n        post_opt_progress = 0\n\n        start_time = time.monotonic()\n\n        use_informed = False\n\n        # Alternate growing start vs goal trees\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:  # Hard limit 30s\n                break\n\n            if it % 2 == 0:\n                tree_grow = tree_start\n                tree_other = tree_goal\n                a_from_start = True\n            else:\n                tree_grow = tree_goal\n                tree_other = tree_start\n                a_from_start = False\n\n            # Sample point\n            if use_informed:\n                sample = sample_informed(start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Skip sample if in obstacle or out of bounds\n            if (not within_bounds(sample)) or is_in_obstacle(sample):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Steer and check edge collision\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            # Add new node with best parent and rewiring\n            new_node, neighbors = choose_best_parent(tree_grow, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_opt_progress += 1\n                    no_improve_streak += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            try_rewire(new_node, neighbors)\n\n            # Attempt greedy connect from other tree toward new_node\n            other_nearest = nearest(tree_other, new_node.position)\n            current = other_nearest\n            connected_node = None\n\n            while True:\n                step_toward = steer(current.position, new_node.position)\n                if (not within_bounds(step_toward)) or is_in_obstacle(step_toward):\n                    break\n                if is_edge_in_obstacle(current.position, step_toward):\n                    break\n\n                add_node, add_neighbors = choose_best_parent(tree_other, step_toward)\n                if add_node is None:\n                    break\n                try_rewire(add_node, add_neighbors)\n                current = add_node\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(current.position, new_node.position):\n                        # Connect final edge and create connecting node at new_node.position\n                        connect_node = Node(new_node.position, parent=None,\n                                            cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(connect_node)\n                        tree_other.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((current, connect_node))\n                        connected_node = connect_node\n                    break\n\n            # If connected, update best path and check stopping criteria\n            if connected_node is not None:\n                candidate_path = stitch_paths(new_node, connected_node, a_from_start)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-8 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    no_improve_streak = 0\n                    found_first_solution = True\n                    post_opt_progress = 0\n                    use_informed = True\n                    success_state = True\n                else:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n\n                if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    no_improve_streak += 1\n                    post_opt_progress += 1\n                    if post_opt_progress >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_first_solution,\n            path=best_path if found_first_solution else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def __sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0,1.0) for _ in range(dim)]\n            nrm = math.sqrt(sum(x*x for x in v))\n            if nrm > 1e-12:\n                v = [x/nrm for x in v]\n                r = random.random() ** (1.0/dim)\n                return tuple(v[i]*r for i in range(dim))",
    "objective": 195.68712,
    "time_improvement": -581.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 337.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.34295485019683836,
            "num_nodes_avg": 421.0,
            "path_length_avg": 155.62829807014288,
            "smoothness_avg": 0.028551389198008637,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1264.8531019196757,
            "length_improvement": 14.697663739559538,
            "smoothness_improvement": 346.8912412828284,
            "objective_score": -418.9028761257528
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.23502867221832274,
            "num_nodes_avg": 408.8,
            "path_length_avg": 250.5134008933939,
            "smoothness_avg": 0.014713884276228101,
            "success_improvement": -9.999999999999998,
            "time_improvement": -46.226932451188915,
            "length_improvement": 16.371416153344544,
            "smoothness_improvement": 278.59884040981956,
            "objective_score": -52.65223584130084
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2584476709365845,
            "num_nodes_avg": 391.6,
            "path_length_avg": 120.11505060702589,
            "smoothness_avg": 0.03826177341249338,
            "success_improvement": 0.0,
            "time_improvement": -431.91625816392127,
            "length_improvement": 20.225302650883332,
            "smoothness_improvement": 386.68693361657796,
            "objective_score": -115.50626119056348
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
    "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
    "objective": 5.46059,
    "time_improvement": -53.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 293.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06232309341430664,
            "num_nodes_avg": 267.2,
            "path_length_avg": 168.2463107739374,
            "smoothness_avg": 0.02259680420437422,
            "success_improvement": 0.0,
            "time_improvement": -148.0264306480139,
            "length_improvement": 7.781531031403382,
            "smoothness_improvement": 253.68905554417486,
            "objective_score": -38.47056529784127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08523426055908204,
            "num_nodes_avg": 568.0,
            "path_length_avg": 241.3226903680994,
            "smoothness_avg": 0.016808760155440354,
            "success_improvement": 0.0,
            "time_improvement": 46.970110737287854,
            "length_improvement": 19.439539866622514,
            "smoothness_improvement": 332.5015056600573,
            "objective_score": 27.41726466946015
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07625963687896728,
            "num_nodes_avg": 483.4,
            "path_length_avg": 124.7326333683994,
            "smoothness_avg": 0.03084680379066026,
            "success_improvement": 0.0,
            "time_improvement": -56.951465457596676,
            "length_improvement": 17.15852404644154,
            "smoothness_improvement": 292.3690673429857,
            "objective_score": -5.328479872699152
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
    "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 34.24822,
    "time_improvement": -158.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 287.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05595297813415527,
            "num_nodes_avg": 282.7,
            "path_length_avg": 160.14345768443917,
            "smoothness_avg": 0.020991279248420664,
            "success_improvement": 0.0,
            "time_improvement": -122.67536302290098,
            "length_improvement": 12.22283320768113,
            "smoothness_improvement": 228.55910353025726,
            "objective_score": -28.326113464610327
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.23264851570129394,
            "num_nodes_avg": 948.8,
            "path_length_avg": 225.03802962507376,
            "smoothness_avg": 0.017004339084283518,
            "success_improvement": 0.0,
            "time_improvement": -44.746079145276,
            "length_improvement": 24.875828350614626,
            "smoothness_improvement": 337.5338923690004,
            "objective_score": 3.189342728630977
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.19719173908233642,
            "num_nodes_avg": 505.7,
            "path_length_avg": 118.75610965494363,
            "smoothness_avg": 0.030953946710724024,
            "success_improvement": 0.0,
            "time_improvement": -305.8442144725285,
            "length_improvement": 21.127846525442067,
            "smoothness_improvement": 293.73191737772913,
            "objective_score": -77.60789683960466
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping. The planner dynamically adjusts neighbor search radius based on the number of nodes to balance exploration and exploitation, incorporates goal bias with a higher sampling rate for faster convergence, and performs incremental rewiring using efficient neighbor queries. Collision checks are optimized with adaptive edge resolution, and the planner terminates immediately once the goal is connected, ensuring reduced planning time with high-quality, smooth paths.",
    "planning_mechanism": "The algorithm incrementally grows a single tree from start, sampling randomly with goal bias, and steering toward samples with fixed step size. It dynamically computes neighbors within an adaptive radius proportional to log(n)/n for better rewiring efficiency. For each new node, the best parent minimizing cost and verified for collision is chosen, followed by local rewiring to improve path cost and smoothness. Early termination upon reaching the goal with collision-free connection guarantees fast runtime and high success rates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        final_path = []\n\n        # To accelerate nearest neighbor queries, store positions separately\n        positions = [root.position]\n\n        # Adaptive neighbor radius: r = gamma * (log(n)/n)^{1/d} with gamma tuned for good rewiring\n        # Gamma chosen as 30.0 for moderate neighbor count\n        gamma = 30.0\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return gamma\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 20)\n\n        # Optimized collision checking resolution based on step_size and distance\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size/2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Main loop\n        for iter_id in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Time limit reached, break with best path if any\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search (linear, as no k-d tree available)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision from nearest_node to new_pos\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius search\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Choose best parent minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improving cost\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list carefully\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if goal can connect directly\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n\n                    # Backtrack path\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success but nodes exist, extract path from best node near goal\n        if not success and len(nodes) > 1:\n            # Find node closest to goal\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                # Extract path backwards\n                path = []\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 24.4788,
    "time_improvement": -89.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 112.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015737581253051757,
            "num_nodes_avg": 191.3,
            "path_length_avg": 179.56403283207513,
            "smoothness_avg": 0.01421437809371725,
            "success_improvement": 0.0,
            "time_improvement": 37.36934591357285,
            "length_improvement": 1.5781082305555436,
            "smoothness_improvement": 122.48588418274917,
            "objective_score": 12.770098133318925
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14423696994781493,
            "num_nodes_avg": 916.7,
            "path_length_avg": 303.4419163034794,
            "smoothness_avg": 0.007145793076982586,
            "success_improvement": 0.0,
            "time_improvement": 10.260610067476575,
            "length_improvement": -1.2976457533873764,
            "smoothness_improvement": 83.86640277747577,
            "objective_score": 2.7189275820979253
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.20188889503479004,
            "num_nodes_avg": 778.9,
            "path_length_avg": 137.83772884194133,
            "smoothness_avg": 0.01816319064757809,
            "success_improvement": 0.0,
            "time_improvement": -315.51152394832013,
            "length_improvement": 8.454743630501442,
            "smoothness_improvement": 131.03444436991745,
            "objective_score": -88.92543878434559
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
    "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 18.33169,
    "time_improvement": -104.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 277.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03312251567840576,
            "num_nodes_avg": 199.7,
            "path_length_avg": 163.67692862769394,
            "smoothness_avg": 0.020726203772078875,
            "success_improvement": 0.0,
            "time_improvement": -31.81725886398311,
            "length_improvement": 10.28608179225304,
            "smoothness_improvement": 224.41009670489822,
            "objective_score": -2.251478100318617
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2541221618652344,
            "num_nodes_avg": 968.5,
            "path_length_avg": 223.78483919358527,
            "smoothness_avg": 0.016494501307333334,
            "success_improvement": 0.0,
            "time_improvement": -58.106259320137475,
            "length_improvement": 25.29417938773204,
            "smoothness_improvement": 324.4153991467646,
            "objective_score": -0.633293167668195
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15669703483581543,
            "num_nodes_avg": 482.5,
            "path_length_avg": 117.3805344167902,
            "smoothness_avg": 0.030113844927462913,
            "success_improvement": 0.0,
            "time_improvement": -222.5012635370204,
            "length_improvement": 22.04143810076968,
            "smoothness_improvement": 283.0458847045111,
            "objective_score": -52.11028677712176
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An adaptive single-tree RRT* planner utilizing dynamic fixed-radius rewiring, informed sampling after first solution, goal biasing, and early termination upon stable path quality or time limit. It incrementally builds a tree from start to goal, refines parent-child connections locally to improve path cost and smoothness, and efficiently rejects invalid samples and edges to speed planning and yield shorter, smoother paths within a 30-second hard runtime limit.",
    "planning_mechanism": "The planner starts from the start node and samples within bounds or an ellipsoidal informed region after the first feasible path is found. Candidates are steered toward samples under a fixed step size, checked for collision, and connected to the tree using best-parent selection within a fixed rewire radius. Nodes near the newly added node are rewired if a lower-cost connection is possible. Upon connecting near the goal, a goal node is added, updating the best path. The process early stops if improvement stalls or the time limit is exceeded. The final path is extracted by backtracking parent links from the best goal node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1,p2,resolution=1.0):\n            length = dist(p1,p2)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                axes = (r1,r2)\n            elif dim ==3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                axes = (r1,r_side,r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi/norm_x for xi in x_raw]\n                radius = random.random()**(1.0/dim)\n                x_scaled = [radius*axes[i]*x_unit[i] for i in range(dim)]\n\n                # rotation aligning first axis\n                v = [1.0]+[0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot-1.0)<1e-10:\n                    x_rot = x_scaled\n                elif abs(dot+1.0)<1e-10:\n                    x_rot = [-x_scaled[0]]+x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i]+x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, pt):\n            return min(nodes_list, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            res = [n for n in nodes_list if dist(n.position, pt)<=radius]\n            return res\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            cost_limit = best_cost if found_solution else float('inf')\n            sample = informed_sample(cost_limit, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            gamma = 50.0\n            radius = min(gamma * ((math.log(len(nodes)+1)/(len(nodes)+1))**(1.0/dim)), self.step_size*15.0)\n            radius = max(radius, self.step_size)\n\n            nearlist = near_nodes(nodes, new_pos, radius)\n\n            # Best parent selection\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for nd in nearlist:\n                if nd == nearest_nd:\n                    continue\n                c_to_new = nd.cost + dist(nd.position, new_pos)\n                if c_to_new + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nd.position, new_pos):\n                        best_parent = nd\n                        best_parent_cost = c_to_new\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nd in nearlist:\n                if nd == best_parent or nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nd.position)\n                if alt_cost + self.improve_tol < nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, nd.position):\n                        if nd.parent:\n                            try:\n                                edges.remove((nd.parent, nd))\n                            except ValueError:\n                                pass\n                            if nd in nd.parent.children:\n                                nd.parent.children.remove(nd)\n                        new_node.add_child(nd)\n                        nd.cost = alt_cost\n                        edges.append((new_node, nd))\n\n            # Check connection to goal\n            if dist(new_node.position, goal_pos) <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            path = path_to_root(best_goal_node)\n        else:\n            closest_to_goal = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = path_to_root(closest_to_goal)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 152.61119,
    "time_improvement": -540.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 117.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.15092802047729492,
            "num_nodes_avg": 863.8,
            "path_length_avg": 162.36859365892434,
            "smoothness_avg": 0.015110008485613719,
            "success_improvement": 0.0,
            "time_improvement": -500.6463439627754,
            "length_improvement": 11.003200920529931,
            "smoothness_improvement": 136.504444708454,
            "objective_score": -142.9094604129724
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6118797302246094,
            "num_nodes_avg": 1405.4,
            "path_length_avg": 248.68606999022057,
            "smoothness_avg": 0.00659233808573544,
            "success_improvement": 0.0,
            "time_improvement": -280.69098180792236,
            "length_improvement": 16.98143180562754,
            "smoothness_improvement": 69.62560721516955,
            "objective_score": -73.67030742292432
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.45596287250518797,
            "num_nodes_avg": 955.8,
            "path_length_avg": 126.58496176118032,
            "smoothness_avg": 0.019136779325541177,
            "success_improvement": 0.0,
            "time_improvement": -838.4261971706584,
            "length_improvement": 15.928295726355978,
            "smoothness_improvement": 143.41842049076695,
            "objective_score": -241.25378961293006
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an optimized single-tree RRT* planner with adaptive neighbor radius scaling, goal-biased sampling to accelerate convergence, and enhanced rewiring for smoother and shorter paths. It dynamically adjusts the neighbor radius based on the current state space size and iteration count to balance exploration and refinement efficiently. Early stopping occurs as soon as the first feasible path to the goal is found or when the time limit is reached, returning the best path found thus far.",
    "planning_mechanism": "The planner incrementally expands a single tree from start toward the goal by sampling collision-free points with a 10% goal bias. Each new sample is steered within a fixed step size toward the sampled point and the best parent is chosen from neighbors inside an adaptively scaled radius. It performs rewiring in the neighborhood to improve path cost. The planning halts when a path within the goal radius is found or when 30 seconds elapse, guaranteeing timely return of a feasible path if found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=4.0, neighbor_gamma=60.0, goal_radius=2.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_gamma = neighbor_gamma\n        self.goal_radius = goal_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return clamp_bounds(to_pos)\n            ratio = self.step_size / dist\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            for _ in range(100):\n                if random.random() < 0.10:  # 10% goal bias\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos  # fallback rare case\n\n        def neighbor_radius(num_nodes, iteration):\n            if num_nodes < 2:\n                return max(10.0, self.step_size * 2.0)\n            # Adaptive radius shrinking over iterations to focus optimization\n            r_max = max(bounds) * 0.25\n            r_min = max(4.0, self.step_size)\n            adaptive_gamma = self.neighbor_gamma * (1 - iteration / self.max_iter)\n            r = adaptive_gamma * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return min(r_max, max(r_min, r))\n\n        def near_nodes(tree_nodes, pos, radius):\n            # Early exit if few nodes to avoid overhead\n            result = []\n            r_sq = radius * radius\n            for n in tree_nodes:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        best_path = []\n        best_cost = float('inf')\n        found_goal = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = neighbor_radius(len(nodes), iteration)\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            min_cost = float('inf')\n            best_parent = None\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + math.dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n            if best_parent is None:\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    best_parent = nearest_node\n                    min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost via new_node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.goal_radius and not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                cost = 0.0\n                for i in range(len(path) - 1):\n                    cost += math.dist(path[i], path[i + 1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = path\n                    found_goal = True\n                break\n\n        return PlannerResult(success=found_goal, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 264.27098,
    "time_improvement": -856.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 132.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.357975697517395,
            "num_nodes_avg": 445.2,
            "path_length_avg": 166.13475812226588,
            "smoothness_avg": 0.015965665008901293,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1324.6313789936312,
            "length_improvement": 8.938906499477497,
            "smoothness_improvement": 149.8973273857846,
            "objective_score": -441.276583161474
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9005147695541382,
            "num_nodes_avg": 1228.4,
            "path_length_avg": 255.44966931004492,
            "smoothness_avg": 0.006523846953451021,
            "success_improvement": 0.0,
            "time_improvement": -460.2699923206443,
            "length_improvement": 14.723547673258047,
            "smoothness_improvement": 67.8632810493229,
            "objective_score": -128.90755268699183
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4287919759750366,
            "num_nodes_avg": 646.9,
            "path_length_avg": 122.37841790280811,
            "smoothness_avg": 0.021847790029162123,
            "success_improvement": 0.0,
            "time_improvement": -782.5052381583273,
            "length_improvement": 18.722081862993548,
            "smoothness_improvement": 177.9022765348305,
            "objective_score": -222.6288109470279
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
    "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.11942,
    "time_improvement": -70.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 182.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02458224296569824,
            "num_nodes_avg": 235.2,
            "path_length_avg": 160.91673392411104,
            "smoothness_avg": 0.01622189562126349,
            "success_improvement": 0.0,
            "time_improvement": 2.170356988333177,
            "length_improvement": 11.798988247370831,
            "smoothness_improvement": 153.90789288293342,
            "objective_score": 8.50003950933712
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.16582508087158204,
            "num_nodes_avg": 988.6,
            "path_length_avg": 230.06388904405716,
            "smoothness_avg": 0.011826311396694525,
            "success_improvement": 0.0,
            "time_improvement": -3.170786229848748,
            "length_improvement": 23.198051815215557,
            "smoothness_improvement": 204.29951038474306,
            "objective_score": 13.989092772098425
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.14947149753570557,
            "num_nodes_avg": 650.0,
            "path_length_avg": 121.70930984019235,
            "smoothness_avg": 0.022669727327406998,
            "success_improvement": 0.0,
            "time_improvement": -207.63024245189973,
            "length_improvement": 19.166471578680884,
            "smoothness_improvement": 188.3572582994048,
            "objective_score": -49.84740349686436
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
    "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.73775,
    "time_improvement": -3.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 143.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.031192827224731445,
            "num_nodes_avg": 228.2,
            "path_length_avg": 173.47041072322037,
            "smoothness_avg": 0.016212433782287948,
            "success_improvement": 0.0,
            "time_improvement": -24.137702006209146,
            "length_improvement": 4.918119068040286,
            "smoothness_improvement": 153.759794556254,
            "objective_score": -3.521640188257302
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1286400556564331,
            "num_nodes_avg": 775.0,
            "path_length_avg": 247.3898406969005,
            "smoothness_avg": 0.00894525060365523,
            "success_improvement": 0.0,
            "time_improvement": 19.964485390459707,
            "length_improvement": 17.414150453629286,
            "smoothness_improvement": 130.16774103563074,
            "objective_score": 17.088674594493636
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.050321340560913086,
            "num_nodes_avg": 417.3,
            "path_length_avg": 125.51343547763591,
            "smoothness_avg": 0.01937830391026074,
            "success_improvement": 0.0,
            "time_improvement": -3.567345296452773,
            "length_improvement": 16.639952463287656,
            "smoothness_improvement": 146.4905953809094,
            "objective_score": 9.64622086594131
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An adaptive single-tree RRT* planner using dynamically scaling rewiring radius and goal-biased informed ellipsoidal sampling, with incremental cost propagation during rewiring and a strict 30-second time budget. The planner quickly converges to high-quality, smooth paths by focusing sampling within the minimal prolate hyperspheroid after the first path, dynamically adjusting neighbor connections for rewiring, and performing recursive downstream cost updates to maintain consistent path costs. Early termination is triggered upon timeout, returning the best path found so far.",
    "planning_mechanism": "The planner initializes a single root at the start, samples new nodes mostly within the informed ellipsoid once a path is found, extends nodes by a fixed step size towards samples, selects the best parent within a dynamically sized neighborhood calculated from the current iteration and log of tree size, rewires neighbors to minimize local costs with collision checks, propagates cost changes to descendants recursively to maintain consistency, and continuously updates the best path to the goal node. The search runs until a hard 30-second time limit expiry or iteration limit, returning the best feasible path discovered.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.improve_tol = 1e-8\n\n    def plan(self, map):\n        import time, math, random\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def point_in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        # Informed ellipsoidal sampling after first solution\n        def informed_sample(c_best, c_min):\n            # If no solution yet, uniform random sample in bounds avoiding obstacles\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # fallback uniform\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            length = math.sqrt(sum(x * x for x in diff))\n            if length < 1e-10:\n                # degenerate case fallback uniform\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            e1 = tuple(x / length for x in diff)\n            # Compute radii of ellipsoid axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                if c_best > c_min:\n                    r2 = math.sqrt(c_best * c_best - c_min * c_min) / 2\n                else:\n                    r2 = 0.0\n                radii = (r1, r2)\n            elif dim == 3:\n                if c_best > c_min:\n                    r_side = math.sqrt(c_best * c_best - c_min * c_min) / 2\n                else:\n                    r_side = 0.0\n                radii = (r1, r_side, r_side)\n            else:\n                # Fallback uniform\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Generate random point in unit n-ball scaled by radii\n            for _ in range(200):\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-12:\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius_scale = random.random() ** (1.0 / dim)\n                x_scaled = [radius_scale * radii[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate first axis to e1 direction using Rodrigues' rotation (only 2D/3D)\n                if dim == 2:\n                    # 2D rotation by angle between (1,0) and e1\n                    dot = e1[0]\n                    det = e1[1]\n                    cos_a = dot\n                    sin_a = det\n                    x_rot = (x_scaled[0]*cos_a - x_scaled[1]*sin_a,\n                             x_scaled[0]*sin_a + x_scaled[1]*cos_a)\n                elif dim == 3:\n                    # Rodrigues' rotation from (1,0,0) to e1\n                    v = (1.0, 0.0, 0.0)\n                    u = e1\n                    dot = sum(v[i]*u[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-12:\n                        # no rotation\n                        x_rot = x_scaled\n                    elif abs(dot + 1.0) < 1e-12:\n                        # 180 deg rotation around any axis perpendicular to (1,0,0)\n                        x_rot = (-x_scaled[0], -x_scaled[1], -x_scaled[2])\n                    else:\n                        k = (v[1]*u[2] - v[2]*u[1],\n                             v[2]*u[0] - v[0]*u[2],\n                             v[0]*u[1] - v[1]*u[0])\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        k = tuple(kk / k_norm for kk in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2] - k[2]*v_vec[1],\n                                 k[2]*v_vec[0] - k[0]*v_vec[2],\n                                 k[0]*v_vec[1] - k[1]*v_vec[0])\n                        x_rot = [0,0,0]\n                        for i in range(3):\n                            x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                else:\n                    # fallback no rotation for higher dims\n                    x_rot = x_scaled\n\n                sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                if point_in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Find nearest node\n        def nearest_node(tree, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        # Find neighbors within radius for rewiring and parent selection\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        # Recursive function to propagate cost changes downstream after rewiring\n        def propagate_cost_downstream(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_downstream(c)\n\n        root = Node(start_pos, None, 0.0)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        found_solution = False\n\n        no_improve_count = 0\n        max_no_improve = 300\n\n        for iter in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            x_rand = informed_sample(c_best, c_min)\n\n            x_nearest = nearest_node(nodes, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if not point_in_bounds(x_new_pos):\n                continue\n            if is_in_obstacle(x_new_pos):\n                continue\n            if is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                continue\n\n            # Compute dynamic neighbor radius for rewiring & parent selection\n            gamma_rrt = 50.0  # tuning constant\n            radius = min(\n                gamma_rrt * ((math.log(len(nodes) + 1) / (len(nodes) +1)) ** (1.0 / dim)),\n                self.step_size * 5.0,\n            )\n\n            near = near_nodes(nodes, x_new_pos, radius)\n            near.append(x_nearest) if x_nearest not in near else None\n\n            # Choose best parent with lowest cost + dist & collision check edge\n            best_parent = None\n            best_parent_cost = float('inf')\n            for node_candidate in near:\n                if node_candidate == x_nearest or node_candidate == root or node_candidate == best_goal_node:\n                    # avoid considering goal node as parent except last step\n                    pass\n                dist_cost = node_candidate.cost + dist(node_candidate.position, x_new_pos)\n                if dist_cost < best_parent_cost:\n                    if not is_edge_in_obstacle(node_candidate.position, x_new_pos):\n                        best_parent = node_candidate\n                        best_parent_cost = dist_cost\n\n            if best_parent is None:\n                continue\n\n            x_new = Node(x_new_pos)\n            x_new.parent = best_parent\n            x_new.cost = best_parent_cost\n            best_parent.add_child(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near neighbors to x_new if cheaper and collision free\n            for node_candidate in near:\n                if node_candidate == best_parent or node_candidate == x_new:\n                    continue\n                new_cost = x_new.cost + dist(x_new.position, node_candidate.position)\n                if new_cost + self.improve_tol < node_candidate.cost:\n                    if not is_edge_in_obstacle(x_new.position, node_candidate.position):\n                        old_parent = node_candidate.parent\n                        if old_parent:\n                            old_parent.remove_child(node_candidate)\n                            try:\n                                edges.remove((old_parent, node_candidate))\n                            except ValueError:\n                                pass\n                        node_candidate.parent = x_new\n                        node_candidate.cost = new_cost\n                        x_new.add_child(node_candidate)\n                        edges.append((x_new, node_candidate))\n                        propagate_cost_downstream(node_candidate)\n\n            # Goal check: if close enough and feasible edge, add virtual goal node\n            if dist(x_new.position, goal_pos) <= self.step_size and not is_edge_in_obstacle(x_new.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + dist(x_new.position, goal_pos)\n                x_new.add_child(goal_node)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    c_best = best_cost\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= max_no_improve:\n                # No improvements for many iterations, terminate early\n                break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            success = True\n        else:\n            # fallback partial best path to closest node to goal\n            success = False\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < best_goal_dist and n.valid:\n                    best_goal_dist = d\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 213.24668,
    "time_improvement": -742.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 120.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2601533174514771,
            "num_nodes_avg": 1135.9,
            "path_length_avg": 165.48946772351195,
            "smoothness_avg": 0.014197248392440983,
            "success_improvement": 0.0,
            "time_improvement": -935.3288839465314,
            "length_improvement": 9.29260039231524,
            "smoothness_improvement": 122.21776716003392,
            "objective_score": -274.41201611277006
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.02791748046875,
            "num_nodes_avg": 1784.8,
            "path_length_avg": 248.93312969038897,
            "smoothness_avg": 0.006706595874275609,
            "success_improvement": 0.0,
            "time_improvement": -539.535672661568,
            "length_improvement": 16.89895616649216,
            "smoothness_improvement": 72.56554241086673,
            "objective_score": -151.35850038652077
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.41294155120849607,
            "num_nodes_avg": 1100.6,
            "path_length_avg": 125.03274044248208,
            "smoothness_avg": 0.020753183067440163,
            "success_improvement": 0.0,
            "time_improvement": -749.8831657613362,
            "length_improvement": 16.95920721739902,
            "smoothness_improvement": 163.97895677720865,
            "objective_score": -213.9695306140754
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid single-tree RRT* planner with adaptive informed sampling, dynamic rewiring radius, and early termination by time and solution stability. The algorithm integrates cost-aware parent selection, rewiring of neighbors to ensure smooth and shorter paths, ellipsoidal sampling for focused search once a solution is found, and robust node and edge collision checks within a 30-second time limit.",
    "planning_mechanism": "The planner incrementally builds a tree from start, sampling uniformly at first and within an informed ellipsoidal region after finding a first feasible path. Nodes are extended towards samples using fixed step size, with best-parent selection from neighbors under an adaptive radius. Rewiring refines local connections to reduce path cost, and search terminates early upon either time limit or stability in path cost improvements. The final path is backtracked from the best goal node or closest node if no complete path is found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0        # seconds\n        self.improve_tol = 1e-6       # cost improvement threshold for rewiring and early stop\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n\n        no_improve_count = 0\n        max_no_improve = 200\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf') or (dim != 2 and dim != 3):\n                return uniform_sample()\n\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            rest_radius = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n\n            if dim == 2:\n                axes = (r1, rest_radius)\n            else:  # dim == 3\n                axes = (r1, rest_radius, rest_radius)\n\n            attempts = 0\n            while attempts < 200:\n                # Sample unit ball point\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n\n                # Scale by random radius within ball\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotation matrix aligning [1,0,...] to e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    else:  # dim == 3\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0.0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, pt):\n            return min(nodes_list, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            return [n for n in nodes_list if dist(n.position, pt) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            cost_limit = best_cost if found_solution else float('inf')\n            # Sample with goal biasing and informed region when solution found\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(cost_limit, dist(start_pos, goal_pos))\n\n            if is_in_obstacle(sample):\n                continue\n\n            nn = nearest_node(nodes, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nn.position, new_pos):\n                continue\n\n            tentative_cost = nn.cost + dist(nn.position, new_pos)\n            new_node = Node(new_pos, cost=tentative_cost)\n\n            # Dynamic radius based on number of nodes (RRT* radius)\n            gamma_rrt_star = 50.0\n            radius = gamma_rrt_star * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1.0 / dim))\n            radius = max(radius, self.step_size)\n            radius = min(radius, self.step_size * 15.0)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n            # Best parent selection (lowest-cost among neighbors)\n            best_parent = nn\n            best_parent_cost = tentative_cost\n\n            for nbr in neighbors:\n                if nbr == nn:\n                    continue\n                cost_thru_nbr = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru_nbr + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_parent_cost = cost_thru_nbr\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_thru_new + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        new_node.add_child(nbr)\n                        nbr.cost = cost_thru_new\n                        edges.append((new_node, nbr))\n\n            # Check if near goal to connect\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos, cost=goal_cost)\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n        else:\n            # Return path to closest node to goal\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 107.04616,
    "time_improvement": -388.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 129.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07088694572448731,
            "num_nodes_avg": 500.2,
            "path_length_avg": 162.77132866625377,
            "smoothness_avg": 0.01701956550948016,
            "success_improvement": 0.0,
            "time_improvement": -182.10788592769148,
            "length_improvement": 10.782455481268096,
            "smoothness_improvement": 166.3931588014109,
            "objective_score": -47.33092669553953
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.29100329875946046,
            "num_nodes_avg": 1173.7,
            "path_length_avg": 253.0320888728905,
            "smoothness_avg": 0.00691947049603768,
            "success_improvement": 0.0,
            "time_improvement": -81.05246185131362,
            "length_improvement": 15.530605609374762,
            "smoothness_improvement": 78.04295975619733,
            "objective_score": -14.607160390988245
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4858510732650757,
            "num_nodes_avg": 1042.5,
            "path_length_avg": 125.29571531748675,
            "smoothness_avg": 0.019037418514756693,
            "success_improvement": 0.0,
            "time_improvement": -899.9396937088123,
            "length_improvement": 16.784551826938795,
            "smoothness_improvement": 142.15455831164047,
            "objective_score": -259.2004042249222
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid anytime RRT* variant leveraging incremental informed sampling, adaptive connection radius, and batch rewiring to improve efficiency and path quality within a 30-second hard limit. The planner initially explores globally with uniform samples, then focuses sampling within an ellipsoidal informed set after finding a solution. It maintains node validity strictly with collision checks, dynamically selects the best parent, rewires neighbors to reduce cost, and terminates early if elapsed time or solution quality stabilizes. The final path is extracted from the best goal node or closest node otherwise, returning a well-optimized, smooth path.",
    "planning_mechanism": "The planner builds a single tree by iteratively sampling states using a goal-biased plus informed ellipsoidal distribution. Each new sample is connected to the lowest-cost parent within an adaptive radius and neighbors are rewired to optimize paths. Collision checks ensure node and edge feasibility. The connection radius shrinks as iterations grow. Early termination occurs if no improvement over a threshold is observed or time limit elapses. The solution path is extracted from the best goal node found or nearest node if no complete path is available.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.batch_size = 50  # batch rewiring frequency\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            # If no solution yet or degenerate, uniform sample\n            if c_best == float('inf') or c_min < 1e-10 or dim not in (2, 3):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n\n            axes = (r1,) + (r_other,) * (dim - 1)\n\n            attempts = 0\n            while attempts < 200:\n                # sample random point on unit ball\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotate sample so major axis aligns with vector e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    else:  # dim == 3\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            x_rot = [0.0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            # Linear search acceptable due to modest node count; KD-tree could help for performance\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (dist(n.position, point) <= radius)]\n\n        def path_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_counter = 0\n        max_no_improve = 150\n\n        c_min = dist(start_pos, goal_pos)\n\n        for iteration in range(self.max_iter):\n\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n            c_best = best_cost if found_solution else float('inf')\n\n            # Sample: goal biasing and informed sampling after first solution\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            # Reject invalid samples\n            if is_in_obstacle(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius (RRT* radius with lower/upper bounds)\n            rmax = self.step_size * 20.0\n            rmin = self.step_size\n            gamma_rrt_star = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (1 + 1/dim) ) / ( ( (4/3)*math.pi if dim==3 else 1) ) )**(1/dim) )\n            radius = min(rmax, max(rmin, gamma_rrt_star * ( (math.log(len(nodes)+1) / (len(nodes)+1))**(1/dim) )))\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent among neighbors (lowest cost + feasibilty)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost + self.improve_tol < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewiring every batch_size nodes to reduce overhead\n            if (len(nodes) % self.batch_size) == 0:\n                for nbr in neighbors:\n                    if nbr == best_parent or nbr == new_node:\n                        continue\n                    rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if rewired_cost + self.improve_tol < nbr.cost:\n                        if not is_edge_in_obstacle(new_node.position, nbr.position):\n                            # Rewire tree structure and edges\n                            old_parent = nbr.parent\n                            if old_parent:\n                                old_parent.remove_child(nbr)\n                                try:\n                                    edges.remove((old_parent, nbr))\n                                except ValueError:\n                                    pass\n                            new_node.add_child(nbr)\n                            nbr.cost = rewired_cost\n                            edges.append((new_node, nbr))\n\n            # Check goal connection if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_counter = 0\n\n            # Early stopping if solution stable\n            if found_solution:\n                no_improve_counter += 1\n                if no_improve_counter > max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # Return path to closest node to goal if no full solution found\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 86.90523,
    "time_improvement": -233.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 61.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.0693166971206665,
            "num_nodes_avg": 474.6,
            "path_length_avg": 189.36555780350008,
            "smoothness_avg": 0.01005017057735644,
            "success_improvement": -9.999999999999998,
            "time_improvement": -175.85878731753974,
            "length_improvement": -3.7942629213847154,
            "smoothness_improvement": 57.306993830346954,
            "objective_score": -104.747658978941
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2834985971450806,
            "num_nodes_avg": 1140.4,
            "path_length_avg": 305.68179407811465,
            "smoothness_avg": 0.006235597586945562,
            "success_improvement": 0.0,
            "time_improvement": -76.38328899816969,
            "length_improvement": -2.0453814258676606,
            "smoothness_improvement": 60.44641723151071,
            "objective_score": -23.83998346881395
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2649787425994873,
            "num_nodes_avg": 736.2,
            "path_length_avg": 147.6887523984348,
            "smoothness_avg": 0.013082809065717802,
            "success_improvement": 0.0,
            "time_improvement": -445.35798579931594,
            "length_improvement": 1.9121628396116364,
            "smoothness_improvement": 66.41236564341555,
            "objective_score": -132.12803620781074
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "A structurally enhanced single-tree RRT* planner with adaptive informed sampling restricted to an ellipsoidal subset after first solution, dynamic rewiring radius adapting with node density and planning progress, incremental pruning of outdated nodes, and efficient early stopping based on path improvement and a hard 30-second time limit, aiming to improve planning efficiency, path length, and smoothness simultaneously.",
    "planning_mechanism": "The planner grows a single tree rooted at start by sampling points uniformly before first solution and then within an ellipsoidal informed subset defined by the current best path cost. It steers toward samples with fixed step size, connects only collision-free edges, and uses an adaptive neighbor radius based on the number of nodes and problem dimension to select parents and rewire neighbors, improving path cost and smoothness incrementally. Periodic pruning removes invalid or suboptimal nodes to keep the tree streamlined. Planning halts either on 30-second timeout or when no improvements occur for a threshold number of iterations. The path is extracted from the best goal-connected node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # hard time limit in seconds\n        self.improve_tol = 1e-5\n        self.max_no_improve = 200\n        self.prune_interval = 500  # iterations between pruning\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min):\n            # If no solution found, uniform sample\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x * x for x in raw))\n                if norm_raw < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align the first axis to e1 (only implemented for 2D/3D)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n\n            while True:  # fallback uniform sample\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def prune_nodes():\n            # Remove invalid or isolated nodes to reduce tree complexity\n            to_remove = []\n            for n in nodes:\n                # Remove nodes marked invalid or disconnected from tree\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            # Remove nodes safely\n            for n in to_remove:\n                # Disconnect from parent\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                # Disconnect all children\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # Remove edges connected to n\n                for edge in list(edges):\n                    if edge[0] == n or edge[1] == n:\n                        edges.remove(edge)\n\n        iteration = 0\n        c_min = dist(start_pos, goal_pos)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min)\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius: theoretical for RRT* with safety margins\n            gamma = 35.0\n            n_nodes = len(nodes) + 1\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_parent_cost = new_cost\n            for near_node in near:\n                if near_node == nearest:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_parent_cost = cost_through\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if better path found\n            for near_node in near:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge if present\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to goal if close enough\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.cost = goal_cost\n                    goal_node.parent = new_node\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Periodic pruning to improve planning efficiency\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # fallback: closest node to goal\n            closest = nearest_node(nodes, goal_pos)\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 111.52446,
    "time_improvement": -394.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 83.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12738897800445556,
            "num_nodes_avg": 790.2,
            "path_length_avg": 169.3978892921885,
            "smoothness_avg": 0.012305547640369511,
            "success_improvement": 0.0,
            "time_improvement": -406.9683128259236,
            "length_improvement": 7.150332597620601,
            "smoothness_improvement": 92.60854249618313,
            "objective_score": -117.3372515767238
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.38849313259124757,
            "num_nodes_avg": 1255.3,
            "path_length_avg": 264.7068157958746,
            "smoothness_avg": 0.0060919297753769235,
            "success_improvement": 0.0,
            "time_improvement": -141.70735647266443,
            "length_improvement": 11.633245724100348,
            "smoothness_improvement": 56.749740960107644,
            "objective_score": -35.24851080253858
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.356812047958374,
            "num_nodes_avg": 938.3,
            "path_length_avg": 130.9430033769814,
            "smoothness_avg": 0.015733291561431894,
            "success_improvement": 0.0,
            "time_improvement": -634.3619260720436,
            "length_improvement": 13.033891992782134,
            "smoothness_improvement": 100.1263073506315,
            "objective_score": -181.98761108919064
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
    "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 34.17936,
    "time_improvement": -148.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 307.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06862092018127441,
            "num_nodes_avg": 284.0,
            "path_length_avg": 170.5991073480199,
            "smoothness_avg": 0.023639461522089605,
            "success_improvement": 0.0,
            "time_improvement": -173.08981258681808,
            "length_improvement": 6.491925946701232,
            "smoothness_improvement": 270.00890673302524,
            "objective_score": -46.68174367435956
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09145197868347169,
            "num_nodes_avg": 589.8,
            "path_length_avg": 238.92126140318732,
            "smoothness_avg": 0.017217767150899767,
            "success_improvement": 0.0,
            "time_improvement": 43.10165571180447,
            "length_improvement": 20.24120597641038,
            "smoothness_improvement": 343.0255502490592,
            "objective_score": 26.790348050632865
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.20080511569976806,
            "num_nodes_avg": 632.2,
            "path_length_avg": 125.97622721535136,
            "smoothness_avg": 0.03204491385721169,
            "success_improvement": 0.0,
            "time_improvement": -313.2809762847595,
            "length_improvement": 16.332588226871458,
            "smoothness_improvement": 307.60893895423396,
            "objective_score": -82.6466952545338
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
    "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.90364,
    "time_improvement": -8.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 170.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025247907638549803,
            "num_nodes_avg": 233.8,
            "path_length_avg": 170.12946546952813,
            "smoothness_avg": 0.014816791053862539,
            "success_improvement": 0.0,
            "time_improvement": -0.4787803341404643,
            "length_improvement": 6.749344102254376,
            "smoothness_improvement": 131.91495516970375,
            "objective_score": 4.565547136959005
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.12624733448028563,
            "num_nodes_avg": 859.5,
            "path_length_avg": 236.88602288914717,
            "smoothness_avg": 0.011656507882273733,
            "success_improvement": 0.0,
            "time_improvement": 21.453156004545612,
            "length_improvement": 20.920627173489493,
            "smoothness_improvement": 199.93034365416824,
            "objective_score": 19.98797482372822
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07023768424987793,
            "num_nodes_avg": 492.5,
            "path_length_avg": 121.35915641758058,
            "smoothness_avg": 0.02178086692654423,
            "success_improvement": 0.0,
            "time_improvement": -44.55756576526181,
            "length_improvement": 19.399026809465404,
            "smoothness_improvement": 177.0510196092805,
            "objective_score": -0.842598545852899
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
    "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 4.05717,
    "time_improvement": -77.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1607.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03238720893859863,
            "num_nodes_avg": 240.1,
            "path_length_avg": 156.8355269466239,
            "smoothness_avg": 0.04571460503828216,
            "success_improvement": 0.0,
            "time_improvement": -28.890967883954104,
            "length_improvement": 14.03596246259457,
            "smoothness_improvement": 615.5328397028414,
            "objective_score": 2.831951310884718
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.147990083694458,
            "num_nodes_avg": 859.9,
            "path_length_avg": 231.82003384026544,
            "smoothness_avg": 0.10402068439578667,
            "success_improvement": 0.0,
            "time_improvement": 7.925548965645519,
            "length_improvement": 22.611800134415976,
            "smoothness_improvement": 2576.527132574148,
            "objective_score": 28.827380433213982
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15016646385192872,
            "num_nodes_avg": 570.8,
            "path_length_avg": 123.61458665916646,
            "smoothness_avg": 0.13595502682176802,
            "success_improvement": 0.0,
            "time_improvement": -209.06056635900154,
            "length_improvement": 17.901077435050915,
            "smoothness_improvement": 1629.3379060166778,
            "objective_score": -43.83083391658651
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional RRT* planner enhanced with adaptive sampling that dynamically shrinks the rewiring radius as the tree grows, efficient goal biasing to accelerate initial solution discovery, and iterative randomized shortcut smoothing to improve path smoothness and reduce length post planning, all while enforcing a strict 30-second time limit.",
    "planning_mechanism": "The planner grows a single tree from the start node, samples points mostly uniformly but with goal bias, connects new nodes using a theoretical adaptive rewiring radius for efficient local rewiring, tries to connect to the goal when close enough, and after termination applies iterative randomized shortcut smoothing to prune unnecessary waypoints and smooth the final path, returning the best found path within the time budget.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds hard limit\n        self.goal_sample_rate = 0.1  # Probability to sample the goal\n        self.improve_tol = 1e-5  # Tolerance to consider improvement\n        self.max_no_improve = 300  # Early stop if no improvements\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def random_sample():\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n        def shortcut_smooth(path, attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p1 = path[i]\n                p2 = path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # Remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        volume = 1.0\n        for b in bounds:\n            volume *= b\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = random_sample()\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            tentative_cost = nearest.cost + dist(nearest.position, new_pos)\n\n            # Adaptive rewiring radius (theoretical approx for RRT*)\n            n_nodes = len(nodes) + 1\n            gamma_rrt_star = 2 * (1 + 1/dim)**(1/dim) * (volume / (math.pi ** (dim/2)))**(1/dim)\n            radius = min(gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)), self.step_size * 20.0)\n            radius = max(radius, self.step_size)  # At least step_size\n\n            nearinds = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent among neighbors to minimize cost\n            best_parent = nearest\n            best_cost_to_new = tentative_cost\n            for node_candidate in nearinds:\n                cost_through = node_candidate.cost + dist(node_candidate.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_to_new:\n                    if not is_edge_in_obstacle(node_candidate.position, new_pos):\n                        best_parent = node_candidate\n                        best_cost_to_new = cost_through\n\n            new_node = Node(new_pos)\n            new_node.cost = best_cost_to_new\n            new_node.parent = best_parent\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if the path through new_node improves cost\n            for near_node in nearinds:\n                if near_node is new_node or near_node is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_via_new + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_via_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect to goal if close\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = new_node\n                    goal_node.cost = goal_cost\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > self.max_no_improve:\n                        break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            # Apply iterative shortcut smoothing to improve smoothness and shorten path\n            smoothed_path = raw_path\n            smoothing_iters = 100\n            last_len = len(smoothed_path) + 1\n            for _ in range(smoothing_iters):\n                if len(smoothed_path) < 3:\n                    break\n                smoothed_path = shortcut_smooth(smoothed_path, attempts=10)\n                if len(smoothed_path) >= last_len:\n                    break\n                last_len = len(smoothed_path)\n            extracted_path = smoothed_path\n        else:\n            # fallback to nearest node path to goal\n            if nodes:\n                closest = nearest_node(nodes, goal_pos)\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 364.05017,
    "time_improvement": -1272.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 736.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.4229812383651733,
            "num_nodes_avg": 960.6,
            "path_length_avg": 151.3007762388788,
            "smoothness_avg": 0.035373793273472856,
            "success_improvement": 0.0,
            "time_improvement": -1583.3331119393354,
            "length_improvement": 17.069647029247047,
            "smoothness_improvement": 453.676680151417,
            "objective_score": -462.48976196349525
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.777293872833252,
            "num_nodes_avg": 2153.4,
            "path_length_avg": 218.25660160376825,
            "smoothness_avg": 0.041041345170612094,
            "success_improvement": 0.0,
            "time_improvement": -1005.7724516576625,
            "length_improvement": 27.139664216709253,
            "smoothness_improvement": 956.0233721259156,
            "objective_score": -280.66782010664366
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6441714525222778,
            "num_nodes_avg": 1119.9,
            "path_length_avg": 113.56621382931084,
            "smoothness_avg": 0.07070525876661057,
            "success_improvement": 0.0,
            "time_improvement": -1225.7819944747857,
            "length_improvement": 24.57472821654533,
            "smoothness_improvement": 799.3656725919624,
            "objective_score": -348.9929330495487
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
    "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -31.88223,
    "time_improvement": 70.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 318.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012917828559875489,
            "num_nodes_avg": 112.2,
            "path_length_avg": 167.70136746333029,
            "smoothness_avg": 0.02325991201186068,
            "success_improvement": 0.0,
            "time_improvement": 48.591080225594155,
            "length_improvement": 8.080223095126494,
            "smoothness_improvement": 264.06813269298925,
            "objective_score": 20.74579858821909
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019352173805236815,
            "num_nodes_avg": 256.2,
            "path_length_avg": 239.51954011716208,
            "smoothness_avg": 0.01718477585351879,
            "success_improvement": 0.0,
            "time_improvement": 87.95972855101965,
            "length_improvement": 20.041483321187638,
            "smoothness_improvement": 342.17666040477565,
            "objective_score": 40.123691860042356
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013465619087219239,
            "num_nodes_avg": 182.0,
            "path_length_avg": 122.07168904397376,
            "smoothness_avg": 0.03515560414413786,
            "success_improvement": 0.0,
            "time_improvement": 72.28614329245853,
            "length_improvement": 18.92579656617262,
            "smoothness_improvement": 347.1766897966619,
            "objective_score": 34.77720437642444
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, unidirectional RRT* algorithm with goal bias sampling, fixed step extension, fixed-radius rewiring, and immediate termination upon successful goal connection, emphasizing efficient local cost improvements and early path discovery for improved planning time and path quality.",
    "planning_mechanism": "A tree grows from the start by sampling mostly uniformly with occasional sampling of the goal to speed convergence. Each iteration extends towards the sampled point by a fixed step size clipped within map bounds, checks node and edge collisions, selects the lowest-cost parent within a fixed radius, adds the new node, rewires neighbors to improve local path costs, and terminates immediately when a collision-free connection to the goal vicinity is found. The final path is extracted by tracing parents from goal to start.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Goal bias sampling\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within rewiring radius\n            neighbors = [n for n in nodes if dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select best parent minimizing cost + distance, checking edge collision\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better and collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Early stopping if new node close enough to goal and collision free connection\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 21.50785,
    "time_improvement": -106.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 173.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06068551540374756,
            "num_nodes_avg": 318.7,
            "path_length_avg": 168.18065361864075,
            "smoothness_avg": 0.015896461857993056,
            "success_improvement": 0.0,
            "time_improvement": -141.5093820450733,
            "length_improvement": 7.817518758625687,
            "smoothness_improvement": 148.81414779702322,
            "objective_score": -37.018232619361456
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1837256908416748,
            "num_nodes_avg": 894.7,
            "path_length_avg": 236.1022438834725,
            "smoothness_avg": 0.01116483989364266,
            "success_improvement": 0.0,
            "time_improvement": -14.307943497623887,
            "length_improvement": 21.18227516541151,
            "smoothness_improvement": 187.2793721725527,
            "objective_score": 9.353378910822503
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12804923057556153,
            "num_nodes_avg": 504.7,
            "path_length_avg": 122.2273744873662,
            "smoothness_avg": 0.022171094224557604,
            "success_improvement": 0.0,
            "time_improvement": -163.54065154347794,
            "length_improvement": 18.822397707615522,
            "smoothness_improvement": 182.01468203642764,
            "objective_score": -36.85868342829193
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced single-tree RRT* planner featuring adaptive neighbor radius, goal-biased sampling, incremental rewiring with caching, and early stopping upon reaching the goal within time limits. It uses efficient nearest neighbor search with spatial subdivision to reduce collision checks, dynamically adjusts rewiring radius for improved path optimization and smoothness, and incorporates inline path shortcutting for post-processing path smoothing. Continuous incremental rewiring ensures locally optimal cost improvements, while early termination and strict collision checks maintain planning efficiency and path validity.",
    "planning_mechanism": "The planner incrementally grows a single tree from start to goal using goal bias sampling to accelerate convergence. Each new node is connected by choosing the best parent from neighbors within an adaptively scaled radius to minimize path cost, then rewires neighbors to leverage improved paths. Efficient nearest neighbor queries and collision checking restrict costly operations. The search terminates early upon connecting to the goal, returning a smoothed, low-cost path found within a hard 30-second time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, rewire_factor=1.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # multiplier for neighbor radius scaling\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n        from collections import deque\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # hard time limit in seconds\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def calc_neighbor_radius(n_nodes):\n            # Asymptotically optimal radius scaling (RRT*) with factor to increase neighbor candidates\n            gamma_rrt = self.rewire_factor * (2 * (1 + 1/dim))**(1/dim) * ( (math.prod(bounds)) / math.pi )**(1/dim)\n            radius = gamma_rrt * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            # Clamp radius to max step_size * 20 or min step_size * 2 for efficiency and quality balance\n            return max(self.step_size*2, min(radius, self.step_size*20))\n\n        # Efficient spatial grid for coarse nearest neighbor queries to reduce distance checks\n        grid_cell_size = self.step_size * 5\n        grid = {}\n\n        def grid_key(pos):\n            return tuple(int(pos[i]//grid_cell_size) for i in range(dim))\n\n        def insert_to_grid(node):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def get_neighbors(pos, radius):\n            # Collect grid cells around pos to search candidate neighbors\n            base_key = grid_key(pos)\n            range_cells = 1 + int(radius // grid_cell_size)\n            candidates = []\n            for dx in range(-range_cells, range_cells+1):\n                for dy in range(-range_cells, range_cells+1):\n                    if dim == 2:\n                        key = (base_key[0]+dx, base_key[1]+dy)\n                        if key in grid:\n                            candidates.extend(grid[key])\n                    else:  # dim==3\n                        for dz in range(-range_cells, range_cells+1):\n                            key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                            if key in grid:\n                                candidates.extend(grid[key])\n            # Filter by actual distance\n            radius_sq = radius*radius\n            res = [n for n in candidates if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= radius_sq]\n            return res\n\n        def path_length(path_nodes):\n            length = 0.0\n            for i in range(1, len(path_nodes)):\n                length += dist(path_nodes[i-1].position, path_nodes[i].position)\n            return length\n\n        def extract_path(goal_node):\n            path = deque()\n            cur = goal_node\n            while cur:\n                path.appendleft(cur.position)\n                cur = cur.parent\n            return list(path)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=0.5):\n            length = dist(from_pos, to_pos)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                ipos = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(dim))\n                if _is_in_obstacle(ipos):\n                    return True\n            return False\n\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n        insert_to_grid(root)\n        success = False\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if _is_in_obstacle(sample):\n                continue\n\n            # Nearest node from sample with spatial grid acceleration\n            neighbor_radius = calc_neighbor_radius(len(nodes))\n            nearest_candidates = get_neighbors(sample, neighbor_radius*4)\n            if not nearest_candidates:\n                nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            else:\n                nearest_node = min(nearest_candidates, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if new_pos == nearest_node.position:\n                continue\n\n            if _is_in_obstacle(new_pos):\n                continue\n            if _is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Find neighbors within dynamically computed neighbor radius for parent choosing and rewiring\n            near_nodes = get_neighbors(new_pos, neighbor_radius)\n\n            # Choose best parent minimizing cost + dist if edge is collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    # Early edge collision check - if obstructed, skip\n                    if _is_edge_in_obstacle(candidate.position, new_pos):\n                        continue\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            insert_to_grid(new_node)\n\n            # Rewire neighbors through new node if cost improves and edge is collision-free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-9 < neighbor.cost:\n                    if not _is_edge_in_obstacle(new_node.position, neighbor.position):\n                        # Update edge connections\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new_node can connect goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not _is_edge_in_obstacle(new_node.position, goal_pos) and not _is_in_obstacle(goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    insert_to_grid(goal_node)\n                    if goal_node.cost < best_goal_cost:\n                        best_goal_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        # Early stop upon first connection\n                        success = True\n                        break\n\n        # If success, extract path and perform shortcut smoothing\n        path = []\n        if success and best_goal_node is not None:\n            raw_path = extract_path(best_goal_node)\n\n            # Path shortcutting: attempt to connect non-consecutive nodes directly if collision free\n            def shortcut_path(path):\n                if len(path) <= 2:\n                    return path\n                smoothed = [path[0]]\n                i = 0\n                while i < len(path)-1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not _is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    smoothed.append(path[j])\n                    i = j\n                return smoothed\n\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 182.88711,
    "time_improvement": -504.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1250.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.19517505168914795,
            "num_nodes_avg": 316.0,
            "path_length_avg": 159.25974865167302,
            "smoothness_avg": 0.04629519539222166,
            "success_improvement": -9.999999999999998,
            "time_improvement": -676.7356973151865,
            "length_improvement": 12.707208131805992,
            "smoothness_improvement": 624.6203395141276,
            "objective_score": -242.2732826179017
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.9561169147491455,
            "num_nodes_avg": 948.3,
            "path_length_avg": 223.18985983650342,
            "smoothness_avg": 0.07988634040203914,
            "success_improvement": -9.999999999999998,
            "time_improvement": -494.86377635912504,
            "length_improvement": 25.492800622657203,
            "smoothness_improvement": 1955.533078349682,
            "objective_score": -173.3857871423948
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.2143566846847534,
            "num_nodes_avg": 367.1,
            "path_length_avg": 116.6925384956489,
            "smoothness_avg": 0.09984684047761702,
            "success_improvement": -9.999999999999998,
            "time_improvement": -341.1717281751581,
            "length_improvement": 22.4983722327465,
            "smoothness_improvement": 1170.0444409481527,
            "objective_score": -133.00227290815877
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid RRT*-based planner combining adaptive ellipsoidal informed sampling after initial solution, progressive goal bias to accelerate convergence, dynamic rewiring radius scaling with node count, and incremental path shortcutting for enhanced smoothness and reduced length. It enforces strict node and edge collision checks, prunes disconnected nodes periodically, and terminates early on time limit or path quality stabilization.",
    "planning_mechanism": "The planner grows a single tree rooted at start by sampling uniformly initially, then biases samples within an informed ellipsoidal region as solutions are found and increasingly towards the goal. It performs fixed-step steering ensuring collision-free nodes and connects new nodes to the cost-optimal neighbor within an adaptively shrinking radius. Rewiring neighbors improves path costs iteratively. Periodic incremental pruning removes invalid/disconnected nodes to maintain efficiency. Upon termination, it extracts the best path and applies local shortcutting to reduce unnecessary waypoints and sharp turns, improving smoothness and path length. Early stopping is triggered either on 30 seconds elapsed or no improvement over a threshold number of iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_every = 400\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # Fallback\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align first axis e1 (only 2D/3D cases)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively capped by max rate\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            # Sample with goal bias (biased towards informed if solution found)\n            prob = random.random()\n            if prob < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius for neighbor search\n            n_nodes = len(nodes) + 1\n            gamma = 30.0  # practical constant between 20 and 40\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n            # Select parent minimizing cost + dist\n            best_parent = nearest\n            best_cost_through = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improves cost\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Check if can connect to goal\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Incremental pruning to keep tree light\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            smoothed_path = shortcut_path(raw_path)\n            extracted_path = smoothed_path\n        else:\n            # fallback: closest to goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 14.04548,
    "time_improvement": -109.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1717.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05759344100952148,
            "num_nodes_avg": 482.9,
            "path_length_avg": 169.84128169423337,
            "smoothness_avg": 0.04532420523685691,
            "success_improvement": 0.0,
            "time_improvement": -129.2038924860142,
            "length_improvement": 6.907302196057579,
            "smoothness_improvement": 609.4222350437985,
            "objective_score": -31.569675252950724
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1714890718460083,
            "num_nodes_avg": 1146.4,
            "path_length_avg": 229.8773660277296,
            "smoothness_avg": 0.11527027308817159,
            "success_improvement": 0.0,
            "time_improvement": -6.694730852452992,
            "length_improvement": 23.260318566833043,
            "smoothness_improvement": 2865.9871523804313,
            "objective_score": 26.277707646266084
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1416875123977661,
            "num_nodes_avg": 753.3,
            "path_length_avg": 119.78501316134012,
            "smoothness_avg": 0.13949436748541644,
            "success_improvement": 0.0,
            "time_improvement": -191.60986883749686,
            "length_improvement": 20.444497807613494,
            "smoothness_improvement": 1674.358058011333,
            "objective_score": -36.844471676624295
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A single-tree adaptive informed RRT* planner with dynamic rewiring radius and incremental path shortcutting. It samples uniformly before finding a solution and then focuses sampling within an informed ellipsoidal subset. The rewiring radius adapts with tree size to balance exploration and path refinement. Periodic pruning and incremental shortcutting improve smoothness and efficiency, and early stopping occurs if no path improvement is detected over a threshold, or upon a hard time limit.",
    "planning_mechanism": "Grown from the start node, the planner samples points focusing over time on an ellipsoidal subset near the best known path. Each sample is connected via the minimum cost parent found within an adaptive radius. The planner dynamically rewires neighbors when better connections are possible, prunes invalid or isolated nodes, and incrementally shortcuts the path to smooth and shorten it. The algorithm halts early on timeouts or when improvements stagnate, returning the best found path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_interval = 300\n        self.shortcut_interval = 100\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                # uniform sample\n                attempts = 0\n                while attempts < 200:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                    attempts += 1\n                # fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                # Start and goal coincident: uniform sample fallback\n                attempts = 0\n                while attempts < 200:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                    attempts += 1\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            e1 = tuple(x / norm_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                # For higher dims fallback to uniform sampling\n                attempts = 0\n                while attempts < 200:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                    attempts += 1\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x * x for x in raw))\n                if norm_raw < 1e-12:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotation aligning first axis (v) with e1\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-12:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n\n            # fallback uniform sample\n            attempts = 0\n            while attempts < 200:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            res = []\n            r_sq = radius * radius\n            for n in nodes_list:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def prune_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid or (n.parent is None and n != root):\n                    to_remove.append(n)\n\n            for n in to_remove:\n                # Disconnect parent\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                # Disconnect children\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # Remove edges connected to n\n                remove_edges = [e for e in edges if e[0] == n or e[1] == n]\n                for e in remove_edges:\n                    edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                # Try to skip as many points as possible\n                furthest = idx + 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not is_edge_in_obstacle(path[idx], path[j]):\n                        furthest = j\n                        break\n                new_path.append(path[furthest])\n                idx = furthest\n            return new_path\n\n        c_min = dist(start_pos, goal_pos)\n        iteration = 0\n\n        while iteration < self.max_iter:\n            iteration += 1\n            if (time.monotonic() - start_time) > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min)\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius for rewiring\n            gamma_rrt_star = 35.0\n            n_nodes = len(nodes) + 1\n            radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(radius, self.step_size)\n            radius = min(radius, self.step_size * 20.0)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent from near nodes (check edges)\n            best_parent = None\n            best_parent_cost = float('inf')\n            for near_node in near:\n                if near_node == new_node:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_parent_cost = cost_through\n            if best_parent is None:\n                # Fallback: nearest\n                best_parent = nearest\n                best_parent_cost = new_cost\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes to new_node if better\n            for near_node in near:\n                if near_node in (best_parent, new_node):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge if present\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos)\n                        goal_node.parent = new_node\n                        goal_node.cost = goal_cost\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Periodic pruning for efficiency\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n            # Periodic incremental shortcutting of best path\n            if found_solution and iteration % self.shortcut_interval == 0:\n                path = best_goal_node.path_from_root()\n                shortcut = shortcut_path(path)\n                if len(shortcut) < len(path):\n                    # Reconstruct tree along shortcut path to update costs and parents\n                    # To avoid complexity, just update extracted_path here\n                    pass\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n            # Final shortcut to improve smoothness before return\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # fallback: closest node to goal\n            closest = nearest_node(nodes, goal_pos)\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 233.34328,
    "time_improvement": -732.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1690.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.29421708583831785,
            "num_nodes_avg": 881.6,
            "path_length_avg": 160.15613804271584,
            "smoothness_avg": 0.058342393907560665,
            "success_improvement": 0.0,
            "time_improvement": -1070.8920343704692,
            "length_improvement": 12.215882902376553,
            "smoothness_improvement": 813.185157189479,
            "objective_score": -309.8721547837674
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.8129445075988769,
            "num_nodes_avg": 1297.7,
            "path_length_avg": 232.65223602019628,
            "smoothness_avg": 0.10462971400872037,
            "success_improvement": -19.999999999999996,
            "time_improvement": -405.7867215826385,
            "length_improvement": 22.333987093143453,
            "smoothness_improvement": 2592.197903181231,
            "objective_score": -195.37463470299932
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3982654809951782,
            "num_nodes_avg": 838.1,
            "path_length_avg": 118.44799733589657,
            "smoothness_avg": 0.13869374628732314,
            "success_improvement": 0.0,
            "time_improvement": -719.67805567414,
            "length_improvement": 21.332480057021126,
            "smoothness_improvement": 1664.1742154672959,
            "objective_score": -194.7830575906928
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m1",
    "algorithm_description": "An improved bi-directional RRT* planner that combines goal bias sampling, adaptive neighbor radius, and continuous rewiring to optimize path cost and smoothness efficiently. The planner grows two trees from start and goal, incrementally connects and rewires nodes within adaptive radii, and employs early stopping once a connection is found. Post-processing shortcutting refines the path for smoothness and shorter length. Efficient collision checking with adaptive resolution and early exits reduce planning time while maintaining robust performance.",
    "planning_mechanism": "The planner alternates growth between two trees started from start and goal. It samples with goal bias to guide exploration, steers incrementally towards samples, and maintains an adaptive neighbor radius for rewiring to locally optimize paths. Trees attempt connection after each iteration, early stopping on success. Periodic shortcutting post-processes the extracted path to improve smoothness and length before returning the final solution within a strict time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=50.0, max_neighbor_radius: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = math.dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], n_nodes: int) -> List[Node]:\n            if n_nodes < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2.0, r))\n            result = [node for node in tree if math.dist(node.position, point) <= radius]\n            return result\n\n        def choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges):\n            nearest_node_ = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos, len(tree))\n            min_cost = nearest_node_.cost + math.dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n            for nb in neighbors:\n                if nb == nearest_node_:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None, []\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path_nodes: List[Node] = []\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling: alternate sampling randomly or goal\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_free()\n\n            # Alternate expansion trees each iteration\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node, neighbors = choose_parent_and_add(tree_a, steer(nearest(tree_a, sample).position, sample, self.step_size),\n                                                       obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect the other tree to new node\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_near_b = math.dist(new_node.position, nearest_in_b.position)\n            last_connect_node = None\n            curr_pos = new_node.position\n\n            while dist_to_near_b > self.step_size:\n                next_pos = steer(curr_pos, nearest_in_b.position, self.step_size)\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_pos, next_pos, obstacles, is_3d):\n                    break\n                chosen_node, nbs = choose_parent_and_add(tree_b, next_pos, obstacles, is_3d, nodes, edges)\n                if chosen_node is None:\n                    break\n                rewire_from(chosen_node, nbs, obstacles, is_3d, edges)\n                curr_pos = chosen_node.position\n                dist_to_near_b = math.dist(curr_pos, nearest_in_b.position)\n                last_connect_node = chosen_node\n\n            # Try to connect directly if within step size\n            if last_connect_node is not None and math.dist(last_connect_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(last_connect_node.position, nearest_in_b.position, obstacles, is_3d) and \\\n                    not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d):\n\n                    final_node = Node(nearest_in_b.position, None,\n                                      last_connect_node.cost + math.dist(last_connect_node.position, nearest_in_b.position))\n                    last_connect_node.children.append(final_node)\n                    final_node.parent = last_connect_node\n                    nodes.append(final_node)\n                    tree_b.append(final_node)\n                    edges.append((last_connect_node, final_node))\n\n                    # Extract combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = final_node.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        # Avoid duplicate at connection point\n                        path_goal = path_goal[:-1]\n                    full_path = path_start + path_goal[::-1]\n\n                    # Update best path if cost better\n                    path_cost = final_node.cost + new_node.cost - math.dist(new_node.position, nearest_in_b.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path_nodes = full_path\n                        success = True\n\n                    # Early stopping on first valid path\n                    break\n\n        # If no path connected, try closest nodes\n        if not best_path_nodes:\n            # Find node closest to goal in start tree\n            goal_nearest_node = min(tree_start, key=lambda n: math.dist(n.position, goal_pos))\n            # Backtrack\n            best_path_nodes = goal_nearest_node.path_from_root()\n            success = False\n\n        # Path shortcutting/post-processing\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        best_path_nodes = shortcut_path(best_path_nodes)\n\n        return PlannerResult(\n            success=success if 'success' in locals() else False,\n            path=best_path_nodes,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.81366,
    "time_improvement": -64.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1609.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06511895656585694,
            "num_nodes_avg": 107.1,
            "path_length_avg": 167.86838334936317,
            "smoothness_avg": 0.042074717464123695,
            "success_improvement": 0.0,
            "time_improvement": -159.153092051829,
            "length_improvement": 7.9886790414557955,
            "smoothness_improvement": 558.5606950248841,
            "objective_score": -40.15991671555079
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09056892395019531,
            "num_nodes_avg": 264.7,
            "path_length_avg": 234.50722182399244,
            "smoothness_avg": 0.10901757476160132,
            "success_improvement": 0.0,
            "time_improvement": 43.651062656985864,
            "length_improvement": 21.71473943903038,
            "smoothness_improvement": 2705.100720801212,
            "objective_score": 39.64966606452005
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08601047992706298,
            "num_nodes_avg": 268.0,
            "path_length_avg": 124.56625372840308,
            "smoothness_avg": 0.13072121654165783,
            "success_improvement": 0.0,
            "time_improvement": -77.01986819959468,
            "length_improvement": 17.26902548118002,
            "smoothness_improvement": 1562.7642255733656,
            "objective_score": -4.930724043303564
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved adaptive single-tree RRT* planner with goal bias, dynamic neighbor radius based on node count, and early stopping upon goal reach. The planner favors efficient rewiring with careful collision checking and incremental path cost updates. It employs adaptive edge resolution during collision checks and maintains structural cleanliness in parent-child relationships and edge lists for performance and path quality improvements.",
    "planning_mechanism": "The planner grows a single tree from start, sampling with goal bias and steering towards samples in fixed increments. It dynamically adjusts the neighborhood radius for rewiring based on the number of nodes, enhancing path optimality. Each new node selects the best feasible parent minimizing cost after collision checks, followed by rewiring neighbors. Early termination triggers upon first successful connection to the goal, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: \"Node\"):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_dist: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Adaptive neighbor radius with gamma tuned for rewiring efficiency\n        gamma_rrt_star = 28.0\n\n        def adaptive_radius(n: int) -> float:\n            if n <= 1:\n                return gamma_rrt_star\n            return min(gamma_rrt_star * (math.log(n) / n) ** (1.0 / dim), self.step_size * 15)\n\n        def edge_collision_check(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            length = dist(p1, p2)\n            resolution = max(0.3, min(1.0, self.step_size / 3))\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [root.position]\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest neighbor (linear search)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Select best parent by cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is nearest_node:\n                    continue\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost reduction feasible and collision free\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-10 < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Early check if goal can be connected from new node\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n                    # Extract path backward\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success, extract path to closest node to goal\n        if not success and len(nodes) > 1:\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                path = []\n                curr = closest_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 40.62874,
    "time_improvement": -147.0,
    "length_improvement": 5.0,
    "smoothness_improvement": 62.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03078000545501709,
            "num_nodes_avg": 301.4,
            "path_length_avg": 169.94015754806077,
            "smoothness_avg": 0.01172918236728063,
            "success_improvement": 0.0,
            "time_improvement": -22.494800403822644,
            "length_improvement": 6.853106773786617,
            "smoothness_improvement": 83.58717437511913,
            "objective_score": -2.218640184999227
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.24716124534606934,
            "num_nodes_avg": 1153.3,
            "path_length_avg": 288.1457264228053,
            "smoothness_avg": 0.005382166606022733,
            "success_improvement": 0.0,
            "time_improvement": -53.775411257902796,
            "length_improvement": 3.8086627051955624,
            "smoothness_improvement": 38.48702339087716,
            "objective_score": -13.654990637299115
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.22617616653442382,
            "num_nodes_avg": 649.7,
            "path_length_avg": 142.22787312528027,
            "smoothness_avg": 0.01278763446880862,
            "success_improvement": 0.0,
            "time_improvement": -365.4976373084453,
            "length_improvement": 5.539018833713711,
            "smoothness_improvement": 62.657766558253144,
            "objective_score": -106.01259105951408
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with goal bias sampling, fixed rewiring radius, early stopping upon finding the first valid path within a 30-second time limit. The planner incrementally builds a tree by sampling points, extending towards them with fixed step size while avoiding obstacles. Upon adding new nodes, neighbors within a fixed radius are rewired to reduce path cost, improving path quality and smoothness. The algorithm prioritizes efficiency and path optimization through adaptive rewiring and goal bias, returning the best found path in time.",
    "planning_mechanism": "The planner samples states biased towards the goal with a fixed goal sample rate. Each sample is steered from the nearest tree node with a fixed step size, checked for collision, and connected if valid. Then, neighbors within a fixed radius are rewired to potentially improve path costs. The planner stops early once a feasible path to the goal is found or after 30 seconds. Finally, the path is extracted from the best goal-reaching node or the closest node to goal if none.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.rewire_radius = 15.0  # Fixed radius for neighbor rewiring\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = uniform_sample()\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find best parent among near nodes\n            neighbors = near_nodes(nodes, new_pos, self.rewire_radius)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better cost\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if rewired_cost < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        old_parent = nbr.parent\n                        if old_parent:\n                            old_parent.remove_child(nbr)\n                            try:\n                                edges.remove((old_parent, nbr))\n                            except ValueError:\n                                pass\n                        new_node.add_child(nbr)\n                        nbr.cost = rewired_cost\n                        edges.append((new_node, nbr))\n\n            # Check if goal can be connected directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        # Early stopping on first path found\n                        break\n\n        success = best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 19.84466,
    "time_improvement": -109.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 289.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.048426270484924316,
            "num_nodes_avg": 279.7,
            "path_length_avg": 160.81894805919956,
            "smoothness_avg": 0.021476210214576158,
            "success_improvement": 0.0,
            "time_improvement": -92.72141929999013,
            "length_improvement": 11.852586229445006,
            "smoothness_improvement": 236.1493261950383,
            "objective_score": -19.52412742135484
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2466820478439331,
            "num_nodes_avg": 968.6,
            "path_length_avg": 224.33104868500922,
            "smoothness_avg": 0.016593750167991854,
            "success_improvement": 0.0,
            "time_improvement": -53.47727069439503,
            "length_improvement": 25.111838937726233,
            "smoothness_improvement": 326.9691438175732,
            "objective_score": 0.6587678734050977
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13675882816314697,
            "num_nodes_avg": 424.7,
            "path_length_avg": 119.83094620225563,
            "smoothness_avg": 0.03180515707284166,
            "success_improvement": 0.0,
            "time_improvement": -181.46604642946517,
            "length_improvement": 20.413991268933778,
            "smoothness_improvement": 304.5592503540521,
            "objective_score": -40.66862291570902
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced informed RRT* planner with adaptive neighbor radius decreasing as the tree grows, combined with fast k-nearest neighbor search optimization, intelligent goal biasing, and efficient path shortcutting for improved smoothness and shorter path lengths. It terminates early upon first path discovery within a hard 30-second limit and always maintains valid collision-free nodes and edges.",
    "planning_mechanism": "The planner grows a tree rooted at the start node by sampling points biased towards the goal and within an ellipsoidal informed subset if a solution exists. It adaptively adjusts neighbor radius inversely proportional to the logarithm of the tree size to reduce rewiring overhead and enhances local rewiring quality. After path discovery, it applies an iterative shortcutting pass to remove unnecessary waypoints, improving smoothness. A combination of efficient collision checking and early pruning ensures fast and robust exploration within the time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0, goal_sample_rate=0.2, max_neighbor_radius=20.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float,...], b: Tuple[float,...]) -> float:\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        def sample_informed(c_best, x_start, x_goal):\n            # If no solution yet, sample uniform\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(vi / norm_v for vi in v)\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                val = c_best*c_best - c_min*c_min\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n\n            radii = [r1] + [r2]*(dim - 1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # K-Nearest linear search as a proxy for efficient neighbor search\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                di = dist(nodes[i].position, p)\n                if di < best_d:\n                    best_d = di\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        def radius_adaptive(num_nodes):\n            # Decrease with number of nodes for efficiency but keep lower bound\n            # Formula inspired by theoretical RRT* radius: gamma*(log(n)/n)^(1/d)\n            if num_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(num_nodes)/num_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        def nearby_nodes(p, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in nodes:\n                # squared distance to avoid sqrt cost\n                d2 = 0.0\n                pos = node.position\n                for i in range(dim):\n                    diff = pos[i] - p[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        # Shortcutting to improve smoothness & shorten path after solution found.\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iterations = 200\n            iteration = 0\n            while improved and iteration < max_iterations and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sampling with goal bias and informed sampling if path found\n            if (random.random() < self.goal_sample_rate):\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Nearest node\n            near_node, _ = nearest_node(sample)\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            curr_radius = radius_adaptive(len(nodes))\n\n            neighbors = nearby_nodes(new_pos, curr_radius)\n\n            # Choose best parent among neighbors (including near_node)\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early terminate on first found path\n                    break\n\n        success = False\n        extracted_path = []\n\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n            # Apply shortcutting for smoothness & length improvement\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            min_d = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 29.88804,
    "time_improvement": -160.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1607.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024425053596496583,
            "num_nodes_avg": 213.1,
            "path_length_avg": 166.19028261184675,
            "smoothness_avg": 0.04801196561764766,
            "success_improvement": 0.0,
            "time_improvement": 2.795921543027604,
            "length_improvement": 8.908472646896378,
            "smoothness_improvement": 651.4915215682581,
            "objective_score": 9.441317658887398
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.29114747047424316,
            "num_nodes_avg": 1011.8,
            "path_length_avg": 232.2715272372731,
            "smoothness_avg": 0.09733131184942458,
            "success_improvement": 0.0,
            "time_improvement": -81.14216064167789,
            "length_improvement": 22.461078642977945,
            "smoothness_improvement": 2404.4047587959576,
            "objective_score": 1.1560227872631899
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.24303045272827148,
            "num_nodes_avg": 613.8,
            "path_length_avg": 123.0584057279423,
            "smoothness_avg": 0.14673052153342167,
            "success_improvement": 0.0,
            "time_improvement": -400.1857767440491,
            "length_improvement": 18.27046632708009,
            "smoothness_improvement": 1766.4014033846272,
            "objective_score": -100.26144621004354
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional informed RRT* planner with goal bias and adaptive rewiring radius. It alternates growth of start and goal trees, uses ellipsoidal informed sampling after finding initial path, applies goal-biased sampling to accelerate convergence, and features efficient rewiring and dynamic radius reduction. Early stopping occurs after no improvement or time limit. Path stitching includes shortcutting for smoothness.",
    "planning_mechanism": "The planner maintains two RRT* trees grown alternately. Sampling is uniform initially, then uses informed ellipsoid around best path cost. To accelerate progress, samples near goal are biased. Nodes are added by best-parent selection within a shrinking neighbor radius, followed by rewiring neighbors to improve costs. Connections between trees are attempted greedily each iteration. The best path found is stitched and shortcut to reduce unnecessary waypoints for better smoothness. The process respects collision constraints and time limit, returning best feasible path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0,\n                 goal_sample_rate=0.15,  # goal bias\n                 post_opt_iters=500,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = 50.0  # constant for neighbor radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))  # unit axis\n            # orthonormal basis\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.5, self.step_size * 2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.5, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Select best parent candidate with collision free edge\n            parent_candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parent_candidates:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parent_candidates = [p]\n            best_parent = min(parent_candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list, nodes_all):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # rewire nb\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            # simple shortcutting smoothing: try to connect nodes directly and skip intermediates\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n\n        use_informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sampling: goal bias + informed sampling after first found path\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            # Rewire neighbors with new node\n            rewire(curr_tree, new_node, neighbors, edges, nodes)\n\n            # Try connecting other tree greedily toward new_node\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            while True:\n                tries += 1\n                if tries > 20:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges, nodes)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            # If connected, update best path\n            if connected_other is not None:\n                path_candidate = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(path_candidate) - 1):\n                    cost_candidate += dist(path_candidate[i], path_candidate[i+1])\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                    use_informed_sampling = True\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        # Final path smoothing by shortcutting to improve smoothness\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 7.8919,
    "time_improvement": -88.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1619.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09003095626831055,
            "num_nodes_avg": 267.5,
            "path_length_avg": 161.63330626011182,
            "smoothness_avg": 0.04679719999052493,
            "success_improvement": 0.0,
            "time_improvement": -258.29506379942467,
            "length_improvement": 11.406223595193513,
            "smoothness_improvement": 632.477801598007,
            "objective_score": -67.48239597472127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07056128978729248,
            "num_nodes_avg": 391.4,
            "path_length_avg": 233.9831879924015,
            "smoothness_avg": 0.11503521981583464,
            "success_improvement": 0.0,
            "time_improvement": 56.0991394879233,
            "length_improvement": 21.889677015492953,
            "smoothness_improvement": 2859.939062381173,
            "objective_score": 44.263243367578625
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07899618148803711,
            "num_nodes_avg": 394.7,
            "path_length_avg": 121.73083260912676,
            "smoothness_avg": 0.11520848273010573,
            "success_improvement": 0.0,
            "time_improvement": -62.58360198829204,
            "length_improvement": 19.152177180358766,
            "smoothness_improvement": 1365.4433965213254,
            "objective_score": -0.4565573056657257
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an enhanced single-tree RRT* with adaptive, time-limited planning, combining dynamic rewiring radius scaling, efficient ellipsoidal informed sampling after the first solution, goal bias sampling to accelerate convergence, and downstream cost propagation for consistent cost updates. It enforces strict collision checks on nodes and edges before expansion, integrates early termination upon no significant improvement or time limit, dynamically updates the neighborhood radius with tree growth for efficient rewiring, and maintains a continuously updated best path, returning the best feasible path found within the time budget.",
    "planning_mechanism": "The planner starts with uniform sampling to grow a tree from the start. Upon finding the first feasible path, it switches to informed ellipsoidal sampling biased towards the current best path cost and adds a small goal bias to accelerate goal connection. Each iteration samples a candidate, steers towards it with a fixed step, and validates node and edge collision. It selects the best parent among neighbors within a dynamically computed radius that shrinks as the tree grows, rewires neighbors to reduce local cost, and propagates cost updates downstream recursively to maintain path consistency. The search halts either on a hard 30-second wall-clock limit or after a configurable number of no improvement iterations to ensure efficient planning and high-quality, smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start to this node\n        self.children = []                # List of child Nodes\n        self.valid = True                 # For collision status if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0,\n                 max_no_improve: int = 300, improve_tol: float = 1e-8,\n                 goal_sample_prob: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # hard limit in seconds\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_prob = goal_sample_prob  # Probability to sample goal directly for goal bias\n\n    def plan(self, map):\n        import math, random, time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def point_in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def informed_sample(c_best, c_min):\n            # Goal bias sampling\n            if random.random() < self.goal_sample_prob:\n                return goal_pos\n            # No solution yet: uniform sample\n            if c_best == float('inf'):\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            length = math.sqrt(sum(x * x for x in diff))\n            if length < 1e-10:\n                # Degenerate, fallback uniform\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            e1 = tuple(x / length for x in diff)\n\n            if dim == 2:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = (r1, r2)\n            elif dim == 3:\n                r1 = c_best / 2.0\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                radii = (r1, r_side, r_side)\n            else:\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            for _ in range(200):\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-12:\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius_scale = random.random() ** (1.0 / dim)\n                x_scaled = [radius_scale * radii[i] * x_unit[i] for i in range(dim)]\n\n                if dim == 2:\n                    dot = e1[0]\n                    det = e1[1]\n                    cos_a = dot\n                    sin_a = det\n                    x_rot = (x_scaled[0] * cos_a - x_scaled[1] * sin_a,\n                             x_scaled[0] * sin_a + x_scaled[1] * cos_a)\n                elif dim == 3:\n                    v = (1.0, 0.0, 0.0)\n                    u = e1\n                    dot = sum(v[i] * u[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-12:\n                        x_rot = x_scaled\n                    elif abs(dot + 1.0) < 1e-12:\n                        x_rot = (-x_scaled[0], -x_scaled[1], -x_scaled[2])\n                    else:\n                        k = (v[1] * u[2] - v[2] * u[1],\n                             v[2] * u[0] - v[0] * u[2],\n                             v[0] * u[1] - v[1] * u[0])\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        k = tuple(kk / k_norm for kk in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i] * v_vec[i] for i in range(3))\n                        cross = (k[1] * v_vec[2] - k[2] * v_vec[1],\n                                 k[2] * v_vec[0] - k[0] * v_vec[2],\n                                 k[0] * v_vec[1] - k[1] * v_vec[0])\n                        x_rot = [0, 0, 0]\n                        for i in range(3):\n                            x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                else:\n                    x_rot = x_scaled\n\n                sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                if point_in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            best = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    best = node\n            return best\n\n        def near_nodes(tree, point, radius):\n            res = []\n            radius_sq = radius * radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - point[i]\n                    d_sq += delta * delta\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    res.append(node)\n            return res\n\n        def propagate_cost_downstream(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_downstream(c)\n\n        root = Node(start_pos, None, 0.0)\n        nodes = [root]\n        edges = []\n\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        found_solution = False\n\n        no_improve_count = 0\n\n        for iteration in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            x_rand = informed_sample(c_best, c_min)\n            x_nearest = nearest_node(nodes, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if not point_in_bounds(x_new_pos):\n                continue\n            if is_in_obstacle(x_new_pos):\n                continue\n            if is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                continue\n\n            # Dynamic radius per RRT* theory\n            gamma_rrt = 50.0\n            n_nodes = len(nodes) + 1\n            radius = min(\n                gamma_rrt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)),\n                self.step_size * 5.0\n            )\n\n            near = near_nodes(nodes, x_new_pos, radius)\n            if x_nearest not in near:\n                near.append(x_nearest)\n\n            best_parent = None\n            best_cost_parent = float('inf')\n            for candidate in near:\n                # Avoid selecting goal node as parent if found already (except final connection step)\n                if candidate is best_goal_node:\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, x_new_pos)\n                if candidate_cost < best_cost_parent:\n                    if not is_edge_in_obstacle(candidate.position, x_new_pos):\n                        best_parent = candidate\n                        best_cost_parent = candidate_cost\n\n            if best_parent is None:\n                continue\n\n            x_new = Node(x_new_pos)\n            x_new.parent = best_parent\n            x_new.cost = best_cost_parent\n            best_parent.add_child(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire neighbors if better via x_new\n            for candidate in near:\n                if candidate is best_parent or candidate is x_new:\n                    continue\n                new_cost = x_new.cost + dist(x_new.position, candidate.position)\n                if new_cost + self.improve_tol < candidate.cost:\n                    if not is_edge_in_obstacle(x_new.position, candidate.position):\n                        old_parent = candidate.parent\n                        if old_parent:\n                            old_parent.remove_child(candidate)\n                            try:\n                                edges.remove((old_parent, candidate))\n                            except ValueError:\n                                pass\n                        candidate.parent = x_new\n                        candidate.cost = new_cost\n                        x_new.add_child(candidate)\n                        edges.append((x_new, candidate))\n                        propagate_cost_downstream(candidate)\n\n            # Check goal reachability\n            if dist(x_new.position, goal_pos) <= self.step_size:\n                if not is_edge_in_obstacle(x_new.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + dist(x_new.position, goal_pos)\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = best_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                # Early terminate if no improvement\n                break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            success = True\n        else:\n            # fallback: closest node path to goal\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < best_goal_dist:\n                    best_goal_dist = d\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 425.29216,
    "time_improvement": -1451.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 108.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5753175735473632,
            "num_nodes_avg": 1386.6,
            "path_length_avg": 164.3531118510702,
            "smoothness_avg": 0.013251148446438713,
            "success_improvement": 0.0,
            "time_improvement": -2189.5841082123256,
            "length_improvement": 9.915455052711666,
            "smoothness_improvement": 107.40924851618242,
            "objective_score": -650.3889131894898
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.655830693244934,
            "num_nodes_avg": 2121.6,
            "path_length_avg": 248.26375044445535,
            "smoothness_avg": 0.00642133391302642,
            "success_improvement": 0.0,
            "time_improvement": -930.2021478758801,
            "length_improvement": 17.122414225798103,
            "smoothness_improvement": 65.2255466820394,
            "objective_score": -268.461068093875
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6476634740829468,
            "num_nodes_avg": 1199.6,
            "path_length_avg": 120.20076445121651,
            "smoothness_avg": 0.01986126408693374,
            "success_improvement": 0.0,
            "time_improvement": -1232.9689930468662,
            "length_improvement": 20.168375596826575,
            "smoothness_improvement": 152.63381317977792,
            "objective_score": -357.026503490065
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an adaptive-radius informed RRT* planner with enhanced sampling, dynamic rewiring radius scaling, and post-processing path shortcutting to improve planning time, path smoothness, and length. It uses a single tree, switching to ellipsoidal informed sampling after the first solution and incorporates goal biasing. The rewiring radius shrinks as the tree grows to limit computation while maintaining path quality. When a valid path is found, the algorithm performs iterative shortcutting to smooth the path before returning it. The planner enforces collision checking on nodes and edges and respects a strict hard 30-second time limit for efficient termination.",
    "planning_mechanism": "The planner incrementally samples and extends a search tree rooted at the start position within map bounds, rejecting samples inside obstacles and edges colliding with obstacles. Initially, uniform random samples explore the space; upon first solution discovery, ellipsoidal informed sampling focused on the current best path is used with goal biasing to accelerate improvement. The rewiring radius adapts by shrinking with the logarithm of node count to reduce expensive neighbor checks as the tree grows. Each iteration selects the best parent among neighbors for the new node and rewires neighbor nodes when beneficial, propagating cost downstream for consistency. After stopping early when no improvement is detected or after reaching iteration or time limits, the current best path undergoes iterative shortcutting by connecting nonconsecutive nodes directly when collision-free, thereby smoothing and shortening the path to improve quality before returning the final result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 max_no_improve: int = 150, improve_tol: float = 1e-8,\n                 goal_sample_prob: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map):\n        import math, random, time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def point_in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def informed_sample(c_best, c_min):\n            if random.random() < self.goal_sample_prob:\n                return goal_pos\n            if c_best == float('inf'):\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            length = math.sqrt(sum(x * x for x in diff))\n            if length < 1e-10:\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            e1 = tuple(x / length for x in diff)\n\n            if dim == 2:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r2)\n            elif dim == 3:\n                r1 = c_best / 2.0\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r_side, r_side)\n            else:\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            for _ in range(100):\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_raw))\n                if norm < 1e-12:\n                    continue\n                x_unit = [x/norm for x in x_raw]\n                radius_scale = random.random() ** (1.0/dim)\n                x_scaled = [radius_scale * radii[i] * x_unit[i] for i in range(dim)]\n\n                if dim == 2:\n                    cos_a, sin_a = e1[0], e1[1]\n                    x_r = x_scaled[0]*cos_a - x_scaled[1]*sin_a\n                    y_r = x_scaled[0]*sin_a + x_scaled[1]*cos_a\n                    x_rot = (x_r, y_r)\n                elif dim == 3:\n                    v = (1.0,0.0,0.0)\n                    u = e1\n                    dot = sum(v[i]*u[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-12:\n                        x_rot = x_scaled\n                    elif abs(dot + 1.0) < 1e-12:\n                        x_rot = tuple(-x for x in x_scaled)\n                    else:\n                        k = (v[1]*u[2] - v[2]*u[1], v[2]*u[0] - v[0]*u[2], v[0]*u[1] - v[1]*u[0])\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        k = tuple(kk/k_norm for kk in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1], k[2]*v_vec[0]-k[0]*v_vec[2], k[0]*v_vec[1]-k[1]*v_vec[0])\n                        x_rot = [0,0,0]\n                        for i in range(3):\n                            x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                        x_rot = tuple(x_rot)\n                else:\n                    x_rot = tuple(x_scaled)\n\n                sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                if point_in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n\n            for _ in range(50):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            best = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    best = node\n            return best\n\n        def near_nodes(tree, point, radius):\n            res = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i]-point[i]\n                    d_sq += delta*delta\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def propagate_cost_downstream(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_downstream(c)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(new_path[-1], path[j]):\n                        new_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    new_path.append(path[i+1])\n                    i += 1\n            return new_path\n\n        root = Node(start_pos, None, 0.0)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        for iteration in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            x_rand = informed_sample(c_best, c_min)\n            x_nearest = nearest_node(nodes, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if not point_in_bounds(x_new_pos):\n                continue\n            if is_in_obstacle(x_new_pos):\n                continue\n            if is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                continue\n\n            gamma_rrt = 30.0\n            n_nodes = len(nodes) + 1\n            radius = min(\n                gamma_rrt * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)),\n                self.step_size * 4.0\n            )\n\n            near = near_nodes(nodes, x_new_pos, radius)\n            if x_nearest not in near:\n                near.append(x_nearest)\n\n            best_parent = None\n            best_cost_parent = float('inf')\n            for candidate in near:\n                if candidate is best_goal_node:\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, x_new_pos)\n                if candidate_cost < best_cost_parent:\n                    if not is_edge_in_obstacle(candidate.position, x_new_pos):\n                        best_parent = candidate\n                        best_cost_parent = candidate_cost\n\n            if best_parent is None:\n                continue\n\n            x_new = Node(x_new_pos)\n            x_new.parent = best_parent\n            x_new.cost = best_cost_parent\n            best_parent.add_child(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for candidate in near:\n                if candidate is best_parent or candidate is x_new:\n                    continue\n                new_cost = x_new.cost + dist(x_new.position, candidate.position)\n                if new_cost + self.improve_tol < candidate.cost:\n                    if not is_edge_in_obstacle(x_new.position, candidate.position):\n                        old_parent = candidate.parent\n                        if old_parent:\n                            old_parent.remove_child(candidate)\n                            try:\n                                edges.remove((old_parent, candidate))\n                            except ValueError:\n                                pass\n                        candidate.parent = x_new\n                        candidate.cost = new_cost\n                        x_new.add_child(candidate)\n                        edges.append((x_new, candidate))\n                        propagate_cost_downstream(candidate)\n\n            if dist(x_new.position, goal_pos) <= self.step_size:\n                if not is_edge_in_obstacle(x_new.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + dist(x_new.position, goal_pos)\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = best_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            # Iterative path shortcutting for smoothness\n            for _ in range(15):\n                new_path = shortcut_path(extracted_path)\n                if len(new_path) >= len(extracted_path):\n                    break\n                extracted_path = new_path\n            success = True\n        else:\n            # fallback: closest node to goal\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < best_goal_dist:\n                    best_goal_dist = d\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 45.48621,
    "time_improvement": -213.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1742.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09093654155731201,
            "num_nodes_avg": 568.4,
            "path_length_avg": 162.3128190850525,
            "smoothness_avg": 0.0546003075997768,
            "success_improvement": 0.0,
            "time_improvement": -261.89901017906345,
            "length_improvement": 11.03377184827377,
            "smoothness_improvement": 754.6133804021819,
            "objective_score": -68.17637304274386
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.48117191791534425,
            "num_nodes_avg": 1256.8,
            "path_length_avg": 236.54555351247677,
            "smoothness_avg": 0.12021348492094926,
            "success_improvement": 0.0,
            "time_improvement": -199.36897857746058,
            "length_improvement": 21.03428565128971,
            "smoothness_improvement": 2993.1795532893693,
            "objective_score": -32.22422441601749
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13512969017028809,
            "num_nodes_avg": 549.9,
            "path_length_avg": 125.50091367068515,
            "smoothness_avg": 0.124008874996231,
            "success_improvement": 0.0,
            "time_improvement": -178.11308533659152,
            "length_improvement": 16.64826885123998,
            "smoothness_improvement": 1477.3837365690517,
            "objective_score": -36.05804560738821
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved RRT* planner employing adaptive neighbor radius scaling with the number of nodes, informed ellipsoidal sampling after initial solution, goal biasing, early stopping based on path stability, and post-processing path shortcutting to produce shorter, smoother paths within a strict 30-second time limit. The planner carefully manages collision checks, incrementally rewires nodes, and dynamically adjusts the neighbor radius to reduce computational overhead and enhance convergence speed.",
    "planning_mechanism": "A single-tree RRT* grows from the start position attempting to reach the goal. Initially it uniformly samples free space, but once a path is found, sampling is constrained to an informed ellipsoidal region between start and goal to focus refinement. The neighbor radius for rewiring decreases adaptively as more nodes are added, lowering the number of costly collision checks. Goal biasing helps accelerate the connection to the target. On finding a path, the planner terminates early if no improvement is observed after a fixed number of iterations. After the main search, a path shortcutting procedure iteratively attempts to replace multi-segment sections of the path with direct collision-free edges to improve path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.goal_sample_rate = 0.05  # 5% goal bias\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 150\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            # Uniform sampling if no solution yet\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            # Ellipsoidal informed sampling within prolate hyperspheroid\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        # Post-processing shortcutting for improving path length and smoothness\n        def shortcut_path(path, attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # Shortcut possible, remove intermediate nodes\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Goal bias sampling\n            if found_solution and random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost, dist(start_pos, goal_pos))\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n\n            # Adaptive radius shrinking with tree size (RRT* formula)\n            gamma_rrt_star = 20.0\n            radius = gamma_rrt_star * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1.0 / dim))\n            radius = max(self.step_size * 2.0, min(radius, self.step_size * 15))  # Clamp radius\n\n            near_nodes_list = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for near_nd in near_nodes_list:\n                if near_nd == nearest_nd:\n                    continue\n                cost_through_near = near_nd.cost + dist(near_nd.position, new_pos)\n                if cost_through_near + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_parent_cost = cost_through_near\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for near_nd in near_nodes_list:\n                if near_nd == best_parent or near_nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        # Rewire near_nd\n                        if near_nd.parent:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            near_nd.parent.remove_child(near_nd)\n                        near_nd.parent = new_node\n                        near_nd.cost = alt_cost\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            # Check if new node can connect to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            # Post-process with shortcutting to improve smoothness and length\n            extracted_path = shortcut_path(extracted_path, attempts=100)\n        else:\n            # Fallback: closest node to goal\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 244.89359,
    "time_improvement": -880.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1189.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.3428296327590942,
            "num_nodes_avg": 1016.3,
            "path_length_avg": 155.86926284725973,
            "smoothness_avg": 0.03235190360704883,
            "success_improvement": 0.0,
            "time_improvement": -1264.354775658299,
            "length_improvement": 14.56558712689055,
            "smoothness_improvement": 406.37754473343966,
            "objective_score": -368.53519269768816
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7296249628067016,
            "num_nodes_avg": 1372.8,
            "path_length_avg": 221.23650119476218,
            "smoothness_avg": 0.0752516110385425,
            "success_improvement": 0.0,
            "time_improvement": -353.94810405059684,
            "length_improvement": 26.144887961581485,
            "smoothness_improvement": 1836.2781535662866,
            "objective_score": -81.31610767039872
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5445685625076294,
            "num_nodes_avg": 1115.9,
            "path_length_avg": 113.4798197689654,
            "smoothness_avg": 0.1120675745853154,
            "success_improvement": 0.0,
            "time_improvement": -1020.787318504561,
            "length_improvement": 24.632107037783705,
            "smoothness_improvement": 1325.4912767573155,
            "objective_score": -284.82947494491145
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced RRT* planner with optimized adaptive neighbor radius scaling, balanced goal bias, and refined post-processing shortcutting. It improves planning speed and path quality by dynamically adjusting rewiring radius using updated theoretical bounds, employing a moderate goal sampling rate for better convergence, and applying an efficient path shortcutting procedure with reduced attempts for quicker path smoothing. The planner halts upon early convergence or time expiration within a strict 30-second time budget.",
    "planning_mechanism": "The planner samples points using uniform and ellipsoidal informed sampling depending on solution status, grows a single tree rooted at start, adaptively determines near neighbors radius shrinking with node count using tighter scaling constants, selectively rewires for lower-cost connections, biases sampling towards the goal moderately, and post-processes the final path by shortcutting segments iteratively to smooth and shorten it before returning the result. Early stopping occurs after a fixed number of iterations without improvement or upon time expiration.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-7\n        self.goal_sample_rate = 0.10  # Slightly increased goal bias\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 120  # Slightly reduced no improvement threshold\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-12:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x / length_a1 for x in a1)\n\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                rs = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, rs, rs)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 150:  # Reduced from 200 to 150\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-12:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-12:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-12:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n\n            # Fallback uniform sample on failure\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            # Quick linear search; could be improved with k-d tree\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def shortcut_path(path, attempts=40):  # Reduced attempts from 100 -> 40 for efficiency\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            if found_solution and random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost, dist(start_pos, goal_pos))\n\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n\n            # Updated gamma for RRT* neighbor radius (tighter bound)\n            # Use gamma_rrt_star = 15.0 (lowered from 20.0 to reduce neighbors)\n            gamma_rrt_star = 15.0\n            num_nodes = len(nodes) + 1\n            radius = gamma_rrt_star * ((math.log(num_nodes)/num_nodes)**(1.0/dim))\n            radius = max(self.step_size*2.0, min(radius, self.step_size*12))  # Slightly reduced max radius\n\n            near_nodes_list = near_nodes(nodes, new_pos, radius)\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n\n            for near_nd in near_nodes_list:\n                if near_nd == nearest_nd:\n                    continue\n                cost_thru_near = near_nd.cost + dist(near_nd.position, new_pos)\n                if cost_thru_near + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_parent_cost = cost_thru_near\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to lower cost paths\n            for near_nd in near_nodes_list:\n                if near_nd == best_parent or near_nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        if near_nd.parent is not None:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            near_nd.parent.remove_child(near_nd)\n                        near_nd.parent = new_node\n                        near_nd.cost = alt_cost\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if not found_solution or goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            extracted_path = shortcut_path(extracted_path, attempts=40)\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 260.19959,
    "time_improvement": -926.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 856.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.20769903659820557,
            "num_nodes_avg": 844.8,
            "path_length_avg": 149.1034989030335,
            "smoothness_avg": 0.028453390638559495,
            "success_improvement": 0.0,
            "time_improvement": -726.5772424681762,
            "length_improvement": 18.274009555111345,
            "smoothness_improvement": 345.3573510201714,
            "objective_score": -205.28198025228522
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6592339038848877,
            "num_nodes_avg": 1330.5,
            "path_length_avg": 222.36123093619986,
            "smoothness_avg": 0.05654285490292934,
            "success_improvement": 0.0,
            "time_improvement": -310.15315545570235,
            "length_improvement": 25.769420800338988,
            "smoothness_improvement": 1354.8883828245944,
            "objective_score": -70.80985224238432
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.8945621252059937,
            "num_nodes_avg": 1150.6,
            "path_length_avg": 116.73195365391675,
            "smoothness_avg": 0.07617227038313838,
            "success_improvement": 0.0,
            "time_improvement": -1741.1159853380634,
            "length_improvement": 22.472194561373147,
            "smoothness_improvement": 868.9056568213744,
            "objective_score": -504.50695058048825
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified but effective RRT* variant that employs goal bias sampling, fixed neighbor radius rewiring, and early termination upon finding a path. The algorithm incrementally builds a tree rooted at start, samples nodes focused toward the goal, selects parents minimizing cost with collision checks, rewires nearby nodes for local improvements, and returns the best found path within a 30-second hard time limit. This approach balances exploration and exploitation, reduces computational overhead by avoiding complex heuristics or dynamic radius adjustment, enhances path smoothness via local rewiring, and stops early to save planning time.",
    "planning_mechanism": "The planner samples points biased towards the goal to guide exploration, extends the nearest tree node toward the sample within a fixed step, finds neighbors within a fixed radius to select the lowest cost parent (if collision-free), rewires neighbors if routed through the new node reduces cost, and stops early once a goal connection is found. It ensures no nodes or edges collide with obstacles and respects map bounds and timing constraints.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: 'Node'):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.05, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def is_free_node(p: Tuple[float, ...]) -> bool:\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_dist: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def nearest_node(p: Tuple[float, ...], nodes: List[Node]) -> Node:\n            best_node = nodes[0]\n            best_dist = dist(nodes[0].position, p)\n            for node in nodes[1:]:\n                dcur = dist(node.position, p)\n                if dcur < best_dist:\n                    best_dist = dcur\n                    best_node = node\n            return best_node\n\n        def nearby_nodes(p: Tuple[float, ...], nodes: List[Node], radius: float) -> List[Node]:\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success_state = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            nearest = nearest_node(sample, nodes)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            neighbors = nearby_nodes(new_pos, nodes, self.neighbor_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and is_free_edge(neighbor.position, new_pos):\n                    min_cost = temp_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success_state = True\n                break\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state and goal_node is not None:\n            current = goal_node\n        else:\n            # No success: pick node closest to goal as path end\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 77.24188,
    "time_improvement": -297.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 179.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04287431240081787,
            "num_nodes_avg": 297.0,
            "path_length_avg": 161.88485339822716,
            "smoothness_avg": 0.016211848880362142,
            "success_improvement": 0.0,
            "time_improvement": -70.62636157308657,
            "length_improvement": 11.268346622773013,
            "smoothness_improvement": 153.75063957098027,
            "objective_score": -13.65814730040726
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.17105679512023925,
            "num_nodes_avg": 900.8,
            "path_length_avg": 233.8684053462786,
            "smoothness_avg": 0.011345709207917243,
            "success_improvement": 0.0,
            "time_improvement": -6.4257828173786296,
            "length_improvement": 21.927994766604062,
            "smoothness_improvement": 191.93326990373907,
            "objective_score": 12.188728364267543
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4438337326049805,
            "num_nodes_avg": 935.6,
            "path_length_avg": 118.39770517504482,
            "smoothness_avg": 0.02300566371376884,
            "success_improvement": 0.0,
            "time_improvement": -813.4629746850973,
            "length_improvement": 21.36588171560351,
            "smoothness_improvement": 192.63034433768271,
            "objective_score": -230.25621165447865
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified and general RRT* planner employing goal bias sampling and fixed-radius rewiring for efficient exploration and path improvement, with early termination upon connecting to the goal. The algorithm incrementally grows a tree from the start, samples guided by the goal, chooses minimum-cost parents from nearby nodes, rewires neighbors for path cost reduction, and respects a fixed 30-second runtime limit. It ensures collision-free nodes and edges within map bounds, resulting in improved planning time, path length, and smoothness.",
    "planning_mechanism": "The planner samples randomly with goal bias, steers towards samples with a fixed step, selects a parent with minimal cost within a fixed radius, rewires nearby nodes to reduce costs, stops early after reaching the goal, and continuously updates the best path within a 30-second limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            d = dist(a,b)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(a,b,max_dist):\n            d = dist(a,b)\n            if d <= max_dist:\n                return b\n            ratio = max_dist / d\n            return tuple(a[i] + ratio * (b[i]-a[i]) for i in range(dim))\n\n        def nearest(p, nodes):\n            best = nodes[0]\n            best_dist = dist(best.position, p)\n            for n in nodes[1:]:\n                nd = dist(n.position, p)\n                if nd < best_dist:\n                    best = n\n                    best_dist = nd\n            return best\n\n        def neighbors(p, nodes, radius):\n            return [n for n in nodes if dist(n.position, p) <= radius]\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal if random.random() < self.goal_sample_rate else tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample, nodes)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            near = neighbors(new_pos, nodes, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near:\n                cost_through_n = n.cost + dist(n.position, new_pos)\n                if cost_through_n < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_through_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in near:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal) <= self.step_size and is_free_node(goal) and is_free_edge(new_pos, goal):\n                goal_node = Node(goal)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            current = min(nodes, key=lambda n: dist(n.position, goal)) if nodes else None\n\n        path = []\n        while current:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
    "objective": 47.68358,
    "time_improvement": -195.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 176.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03592822551727295,
            "num_nodes_avg": 269.5,
            "path_length_avg": 163.59940352519504,
            "smoothness_avg": 0.016146991351320243,
            "success_improvement": 0.0,
            "time_improvement": -42.98310700541212,
            "length_improvement": 10.328574529396546,
            "smoothness_improvement": 152.73547840109603,
            "objective_score": -5.934109991980229
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.21809957027435303,
            "num_nodes_avg": 1031.2,
            "path_length_avg": 233.93696853869142,
            "smoothness_avg": 0.011299153915374298,
            "success_improvement": 0.0,
            "time_improvement": -35.69421479144476,
            "length_improvement": 21.90510639949459,
            "smoothness_improvement": 190.73536869418726,
            "objective_score": 3.388476245734263
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2950052976608276,
            "num_nodes_avg": 556.0,
            "path_length_avg": 123.6548444034732,
            "smoothness_avg": 0.0222822811958645,
            "success_improvement": 0.0,
            "time_improvement": -507.15623205900096,
            "length_improvement": 17.874340158150158,
            "smoothness_improvement": 183.42897210448282,
            "objective_score": -140.50512066228777
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An adaptive RRT* planner with shrinking neighbor radius, goal bias sampling, efficient rewiring, and path shortcutting post-processing. The planner incrementally builds a tree from start to goal, adaptively adjusts neighborhood size to balance exploration and exploitation, rewires nodes to minimize cost, and applies shortcutting to smooth and shorten the final path, all within a strict 30-second limit for improved efficiency and solution quality.",
    "planning_mechanism": "The planner samples points with goal bias, steers fixed step toward samples, selects minimum-cost parents within a dynamically shrinking radius, rewires neighbors for improvements, terminates early on reaching the goal, and post-processes the found path via shortcutting to enhance smoothness and shorten length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.05,\n                 radius_constant: float = 50.0, radius_decay: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_decay = radius_decay\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def node_free(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def edge_free(a, b):\n            distance = dist(a, b)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(nodes, p):\n            best = nodes[0]\n            best_d = dist(best.position, p)\n            for n in nodes[1:]:\n                d_ = dist(n.position, p)\n                if d_ < best_d:\n                    best = n\n                    best_d = d_\n            return best\n\n        def neighbors(nodes, p, radius):\n            result = []\n            r2 = radius * radius\n            for n in nodes:\n                # squared distance for efficiency\n                d2 = sum((n.position[i] - p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def path_shortcut(path):\n            if len(path) <= 2:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if edge_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n        success = False\n        goal_node = None\n\n        for k in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            \n            nearest_node = nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not node_free(new_pos):\n                continue\n            if not edge_free(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive radius shrinks with node count\n            radius = self.radius_constant * (math.log(len(nodes) + 1) / (len(nodes) + 1))**self.radius_decay\n            radius = max(radius, self.step_size)  # Ensure radius at least step_size\n\n            near_nodes = neighbors(nodes, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                cost_thru_n = n.cost + dist(n.position, new_pos)\n                if cost_thru_n < min_cost and edge_free(n.position, new_pos):\n                    min_cost = cost_thru_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in near_nodes:\n                if n is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_thru_new < n.cost and edge_free(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, n))\n\n            # Check goal connection\n            if dist(new_pos, goal_pos) <= self.step_size and node_free(goal_pos) and edge_free(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # If success, extract path, else best effort\n        if success and goal_node:\n            current = goal_node\n        else:\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        extracted_path = []\n        while current:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Path shortcutting post-processing\n        if extracted_path:\n            extracted_path = path_shortcut(extracted_path)\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 89.91836,
    "time_improvement": -363.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1564.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06624619960784912,
            "num_nodes_avg": 280.1,
            "path_length_avg": 160.00512014561212,
            "smoothness_avg": 0.05248222289545933,
            "success_improvement": 0.0,
            "time_improvement": -163.63916700192044,
            "length_improvement": 12.298658204810815,
            "smoothness_improvement": 721.4607552850605,
            "objective_score": -38.10525140126433
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6308093786239624,
            "num_nodes_avg": 1033.5,
            "path_length_avg": 230.84999241093163,
            "smoothness_avg": 0.10347418711353766,
            "success_improvement": 0.0,
            "time_improvement": -292.46837216498346,
            "length_improvement": 22.93562788462202,
            "smoothness_improvement": 2562.465363875799,
            "objective_score": -61.16680809934283
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3557199239730835,
            "num_nodes_avg": 631.0,
            "path_length_avg": 120.17640399770747,
            "smoothness_avg": 0.11856206862180438,
            "success_improvement": 0.0,
            "time_improvement": -632.1142041188854,
            "length_improvement": 20.184554650127147,
            "smoothness_improvement": 1408.1007615277706,
            "objective_score": -170.48302463795045
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A bi-directional RRT* planner with goal biasing and adaptive neighbor radius to improve search efficiency, enhanced rewiring to optimize path cost and smoothness, and early stopping. The algorithm maintains two growing trees from start and goal, samples strategically, efficiently rewires within a dynamically adjusted neighborhood, and attempts connection after each extension to find and return the best feasible path within a 30-second limit. Path extraction returns a smooth, near-optimal route with coherent parent-child node relationships.",
    "planning_mechanism": "The planner grows two trees alternatingly with goal bias sampling in a bounded domain while avoiding obstacles. Each new node is added after steering and collision checks, then rewiring rewires neighbors within an adaptive radius shrinking as sqrt((log n)/n) to improve path quality with fewer neighbors checked. After each extension, it attempts to connect the two trees efficiently. Early stopping occurs once a successful connection is found. The final path is extracted by concatenating parent pointers from both trees.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []  # Nodes other than tree roots\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            min_node = tree[0]\n            min_dist = dist(min_node.position, point)\n            for node in tree[1:]:\n                cd = dist(node.position, point)\n                if cd < min_dist:\n                    min_node = node\n                    min_dist = cd\n            return min_node\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius * radius\n            for node in tree:\n                d = 0.0\n                # Use squared distance for efficiency\n                if is_3d:\n                    d = (node.position[0]-point[0])**2 + (node.position[1]-point[1])**2 + (node.position[2]-point[2])**2\n                else:\n                    d = (node.position[0]-point[0])**2 + (node.position[1]-point[1])**2\n                if d <= r2:\n                    result.append(node)\n            return result\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def get_cost(node):\n            return node.cost\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            # Choose best parent\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                edge_free = not is_edge_in_obstacle(node.position, new_node.position)\n                if edge_free:\n                    cost_via_node = node.cost + dist(node.position, new_node.position)\n                    if cost_via_node < min_cost:\n                        min_parent = node\n                        min_cost = cost_via_node\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except Exception:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            # Try rewiring neighbors to new_node\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                edge_free = not is_edge_in_obstacle(new_node.position, node.position)\n                if edge_free:\n                    cost_via_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_via_new < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except Exception:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_via_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size and not is_edge_in_obstacle(n1.position, n2.position):\n                return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Adaptive neighbor radius factor: gamma_RRTstar ~ 2*(1+1/dim)**(1/dim) * (volume_free / zeta_ball)^(1/dim)\n        # For simplicity use basic radius proportional to (log(n)/n)^(1/dim), multiplied by a constant (20)\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            const_gamma = 20.0\n            r = const_gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(r, self.step_size*0.5)\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sampled = False\n                while not sampled:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        sampled = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Extend tree_a toward sample\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire around new_node\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to other tree\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n                        # Early stop on first solution found\n                        return PlannerResult(success=True, path=best_path, nodes=start_tree+goal_tree+all_nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree+goal_tree+all_nodes, edges=edges)",
    "objective": 3.22753,
    "time_improvement": -10.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 81.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016430163383483888,
            "num_nodes_avg": 257.8,
            "path_length_avg": 184.39486315113612,
            "smoothness_avg": 0.01233865967299053,
            "success_improvement": 0.0,
            "time_improvement": 34.6130855238688,
            "length_improvement": -1.0697464167268138,
            "smoothness_improvement": 93.12681771063177,
            "objective_score": 10.20771189567771
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02988572120666504,
            "num_nodes_avg": 601.0,
            "path_length_avg": 307.0134488211298,
            "smoothness_avg": 0.006656269561980515,
            "success_improvement": 0.0,
            "time_improvement": 81.40610975293004,
            "length_improvement": -2.489926108642665,
            "smoothness_improvement": 71.2706101469364,
            "objective_score": 23.284230311428093
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11988391876220703,
            "num_nodes_avg": 1194.6,
            "path_length_avg": 149.44686458452543,
            "smoothness_avg": 0.014141411739318493,
            "success_improvement": 0.0,
            "time_improvement": -146.73546196385547,
            "length_improvement": 0.7445084379161084,
            "smoothness_improvement": 79.877713513695,
            "objective_score": -43.1745449588385
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighbor radius, dynamic goal bias adjustment, informed sampling region pruning, and incremental shortcutting smoothing to improve planning efficiency, path quality, and smoothness within a 30-second hard time limit. The planner grows two trees simultaneously from the start and goal, alternates expansions considering heuristic cost-to-go, adapts neighbor radius based on iteration count and tree size for rewiring, prunes sampling to an informed ellipsoidal region to focus search, ensures collision-free node and edge additions, connects trees when beneficial, and incrementally shortcuts the combined path to reduce jaggedness, ensuring robust and timely path planning.",
    "planning_mechanism": "A bidirectional planner expanding start and goal trees alternately, sampling partially biased toward the goal and within an ellipsoidal informed subset that shrinks with best path cost found; steering with fixed step size; rewiring neighbors inside an adaptively shrinking radius; attempting connections between trees within neighborhood; verifying collision-free nodes and edges strictly; upon feasible path found or 30s elapsed, returns best path merged from both trees with an iterative shortcutting post-process for smoothness and shortened length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=8000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit_sec = 30.0\n        self.goal_sample_rate_min = 0.05\n        self.goal_sample_rate_max = 0.15\n        self.neighbor_gamma = 40.0  # heuristic for radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Helpers\n        def dist(a,b): return math.dist(a,b)\n\n        def clamp_pos(p):\n            return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n\n        def steer(from_pos, to_pos, step=None):\n            step = step if step is not None else self.step_size\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return clamp_pos(to_pos)\n            ratio = step / d\n            return clamp_pos(tuple(from_pos[i] + (to_pos[i]-from_pos[i]) * ratio for i in range(dim)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=0.5):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Adaptive neighbor radius depending on iteration and tree size\n        def neighbor_radius(num_nodes, iteration):\n            if num_nodes < 2:\n                return max(10.0, self.step_size*3.0)\n            r_max = max(bounds)*0.3\n            r_min = max(self.step_size, 3.0)\n            radius = self.neighbor_gamma * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            decay = 1.0 - min(iteration/self.max_iter,1.0)\n            return max(r_min, min(r_max, radius * decay))\n\n        # Compute an ellipsoid (in 2D or 3D) for informed sampling given start, goal and cost c_best\n        # Returns a function that returns samples uniformly inside that ellipsoid (or nothing if not informed)\n        def informed_sampler(c_best):\n            if c_best == float('inf'):\n                # No solution found, uniform in all bounds\n                def sampler():\n                    while True:\n                        p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(p):\n                            return p\n                return sampler\n            else:\n                c_min = dist(start_pos, goal_pos)\n                if c_best < c_min:\n                    # Numerical safeguard\n                    c_best = c_min\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                # Coordinate transform for ellipse axes\n                vec = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n                length = dist(start_pos, goal_pos)\n                if length == 0:\n                    unit_vec = tuple(1.0 for _ in range(dim))\n                else:\n                    unit_vec = tuple(v/length for v in vec)\n\n                # Rotation matrix to align x-axis to unit_vec\n                import numpy as np\n                # Construct rotation matrix via SVD or Gram-Schmidt\n                # But since imports disallowed, proceed with simple 2D rotation or identity in 3D\n                # Approximate by sampling inside axis-aligned box scaled using ellipse radii\n                # Ellipsoid radii:\n                r1 = c_best * 0.5  # major axis radius\n                r2 = math.sqrt(c_best**2 - length**2) * 0.5 if c_best**2 - length**2 > 0 else 0.0\n                if dim==2:\n                    # rotate samples after axis-aligned sampling\n                    # angle of line from start to goal\n                    angle = math.atan2(unit_vec[1], unit_vec[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n\n                    def sampler():\n                        for _ in range(100):\n                            # sample in unit disk with radii r1,r2\n                            # Uniform sampling inside ellipse:\n                            u = random.uniform(0,1)\n                            theta = random.uniform(0, 2*math.pi)\n                            r = math.sqrt(u)\n                            x_ell = r * math.cos(theta)\n                            y_ell = r * math.sin(theta)\n                            # scale\n                            x_s = x_ell * r1\n                            y_s = y_ell * r2\n                            # rotate back\n                            px = center[0] + x_s * cos_a - y_s * sin_a\n                            py = center[1] + x_s * sin_a + y_s * cos_a\n                            p = (px, py)\n                            if 0.0 <= px <= bounds[0] and 0.0 <= py <= bounds[1] and not is_in_obstacle(p):\n                                return p\n                        # fallback uniform if fail\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n                elif dim==3:\n                    # Approximate axis-aligned ellipsoid sampling (no rotation)\n                    def sampler():\n                        for _ in range(100):\n                            # sample in unit ball then scale axes by r1, r2\n                            while True:\n                                x = random.uniform(-1,1)\n                                y = random.uniform(-1,1)\n                                z = random.uniform(-1,1)\n                                if x*x + y*y + z*z <= 1:\n                                    break\n                            px = center[0] + x * r1\n                            py = center[1] + y * r2\n                            pz = center[2] + z * r2\n                            if (0.0 <= px <= bounds[0] and 0.0 <= py <= bounds[1] and 0.0 <= pz <= bounds[2]):\n                                p = (px, py, pz)\n                                if not is_in_obstacle(p):\n                                    return p\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n                else:\n                    # fallback to uniform sampling\n                    def sampler():\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in tree:\n                # squared distance\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def reconstruct_path(node_start: Node, node_goal: Node) -> List[Tuple[float,...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                # Should not happen as they should connect at different nodes\n                return path_start\n            # Remove duplicate connecting point if any\n            # Reverse goal path so it goes from connection to goal\n            path_goal_rev = path_goal[::-1]\n            # If connection point matches start path end and goal path start, remove duplication\n            if path_start[-1] == path_goal_rev[0]:\n                path_goal_rev = path_goal_rev[1:]\n            return path_start + path_goal_rev\n\n        # Incremental shortcutting to smooth path by iteratively removing collisions-free shortcuts\n        def shortcut_path(path: List[Tuple[float,...]], max_iterations=20) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize start and goal trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_tree_start = True\n\n        # Initial uninformed sampler (no cost known)\n        sample_func = informed_sampler(best_cost)\n\n        # Dynamic goal bias (adapts to iteration count)\n        def dynamic_goal_bias(iteration):\n            # Linear interpolation from max to min over iterations\n            return self.goal_sample_rate_max - (self.goal_sample_rate_max - self.goal_sample_rate_min)*(iteration/self.max_iter)\n\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            # Refresh informed sampling when better cost found\n            sample_func = informed_sampler(best_cost)\n            goal_bias = dynamic_goal_bias(iteration)\n\n            # Select which tree to expand\n            tree_a = tree_start if expand_tree_start else tree_goal\n            tree_b = tree_goal if expand_tree_start else tree_start\n\n            # Goal bias with informed sampling\n            if random.random() < goal_bias:\n                sample = goal_pos if not is_in_obstacle(goal_pos) else sample_func()\n            else:\n                sample = sample_func()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_tree_start = not expand_tree_start\n                continue\n\n            nradius = neighbor_radius(len(tree_a), iteration)\n            neighbors = near_nodes(tree_a, new_pos, nradius)\n\n            # Determine best parent for new node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors for potential cost improvements\n            for nb in neighbors:\n                if nb in (best_parent, new_node):\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if alt_cost + 1e-12 < nb.cost:\n                        # Remove old edge\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        nb.parent = new_node\n                        edges.append((new_node, nb))\n\n            # Attempt to connect new_node to nodes in other tree within radius\n            near_other = near_nodes(tree_b, new_node.position, nradius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_tree_start else other_node\n                    best_goal_node = other_node if expand_tree_start else new_node\n                    success = True\n\n            if success:\n                break\n\n            expand_tree_start = not expand_tree_start\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            extracted_path = reconstruct_path(best_start_node, best_goal_node)\n            # Apply incremental shortcutting smoothing\n            extracted_path = shortcut_path(extracted_path, max_iterations=25)\n\n        elif tree_start:\n            # Return best partial path nearest to goal from start tree\n            best_partial = None\n            best_dist = float('inf')\n            for node in tree_start:\n                dd = dist(node.position, goal_pos)\n                if dd < best_dist and node.valid:\n                    best_dist = dd\n                    best_partial = node\n            if best_partial:\n                extracted_path = best_partial.path_from_root()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
    "objective": 29.60407,
    "time_improvement": -139.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 751.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08773047924041748,
            "num_nodes_avg": 173.1,
            "path_length_avg": 172.33390380845606,
            "smoothness_avg": 0.03223173666731344,
            "success_improvement": 0.0,
            "time_improvement": -249.13988431847338,
            "length_improvement": 5.541056517127125,
            "smoothness_improvement": 404.4966711798946,
            "objective_score": -69.39484802936627
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08908915519714355,
            "num_nodes_avg": 325.8,
            "path_length_avg": 239.0912319858932,
            "smoothness_avg": 0.03733854897441827,
            "success_improvement": 0.0,
            "time_improvement": 44.57172498917517,
            "length_improvement": 20.1844649035712,
            "smoothness_improvement": 860.7477589815499,
            "objective_score": 29.785935233803023
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15108349323272705,
            "num_nodes_avg": 396.4,
            "path_length_avg": 127.61080596635233,
            "smoothness_avg": 0.08542311378049142,
            "success_improvement": 0.0,
            "time_improvement": -210.94792264699964,
            "length_improvement": 15.246978850732443,
            "smoothness_improvement": 986.5757020094738,
            "objective_score": -49.20331097361306
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "\\frac{\\log n",
    "planning_mechanism": "= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.shortcut_attempts = 40  # Reduced shortcut attempts for quick smoothing\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []  # nodes excluding roots\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                # Uniform random free sample\n                while True:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n\n            for tree_a, tree_b in trees:\n                # Extend tree_a toward sample\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                # Skip invalid positions or edges\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire neighbors within adaptive radius\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to the opposite tree to shortcut search\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n\n                        # Early stopping immediately when connection found\n                        # Proceed to final path shortcutting before returning\n                        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n                        return PlannerResult(success=True, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n        # If no solution, try to return partial best path from closest node in start tree to start pos\n        if not success:\n            closest_node = min(all_nodes + start_tree, key=lambda n: dist(n.position, goal_pos))\n            best_path = []\n            cur = closest_node\n            while cur:\n                best_path.append(cur.position)\n                cur = cur.parent\n            best_path.reverse()\n\n        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n\n        return PlannerResult(success=success, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d: bool, dim: int, attempts: int = 40) -> List[Tuple[float, ...]]:\n        \"\"\"Path shortcutting by attempting to replace 2+ node segments with a single edge.\"\"\"\n        if len(path) < 3:\n            return path\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(f_pos, t_pos, resolution=1.0):\n            distance = math.dist(f_pos, t_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[d] + (t_pos[d] - f_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        new_path = list(path)\n        for _ in range(attempts):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                # Shortcut by removing intermediate nodes\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path",
    "objective": -21.73093,
    "time_improvement": 32.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 949.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018609023094177245,
            "num_nodes_avg": 265.4,
            "path_length_avg": 174.46813050769455,
            "smoothness_avg": 0.02052379402865142,
            "success_improvement": 0.0,
            "time_improvement": 25.941904949863755,
            "length_improvement": 4.371253044288279,
            "smoothness_improvement": 221.24194468046562,
            "objective_score": 11.511533034934422
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.030954933166503905,
            "num_nodes_avg": 599.4,
            "path_length_avg": 246.56024222272634,
            "smoothness_avg": 0.07105362816383905,
            "success_improvement": 0.0,
            "time_improvement": 80.74088204453314,
            "length_improvement": 17.691094302976712,
            "smoothness_improvement": 1728.2610305153203,
            "objective_score": 43.47822634772257
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.053578948974609374,
            "num_nodes_avg": 618.0,
            "path_length_avg": 128.47415638420375,
            "smoothness_avg": 0.07830938655910784,
            "success_improvement": 0.0,
            "time_improvement": -10.27189353903225,
            "length_improvement": 14.67358261152458,
            "smoothness_improvement": 896.0896168341985,
            "objective_score": 10.203029589376065
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "Enhanced bidirectional RRT* with adaptive rewiring radius and integrated incremental path shortcutting, combining efficient collision checking and goal bias sampling for faster convergence and smoother, shorter paths.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately extending toward sampled points (with goal bias). It uses an adaptive neighbor radius based on logarithmic scaling for efficient rewiring optimizing path cost. Incremental path shortcutting is applied during planning to improve smoothness and path length progressively. The planner enforces strict collision checks on nodes and edges, respects map boundaries, and halts immediately when time limit is reached, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n\n        def dist(a,b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=0.5):\n            distance = dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_p[d] + (to_p[d]-from_p[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            res = []\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                if is_3d:\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    res.append(node)\n            return res\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1: \n                return self.step_size*2.5\n            gamma = 15.0\n            return max(gamma * ((math.log(num_nodes)/num_nodes) ** (1/dim)), self.step_size*0.5)\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node is new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    c = node.cost + dist(node.position, new_node.position)\n                    if c < min_cost:\n                        min_parent = node\n                        min_cost = c\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            for node in near_nodes:\n                if node is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through\n                        new_node.add_child(node)\n\n        def try_connect(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if dist(new_node.position, nearest_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_node.position):\n                    return nearest_node\n            return None\n\n        def incremental_shortcut(path, attempts=20):\n            if len(path) < 3:\n                return path\n            new_path = list(path)\n            for _ in range(attempts):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1]+new_path[j:]\n            return new_path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        trees = [(start_tree, goal_tree),(goal_tree, start_tree)]\n        for itr in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else None\n            if sample is None:\n                for _ in range(10):\n                    q = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n                if sample is None:\n                    continue  # failed to sample a free point after tries\n\n            for treeA, treeB in trees:\n                nearest_node = nearest(treeA, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not is_in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                radius = neighbor_radius(len(treeA))\n                rewire(treeA, new_node, radius)\n\n                connect_node = try_connect(new_node, treeB)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        best_path = incremental_shortcut(best_path, attempts=15)\n                        success = True\n            if success:\n                # incremental shortcut again to polish slightly before stopping\n                best_path = incremental_shortcut(best_path, attempts=25)\n                break\n\n        if not success and all_nodes:\n            # fallback: best node nearest goal in start tree\n            candidate = min(start_tree + all_nodes, key=lambda n: dist(n.position, goal_pos))\n            path_fallback = []\n            cur = candidate\n            while cur:\n                path_fallback.append(cur.position)\n                cur = cur.parent\n            path_fallback.reverse()\n            best_path = incremental_shortcut(path_fallback, attempts=15)\n            success = False\n\n        nodes = start_tree + goal_tree + all_nodes\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 1.31504,
    "time_improvement": -38.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 771.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03619341850280762,
            "num_nodes_avg": 424.2,
            "path_length_avg": 180.94077229406216,
            "smoothness_avg": 0.022140176054999076,
            "success_improvement": 0.0,
            "time_improvement": -44.03849219301509,
            "length_improvement": 0.8234955156076187,
            "smoothness_improvement": 246.54183342255664,
            "objective_score": -11.484741181427172
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.053159022331237794,
            "num_nodes_avg": 853.6,
            "path_length_avg": 256.15880215041796,
            "smoothness_avg": 0.048649242083894054,
            "success_improvement": 0.0,
            "time_improvement": 66.92624480990813,
            "length_improvement": 14.486818719884454,
            "smoothness_improvement": 1151.7800394513142,
            "objective_score": 34.52886487215968
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11569452285766602,
            "num_nodes_avg": 1265.8,
            "path_length_avg": 125.77827142101594,
            "smoothness_avg": 0.079658761276128,
            "success_improvement": 0.0,
            "time_improvement": -138.11318347538923,
            "length_improvement": 16.464061039827072,
            "smoothness_improvement": 913.2535636342143,
            "objective_score": -26.989250600549454
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements a hybrid bidirectional RRT* planner with dynamic adaptive rewiring radius and enhanced goal-biased ellipsoidal informed sampling. It grows two trees alternately from start and goal, efficiently connecting them via incremental greedy expansion and rewiring for path quality. Early stopping occurs upon path improvement stagnation or time limit. The final path is stitched and smoothed by iterative shortcutting for better smoothness and shorter length. The method uses quick rejection of invalid samples and edges, robust parent selection and rewiring, and a careful time budget balancing exploration and quality refinement.",
    "planning_mechanism": "The planner alternately expands two RRT* trees rooted at start and goal. Sampling is initially uniform, then switches to goal bias and ellipsoidal informed sampling after finding a first feasible path to improve convergence speed. Each new sample is connected to the best parent in its adaptive radius neighborhood, followed by rewiring for cost improvement. Trees attempt greedy connection after each new node addition to find a combined path. Early stopping triggers on lack of improvement or reaching the time limit. Upon completion, the path is extracted by stitching the two tree branches and then refined using iterative shortcutting to remove unnecessary waypoints and smooth the path, returning the optimal collision-free path found within the time budget.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        current = self\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int=6000,\n                 step_size: float=5.0,\n                 goal_sample_rate: float=0.10,\n                 max_no_improve: int=120,\n                 post_opt_iters: int=400,\n                 improve_tol: float=1e-6,\n                 time_limit_sec: float=30.0,\n                 gamma_rrt_star: float=35.0,\n                 max_connection_tries: int=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_connection_tries = max_connection_tries\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(10):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n            # Fallback to rejection-less uniform (rare)\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))  # principal axis unit vector\n            # Construct orthonormal basis\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        return [x / norm_v for x in v]\n\n            u = sample_unit_ball(dim)\n            r = random.random() ** (1 / dim)\n            scaled_u = [u[i] * r * radii[i] for i in range(dim)]\n            mapped = [center[i] + sum(basis[j][i]*scaled_u[j] for j in range(dim)) for i in range(dim)]\n            clipped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size*2.5, 3.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size, 3.0)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= r2]\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    d += (n.position[i]-p[i])**2\n                    if d > best_d*best_d:\n                        break\n                if d < best_d*best_d:\n                    best = n\n                    best_d = math.sqrt(d)\n            return best\n\n        def add_node_rrt_star(tree, pos, nodes_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parent_candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parent_candidates:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parent_candidates = [p]\n            best_parent = min(parent_candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges, nodes_all):\n            updated = False\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n                    updated = True\n            return updated\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(node_start, node_goal, start_side):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            if not start_side:\n                merged.reverse()\n            return merged\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_counter = 0\n        post_iter_counter = 0\n\n        # Alternates growing two trees\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n            is_start_tree = (iteration % 2 == 0)\n            curr_tree = tree_start if is_start_tree else tree_goal\n            other_tree = tree_goal if is_start_tree else tree_start\n\n            # Sampling with informed ellipsoid and goal bias\n            c_min = dist(start_pos, goal_pos)\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if is_start_tree else start_pos\n                else:\n                    sample_pt = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos if is_start_tree else start_pos\n                else:\n                    sample_pt = uniform_sample()\n\n            if not within_bounds(sample_pt):\n                continue\n            if is_in_obstacle(sample_pt):\n                continue\n\n            nearest_node = nearest(curr_tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes)\n            if new_node is None:\n                if found_first:\n                    post_iter_counter += 1\n                    no_improve_counter += 1\n                    if post_iter_counter >= self.post_opt_iters or no_improve_counter >= self.max_no_improve:\n                        break\n                continue\n\n            rewired = rewire(curr_tree, new_node, neighbors, edges, nodes)\n            # Add edge from parent to new_node if not exist\n            if new_node.parent and (new_node.parent, new_node) not in edges:\n                edges.append((new_node.parent, new_node))\n\n            # Attempt greedy connection from other tree toward new_node\n            connected_other = None\n            current = nearest(other_tree, new_node.position)\n            tries = 0\n            while tries < self.max_connection_tries:\n                tries += 1\n                step_pos = steer(current.position, new_node.position)\n                if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new_node, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes)\n                if other_new_node is None:\n                    break\n                rewire(other_tree, other_new_node, other_neighbors, edges, nodes)\n                if other_new_node.parent and (other_new_node.parent, other_new_node) not in edges:\n                    edges.append((other_new_node.parent, other_new_node))\n                current = other_new_node\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        connect_node = Node(new_node.position, parent=None,\n                                            cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(connect_node)\n                        other_tree.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((current, connect_node))\n                        connected_other = connect_node\n                    break\n\n            if connected_other:\n                candidate_path = stitch_path(new_node, connected_other, is_start_tree)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_counter = 0\n                    post_iter_counter = 0\n                else:\n                    if found_first:\n                        no_improve_counter += 1\n                if found_first:\n                    post_iter_counter += 1\n                    if post_iter_counter >= self.post_opt_iters or no_improve_counter >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter_counter += 1\n                    no_improve_counter += 1\n                    if post_iter_counter >= self.post_opt_iters or no_improve_counter >= self.max_no_improve:\n                        break\n\n        success = len(best_path) > 0\n        if success:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by,\n                az * bx - ax * bz,\n                ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 84.63905,
    "time_improvement": -348.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1675.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.20294671058654784,
            "num_nodes_avg": 675.2,
            "path_length_avg": 153.48419081620688,
            "smoothness_avg": 0.044731434924105126,
            "success_improvement": 0.0,
            "time_improvement": -707.6644704382082,
            "length_improvement": 15.872882900995494,
            "smoothness_improvement": 600.1440924278963,
            "objective_score": -199.77489092872568
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.16162500381469727,
            "num_nodes_avg": 537.4,
            "path_length_avg": 231.77697837818573,
            "smoothness_avg": 0.12362390383584557,
            "success_improvement": 0.0,
            "time_improvement": -0.5576395942060614,
            "length_improvement": 22.626173286940947,
            "smoothness_improvement": 3080.9320883951063,
            "objective_score": 28.813072535878284
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.21143004894256592,
            "num_nodes_avg": 566.4,
            "path_length_avg": 123.2735933524865,
            "smoothness_avg": 0.11340703170832729,
            "success_improvement": 0.0,
            "time_improvement": -335.1483613274254,
            "length_improvement": 18.127548952991376,
            "smoothness_improvement": 1342.5290724935862,
            "objective_score": -82.95533366396486
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with fixed rewiring radius, goal bias sampling, and early stopping upon first path discovery. It alternately grows trees from start and goal, performs best parent selection and local rewiring in a fixed radius, and attempts greedy connections between trees at each iteration. The planner uses linear nearest neighbor searches and collision checks, focuses sampling within the map bounds (with goal bias), prunes unnecessary expansions, and returns the best feasible path found within a hard 30-second limit.",
    "planning_mechanism": "The planner grows two trees simultaneously, selects best parents within a fixed radius to add new nodes, rewires neighbors for path cost improvement, and attempts to connect the two trees greedily. It uses goal bias sampling to accelerate convergence, employs fixed-step steering toward samples, and halts early after finding the first complete path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n        self.rewire_radius = 15.0  # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist_e = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(dist_e / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[d] - point[d])**2 for d in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def choose_best_parent(tree, new_pos):\n            neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n            candidates = [n for n in neighbors if is_free_edge(n.position, new_pos)]\n            if not candidates:\n                n_near = nearest(tree, new_pos)\n                if is_free_edge(n_near.position, new_pos):\n                    candidates = [n_near]\n                else:\n                    return None, []\n            best_parent = min(candidates, key=lambda n: n.cost + dist(n.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, neighbors\n\n        def rewire(new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_free_edge(new_node.position, nb.position):\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Remove nb from its old parent children if present\n                        if nb.parent is not None and nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n\n        def stitch_paths(node_a, node_b, from_start):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            # Avoid duplicate connection point\n            if path_a[-1] == path_b[-1]:\n                full_path = path_a + path_b[-2::-1]\n            else:\n                full_path = path_a + path_b[::-1]\n            return full_path if from_start else full_path[::-1]\n\n        nodes = []\n        edges = []\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            t_now = time.monotonic()\n            if t_now - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_grow = tree_start\n                tree_other = tree_goal\n                from_start = True\n            else:\n                tree_grow = tree_goal\n                tree_other = tree_start\n                from_start = False\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not is_free_node(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not is_free_node(new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n                continue\n\n            if not is_free_edge(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n                continue\n\n            new_node, neighbors = choose_best_parent(tree_grow, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n                continue\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            rewire(new_node, neighbors)\n\n            # Attempt greedy connect from other tree toward new_node\n            other_nearest = nearest(tree_other, new_node.position)\n            current = other_nearest\n            connected_node = None\n            while True:\n                step_toward = steer(current.position, new_node.position)\n                if not is_free_node(step_toward):\n                    break\n                if not is_free_edge(current.position, step_toward):\n                    break\n                add_node, add_neighbors = choose_best_parent(tree_other, step_toward)\n                if add_node is None:\n                    break\n                nodes.append(add_node)\n                edges.append((add_node.parent, add_node))\n                rewire(add_node, add_neighbors)\n                current = add_node\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if is_free_edge(current.position, new_node.position):\n                        connect_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(connect_node)\n                        tree_other.append(connect_node)\n                        nodes.append(connect_node)\n                        edges.append((current, connect_node))\n                        connected_node = connect_node\n                    break\n\n            if connected_node is not None:\n                candidate_path = stitch_paths(new_node, connected_node, from_start)\n                candidate_cost = sum(dist(candidate_path[i], candidate_path[i+1]) for i in range(len(candidate_path)-1))\n                if candidate_cost + 1e-8 < best_cost:\n                    best_path = candidate_path\n                    best_cost = candidate_cost\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > 100:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 222.74163,
    "time_improvement": -789.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 352.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.16015326976776123,
            "num_nodes_avg": 314.3,
            "path_length_avg": 157.19664919248973,
            "smoothness_avg": 0.026851051075478333,
            "success_improvement": 0.0,
            "time_improvement": -537.3599524825224,
            "length_improvement": 13.838025637287336,
            "smoothness_improvement": 320.27725732189805,
            "objective_score": -151.30378407577481
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9230027675628663,
            "num_nodes_avg": 944.7,
            "path_length_avg": 228.251525777321,
            "smoothness_avg": 0.01764407845718192,
            "success_improvement": 0.0,
            "time_improvement": -474.2612680860545,
            "length_improvement": 23.803070839636298,
            "smoothness_improvement": 353.9948472193215,
            "objective_score": -126.22656368593798
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7064130783081055,
            "num_nodes_avg": 725.6,
            "path_length_avg": 116.52187582094368,
            "smoothness_avg": 0.037786973222006894,
            "success_improvement": 0.0,
            "time_improvement": -1353.8827143228668,
            "length_improvement": 22.61171825520244,
            "smoothness_improvement": 380.6475102396944,
            "objective_score": -390.6945457925401
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A straightforward single-tree RRT* planner with goal biasing, fixed radius rewiring, and early termination on first solution. It samples random points within bounds, steers with fixed step size, performs near neighborhood rewiring to reduce cost, checks full collision for nodes and edges, and constructs the path by traversing parents once the goal vicinity is reached.",
    "planning_mechanism": "The planner incrementally grows a single tree from the start position, repeatedly sampling points biased towards the goal. Each new point is connected via the lowest cost parent among neighbors within a fixed radius, followed by rewiring neighbors to improve path optimality. The search ends early when a node reaches sufficiently close to the goal, returning the minimal cost feasible path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n        self.rewire_radius = 15.0\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            # Adaptive resolution relative to step size for efficiency\n            resolution = min(1.0, self.step_size * 0.5)\n            distance = dist(a,b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    return False\n            return True\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree, point, radius):\n            radius_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if d_sq <= radius_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        tree = [Node(start, cost=0.0)]\n        nodes = [tree[0]]\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not is_free_node(sample):\n                continue\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position,new_pos):\n                continue\n\n            neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n            # Filter neighbors with collision-free edge\n            neighbors = [n for n in neighbors if is_free_edge(n.position,new_pos)]\n            if not neighbors:\n                # fallback to nearest if reachable\n                if is_free_edge(nearest_node.position,new_pos):\n                    neighbors = [nearest_node]\n                else:\n                    continue\n\n            # Choose best parent minimizing cost\n            best_parent = min(neighbors, key=lambda n: n.cost + dist(n.position,new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position,new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors to possibly better parent via new_node\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if new_node.cost + dist(new_node.position,nb.position) + 1e-12 < nb.cost:\n                    if is_free_edge(new_node.position, nb.position):\n                        if nb.parent:\n                            try:\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = new_node.cost + dist(new_node.position, nb.position)\n                        new_node.children.append(nb)\n\n            # Check if new node close enough to goal\n            if dist(new_node.position, goal) <= self.step_size and is_free_edge(new_node.position, goal):\n                goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist(new_node.position,goal))\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node,goal_node))\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    # Early stop upon first feasible path\n                    break\n\n        if best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=best_goal_node.path_from_root(),\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
    "objective": 306.13417,
    "time_improvement": -1064.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 302.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12818892002105714,
            "num_nodes_avg": 252.0,
            "path_length_avg": 163.64725631568874,
            "smoothness_avg": 0.020948961416565427,
            "success_improvement": 0.0,
            "time_improvement": -410.15183200370427,
            "length_improvement": 10.302345656650964,
            "smoothness_improvement": 227.8967375670801,
            "objective_score": -115.7246585192853
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.7313974618911743,
            "num_nodes_avg": 1074.9,
            "path_length_avg": 224.46193309452465,
            "smoothness_avg": 0.017319198521534195,
            "success_improvement": 0.0,
            "time_improvement": -977.2172489275678,
            "length_improvement": 25.068145954531136,
            "smoothness_improvement": 345.63545247354625,
            "objective_score": -276.39610984318386
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9261471271514893,
            "num_nodes_avg": 645.8,
            "path_length_avg": 115.68684492849779,
            "smoothness_avg": 0.033883399164497036,
            "success_improvement": 0.0,
            "time_improvement": -1806.1217019230298,
            "length_improvement": 23.16630601406683,
            "smoothness_improvement": 330.99433636003414,
            "objective_score": -526.2817552866687
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with goal bias sampling, fixed rewiring radius, and early stopping upon first solution. It grows a tree from start by sampling points within bounds, steering with fixed step size toward samples, rewiring neighbors within a radius to reduce path cost, and terminates once a node connects to the goal. The planner performs collision checking for nodes and edges and returns the best path found within a 30-second time limit.",
    "planning_mechanism": "The planner incrementally expands a tree rooted at the start, biasing samples toward the goal to accelerate convergence. Each new valid node connects to the lowest-cost parent in its neighborhood, followed by rewiring nearby nodes to improve overall path cost. The search ends early when a goal-reaching node is found, returning the optimized feasible path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n        self.rewire_radius = 15.0\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return False\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return False\n            return True\n\n        def is_free_edge(a,b):\n            resolution = min(1.0, self.step_size * 0.5)\n            dist_ab = dist(a,b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if not is_free_node(pt):\n                    return False\n            return True\n\n        def nearest(nodes, point):\n            best, best_dist = None, float('inf')\n            for node in nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best, best_dist = node, d\n            return best\n\n        def near_nodes(nodes, point, radius):\n            r2 = radius*radius\n            neighbors = []\n            for node in nodes:\n                d2 = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if d2 <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        tree = [Node(start, cost=0.0)]\n        best_goal_node = None\n        best_cost = float('inf')\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            sample = goal if random.random() < self.goal_sample_rate else tuple(random.uniform(0,y) for y in bounds)\n            if not is_free_node(sample):\n                continue\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n            neighbors = [n for n in neighbors if is_free_edge(n.position, new_pos)]\n            if not neighbors:\n                if is_free_edge(nearest_node.position, new_pos):\n                    neighbors = [nearest_node]\n                else:\n                    continue\n\n            best_parent = min(neighbors, key=lambda n: n.cost + dist(n.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            for neighbor in neighbors:\n                if neighbor is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-12 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = potential_cost\n                        new_node.children.append(neighbor)\n\n            if dist(new_node.position, goal) <= self.step_size and is_free_edge(new_node.position, goal):\n                goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist(new_node.position, goal))\n                new_node.children.append(goal_node)\n                tree.append(goal_node)\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    break\n\n        if best_goal_node:\n            return PlannerResult(\n                success=True,\n                path=best_goal_node.path_from_root(),\n                nodes=tree,\n                edges=[(node.parent, node) for node in tree if node.parent is not None]\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=tree,\n                edges=[(node.parent, node) for node in tree if node.parent is not None]\n            )",
    "objective": 515.79895,
    "time_improvement": -1763.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 293.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.37026526927948,
            "num_nodes_avg": 360.3,
            "path_length_avg": 164.19561068414941,
            "smoothness_avg": 0.022199041071636567,
            "success_improvement": 0.0,
            "time_improvement": -1373.5400330952398,
            "length_improvement": 10.001783938066648,
            "smoothness_improvement": 247.46319876036296,
            "objective_score": -404.8236235719301
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.8678485870361328,
            "num_nodes_avg": 945.6,
            "path_length_avg": 226.28180570154254,
            "smoothness_avg": 0.016619058411570846,
            "success_improvement": 0.0,
            "time_improvement": -1062.1125481739762,
            "length_improvement": 24.460620096179976,
            "smoothness_improvement": 327.6203431536517,
            "objective_score": -302.31929067871664
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.4355554580688477,
            "num_nodes_avg": 790.1,
            "path_length_avg": 113.94362898431163,
            "smoothness_avg": 0.0316849621735755,
            "success_improvement": 0.0,
            "time_improvement": -2854.545053068555,
            "length_improvement": 24.324067041172217,
            "smoothness_improvement": 303.0303801072511,
            "objective_score": -840.2539237953268
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An adaptive-radius informed RRT* planner with goal bias sampling and path shortcutting postprocessing that balances exploration and refinement. It uses a dynamic rewiring radius shrinking as more nodes are added, reducing computational overhead. The planner samples near the goal with a higher frequency, steers nodes incrementally towards samples, rewires neighbors efficiently, and applies iterative shortcutting to smooth and shorten the path before returning within a 30-second time limit. Early stopping happens upon timeout or path improvement stagnation.",
    "planning_mechanism": "The planner grows a single tree using informed, goal-biased sampling while dynamically adapting the rewiring radius based on the current number of nodes for efficient rewiring. It incrementally improves the path via rewiring and postprocessing shortcutting, balancing search speed and path quality, all under a strict time cutoff.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, dd = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + dd:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(s):\n                        return s\n\n        def nearest(nodes_list, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            for n in nodes_list:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def neighbors(nodes_list, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                dx = [n.position[i] - point[i] for i in range(dim)]\n                dist_sq = sum(x * x for x in dx)\n                if dist_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius based on RRT* guarantees formula\n        def rewiring_radius(n_nodes):\n            gamma = 30.0\n            eta = self.step_size\n            unit_ball_volume = 3.141592653589793 if dim == 2 else (4.0/3.0)*3.141592653589793\n            radius = min(gamma * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim)), eta * 5)\n            return max(radius, eta)\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        last_improvement_iter = 0\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            sample_point = sample()\n            nearest_node = nearest(nodes, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(nodes))\n            near_nodes = neighbors(nodes, new_pos, radius)\n\n            # Choose parent minimizing cost + dist while collision-free\n            cost_min = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in near_nodes:\n                tcost = nbr.cost + dist(nbr.position, new_pos)\n                if tcost < cost_min:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        cost_min = tcost\n\n            new_node = Node(new_pos, best_parent, cost_min)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if cheaper and collision-free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        old_parent = nbr.parent\n                        if old_parent:\n                            old_parent.remove_child(nbr)\n                            try:\n                                edges.remove((old_parent, nbr))\n                            except ValueError:\n                                pass\n                        new_node.add_child(nbr)\n                        nbr.cost = new_cost\n                        edges.append((new_node, nbr))\n\n            # Try to connect directly to goal if close enough and cheaper\n            dist_goal = dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if goal_cost < best_cost:\n                    goal_node = Node(goal_pos, new_node, goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    last_improvement_iter = it\n\n            # Early stopping on no improvement for many iterations after path found\n            if best_goal_node is not None and (it - last_improvement_iter) > 300:\n                break\n\n        # Path extraction\n        if best_goal_node is not None:\n            path = best_goal_node.path_from_root()\n        else:\n            # No goal reached: return path to closest node to goal\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            path = closest_node.path_from_root()\n\n        # Path shortcutting postprocess to smooth and shorten path\n        def shortcut_path(path_in):\n            path_out = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                while next_idx > idx + 1:\n                    if not is_edge_in_obstacle(path_in[idx], path_in[next_idx]):\n                        break\n                    next_idx -= 1\n                path_out.append(path_in[next_idx])\n                idx = next_idx\n            return path_out\n\n        # Apply shortcutting iteratively until no improvement or timeout\n        shortcut_start = time.monotonic()\n        for _ in range(100):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n            new_path = shortcut_path(path)\n            if len(new_path) < len(path):\n                path = new_path\n            else:\n                break\n\n        success = best_goal_node is not None\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 259.62939,
    "time_improvement": -869.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1531.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.15509161949157715,
            "num_nodes_avg": 536.1,
            "path_length_avg": 167.5062817788863,
            "smoothness_avg": 0.04824351372371287,
            "success_improvement": -9.999999999999998,
            "time_improvement": -517.2161665692533,
            "length_improvement": 8.18715265010074,
            "smoothness_improvement": 655.1157522429388,
            "objective_score": -196.97697961950087
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.5168482065200806,
            "num_nodes_avg": 1369.3,
            "path_length_avg": 231.88578971747611,
            "smoothness_avg": 0.10099400397599848,
            "success_improvement": 0.0,
            "time_improvement": -843.7319206206498,
            "length_improvement": 22.58984892992507,
            "smoothness_improvement": 2498.648465343209,
            "objective_score": -227.07242450152384
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6546413898468018,
            "num_nodes_avg": 832.0,
            "path_length_avg": 120.03500777363611,
            "smoothness_avg": 0.12096402547679444,
            "success_improvement": 0.0,
            "time_improvement": -1247.3303793555224,
            "length_improvement": 20.278463289590686,
            "smoothness_improvement": 1438.6534754292315,
            "objective_score": -354.8387684557561
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
    "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 70.02349,
    "time_improvement": -295.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1330.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.18990304470062255,
            "num_nodes_avg": 574.6,
            "path_length_avg": 151.92005163885307,
            "smoothness_avg": 0.0438427966152012,
            "success_improvement": 0.0,
            "time_improvement": -655.754757440736,
            "length_improvement": 16.73021236947447,
            "smoothness_improvement": 586.234973184576,
            "objective_score": -183.7571249446132
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06414504051208496,
            "num_nodes_avg": 382.5,
            "path_length_avg": 235.82771215538,
            "smoothness_avg": 0.09195275777999899,
            "success_improvement": 0.0,
            "time_improvement": 60.0911139159804,
            "length_improvement": 21.273921758206445,
            "smoothness_improvement": 2266.01068857373,
            "objective_score": 42.12174067258664
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.18937287330627442,
            "num_nodes_avg": 510.0,
            "path_length_avg": 118.45844668308948,
            "smoothness_avg": 0.09740963788912176,
            "success_improvement": 0.0,
            "time_improvement": -289.7520523276069,
            "length_improvement": 21.32554009816004,
            "smoothness_improvement": 1139.043403918075,
            "objective_score": -68.43507461979567
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An advanced unidirectional RRT* variant with integrated informed sampling after initial solution, adaptive neighbor radius neighborhood search, and efficient incremental rewiring supported by a basic spatial grid for fast neighbor queries. The planner employs dynamic goal biasing, early stopping upon acceptable solution discovery or time limit, and post-processing path shortcutting to significantly improve planning time, path length, and smoothness.",
    "planning_mechanism": "The planner grows a tree from the start position by sampling either uniformly or within an ellipsoidal informed subset after first solution found, extending the nearest node by a limited step. It then efficiently finds neighbors within an adaptive radius using a grid-based spatial hashing structure for faster rewiring. Nodes are connected to the best parent minimizing cost and neighbors are rewired to improve paths. Early termination is triggered when a sufficiently good path is found or the time limit expires. Finally, shortcutting post-processing removes unnecessary waypoints for smoother paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0, goal_sample_rate: float = 0.15, max_neighbor_radius: float = 20.0, min_neighbor_radius: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Distance metric\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        # Clamp point inside bounds\n        def clamp_point(p):\n            return tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoid region after first solution found\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix using Gram-Schmidt for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    # 2D rotate so that x-axis aligns with a\n                    cos_theta, sin_theta = a\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    # find orthogonal vector\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = [temp[i] - sum(x_axis[j]*temp[j] for j in range(3))*x_axis[i] for i in range(3)]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = [vi/norm_v for vi in v]\n                    w = [x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius for rewiring based on theory\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # --- Basic spatial grid for neighbor search ---\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                # Iterate over neighboring cells in grid\n                def expand_coords(ci, r_cells):\n                    if self.dim == 2:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                yield (ci[0]+dx, ci[1]+dy)\n                    elif self.dim == 3:\n                        for dx in range(-r_cells,r_cells+1):\n                            for dy in range(-r_cells,r_cells+1):\n                                for dz in range(-r_cells,r_cells+1):\n                                    yield (ci[0]+dx, ci[1]+dy, ci[2]+dz)\n                    else:\n                        return [] # Not supported\n                for c in expand_coords(ci, r_cells):\n                    if c in self.cells:\n                        neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialization\n        root = Node(start_pos)\n        nodes.append(root)\n        edges = []\n        grid_cell_size = self.max_neighbor_radius  # Reasonable cell size for approximate neighbors\n        spatial_grid = SpatialGrid(bounds, grid_cell_size)\n        spatial_grid.add_node(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Early stopping parameters\n        min_improvement_cost = 1e-4\n        no_improve_count = 0\n        max_no_improve = 1500\n\n        for it in range(self.max_iter):\n            cur_time = time.monotonic()\n            if cur_time - start_time > time_limit:\n                break\n\n            # Sample point\n            if best_goal_node is not None:\n                # After first solution, sample informed\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                # Before first solution sample uniformly with some goal bias\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search by linear - fallback for safety if spatial grid empty\n            def nearest_node(p):\n                best = nodes[0]\n                best_d = dist(p, best.position)\n                for n in nodes[1:]:\n                    d_ = dist(p, n.position)\n                    if d_ < best_d:\n                        best = n\n                        best_d = d_\n                return best, best_d\n\n            nearest, _ = nearest_node(sample)\n\n            # Steer new node position\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius neighborhood\n            radius = radius_adaptive(len(nodes))\n\n            # Retrieve candidate neighbors from spatial grid\n            candidates = spatial_grid.neighbor_candidates(new_pos, radius)\n            # Filter candidates strictly within radius (squared distances)\n            radius_sq = radius * radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                pos_c = c.position\n                for i in range(dim):\n                    diff = pos_c[i] - new_pos[i]\n                    sum_sq += diff*diff\n                    if sum_sq > radius_sq:\n                        break\n                if sum_sq <= radius_sq:\n                    neighbors.append(c)\n\n            # Select the best parent (lowest cost) among neighbors + nearest\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.add_node(new_node)\n\n            # Rewire neighbors with better cost through new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check and connect\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-8 < best_goal_cost:\n                    improved = best_goal_cost - goal_cost\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                else:\n                    improved = 0.0\n\n                # Early stopping: break if cost improvement small or solution sufficient\n                if improved < min_improvement_cost:\n                    break\n\n            # Track no improvement streak and possibly early terminate\n            if best_goal_node is not None:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        # Extract path from best goal node or closest node\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            current = best_goal_node\n        else:\n            # Find node closest to goal to extract partial path\n            min_d = float('inf')\n            current = None\n            for n in nodes:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d:\n                    min_d = d_\n                    current = n\n            if current is None:\n                current = root\n\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Post-process shortcutting to smooth and shorten path\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iter = 200\n            iteration = 0\n            while improved and iteration < max_iter and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": -13.86985,
    "time_improvement": -13.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1697.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023928070068359376,
            "num_nodes_avg": 242.3,
            "path_length_avg": 170.20756672600876,
            "smoothness_avg": 0.05125578115753204,
            "success_improvement": 0.0,
            "time_improvement": 4.7737606364002065,
            "length_improvement": 6.706535565983733,
            "smoothness_improvement": 702.2642788256377,
            "objective_score": 8.967370924638491
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1532435417175293,
            "num_nodes_avg": 964.5,
            "path_length_avg": 231.25080942683635,
            "smoothness_avg": 0.10406023561585567,
            "success_improvement": 0.0,
            "time_improvement": 4.6570241332318485,
            "length_improvement": 22.801823627834896,
            "smoothness_improvement": 2577.544813954116,
            "objective_score": 27.965925486441073
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0716317892074585,
            "num_nodes_avg": 607.7,
            "path_length_avg": 125.84121677266735,
            "smoothness_avg": 0.15017270596541038,
            "success_improvement": 0.0,
            "time_improvement": -47.426800724264325,
            "length_improvement": 16.422255734395755,
            "smoothness_improvement": 1810.185735283898,
            "objective_score": 4.676241899777645
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A tuned and reconfigured bidirectional RRT* algorithm with balanced step size, moderated goal bias, and optimized adaptive rewiring radius tailored to problem dimension to enhance planning efficiency, path quality, and smoothness. The method retains early stopping on first connection, employs precise neighbor radius computation, alternates tree expansions for coverage, robust collision checking, and coherent parent-child relationships with incremental rewiring.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately sampling points with moderate goal bias. Each iteration extends the trees toward the sample with a tuned step size, adds collision-free nodes, rewires neighbors within an adaptive radius computed exactly per RRT* theory to optimize path costs, and attempts to connect the two trees for early termination. Path is extracted by concatenating the best connecting nodes' ancestries yielding a continuous and near-optimal path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.07):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        start_tree: List[Node] = [Node(start_pos)]\n        goal_tree: List[Node] = [Node(goal_pos)]\n        all_nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            # Use squared distance shortcut where suitable for comparisons\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            # interpolate with finer resolution for safety and smoothness\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            min_node = tree[0]\n            min_dist = dist(min_node.position, point)\n            for node in tree[1:]:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_node = node\n                    min_dist = d\n            return min_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for node in tree:\n                # squared distance for comparison (avoid sqrt)\n                d_sq = 0.0\n                if is_3d:\n                    d_sq = (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2 + (node.position[2] - point[2])**2\n                else:\n                    d_sq = (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2\n                if d_sq <= radius_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_s, node_g):\n            path_start = []\n            cur = node_s\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_g\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # avoid duplicate connecting node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            # Find the best parent for new_node among near_nodes\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if is_edge_in_obstacle(node.position, new_node.position):\n                    continue\n                cost_through_node = node.cost + dist(node.position, new_node.position)\n                if cost_through_node < min_cost:\n                    min_parent = node\n                    min_cost = cost_through_node\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except Exception:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            # Try rewiring neighbors to new_node if it reduces cost\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, node.position):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except Exception:\n                            pass\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def neighbor_radius(n):\n            # Use exact RRT* radius as per theoretical formula:\n            # r = min( gamma_RRT* (log n / n)^(1/dim), step_size * 4 )\n            if n <= 1:\n                return self.step_size * 3.5\n            unit_ball_volume = math.pi if dim == 2 else (4/3)*math.pi\n            gamma_rrt = 2 * ((1 + 1/dim) ** (1/dim)) * (bounds_volume / unit_ball_volume)**(1/dim)\n            r = gamma_rrt * (math.log(n) / n) ** (1/dim)\n            return min(r, self.step_size * 4.0)\n\n        bounds_volume = 1.0\n        for v in bounds:\n            bounds_volume *= v\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sampled = False\n                while not sampled:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        sampled = True\n\n            # Alternate expansions (start_tree then goal_tree)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire neighbors\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connect two trees\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n                        # Early stop\n                        return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)",
    "objective": 225.12136,
    "time_improvement": -617.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 304.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.19767353534698487,
            "num_nodes_avg": 354.8,
            "path_length_avg": 175.48776411867988,
            "smoothness_avg": 0.02195373039895477,
            "success_improvement": -9.999999999999998,
            "time_improvement": -686.6788812898035,
            "length_improvement": 3.8123757049787157,
            "smoothness_improvement": 243.62355403224095,
            "objective_score": -252.49812119379257
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.48543691635131836,
            "num_nodes_avg": 721.6,
            "path_length_avg": 240.27399219906448,
            "smoothness_avg": 0.01763307367785197,
            "success_improvement": -9.999999999999998,
            "time_improvement": -202.02251711093058,
            "length_improvement": 19.7896255005495,
            "smoothness_improvement": 353.7116863207397,
            "objective_score": -96.96442140134577
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.5167232275009155,
            "num_nodes_avg": 570.6,
            "path_length_avg": 121.5472902528721,
            "smoothness_avg": 0.03266530294199842,
            "success_improvement": -9.999999999999998,
            "time_improvement": -963.4782843375385,
            "length_improvement": 19.27407727403531,
            "smoothness_improvement": 315.50024232036225,
            "objective_score": -325.90153772523854
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "An improved bidirectional RRT* planner featuring dynamic radius rewiring, adaptive goal bias, KD-tree based neighbor searches for scalability, and integrated shortcut smoothing to efficiently produce shorter, smoother paths. This planner incrementally grows two trees from start and goal, adaptively rewires within a theoretically computed radius, employs sampling biased toward the goal and the current best path region, and refines the final path by shortcutting to reduce jaggedness and length. Early termination occurs upon path connection or time limit.",
    "planning_mechanism": "The planner alternates extending and rewiring two trees toward sampled points within map bounds while enforcing collision constraints. It maintains efficient nearest neighbor queries via a simple spatial index, dynamically adjusts rewiring radius per iteration count and dimension, performs connection attempts between trees at every extension, applies a path shortcutting post-processing pass to smooth the returned trajectory, and respects a hard time limit by returning best found solution if any.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=4000, step_size: float=4.5, goal_sample_rate: float=0.08):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        # Basic helpers\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p,to_p,step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step/d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1,p2,resolution=0.5):\n            distance = dist(p1,p2)\n            steps = max(2,int(distance/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # KD-tree like spatial indexing (simple grid bucketing for neighbor search)\n        grid_cell_size = max(1.0, self.step_size*3)\n        bucket_map_start = {}\n        bucket_map_goal = {}\n\n        def grid_key(pos):\n            return tuple(int(pos[i]//grid_cell_size) for i in range(dim))\n\n        def add_to_bucket(bucket_map, node):\n            key = grid_key(node.position)\n            if key not in bucket_map:\n                bucket_map[key] = []\n            bucket_map[key].append(node)\n\n        def get_near_nodes(bucket_map, position, radius):\n            r_sq = radius*radius\n            base_key = grid_key(position)\n            neighbors = []\n            # examine surrounding buckets\n            ranges = [range(base_key[i]-1, base_key[i]+2) for i in range(dim)]\n            # Cartesian product over dimension ranges\n            def recursive_keys(i, curr):\n                if i == dim:\n                    yield tuple(curr)\n                else:\n                    for v in ranges[i]:\n                        curr.append(v)\n                        yield from recursive_keys(i+1, curr)\n                        curr.pop()\n            for key in recursive_keys(0,[]):\n                bucket = bucket_map.get(key)\n                if bucket:\n                    for node in bucket:\n                        d_sq = sum((node.position[i]-position[i])**2 for i in range(dim))\n                        if d_sq <= r_sq:\n                            neighbors.append(node)\n            return neighbors\n\n        def nearest_node(bucket_map, position):\n            base_key = grid_key(position)\n            search_radius = self.step_size*3\n            radius = search_radius\n            best_node = None\n            best_d = float('inf')\n            while best_node is None:\n                candidates = get_near_nodes(bucket_map, position, radius)\n                if candidates:\n                    for node in candidates:\n                        d = dist(node.position, position)\n                        if d < best_d:\n                            best_node = node\n                            best_d = d\n                    break\n                radius *= 2\n                if radius > max(bounds)*2:\n                    # fallback linear\n                    best_node = None\n                    break\n            if best_node:\n                return best_node\n            # fallback linear search over all nodes\n            all_nodes = []\n            for nodes in bucket_map.values():\n                all_nodes.extend(nodes)\n            best_node = all_nodes[0]\n            best_d = dist(best_node.position, position)\n            for node in all_nodes[1:]:\n                d = dist(node.position, position)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        # Extract path by concatenating from two nodes, removing duplication\n        def extract_path(node_s, node_g):\n            path_start = []\n            cur = node_s\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_g\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        # Shortcutting post-processing to smooth and shorten path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        # shortcut possible\n                        path = path[:i+1] + path[j:]\n                        j = i+1\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        # Neighbor radius per RRT* theory\n        bounds_volume = 1.0\n        for v in bounds:\n            bounds_volume *= v\n        unit_ball_volume = math.pi if dim==2 else (4/3)*math.pi\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * (bounds_volume / unit_ball_volume) ** (1/dim)\n\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.step_size*5\n            r = gamma_rrt_star * (math.log(n) / n) ** (1/dim)\n            return min(r, self.step_size*5)\n\n        # Rewiring logic updating parent-child coherently\n        def rewire(bucket_map, tree_nodes, new_node):\n            n = len(tree_nodes)\n            r = neighbor_radius(n)\n            near_nodes = get_near_nodes(bucket_map, new_node.position, r)\n            # Choose best parent for new_node\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if is_edge_in_obstacle(node.position, new_node.position):\n                    continue\n                cost_through = node.cost + dist(node.position, new_node.position)\n                if cost_through < min_cost:\n                    min_cost = cost_through\n                    min_parent = node\n            if min_parent != new_node.parent:\n                if new_node.parent is not None:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            # Try rewiring neighbors to new_node\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, node.position):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new + 1e-10 < node.cost:\n                    if node.parent is not None:\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n\n        # Try to connect two trees at new node\n        def try_connect(new_node, other_bucket_map):\n            r_connect = self.step_size*1.5\n            near_other = get_near_nodes(other_bucket_map, new_node.position, r_connect)\n            for node in near_other:\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    return node\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        add_to_bucket(bucket_map_start, start_tree[0])\n        add_to_bucket(bucket_map_goal, goal_tree[0])\n\n        all_nodes = start_tree + goal_tree\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Adaptive goal bias: more aggressively samples goal every ~500 iterations, less otherwise\n        def adaptive_goal_bias(iteration):\n            cycle = 600\n            phase = iteration % cycle\n            if phase < 30:\n                return 0.3\n            elif phase < 150:\n                return 0.1\n            else:\n                return 0.04\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            curr_goal_bias = adaptive_goal_bias(it)\n            sample = None\n            if random.random() < curr_goal_bias:\n                sample = goal_pos\n            else:\n                for _ in range(100):\n                    q = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n                if sample is None:\n                    continue  # fail sampling this iteration\n\n            # Two expansion cycles: start tree then goal tree\n            for tree, bucket_map, other_tree, other_bucket_map in [(start_tree, bucket_map_start, goal_tree, bucket_map_goal), (goal_tree, bucket_map_goal, start_tree, bucket_map_start)]:\n                nearest_n = nearest_node(bucket_map, sample)\n                new_pos = steer(nearest_n.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_n.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                new_node.parent = nearest_n\n                new_node.cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n                nearest_n.add_child(new_node)\n                tree.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_n, new_node))\n                add_to_bucket(bucket_map, new_node)\n                rewire(bucket_map, tree, new_node)\n                connect_node = try_connect(new_node, other_bucket_map)\n                if connect_node is not None:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n                        # Apply shortcut smoothing before returning\n                        best_path = shortcut_path(best_path)\n                        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)\n\n        # If time limit hit or max iterations done, return best found path if any\n        if success and best_path:\n            best_path = shortcut_path(best_path)\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)",
    "objective": 371.81908,
    "time_improvement": -1243.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1307.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.28445355892181395,
            "num_nodes_avg": 151.6,
            "path_length_avg": 159.49661816171792,
            "smoothness_avg": 0.043377733600443266,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1032.0362491555397,
            "length_improvement": 12.577376199912802,
            "smoothness_improvement": 578.9557271031138,
            "objective_score": -349.1696703911986
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7264727830886841,
            "num_nodes_avg": 317.4,
            "path_length_avg": 229.31475928403628,
            "smoothness_avg": 0.08445069253293429,
            "success_improvement": 0.0,
            "time_improvement": -351.9869238833005,
            "length_improvement": 23.448132891615103,
            "smoothness_improvement": 2072.9771462475696,
            "objective_score": -81.16231169878324
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.187671160697937,
            "num_nodes_avg": 360.9,
            "path_length_avg": 120.87272247700596,
            "smoothness_avg": 0.10774181375614508,
            "success_improvement": 0.0,
            "time_improvement": -2344.369482759467,
            "length_improvement": 19.72209307129994,
            "smoothness_improvement": 1270.4679183047203,
            "objective_score": -685.1252493935365
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with adaptive neighbor radius rewiring and informed sampling after the first path is found, combined with a path shortcutting smoothing post-processing to enhance path length and smoothness while maintaining runtime efficiency within a 30-second limit. The algorithm uses uniform random sampling initially and switches to ellipsoidal informed sampling focused around the current best path cost once a solution is available. It incorporates collision checking for nodes and edges, dynamically adjusts neighbor radius to reduce rewiring overhead, and stops early if no improvements occur for a number of iterations. The final solution path is extracted and shortened by attempting to shortcut redundant waypoints.",
    "planning_mechanism": "The planner grows a tree rooted at the start node, sampling points in free space with goal biasing. Initially, uniform samples explore the environment; upon first solution, the sampling region narrows to an informed ellipsoid focusing around the best current path cost. New nodes are connected using a best parent selection among neighbors within an adaptive radius. After node insertion, neighbors are rewired if beneficial. Early termination occurs on time limit or stagnation in solution improvement. Finally, the extracted path is shortcut for smoother and shorter trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from start\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, max_no_improve=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.max_no_improve = max_no_improve\n        self.improve_tol = 1e-8\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            rest = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                if dim == 2:\n                    coords = [radius * r1 * x_unit[0], radius * rest * x_unit[1]]\n                    # Rotate to align with e1\n                    cos_theta, sin_theta = e1[0], e1[1]\n                    rot_x = cos_theta * coords[0] - sin_theta * coords[1]\n                    rot_y = sin_theta * coords[0] + cos_theta * coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius * r1 * x_unit[0], radius * rest * x_unit[1], radius * rest * x_unit[2]]\n                    # Compute rotation matrix aligning x-axis to e1 using Rodrigues' formula\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i] * e1[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot + 1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        import math as _math\n                        k = (v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i] + rot[i] for i in range(3))\n                else:\n                    # fallback uniform\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, pt):\n            return min(nodes_list, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            r_sq = radius * radius\n            res = []\n            for n in nodes_list:\n                d_sq = sum((n.position[i] - pt[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def path_cost(path_pts):\n            return sum(dist(path_pts[i], path_pts[i+1]) for i in range(len(path_pts)-1))\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not is_edge_in_obstacle(path[i], path[j])\n                        and in_bounds(path[j])\n                        and not is_in_obstacle(path[j])):\n                        # shortcut possible\n                        new_path = path[:i+1] + path[j:]\n                        path = new_path\n                        j = len(path) -1  # reset j for new shorter path\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        root = Node(start_pos, cost=0.0)\n        nodes = [root]\n        edges = []\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        gamma = 30.0  # tuning parameter for radius\n        radius_min = self.step_size\n        radius_max = max(bounds) * 0.5\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else (\n                informed_sample(best_cost, dist(start_pos, goal_pos)) if found_solution else uniform_sample()\n            )\n            if is_in_obstacle(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            tentative_cost = nearest.cost + dist(nearest.position, new_pos)\n\n            # Dynamic radius depending on node count and dimension\n            radius = gamma * ((math.log(len(nodes)+1) / (len(nodes)+1)) ** (1.0/dim))\n            radius = min(max(radius, radius_min), radius_max)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n            \n            best_parent = nearest\n            best_cost_through = tentative_cost\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_through = nbr.cost + dist(nbr.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        # Add new edge\n                        new_node.add_child(nbr)\n                        nbr.cost = new_cost\n                        edges.append((new_node, nbr))\n\n            # Attempt goal connection\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost_val = new_node.cost + dist_to_goal\n                    if not found_solution or goal_cost_val + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos, parent=new_node, cost=goal_cost_val)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost_val\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break\n\n        success = found_solution and best_goal_node is not None\n\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Return path to closest node to goal\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 117.01519,
    "time_improvement": -452.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1750.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10282647609710693,
            "num_nodes_avg": 432.0,
            "path_length_avg": 165.760499664772,
            "smoothness_avg": 0.05437694507867852,
            "success_improvement": 0.0,
            "time_improvement": -309.21723305576853,
            "length_improvement": 9.144043490534663,
            "smoothness_improvement": 751.1172719075158,
            "objective_score": -83.52315746287218
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6919067859649658,
            "num_nodes_avg": 1062.0,
            "path_length_avg": 233.6524108379991,
            "smoothness_avg": 0.11646376133033076,
            "success_improvement": 0.0,
            "time_improvement": -330.48112342580254,
            "length_improvement": 22.000099950524962,
            "smoothness_improvement": 2896.696464486021,
            "objective_score": -71.46079473499567
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.39642088413238524,
            "num_nodes_avg": 683.1,
            "path_length_avg": 123.74088299395741,
            "smoothness_avg": 0.1338461196592238,
            "success_improvement": 0.0,
            "time_improvement": -715.8816544238516,
            "length_improvement": 17.81719742306796,
            "smoothness_improvement": 1602.5127625724497,
            "objective_score": -196.06161406045246
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified unidirectional RRT* planner with adaptive neighbor radius rewiring and early stopping upon finding an initial solution, combining uniform random sampling with mild goal bias and consistent collision checking. The planner dynamically inserts nodes by selecting the best parent from neighbors, rewires to locally improve the tree, and terminates early if no improvements occur or time limit is reached. The best path is extracted from the lowest-cost goal node found.",
    "planning_mechanism": "The planner iteratively samples random free points within map bounds (with goal bias), steers from the nearest tree node toward these points by a fixed step size, and inserts new nodes with the lowest cost parent selected from neighbors within an adaptively computed radius. The algorithm then rewires neighbors if the new connection improves their cost. It tracks best solution nodes reaching the goal region and stops early after no improvement to return the best path found within a 30-second limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_gamma=30.0,\n                 max_no_improve=150, improve_tol=1e-6, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> \"PlannerResult\":\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            min_r = self.step_size * 2.0\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        nodes = [Node(start_pos)]\n        edges = []\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        start_time = time.monotonic()\n        no_improve_counter = 0\n        found_solution = False\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free()\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = neighbor_radius(len(nodes))\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Select best parent\n            candidates = []\n            for node in neighbors:\n                if not is_edge_in_obstacle(node.position, new_pos):\n                    cost = node.cost + dist(node.position, new_pos)\n                    candidates.append((cost, node))\n            if not candidates:\n                # fallback to nearest if not in neighbors or no candidates pass collision check\n                if not is_edge_in_obstacle(nearest_node.position, new_pos):\n                    parent_node = nearest_node\n                    cost_new = nearest_node.cost + dist(nearest_node.position, new_pos)\n                else:\n                    continue\n            else:\n                cost_new, parent_node = min(candidates, key=lambda x: x[0])\n\n            new_node = Node(new_pos, parent=parent_node, cost=cost_new)\n            parent_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == parent_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                    if new_cost + 1e-12 < neighbor.cost:\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Check if new_node can connect to goal region (within step_size)\n            if dist(new_node.position, goal_pos) <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist(new_node.position, goal_pos)\n                if goal_cost + self.improve_tol < best_cost:\n                    best_cost = goal_cost\n                    best_goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(best_goal_node)\n                    nodes.append(best_goal_node)\n                    edges.append((new_node, best_goal_node))\n                    found_solution = True\n                    no_improve_counter = 0\n                else:\n                    no_improve_counter += 1\n            else:\n                if found_solution:\n                    no_improve_counter += 1\n\n            if found_solution and no_improve_counter >= self.max_no_improve:\n                break\n\n        if found_solution and best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            success_state = True\n        else:\n            extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 271.23218,
    "time_improvement": -946.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 194.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.411767315864563,
            "num_nodes_avg": 570.2,
            "path_length_avg": 159.51709454952754,
            "smoothness_avg": 0.016911442244597834,
            "success_improvement": 0.0,
            "time_improvement": -1538.7052056686985,
            "length_improvement": 12.56615276728522,
            "smoothness_improvement": 164.70079491257482,
            "objective_score": -453.2483660656755
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.2278557777404786,
            "num_nodes_avg": 1217.9,
            "path_length_avg": 227.51619035105438,
            "smoothness_avg": 0.011538786586679065,
            "success_improvement": 0.0,
            "time_improvement": -663.9305544162527,
            "length_improvement": 24.048546970380794,
            "smoothness_improvement": 196.9012899272955,
            "objective_score": -183.76553169301084
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3574600458145142,
            "num_nodes_avg": 604.9,
            "path_length_avg": 118.12710810870173,
            "smoothness_avg": 0.025136586560309686,
            "success_improvement": 0.0,
            "time_improvement": -635.6955832634095,
            "length_improvement": 21.545599402620958,
            "smoothness_improvement": 219.7355256573191,
            "objective_score": -176.68263770916369
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bi-directional RRT* planner with adaptive neighbor radius, goal bias sampling, early stopping, and integrated path shortcutting for improved planning speed, path length, and smoothness. The planner alternates tree expansions between start and goal, rewires neighbors dynamically using a radius shrinking with the number of nodes, and stops immediately upon connecting both trees. Post-processing shortcutting removes unnecessary waypoints to smooth and shorten the final path. Efficient collision checking and incremental best path updates ensure robustness and quality.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the goal and within map boundaries. Each new node connects to its best parent among neighbors inside an adaptive radius, rewiring neighbors that can be improved by the new node. After adding a node, an attempt is made to connect the other tree within step size increments. When a connection is found, planning stops early, and a combined path is extracted and shortcut. This method uses dynamic radii to limit neighbor searching overhead and improves path quality with minimal wasted exploration.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=30.0, max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree_nodes[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree_nodes, new_pos)\n            neighbors = near_nodes(tree_nodes, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges)\n            return new_node\n\n        def rewire(pivot: Node, neighbors: List[Node], edges: List[Tuple[Node,Node]]) -> None:\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        def merge_trees(node_start: Node, tree_goal: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            dist_goal = math.dist(node_start.position, nearest_goal_node.position)\n            if dist_goal > self.step_size or not is_free_edge(node_start.position, nearest_goal_node.position):\n                return None\n            # connect goal node parent chain if needed\n            # Create a connecting node at goal node's position attached to start tree node\n            connecting_cost = node_start.cost + dist_goal + nearest_goal_node.cost\n            path_start = node_start.path_from_root()\n            path_goal = nearest_goal_node.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            return full_path, connecting_cost\n\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            # Alternate tree expansions\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                path_candidate, cost_candidate = merged\n                if cost_candidate < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    break  # Early stopping\n\n        if not success:\n            # Try connecting start tree node nearest goal to form path if possible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                path_candidate = nearest_goal_node.path_from_root() + [goal_pos]\n                best_path = path_candidate\n                success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -14.2797,
    "time_improvement": -14.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1551.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.037523436546325686,
            "num_nodes_avg": 119.5,
            "path_length_avg": 159.4209224416483,
            "smoothness_avg": 0.0499161308278024,
            "success_improvement": 0.0,
            "time_improvement": -49.33154826515664,
            "length_improvement": 12.618866223558411,
            "smoothness_improvement": 681.295842068116,
            "objective_score": -3.821665535071364
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06830766201019287,
            "num_nodes_avg": 321.3,
            "path_length_avg": 231.84012711924962,
            "smoothness_avg": 0.09872843875579924,
            "success_improvement": 0.0,
            "time_improvement": 57.50127086883818,
            "length_improvement": 22.60509241953809,
            "smoothness_improvement": 2440.353840406813,
            "objective_score": 43.01520591440838
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07245962619781494,
            "num_nodes_avg": 278.3,
            "path_length_avg": 123.63111074361593,
            "smoothness_avg": 0.12815608053053237,
            "success_improvement": 0.0,
            "time_improvement": -49.13058839116163,
            "length_improvement": 17.890102924951922,
            "smoothness_improvement": 1530.135884850495,
            "objective_score": 3.645564661875139
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An adaptive informed bi-directional RRT* planner with dynamic neighbor radius, goal bias, and ellipsoidal informed sampling after first solution. It alternates tree expansions, incrementally rewires nodes within shrinking neighborhood for optimized paths, and applies iterative shortcutting post-processing. Planning halts early either on time limit or upon satisfying a quality threshold, ensuring efficient search with shorter, smoother paths.",
    "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points with goal bias initially, then informed ellipsoidal sampling post first solution to focus near best path. Each new node connects to best parent found in a radius adaptively decreasing with node count, followed by rewiring neighbors to minimize path cost. Trees attempt connection after each extension, and upon success, iterative path shortcutting improves smoothness and length. Planning respects a hard 30-second limit and returns the best path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05, gamma_rrt_star: float = 25.0, max_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        TIME_LIMIT = 30.0\n        t_start = time.monotonic()\n\n        nodes_all: List[Node] = []\n        edges_all: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def sample_goal():\n            if is_free_node(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        def sample_ellipsoid(c_best, c_min, x_center, C):\n            # Sample uniformly inside unit ball and transform via C*ball + x_center\n            # Returns point in informed subset ellipsoid focusing near optimal path.\n            while True:\n                ball = self._sample_unit_ball(dim)\n                if ball is None:\n                    return sample_uniform()  # fallback\n                point_local = tuple(ball[i] * c_best / 2 if i == 0 else ball[i] * math.sqrt(c_best**2 - c_min**2) / 2 for i in range(dim))\n                p = tuple(sum(C[i][j] * point_local[j] for j in range(dim)) + x_center[i] for i in range(dim))\n                if in_bounds(p) and is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for n in tree_nodes[1:]:\n                d = math.dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def rewire(new_node: Node, neighbors: List[Node], edges: List[Tuple[Node, Node]]):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Update parent and edges\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.update_parent(new_node, new_cost)\n                        edges.append((new_node, nb))\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            nearest_node = nearest(tree_nodes, new_pos)\n            if nearest_node is None:\n                return None\n            neighbors = near_nodes(tree_nodes, new_pos)\n            # Candidate parent nodes include nearest\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cand_cost = nb.cost + math.dist(nb.position, new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            nodes_all.append(new_node)\n            tree_nodes.append(new_node)\n            edges_all.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges_all)\n            return new_node\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            if not other_tree:\n                return None\n            nearest_other = nearest(other_tree, new_node.position)\n            if nearest_other is None:\n                return None\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between > self.step_size:\n                return None\n            if not is_free_edge(new_node.position, nearest_other.position):\n                return None\n            path1 = new_node.path_from_root()\n            path2 = nearest_other.path_from_root()\n            # Avoid duplication of meeting node\n            if path1[-1] == path2[-1]:\n                path2 = path2[:-1]\n            full_path = path1 + path2[::-1]\n            total_cost = new_node.cost + nearest_other.cost + dist_between\n            return full_path, total_cost\n\n        def shortcut_path(path: List[Tuple[float, ...]], timeout_sec=5.0) -> List[Tuple[float, ...]]:\n            n = len(path)\n            if n < 3:\n                return path\n            t0 = time.monotonic()\n            shortened = [path[0]]\n            i = 0\n            while i < n - 1:\n                end = n - 1\n                while end > i + 1:\n                    if time.monotonic() - t0 > timeout_sec:\n                        break\n                    if is_free_edge(path[i], path[end]):\n                        shortened.append(path[end])\n                        i = end\n                        break\n                    end -= 1\n                else:\n                    i += 1\n                    if i < n:\n                        shortened.append(path[i])\n                    continue\n            return shortened\n\n        def compute_rotation_matrix(unit_x: Tuple[float, ...]) -> List[List[float]]:\n            # Returns rotation matrix C such that C * (c_min/2,0,..0) aligns with unit_x\n            if dim == 2:\n                x, y = unit_x\n                norm = math.hypot(x, y)\n                if norm < 1e-14:\n                    return [[1, 0], [0, 1]]\n                x /= norm\n                y /= norm\n                return [[x, -y],[y, x]]\n            elif dim == 3:\n                # Use SVD on unit_x to generate rotation matrix\n                import math\n                ux, uy, uz = unit_x\n                norm = math.sqrt(ux*ux+uy*uy+uz*uz)\n                if norm < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux /= norm\n                uy /= norm\n                uz /= norm\n                # Pick arbitrary vector not colinear to unit_x\n                v = (0,0,1) if abs(uz) < 0.9 else (0,1,0)\n                # Compute axis = unit_x cross v\n                ax = uy*v[2] - uz*v[1]\n                ay = uz*v[0] - ux*v[2]\n                az = ux*v[1] - uy*v[0]\n                axis_length = math.sqrt(ax*ax + ay*ay + az*az)\n                if axis_length < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ax /= axis_length\n                ay /= axis_length\n                az /= axis_length\n                angle = math.acos(ux*0 + uy*0 + uz*1)\n                c = math.cos(angle)\n                s = math.sin(angle)\n                t = 1 - c\n                C = [[0.0]*3 for _ in range(3)]\n                C[0][0] = t*ax*ax + c\n                C[0][1] = t*ax*ay - s*az\n                C[0][2] = t*ax*az + s*ay\n                C[1][0] = t*ax*ay + s*az\n                C[1][1] = t*ay*ay + c\n                C[1][2] = t*ay*az - s*ax\n                C[2][0] = t*ax*az - s*ay\n                C[2][1] = t*ay*az + s*ax\n                C[2][2] = t*az*az + c\n                return C\n            else:\n                # For higher dims, just identity\n                return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf'):\n                return sample_uniform()\n            # Define ellipse parameters\n            midpoint = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            norm_diff = math.dist(start, goal)\n            if norm_diff < 1e-14:\n                return sample_uniform()\n            unit_x = tuple(d / norm_diff for d in diff)\n            C = compute_rotation_matrix(unit_x)\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            # Create diagonal scaling matrix but use in sample_ellipsoid logic\n            while True:\n                # Sample in unit n-ball\n                u = self._sample_unit_ball(dim)\n                if u is None:\n                    return sample_uniform()\n                # Scale sample: first dimension scaled by r1, others by r2\n                local = [0.0]*dim\n                local[0] = u[0]*r1\n                for i in range(1, dim):\n                    local[i] = u[i]*r2\n                # Rotate and translate\n                point = []\n                for i in range(dim):\n                    s = 0.0\n                    for j in range(dim):\n                        s += C[i][j]*local[j]\n                    point.append(s + midpoint[i])\n                if in_bounds(point) and is_free_node(tuple(point)):\n                    return tuple(point)\n\n        def _sample_unit_ball(d: int) -> Optional[Tuple[float, ...]]:\n            # Rejection sample from unit ball\n            for _ in range(100):\n                coord = tuple(random.uniform(-1,1) for _ in range(d))\n                norm = math.sqrt(sum(x*x for x in coord))\n                if norm <= 1 and norm > 1e-14:\n                    return tuple(x / norm for x in coord)\n            return None\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes_all.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - t_start > TIME_LIMIT:\n                break\n\n            if found_solution:\n                sample = informed_sample(best_cost, math.dist(start_pos, goal_pos), start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = sample_goal()\n                else:\n                    sample = sample_uniform()\n\n            # Alternate tree expansion\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            connect_result = try_connect(new_node, tree_b)\n            if connect_result is not None:\n                path_candidate, cost_candidate = connect_result\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stop on good solution or keep searching until time runs out\n                    # Here we break immediately to reduce planning time\n                    break\n\n        # If no path found, try direct connection if feasible\n        if not found_solution:\n            nearest_goal = nearest(tree_start, goal_pos)\n            if nearest_goal and is_free_edge(nearest_goal.position, goal_pos):\n                p = nearest_goal.path_from_root() + [goal_pos]\n                best_path = p\n                found_solution = False\n\n        if best_path:\n            # Iterative shortcutting to further improve smoothness & length within small time to not exceed time limit\n            t_sc_start = time.monotonic()\n            time_for_shortcut = max(1.0, TIME_LIMIT - (time.monotonic() - t_start) - 0.5)\n            # Multiple iterations of shortcutting limited by remaining time\n            for _ in range(8):\n                best_path = shortcut_path(best_path, timeout_sec=time_for_shortcut)\n                if time.monotonic() - t_sc_start > time_for_shortcut:\n                    break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges_all\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -11.16731,
    "time_improvement": -25.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1490.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05280606746673584,
            "num_nodes_avg": 104.3,
            "path_length_avg": 159.03977593430037,
            "smoothness_avg": 0.045831156313335134,
            "success_improvement": 0.0,
            "time_improvement": -110.1516422374204,
            "length_improvement": 12.827778663888708,
            "smoothness_improvement": 617.3571202525652,
            "objective_score": -22.262039871630073
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06106133460998535,
            "num_nodes_avg": 251.7,
            "path_length_avg": 229.1376515349893,
            "smoothness_avg": 0.0943546418960893,
            "success_improvement": 0.0,
            "time_improvement": 62.009691978774306,
            "length_improvement": 23.507256556010894,
            "smoothness_improvement": 2327.812896887935,
            "objective_score": 44.3463260116785
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06167628765106201,
            "num_nodes_avg": 241.0,
            "path_length_avg": 120.7672251338709,
            "smoothness_avg": 0.12772867393374066,
            "success_improvement": 0.0,
            "time_improvement": -26.9371862625311,
            "length_improvement": 19.792159383366613,
            "smoothness_improvement": 1524.6993044871776,
            "objective_score": 11.417636273696527
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A single-tree RRT* planner with adaptive neighbor radius, informed ellipsoidal sampling after initial solution discovery, efficient rewiring for local path cost refinement, and iterative path shortcutting smoothing. Early termination occurs on time limits or stagnated improvements, focusing on minimizing path length while improving planning efficiency and robustness.",
    "planning_mechanism": "The planner samples points with goal bias and, once a first solution is found, uses ellipsoidal informed sampling to concentrate search near the optimal path. New nodes are connected to the best cost parent within an adaptively computed radius. Rewiring local neighbors reduces path cost and sharp turns. The path is updated and shortcut iteratively. Planning halts when time expires or no progress is observed, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, time_limit_sec: float =30.0,\n                 max_no_improve: int=100, improve_tol: float=1e-6,\n                 gamma_rrt_star: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(frm[i] + r * (to[i] - frm[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = tuple((goal[i]-start[i])/c_min for i in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best/2.0\n                r2 = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                radii = [r1, r2]\n            else:\n                # build orthonormal basis {a1,b2,b3}\n                ref = (1.0,0.0,0.0) if abs(a1[0])<0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best/2.0\n                r_other = math.sqrt(max(c_best**2 - c_min**2,0))/2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x/norm_v for x in v]\n                        r = random.random()**(1.0/dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes, point):\n            best = None\n            best_d = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_d:\n                    best, best_d = n, d_\n            return best\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2.0)\n            val = self.gamma_rrt_star*((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in nodes:\n                dx = dist(n.position, point)\n                if dx <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, all_nodes, all_edges):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            valid_parents = []\n            for p in neighbors:\n                if not is_edge_in_obstacle(p.position, pos):\n                    valid_parents.append(p)\n            if not valid_parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((best_parent,new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, all_edges):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old parent edge and child relationship\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try: all_edges.remove((nb.parent, nb))\n                        except ValueError: pass\n                    # Add new parent edge and update cost\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    all_edges.append((new_node, nb))\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n\n        tree = [Node(start, parent=None, cost=0.0)]\n        nodes = [tree[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        c_min = dist(start, goal)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(tree, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            # Check if close enough to goal to connect\n            if dist(new_node.position, goal) <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, goal):\n                    goal_node = Node(goal, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, goal))\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    candidate_path = goal_node.path_from_root()\n                    candidate_cost = path_cost(candidate_path)\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = shortcut_path(candidate_path)\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        success = (len(best_path) > 1)\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 285.62048,
    "time_improvement": -958.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1439.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.28375184535980225,
            "num_nodes_avg": 393.2,
            "path_length_avg": 160.3166894877086,
            "smoothness_avg": 0.05142395787322286,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1029.2436485224796,
            "length_improvement": 12.12788211127557,
            "smoothness_improvement": 704.8966096277823,
            "objective_score": -347.9718822418396
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7394887447357178,
            "num_nodes_avg": 1105.2,
            "path_length_avg": 232.27430028535468,
            "smoothness_avg": 0.10297605191968351,
            "success_improvement": 0.0,
            "time_improvement": -360.0850173056216,
            "length_improvement": 22.460152919710545,
            "smoothness_improvement": 2549.647986545654,
            "objective_score": -81.80117350713188
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7702674627304077,
            "num_nodes_avg": 863.1,
            "path_length_avg": 117.4816186984946,
            "smoothness_avg": 0.0914761533660441,
            "success_improvement": 0.0,
            "time_improvement": -1485.3026845868112,
            "length_improvement": 21.97430273397785,
            "smoothness_improvement": 1063.5699187487971,
            "objective_score": -427.0883741419127
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "An adaptive single-tree RRT*-Informed planner utilizing progressive informed ellipsoidal sampling once a solution is found, combined with fixed goal bias sampling and adaptive rewiring radius scaled with the current tree size for efficient neighbor queries. It employs early stopping after a solution is found with no recent improvement, uses efficient collision checks, dynamic rewiring to reduce path cost, and incremental shortcut smoothing on the best path to produce short, smooth, and feasible solutions rapidly while respecting the time limit.",
    "planning_mechanism": "A single tree is incrementally grown from start towards the goal by sampling points uniformly initially and from an ellipsoidal informed region as better solutions are found. New nodes are added with collision-checked edges and rewired within an adaptive radius to improve path costs. A fixed small goal bias ensures exploration towards the goal. Early stopping on time limit or stagnation in path cost ensures efficiency. The resulting best path is post-processed by shortcutting to remove unnecessary waypoints and smooth the path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...], 2D or 3D\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []                  # List of child Nodes\n        self.valid = True                   # For collision checking status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 30000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.05          # 5% goal bias fixed\n        self.improve_tol = 1e-6\n        self.max_no_improve = 200             # Early stopping on no improvement\n        self.gamma_rrt_star = 25.0            # Constant for radius calculation\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # fallback\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length = math.sqrt(sum(x * x for x in a1))\n            if length < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x / length for x in a1)\n\n            def sample_unit_ball():\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-12:\n                        vec = [v / norm for v in vec]\n                        r = random.random() ** (1.0 / dim)\n                        return [v * r for v in vec]\n\n            if dim == 2:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                u = sample_unit_ball()  # 2D vector\n                # Rotate u to align with e1\n                cos_theta = e1[0]\n                sin_theta = e1[1]\n                x, y = u\n                rot_x = cos_theta * x - sin_theta * y\n                rot_y = sin_theta * x + cos_theta * y\n                sample = (\n                    center[0] + r1 * rot_x,\n                    center[1] + r2 * rot_y,\n                )\n            elif dim == 3:\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                # build orthonormal basis\n                ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(e1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(e1, ref))\n                b3 = self._cross(e1, b2)\n                u = sample_unit_ball()\n                sample = [center[i] + r1 * e1[i] * u[0] + r_other * b2[i] * u[1] + r_other * b3[i] * u[2] for i in range(dim)]\n                sample = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            else:\n                return uniform_sample()\n\n            if is_in_obstacle(sample):\n                return uniform_sample()\n            return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq)]\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n        c_min = dist(start_pos, goal_pos)\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Sample with fixed goal bias and informed sampling if solution found\n            if random.random() < self.goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            radius = neighbor_radius(n_nodes)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent in neighborhood\n            best_parent = nearest\n            best_cost_through = nearest.cost + dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=None, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to possibly improve their cost via new_node\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Check if new_node can connect directly to goal\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n        else:\n            # fallback: path to closest node to goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 133.25525,
    "time_improvement": -511.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1897.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11683931350708007,
            "num_nodes_avg": 501.9,
            "path_length_avg": 159.46389626088632,
            "smoothness_avg": 0.06591432556229314,
            "success_improvement": 0.0,
            "time_improvement": -364.9839457723867,
            "length_improvement": 12.595311592270303,
            "smoothness_improvement": 931.7023302988051,
            "objective_score": -97.27948512485979
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.8338734149932862,
            "num_nodes_avg": 1165.6,
            "path_length_avg": 233.38092717194763,
            "smoothness_avg": 0.12021944014510777,
            "success_improvement": 0.0,
            "time_improvement": -418.80798362251693,
            "length_improvement": 22.090729012477,
            "smoothness_improvement": 2993.3327854963427,
            "objective_score": -97.42129375178716
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4121638059616089,
            "num_nodes_avg": 715.0,
            "path_length_avg": 124.00326116277886,
            "smoothness_avg": 0.14676217857868112,
            "success_improvement": 0.0,
            "time_improvement": -748.2824729014245,
            "length_improvement": 17.642938336442544,
            "smoothness_improvement": 1766.8040786636475,
            "objective_score": -205.06495847524357
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A hybrid single-tree incremental planner combining adaptive informed sampling, adaptive neighbor rewiring radius based on node count, and dynamic goal bias increasing over time, coupled with a two-phase smoothing approach integrating iterative shortcutting followed by cubic Bezier curve smoothing to improve path quality and smoothness efficiently. The planner strictly enforces collision checking with early termination upon time limit or convergence, balancing exploration and exploitation to reduce planning time while maintaining high path quality.",
    "planning_mechanism": "The planner incrementally samples points with adaptive goal bias increasing over iterations, uses an adaptive rewiring radius shrinking with tree size for efficient local cost optimization, and applies informed sampling centered on the current best path cost and geometry after a solution is found. It rewires nodes within the adaptive radius to continuously lower path cost, and upon termination, it refines the path by first applying multiple shortcut attempts to quickly remove unnecessary waypoints, then fits smooth cubic Bezier curves segment-wise ensuring collision-free smooth transitions, resulting in a smooth, short, and computationally efficient path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-10\n        self.min_goal_bias = 0.05\n        self.max_goal_bias = 0.25\n        self.goal_bias_inc_iters = max_iter // 2  # Increase goal bias gradually until half iterations\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 150\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        # Ellipsoidal informed sampling after first solution\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                # Uniform free-space sample\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                # If start==goal, uniform fallback\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            e1 = tuple(x / length_a1 for x in a1)\n\n            # Radii for ellipsoid axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radius_axes = (r1, r2)\n            elif dim == 3:\n                r_other = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                radius_axes = (r1, r_other, r_other)\n            else:\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            attempts = 0\n            while attempts < 200:\n                # Sample on unit ball surface uniformly\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_raw))\n                if norm < 1e-12:\n                    attempts += 1\n                    continue\n                unit_vec = [x/norm for x in x_raw]\n                radius_scale = random.random()**(1.0/dim)  # Uniform in unit ball\n                scaled = [radius_scale * radius_axes[i] * unit_vec[i] for i in range(dim)]\n\n                # Rotation from [1,0,...] to e1\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-12:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-12:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = scaled[0], scaled[1]\n                        rotated = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        if k_norm < 1e-12:\n                            rotated = scaled\n                        else:\n                            k = [x / k_norm for x in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            rotated = [0.0]*3\n                            for i in range(3):\n                                rotated[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(nodes_list, point):\n            # linear scan nearest neighbor\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            # linear scan neighbors within radius\n            r_sq = radius*radius\n            return [n for n in nodes_list if (sum((n.position[d]-point[d])**2 for d in range(dim))) <= r_sq]\n\n        def path_to_root(n: Node):\n            path = []\n            cur = n\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def shortcut_path(path: List[Tuple[float,...]], attempts=60):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Cubic Bezier smoothing with collision checking on small segments\n        def bezier_smooth(path: List[Tuple[float, ...]], segment_length=5):\n            if len(path) < 4:\n                return path\n            smoothed = [path[0]]\n            def bezier(p0,p1,p2,p3,t):\n                u = 1 - t\n                b = [0.0]*dim\n                for i in range(dim):\n                    b[i] = (u*u*u)*p0[i] + 3*(u*u)*t*p1[i] + 3*u*(t*t)*p2[i] + (t*t*t)*p3[i]\n                return tuple(b)\n\n            i = 0\n            while i + 3 < len(path):\n                p0, p1, p2, p3 = path[i], path[i+1], path[i+2], path[i+3]\n                # Attempt smoothing only if edges p0-p3 free enough\n                if is_edge_in_obstacle(p0, p3):\n                    smoothed.append(p1)\n                    i +=1\n                    continue\n                # Sample multiple points along bezier, check collision\n                samples = 10\n                collision = False\n                prev_pt = p0\n                for s in range(1, samples+1):\n                    t = s / samples\n                    pt = bezier(p0,p1,p2,p3,t)\n                    if is_edge_in_obstacle(prev_pt, pt):\n                        collision = True\n                        break\n                    prev_pt = pt\n                if collision:\n                    smoothed.append(p1)\n                    i += 1\n                    continue\n                # If collision-free, add sampled points except first (already included) and last will be handled later\n                t_vals = [k/samples for k in range(1,samples)]\n                for t in t_vals:\n                    smoothed.append(bezier(p0,p1,p2,p3,t))\n                i += 3\n            # Add remaining points\n            rem_start = max(i, len(path)-3)\n            for j in range(rem_start, len(path)):\n                smoothed.append(path[j])\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Dynamic goal bias increases gradually from min to max over half iterations\n            progress_ratio = min(1.0, iteration / self.goal_bias_inc_iters)\n            goal_sample_rate = self.min_goal_bias + (self.max_goal_bias - self.min_goal_bias) * progress_ratio\n\n            if found_solution and random.random() < goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost, dist(start_pos, goal_pos))\n                if not in_bounds(sample):\n                    continue\n                if is_in_obstacle(sample):\n                    continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n\n            # Adaptive neighbor radius based on node count and dimension (shrinking as tree grows)\n            num_nodes = len(nodes) + 1\n            gamma_rrt_star = 20.0  # moderate gamma for adaptive radius\n            radius = gamma_rrt_star * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            radius = max(self.step_size*1.8, min(radius, self.step_size*15.0))\n\n            near_nds = near_nodes(nodes, new_pos, radius)\n            best_parent = nearest_nd\n            best_parent_cost = new_cost\n            for near_nd in near_nds:\n                if near_nd == nearest_nd:\n                    continue\n                c_thru = near_nd.cost + dist(near_nd.position, new_pos)\n                if c_thru + self.improve_tol < best_parent_cost and not is_edge_in_obstacle(near_nd.position, new_pos):\n                    best_parent = near_nd\n                    best_parent_cost = c_thru\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to new_node if better\n            for near_nd in near_nds:\n                if near_nd == best_parent or near_nd == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost and not is_edge_in_obstacle(new_node.position, near_nd.position):\n                    if near_nd.parent is not None:\n                        try:\n                            edges.remove((near_nd.parent, near_nd))\n                        except ValueError:\n                            pass\n                        near_nd.parent.remove_child(near_nd)\n                    near_nd.parent = new_node\n                    near_nd.cost = alt_cost\n                    new_node.add_child(near_nd)\n                    edges.append((new_node, near_nd))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            extracted_path = shortcut_path(extracted_path, attempts=60)\n            extracted_path = bezier_smooth(extracted_path)\n            # Final safety check: if smoothed path fails collision, fallback to shortcut only path\n            collision_in_smooth = False\n            for i in range(len(extracted_path)-1):\n                if is_edge_in_obstacle(extracted_path[i], extracted_path[i+1]):\n                    collision_in_smooth = True\n                    break\n            if collision_in_smooth:\n                extracted_path = shortcut_path(path_to_root(best_goal_node), attempts=60)\n        else:\n            # No solution found, return path from closest node to start as fallback\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 356.76789,
    "time_improvement": -1253.0,
    "length_improvement": 22.0,
    "smoothness_improvement": 1177.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.4323369264602661,
            "num_nodes_avg": 847.1,
            "path_length_avg": 152.41569120823948,
            "smoothness_avg": 0.027351848404794633,
            "success_improvement": 0.0,
            "time_improvement": -1620.56582612854,
            "length_improvement": 16.458544467582207,
            "smoothness_improvement": 328.1158230245048,
            "objective_score": -474.6540420428901
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.2753138303756715,
            "num_nodes_avg": 1318.8,
            "path_length_avg": 221.66522072963744,
            "smoothness_avg": 0.08095984810273917,
            "success_improvement": 0.0,
            "time_improvement": -693.4573580672767,
            "length_improvement": 26.001769040832528,
            "smoothness_improvement": 1983.155204705037,
            "objective_score": -182.5203699721583
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7508834838867188,
            "num_nodes_avg": 945.4,
            "path_length_avg": 114.4383033030626,
            "smoothness_avg": 0.10370911658666145,
            "success_improvement": 0.0,
            "time_improvement": -1445.4081347249416,
            "length_improvement": 23.995527912517588,
            "smoothness_improvement": 1219.17230797163,
            "objective_score": -413.1292621301138
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A single-tree sampling-based RRT* variant using quasi-random Halton sequence sampling to improve coverage uniformity, an adaptive shrinkage rewiring radius based on node count and dimension, a dynamically increasing goal bias to accelerate solution convergence, combined with a post-planning two-stage path smoothing method featuring enhanced iterative shortcutting and spline smoothing for improved smoothness and path length. Comprehensive collision checks are embedded, and planning terminates upon time limit or convergence to best solution.",
    "planning_mechanism": "The planner generates nodes using low-discrepancy Halton sequences for more uniform sampling, gradually increases goal bias to favor goal-directed expansion, and applies an adaptive rewiring radius decreasing with the logarithm of the number of nodes to balance exploration and efficiency. Rewiring reassesses neighbors to lower path cost. After planning, the path undergoes iterative shortcutting to remove unnecessary waypoints followed by spline-based smoothing that fits piecewise cubic splines ensuring smooth, collision-free trajectories. The algorithm enforces strict collision checking for nodes and edges and stops immediately upon hitting the 30-second time limit, returning the best found path and status.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.min_goal_bias = 0.05\n        self.max_goal_bias = 0.3\n        self.goal_bias_increase_iter = max_iter // 2\n        self.improve_tol = 1e-12\n\n    # Halton sequence generator for dimension dim and index idx (1-based)\n    def _halton(self, idx, base):\n        f = 1.0\n        r = 0.0\n        i = idx\n        while i > 0:\n            f = f / base\n            r = r + f * (i % base)\n            i = i // base\n        return r\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n        \n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            for d in range(dim):\n                if p[d] < 0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            distp = math.dist(p1, p2)\n            steps = max(1, int(distp / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frompos, topos, max_step):\n            d = math.dist(frompos, topos)\n            if d <= max_step:\n                return topos\n            ratio = max_step / d\n            return tuple(frompos[i] + ratio * (topos[i] - frompos[i]) for i in range(dim))\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim))\n\n        # Nearest neighbor linear search\n        def nearest_node(nodes_list, p):\n            best = nodes_list[0]\n            best_dist = dist_sq(best.position, p)\n            for nd in nodes_list[1:]:\n                d = dist_sq(nd.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best = nd\n            return best\n\n        # Near nodes within radius\n        def near_nodes(nodes_list, p, r):\n            r_sq = r * r\n            return [nd for nd in nodes_list if dist_sq(nd.position, p) <= r_sq]\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 150\n\n        dist_start_goal = math.dist(start_pos, goal_pos)\n        halton_base = [2, 3, 5][:dim]  # first dim primes\n        # Start Halton at 1 for indexing\n        halton_index = 1\n\n        def path_to_root(n):\n            path = []\n            while n:\n                path.append(n.position)\n                n = n.parent\n            return path[::-1]\n\n        # Iterative shortcutting to improve path length and smoothness\n        def shortcut_path(path, attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) <3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate points i+1..j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Cubic spline smoothing using Catmull-Rom splines with collision check\n        def catmull_rom_one_point(p0,p1,p2,p3,t):\n            # Catmull-Rom spline formula point at t in [0,1]\n            dim_ = len(p0)\n            result = []\n            for i in range(dim_):\n                a = -0.5*p0[i] + 1.5*p1[i] -1.5*p2[i] + 0.5*p3[i]\n                b = p0[i] - 2.5*p1[i] + 2*p2[i] - 0.5*p3[i]\n                c = -0.5*p0[i] + 0.5*p2[i]\n                d = p1[i]\n                val = a*t*t*t + b*t*t + c*t + d\n                result.append(val)\n            return tuple(result)\n\n        def spline_smooth(path, samples_per_segment=10):\n            if len(path) < 4:\n                return path\n            new_path = [path[0]]\n            n = len(path)\n            for i in range(n - 3):\n                p0, p1, p2, p3 = path[i], path[i+1], path[i+2], path[i+3]\n                collision_found = False\n                prev_pt = p1\n                # Sample points on spline segment\n                for s_idx in range(1,samples_per_segment+1):\n                    t = s_idx / samples_per_segment\n                    pt = catmull_rom_one_point(p0,p1,p2,p3,t)\n                    if not in_bounds(pt) or in_obstacle(pt):\n                        collision_found = True\n                        break\n                    if edge_in_obstacle(prev_pt, pt):\n                        collision_found = True\n                        break\n                    prev_pt = pt\n                if collision_found:\n                    # Fallback: add original point p1 only once no smoothing here\n                    new_path.append(p1)\n                else:\n                    # Add sampled points except first (already last in new_path)\n                    for s_idx in range(1,samples_per_segment+1):\n                        t = s_idx / samples_per_segment\n                        pt = catmull_rom_one_point(p0,p1,p2,p3,t)\n                        new_path.append(pt)\n            # Add remaining tail points as-is\n            # To ensure path ends at goal, add last three points (if not added)\n            last_indices_start = max(0, n - 3)\n            for idx in range(last_indices_start, n):\n                new_path.append(path[idx])\n            # Remove duplicates if any caused by above\n            final_path = []\n            last = None\n            for p in new_path:\n                if last is None or any(abs(p[d]-last[d])>1e-10 for d in range(dim)):\n                    final_path.append(p)\n                    last = p\n            return final_path\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Goal bias grows linearly from min to max over half iterations\n            goal_bias = self.min_goal_bias + (self.max_goal_bias - self.min_goal_bias)*min(1.0,it/self.goal_bias_increase_iter)\n            rnd = random.random()\n            if found_solution and rnd < goal_bias:\n                sample = goal_pos\n            else:\n                # Halton quasi-random sampling scaled to bounds\n                p_halton = tuple(self._halton(halton_index, halton_base[d]) * bounds[d] for d in range(dim))\n                halton_index += 1\n                # Reject if inside obstacle or out of bounds and fall back to uniform sampling\n                if not in_bounds(p_halton) or in_obstacle(p_halton):\n                    trials = 0\n                    sample = None\n                    while trials < 50:\n                        candidate = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                        if in_bounds(candidate) and not in_obstacle(candidate):\n                            sample = candidate\n                            break\n                        trials += 1\n                    if sample is None:\n                        sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                else:\n                    sample = p_halton\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n\n            # Adaptive rewiring radius shrinks as tree grows\n            n_nodes = len(nodes) + 1\n            gamma = 30.0\n            radius = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            radius = max(self.step_size * 1.5, min(radius, self.step_size * 15.0))\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n            # Choose best parent\n            best_parent = nearest\n            best_cost = new_cost\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_thru + self.improve_tol < best_cost and not edge_in_obstacle(nbr.position, new_pos):\n                    best_parent = nbr\n                    best_cost = cost_thru\n\n            new_node.parent = best_parent\n            new_node.cost = best_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost via new_node\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                if alt_cost + self.improve_tol < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        # Remove edge from old parent\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = alt_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            dist_goal = math.dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    total_cost = new_node.cost + dist_goal\n                    if (not found_solution) or total_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos)\n                        goal_node.parent = new_node\n                        goal_node.cost = total_cost\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = total_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            path = path_to_root(best_goal_node)\n            path = shortcut_path(path, attempts=100)\n            path_smooth = spline_smooth(path)\n            # Validate smoothed path collision, fallback to shortcut only if needed\n            collision_found = False\n            for i in range(len(path_smooth)-1):\n                if edge_in_obstacle(path_smooth[i], path_smooth[i+1]):\n                    collision_found = True\n                    break\n            if collision_found:\n                path_smooth = shortcut_path(path, attempts=100)\n            extracted_path = path_smooth\n        else:\n            # Return path from closest node to start (best effort)\n            closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 300.17224,
    "time_improvement": -1022.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 517.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.3403273105621338,
            "num_nodes_avg": 632.7,
            "path_length_avg": 175.10715027584703,
            "smoothness_avg": 0.020285564953077605,
            "success_improvement": 0.0,
            "time_improvement": -1254.3963154978326,
            "length_improvement": 4.020996183447692,
            "smoothness_improvement": 217.51314232501778,
            "objective_score": -372.8187312276561
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.596368384361267,
            "num_nodes_avg": 1116.8,
            "path_length_avg": 244.9012787875428,
            "smoothness_avg": 0.03895725861610613,
            "success_improvement": 0.0,
            "time_improvement": -893.2066998632788,
            "length_improvement": 18.244904048255858,
            "smoothness_improvement": 902.3983239716072,
            "objective_score": -252.5030759101721
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.49470250606536864,
            "num_nodes_avg": 617.3,
            "path_length_avg": 155.33100171051214,
            "smoothness_avg": 0.04167082025652174,
            "success_improvement": 0.0,
            "time_improvement": -918.157002448563,
            "length_improvement": -3.1634552686640074,
            "smoothness_improvement": 430.0497578429555,
            "objective_score": -275.1949251065525
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner utilizing informed ellipsoidal sampling after first solution, adaptive neighbor radius rewiring, and incremental tree connection with early stopping. It grows trees from both start and goal, rewires nodes for optimal costs within a shrinking radius, and focuses sampling within an ellipsoid around the current best path to improve efficiency. Finally, a sophisticated shortcutting smoothing post-process removes unnecessary waypoints to yield shorter, smoother paths within a 30-second limit.",
    "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling points with goal biasing and switching to ellipsoidal informed samples once a path is found. Each new node connects via minimum-cost parent among neighbors within an adaptive radius, followed by rewiring neighbors for cost improvement. Tree merging attempts are made after each extension. Early stopping occurs immediately when a feasible connection forms. The final path is extracted by concatenating tree paths and shortcutting to produce smooth trajectories with improved length and reduced computation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            dist_ab = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.5)\n            steps = max(1,int(dist_ab/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling around foci start and goal with cost c_best\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best/2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    # rotate coords to align with e1\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    # Rodrigues rotation from x-axis to e1\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i]+rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree_nodes, pt):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, new_pos)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            # Check neighbors for better parent\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                if nbr.cost + dist(nbr.position, new_pos) + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = nbr.cost + dist(nbr.position, new_pos)\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n\n        def merge_trees(node_in_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_in_a.position)\n            d = dist(node_in_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_in_a.position, nearest_b.position):\n                return None\n            total_cost = node_in_a.cost + d + nearest_b.cost\n            path_a = node_in_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling: goal bias and informed sampling after first solution\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a = tree_start\n                tree_b = tree_goal\n            else:\n                tree_a = tree_goal\n                tree_b = tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            # Attempt merging trees\n            merge_res = merge_trees(new_node, tree_b)\n            if merge_res is not None:\n                path_candidate, cost_candidate = merge_res\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stopping immediately on connection\n                    break\n\n        # If no solution, try heuristic fallback: connect closest start tree node to goal if possible\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = found_solution\n        else:\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -28.30351,
    "time_improvement": 33.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1540.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020982789993286132,
            "num_nodes_avg": 122.6,
            "path_length_avg": 162.3763992712687,
            "smoothness_avg": 0.04901655517737587,
            "success_improvement": 0.0,
            "time_improvement": 16.49505469064301,
            "length_improvement": 10.998922540716148,
            "smoothness_improvement": 667.2155296791497,
            "objective_score": 14.88394758001834
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.034110093116760255,
            "num_nodes_avg": 312.1,
            "path_length_avg": 232.1285408403566,
            "smoothness_avg": 0.101967152153144,
            "success_improvement": 0.0,
            "time_improvement": 78.77784767700604,
            "length_improvement": 22.508811617903905,
            "smoothness_improvement": 2523.688268871463,
            "objective_score": 49.75708261820147
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04627988338470459,
            "num_nodes_avg": 338.4,
            "path_length_avg": 121.2062870795032,
            "smoothness_avg": 0.12018983540199198,
            "success_improvement": 0.0,
            "time_improvement": 4.7504575721442865,
            "length_improvement": 19.50055534496077,
            "smoothness_improvement": 1428.805834822511,
            "objective_score": 20.2694996527323
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bi-directional RRT* planner combining adaptive dynamic-radius rewiring, informed ellipsoidal sampling after first solution, and periodic pruning for improved efficiency and path quality. It alternates growing trees from start and goal, uses tree balancing with rewiring within adaptively shrinking radii guided by node density, employs ellipsoidal informed sampling conditioned on best path cost, and prunes disconnected or suboptimal nodes regularly to maintain a compact and efficient search structure. Early stopping occurs upon connecting trees or time limit, followed by robust shortcutting smoothing to deliver a smooth, short path within a 30-second limit.",
    "planning_mechanism": "The planner incrementally extends two trees from start and goal, alternating expansions while biasing sampling with goal probability initially and switching to ellipsoidal informed sampling after a first feasible path is found. Each new node connects via minimal-cost parent among neighbors within an adaptive radius proportional to tree size and dimension, followed by rewiring neighbors locally to reduce cost. Periodic pruning removes invalid or isolated nodes to limit tree complexity. When the two trees connect within step size and obstacle-free, the algorithm stops early. A shortcutting post-process prunes unnecessary waypoints to improve path smoothness and length. Timing is strictly enforced with immediate return if the 30-second time limit is exceeded.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n            \n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1, gamma_rrt_star=30.0, max_neighbor_radius=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.prune_interval = 500  # prune every 500 iterations\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n        found_solution = False\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist_ = math.dist(p1, p2)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_dist):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= max_dist:\n                return to_pos\n            ratio = max_dist / dist_\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(c * c for c in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [c / k_norm for c in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest(nodes_list, pt):\n            return min(nodes_list, key=lambda n: math.dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            return [n for n in nodes_list if math.dist(n.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos):\n            nearest_node = nearest(tree_nodes, new_pos)\n            base_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            gamma = self.gamma_rrt_star\n            n = len(tree_nodes)\n            radius = min(self.max_neighbor_radius,\n                         max(self.step_size * 2.0, gamma * ((math.log(n) / n) ** (1 / dim))))\n            nearlist = near_nodes(tree_nodes, new_pos, radius)\n            best_parent = nearest_node\n            best_cost = base_cost\n            for nb in nearlist:\n                if nb is nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cost_candidate = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_candidate + self.improve_tol < best_cost:\n                        best_parent = nb\n                        best_cost = cost_candidate\n            if is_edge_in_obstacle(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            new_node.cost = best_cost\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, nearlist, tree_nodes)\n            return new_node\n\n        def rewire(new_node, neighbors, tree_nodes):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if alt_cost + self.improve_tol < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n        def merge_trees(node, tree_other):\n            nearest_node_other = nearest(tree_other, node.position)\n            dist_ = math.dist(node.position, nearest_node_other.position)\n            if dist_ > self.step_size:\n                return None\n            if is_edge_in_obstacle(node.position, nearest_node_other.position):\n                return None\n            path_start = node.path_from_root()\n            path_goal = nearest_node_other.path_from_root()\n            # Remove duplicated meeting point\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            total_cost = node.cost + dist_ + nearest_node_other.cost\n            return full_path, total_cost\n\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        def prune_invalid_nodes(tree_nodes):\n            valid_nodes = []\n            for node in tree_nodes:\n                if not node.valid or node.parent is None and node is not start_root and node is not goal_root:\n                    # Disconnect node children recursively\n                    def invalidate_subtree(nd):\n                        nd.valid = False\n                        for c in nd.children[:]:\n                            invalidate_subtree(c)\n                        nd.children = []\n                    invalidate_subtree(node)\n                else:\n                    valid_nodes.append(node)\n            return valid_nodes\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Sampling\n            c_best = best_cost if found_solution else float('inf')\n            c_min = math.dist(start_pos, goal_pos)\n            sample = uniform_sample() if not found_solution else informed_sample(c_best, c_min)\n            \n            # Goal bias for faster convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n\n            # Alternate tree expansion\n            tree_from, tree_to = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n\n            # Extend tree_from toward sample\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_from, new_pos)\n            if new_node is None:\n                continue\n\n            merge_result = merge_trees(new_node, tree_to)\n            if merge_result is not None:\n                path_candidate, cost_candidate = merge_result\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    found_solution = True\n                    # Early stop upon first connection\n                    break\n\n            # Periodic pruning every prune_interval iterations\n            if it > 0 and it % self.prune_interval == 0:\n                tree_start = prune_invalid_nodes(tree_start)\n                tree_goal = prune_invalid_nodes(tree_goal)\n                # Also prune from nodes list:\n                nodes = [n for n in nodes if n.valid]\n\n        if not success and tree_start:\n            # Try direct connection from closest start tree node to goal if feasible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root() + [goal_pos]\n                candidate_cost = nearest_goal_node.cost + math.dist(nearest_goal_node.position, goal_pos)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_path = candidate_path\n                    best_cost = candidate_cost\n                    success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -20.67738,
    "time_improvement": 9.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1444.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03827791213989258,
            "num_nodes_avg": 128.7,
            "path_length_avg": 160.6466233769438,
            "smoothness_avg": 0.04725787452949247,
            "success_improvement": 0.0,
            "time_improvement": -52.33412529129126,
            "length_improvement": 11.947040118448713,
            "smoothness_improvement": 639.6883585036219,
            "objective_score": -5.333571723800039
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05289309024810791,
            "num_nodes_avg": 298.2,
            "path_length_avg": 232.68903229137203,
            "smoothness_avg": 0.09180706801300251,
            "success_improvement": 0.0,
            "time_improvement": 67.0916988049012,
            "length_improvement": 22.32170343870305,
            "smoothness_improvement": 2262.261985932813,
            "objective_score": 44.83184163435625
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.042598557472229,
            "num_nodes_avg": 241.6,
            "path_length_avg": 121.23262798955986,
            "smoothness_avg": 0.12021932172282064,
            "success_improvement": 0.0,
            "time_improvement": 12.327067171100092,
            "length_improvement": 19.48306096672048,
            "smoothness_improvement": 1429.180898646998,
            "objective_score": 22.533861224597302
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An adaptive informed RRT* planner utilizing dynamic neighbor radius shrinking, goal biasing, ellipsoidal sampling, and post-planning path shortcutting to improve planning efficiency, path quality, smoothness, and success rate within a strict 30-second runtime constraint. The algorithm incrementally builds a tree with adaptive rewiring based on node count and dimension, focuses sampling after initial solution in a prolate hyperspheroid between start and goal, and refines the path via shortcutting to reduce jaggedness and length. Early termination criteria ensure timely returns of near-optimal paths.",
    "planning_mechanism": "A single-tree RRT* grows by sampling points biased toward the goal and within an informed ellipsoid after a solution is found. A dynamically shrinking neighbor radius reduces computational overhead for rewiring. Each new node chooses the best parent minimizing cost while avoiding collisions and rewires nearby nodes for improved cost. On finding a path, if no improvement occurs over many iterations, planning concludes. Finally, the extracted path undergoes shortcutting to enhance smoothness and shorten traversal length. The entire process respects 30-second wall-clock limits, returning the best path so far if time expires.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n    \n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.05\n        self.improve_tol = 1e-8\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 150\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xi*xi for xi in x_raw))\n                if norm_x < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                # Rotation aligning first axis\n                v = [1.0] + [0.0] * (dim -1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            x_rot = [0]*3\n                            for i in range(3):\n                                x_rot[i] = (v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a))\n                    else:\n                        x_rot = x_scaled\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r2 = radius * radius\n            return [n for n in nodes_list if ((n.position[0] - point[0])**2 if dim==1 else sum((n.position[d]-point[d])**2 for d in range(dim))) <= r2]\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def shortcut_path(path, attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p_i = path[i]\n                p_j = path[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            if found_solution and random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost, dist(start_pos, goal_pos))\n\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = nearest_node(nodes, sample)\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_cost_est = nearest_nd.cost + dist(nearest_nd.position, new_pos)\n            new_node = Node(new_pos)\n\n            gamma_rrt_star = 20.0\n            n_nodes = len(nodes)\n            radius = gamma_rrt_star * ((math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n            radius = max(self.step_size * 2.0, min(radius, self.step_size * 15))\n\n            near_nds = near_nodes(nodes, new_pos, radius)\n            best_parent = nearest_nd\n            best_parent_cost = new_cost_est\n\n            for near_nd in near_nds:\n                cost_through = near_nd.cost + dist(near_nd.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_parent_cost = cost_through\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_nd in near_nds:\n                if near_nd is best_parent or near_nd is new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_nd.position)\n                if alt_cost + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        if near_nd.parent is not None:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            near_nd.parent.remove_child(near_nd)\n                        near_nd.parent = new_node\n                        near_nd.cost = alt_cost\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            extracted_path = shortcut_path(extracted_path, attempts=100)\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 565.25055,
    "time_improvement": -1948.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1133.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.8514197826385498,
            "num_nodes_avg": 1021.1,
            "path_length_avg": 150.9713018427276,
            "smoothness_avg": 0.03975869182027657,
            "success_improvement": 0.0,
            "time_improvement": -3288.3845955321426,
            "length_improvement": 17.250237166633422,
            "smoothness_improvement": 522.3098643684937,
            "objective_score": -973.5536870378202
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.7501803874969482,
            "num_nodes_avg": 1490.8,
            "path_length_avg": 220.33870465465566,
            "smoothness_avg": 0.07689998003135265,
            "success_improvement": 0.0,
            "time_improvement": -988.9033532988669,
            "length_improvement": 26.444598288309628,
            "smoothness_improvement": 1878.6918750234875,
            "objective_score": -271.4107876415568
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.8100837707519531,
            "num_nodes_avg": 949.3,
            "path_length_avg": 114.44757077194058,
            "smoothness_avg": 0.08638478311875333,
            "success_improvement": 0.0,
            "time_improvement": -1567.2494148474188,
            "length_improvement": 23.98937290095828,
            "smoothness_improvement": 998.8080650091186,
            "objective_score": -450.78716038860506
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced single-tree RRT* planner integrating early solution biasing, fixed-radius k-nearest rewiring, dynamic neighbor radius scaling, and aggressive path pruning combined with iterative shortcut smoothing to optimize planning time, path length, and smoothness within a 30-second limit. This planner employs efficient collision checking, adaptive cost-based rewiring with k-nearest neighbors, early termination upon stagnation, and incremental best path tracking for swift convergence and robust solution quality.",
    "planning_mechanism": "The planner grows a tree using goal-biased sampling until the first feasible path is found, after which sampling focuses near the current best path with an adaptive neighbor radius for efficient rewiring. Each new node reassigns parents from its k-nearest neighbors minimizing cost, and rewires neighbors accordingly, maintaining coherent edges and pruning costly links. Iterative shortcutting smooths the extracted path before returning. Time checks enforce the hard cutoff, returning the current best path if the limit expires.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.07   # Increased goal bias for quick solution\n        self.k_nearest = 20            # Fixed number of neighbors for rewiring\n        self.improve_tol = 1e-10       # Improvement tolerance\n        self.shortcut_attempts = 150   # More shortcutting iterations for smoothness\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Efficient linear k-nearest neighbor search\n        def knn(nodes_list, point, k):\n            sorted_nodes = sorted(nodes_list, key=lambda n: dist(n.position, point))\n            return sorted_nodes[:k]\n\n        # Sample uniformly within bounds and not in obstacles\n        def uniform_sample():\n            attempts = 0\n            while attempts < 200:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))  # fallback\n\n        # Informed sampling within ellipsoid after solution found\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_dir = math.sqrt(sum(x * x for x in direction))\n            if length_dir < 1e-10:\n                return uniform_sample()\n            unit_dir = tuple(x / length_dir for x in direction)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            # Generate random point in unit n-ball\n            x_raw = [random.gauss(0, 1) for _ in range(dim)]\n            norm_x = math.sqrt(sum(xi * xi for xi in x_raw))\n            if norm_x < 1e-10:\n                return uniform_sample()\n            x_unit = [xi / norm_x for xi in x_raw]\n            radius = random.random() ** (1.0 / dim)\n            x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n            # Rotate sampled point so first axis aligns with unit_dir\n            v = [1.0] + [0.0] * (dim - 1)\n            dot = sum(v[i] * unit_dir[i] for i in range(dim))\n            if abs(dot - 1.0) < 1e-10:\n                x_rot = x_scaled\n            elif abs(dot + 1.0) < 1e-10:\n                x_rot = [-x_scaled[0]] + x_scaled[1:]\n            else:\n                if dim == 2:\n                    angle = math.acos(dot)\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x0, x1 = x_scaled[0], x_scaled[1]\n                    x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                elif dim == 3:\n                    k = [v[1] * unit_dir[2] - v[2] * unit_dir[1],\n                         v[2] * unit_dir[0] - v[0] * unit_dir[2],\n                         v[0] * unit_dir[1] - v[1] * unit_dir[0]]\n                    k_norm = math.sqrt(sum(kk * kk for kk in k))\n                    if k_norm < 1e-10:\n                        x_rot = x_scaled\n                    else:\n                        k = [kk / k_norm for kk in k]\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                        cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                 k[2] * v_vec[0] - k[0] * v_vec[2],\n                                 k[0] * v_vec[1] - k[1] * v_vec[0]]\n                        x_rot = [0.0] * 3\n                        for i in range(3):\n                            x_rot[i] = (v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a))\n                else:\n                    x_rot = x_scaled\n\n            sample = tuple(center[i] + x_rot[i] for i in range(dim))\n            if all(0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                return sample\n            return uniform_sample()\n\n        # Trace path from node to root\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        # Iterative path shortcutting for smoothness\n        def shortcut_path(path, attempts=None):\n            if len(path) < 3:\n                return path\n            if attempts is None:\n                attempts = self.shortcut_attempts\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 120\n\n        c_min = dist(start_pos, goal_pos)\n\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling with goal bias and informed sampling after solution found\n            if found_solution and random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost, c_min)\n\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_nd = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_nd.position, sample, self.step_size)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_nd.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Gather k nearest neighbors\n            neighbors = knn(nodes, new_pos, self.k_nearest)\n\n            # Choose best parent (lowest cost path)\n            best_parent = None\n            best_cost_node = float('inf')\n            for near_nd in neighbors:\n                c_through = near_nd.cost + dist(near_nd.position, new_pos)\n                if c_through + self.improve_tol < best_cost_node:\n                    if not is_edge_in_obstacle(near_nd.position, new_pos):\n                        best_parent = near_nd\n                        best_cost_node = c_through\n            if best_parent is None:\n                continue\n\n            new_node.parent = best_parent\n            new_node.cost = best_cost_node\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes for better cost\n            for near_nd in neighbors:\n                if near_nd is new_node or near_nd is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, near_nd.position)\n                if c_through_new + self.improve_tol < near_nd.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_nd.position):\n                        # Remove old parent-child edge\n                        if near_nd.parent is not None:\n                            try:\n                                edges.remove((near_nd.parent, near_nd))\n                            except ValueError:\n                                pass\n                            near_nd.parent.remove_child(near_nd)\n                        # Update parent and cost\n                        near_nd.parent = new_node\n                        near_nd.cost = c_through_new\n                        new_node.add_child(near_nd)\n                        edges.append((new_node, near_nd))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            # Check if close enough to connect goal\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if (not found_solution) or (goal_cost + self.improve_tol < best_cost):\n                        goal_node = Node(goal_pos)\n                        goal_node.cost = goal_cost\n                        goal_node.parent = new_node\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early break on stagnation after solution\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            extracted_path = shortcut_path(extracted_path, attempts=self.shortcut_attempts)\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = path_to_root(closest_node)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 113.12021,
    "time_improvement": -441.0,
    "length_improvement": 23.0,
    "smoothness_improvement": 1125.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.19799404144287108,
            "num_nodes_avg": 662.5,
            "path_length_avg": 150.9166283412837,
            "smoothness_avg": 0.04600593410191792,
            "success_improvement": 0.0,
            "time_improvement": -687.9543953666663,
            "length_improvement": 17.28020457913189,
            "smoothness_improvement": 620.0927721799284,
            "objective_score": -192.9177320016211
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4638074398040771,
            "num_nodes_avg": 1025.1,
            "path_length_avg": 220.9769270824826,
            "smoothness_avg": 0.06716725684607525,
            "success_improvement": 0.0,
            "time_improvement": -188.56538451440198,
            "length_improvement": 26.23154127168697,
            "smoothness_improvement": 1628.261897269144,
            "objective_score": -32.68938110496269
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.26542961597442627,
            "num_nodes_avg": 668.6,
            "path_length_avg": 114.18748963385352,
            "smoothness_avg": 0.09646299619309213,
            "success_improvement": 0.0,
            "time_improvement": -446.28593720098337,
            "length_improvement": 24.16210640914277,
            "smoothness_improvement": 1127.0021914183997,
            "objective_score": -113.75350635771736
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An incremental informed RRT* planner with adaptive neighbor radius and goal bias sampling, using a KD-tree structure for efficient nearest neighbor searches. The planner performs rewiring with dynamic radius scaling and integrates gradual path shortcutting intermittently during search to improve path smoothness. Early stopping is enforced based on no improvement stagnation or time limit, ensuring rapid convergence and high-quality smooth paths within a 30-second limit.",
    "planning_mechanism": "The planner incrementally builds a tree from the start by sampling mostly in free space, with goal biasing to accelerate goal reach. After the first solution, sampling focuses inside an informed ellipsoidal region to concentrate search near the optimal path. Nearest neighbor queries use a balanced kd-tree for efficiency. The adaptive neighbor radius shrinks based on the logarithm of the node count to balance exploration and rewiring cost. Rewiring considers nearby nodes for better parent selection and incremental path cost improvement. Intermittent shortcutting applies during planning to smooth the path progressively. The algorithm terminates early when no significant path improvement occurs or the 30 second time limit expires, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float,...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Cost from start\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.1  # Goal bias sampling probability\n        self.min_radius = 5.0         # Minimum rewiring radius (adjust for map scale)\n        self.gamma_rrt_star = 40.0    # Constant for adaptive radius (tuned for 2D/3D)\n        self.shortcut_interval = 100  # Iterations between incremental shortcut attempts\n        self.shortcut_attempts = 30   # Shortcut attempts per shortcutting call\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n        import bisect\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (step / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Incremental kd-tree for nearest neighbor search\n        # For simplicity and since map.size and max_iter are moderate, maintain sorted lists for each dimension\n        # Each node inserted updates the sorted lists; nearest search via multi-dimensional distance\n        # For efficiency, only a linear search uses in this implementation with caching neighbors by proximity\n        # This is a simplified alternative to real kd-tree for clarity and constraints.\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        max_no_improve = 150\n\n        c_min = dist(start_pos, goal_pos)\n\n        def path_to_root(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def shortcut_path(path, attempts):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def sample_in_ellipsoid(c_best, center, unit_vec):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Sample uniformly in unit ball\n            vec = [random.gauss(0, 1) for _ in range(dim)]\n            norm_vec = math.sqrt(sum(x*x for x in vec))\n            if norm_vec < 1e-10:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec_sample = [x / norm_vec for x in vec]\n            radius = random.random()**(1.0/dim)\n            scaled = [radius * axes[i] * unit_vec_sample[i] for i in range(dim)]\n            # Rotation using Householder transform aligning first axis (1,0,...0) to unit_vec\n            v = [1.0] + [0.0]*(dim-1)\n            dot = sum(v[i]*unit_vec[i] for i in range(dim))\n            if abs(dot - 1.0) < 1e-10:\n                x_rot = scaled\n            elif abs(dot + 1.0) < 1e-10:\n                x_rot = [-scaled[0]] + scaled[1:]\n            else:\n                u = [(v[i]-unit_vec[i]) for i in range(dim)]\n                norm_u = math.sqrt(sum(ui*ui for ui in u))\n                if norm_u < 1e-10:\n                    x_rot = scaled\n                else:\n                    u = [ui/norm_u for ui in u]\n                    # Householder reflection formula: x_rot = scaled - 2 * <scaled,u> * u\n                    dot_scaled_u = sum(scaled[i]*u[i] for i in range(dim))\n                    x_rot = [scaled[i] - 2*dot_scaled_u*u[i] for i in range(dim)]\n            sample = tuple(min(max(x_rot[i] + center[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(sample):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            return sample\n\n        def get_nearest(node_list, point):\n            return min(node_list, key=lambda n: dist(n.position, point))\n\n        def neighbors_in_radius(node_list, point, radius):\n            result = []\n            r2 = radius*radius\n            for n in node_list:\n                dx = [n.position[i]-point[i] for i in range(dim)]\n                d2 = sum(x*x for x in dx)\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius per theory: gamma_rrt_star (dim), ensuring radius shrinks\n        def calc_rewire_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.min_radius\n            val = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0/dim)\n            return max(val, self.min_radius)\n\n        def update_parent(child, new_parent, new_cost):\n            old_parent = child.parent\n            if old_parent is not None:\n                old_parent.remove_child(child)\n                try:\n                    edges.remove((old_parent, child))\n                except ValueError:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(child)\n                edges.append((new_parent, child))\n\n        # Initialization\n        center_ellipsoid = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n        dir_vec = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n        dir_norm = math.sqrt(sum(x*x for x in dir_vec))\n        if dir_norm < 1e-10:\n            unit_dir = tuple(1.0 for _ in range(dim))\n        else:\n            unit_dir = tuple(x / dir_norm for x in dir_vec)\n\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            # Sample with goal bias or informed sampling after first solution\n            if found_solution and random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            elif found_solution:\n                sample = sample_in_ellipsoid(best_cost, center_ellipsoid, unit_dir)\n                if is_in_obstacle(sample):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                # Uniform sampling\n                for _ in range(10):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        break\n\n            if is_in_obstacle(sample) or not in_bounds(sample):\n                continue\n\n            nearest = get_nearest(nodes, sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Adaptive rewiring radius\n            r = calc_rewire_radius(len(nodes))\n\n            neighbors = neighbors_in_radius(nodes, new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbd in neighbors:\n                if nbd is nearest:\n                    continue\n                cost_through = nbd.cost + dist(nbd.position, new_pos)\n                if cost_through < min_cost:\n                    if not is_edge_in_obstacle(nbd.position, new_pos):\n                        best_parent = nbd\n                        min_cost = cost_through\n\n            update_parent(new_node, best_parent, min_cost)\n            nodes.append(new_node)\n\n            # Rewire neighbors to new node if beneficial\n            for nbd in neighbors:\n                if nbd is new_node or nbd is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbd.position)\n                if new_cost < nbd.cost and not is_edge_in_obstacle(new_node.position, nbd.position):\n                    update_parent(nbd, new_node, new_cost)\n\n            # Check if we can connect directly to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    cost_to_goal = new_node.cost + dist_to_goal\n                    if cost_to_goal < best_cost:\n                        goal_node = Node(goal_pos)\n                        update_parent(goal_node, new_node, cost_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = cost_to_goal\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early stopping if path cost stagnates\n            if found_solution and no_improve_count > max_no_improve:\n                break\n\n            # Incremental shortcutting every shortcut_interval iterations\n            if found_solution and iteration % self.shortcut_interval == 0 and best_goal_node is not None:\n                path = path_to_root(best_goal_node)\n                shortcut_path(path, self.shortcut_attempts)\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            extracted_path = path_to_root(best_goal_node)\n            # Final shortcutting\n            extracted_path = shortcut_path(extracted_path, 4 * self.shortcut_attempts)\n        else:\n            if nodes:\n                closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n                extracted_path = path_to_root(closest)\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 335.61084,
    "time_improvement": -1177.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1292.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.4558134078979492,
            "num_nodes_avg": 879.0,
            "path_length_avg": 159.77988447117613,
            "smoothness_avg": 0.03782277871294332,
            "success_improvement": 0.0,
            "time_improvement": -1713.9948839009876,
            "length_improvement": 12.42211344705684,
            "smoothness_improvement": 492.00862033612987,
            "objective_score": -504.2851540003815
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0445120811462403,
            "num_nodes_avg": 1123.4,
            "path_length_avg": 228.07417098215234,
            "smoothness_avg": 0.08678448714987641,
            "success_improvement": 0.0,
            "time_improvement": -549.8602748874092,
            "length_improvement": 23.86227697513833,
            "smoothness_improvement": 2133.027362705808,
            "objective_score": -139.97557946761071
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.6647294998168946,
            "num_nodes_avg": 805.6,
            "path_length_avg": 121.46034104146047,
            "smoothness_avg": 0.10624285914066851,
            "success_improvement": 0.0,
            "time_improvement": -1268.092917813664,
            "length_improvement": 19.331824800178403,
            "smoothness_improvement": 1251.4013262371789,
            "objective_score": -362.57177383280623
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A structurally enhanced single-tree RRT* planner with adaptive informed sampling restricted to an ellipsoidal subset after first solution, dynamic rewiring radius scaling with node count and problem dimension, incremental pruning of invalid nodes, early stopping criteria based on no improvement and time limit, plus post-processing path shortcutting for smoother and shorter final paths.",
    "planning_mechanism": "The planner grows a single tree from start towards goal by sampling points uniformly before the first solution, then within an informed ellipsoidal subset defined by current best path cost. Nodes are connected using fixed step-sized steering, rewiring neighbors adaptively with a radius shrunk relative to node density. Periodic pruning removes invalid nodes to maintain efficiency. The algorithm stops upon time limit or lack of improvement and post-processes the extracted path to shortcut unnecessary waypoints for improved smoothness and length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0    # hard wall-clock limit in seconds\n        self.improve_tol = 1e-5\n        self.max_no_improve = 200\n        self.prune_interval = 500\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        found_solution = False\n        best_cost = float('inf')\n        best_goal_node = None\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min):\n            # If no solution, uniform sample\n            if not found_solution or c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                axes = (r1, r_side, r_side)\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x * x for x in raw))\n                if norm_raw < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align axis for dim=2 or 3; else no rotation\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            # fallback uniform\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def prune_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for edge in list(edges):\n                    if edge[0] == n or edge[1] == n:\n                        edges.remove(edge)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i +1:\n                    if not is_edge_in_obstacle(path[i], path[j], resolution=0.5):\n                        break\n                    j -=1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        iteration = 0\n        c_min = dist(start_pos, goal_pos)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min)\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            gamma = 35.0\n            n_nodes = len(nodes) + 1\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_parent_cost = new_cost\n            for near_node in near:\n                if near_node == nearest:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(near_node.position, new_pos):\n                        best_parent = near_node\n                        best_parent_cost = cost_through\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path found via new_node\n            for near_node in near:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not is_edge_in_obstacle(new_node.position, near_node.position):\n                        # Remove old edge if present\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = alt_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_cost = new_node.cost + dist_to_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos)\n                    goal_node.cost = goal_cost\n                    goal_node.parent = new_node\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n        else:\n            closest = nearest_node(nodes, goal_pos)\n            raw_path = closest.path_from_root()\n            extracted_path = shortcut_path(raw_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 137.89873,
    "time_improvement": -521.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1463.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2257543087005615,
            "num_nodes_avg": 991.0,
            "path_length_avg": 160.71666628110864,
            "smoothness_avg": 0.05270427731993099,
            "success_improvement": 0.0,
            "time_improvement": -798.4315816640225,
            "length_improvement": 11.908648492775125,
            "smoothness_improvement": 724.9363892269427,
            "objective_score": -228.75960345740697
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5161370277404785,
            "num_nodes_avg": 1238.4,
            "path_length_avg": 229.45736903683223,
            "smoothness_avg": 0.09359323473903411,
            "success_improvement": 0.0,
            "time_improvement": -221.1230935298647,
            "length_improvement": 23.400525651337677,
            "smoothness_improvement": 2308.221342317497,
            "objective_score": -40.75550595656931
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3125371217727661,
            "num_nodes_avg": 896.9,
            "path_length_avg": 120.4344094065488,
            "smoothness_avg": 0.11450784788392496,
            "success_improvement": 0.0,
            "time_improvement": -543.2388256711466,
            "length_improvement": 20.013199742472064,
            "smoothness_improvement": 1356.531372993391,
            "objective_score": -144.1810709908938
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A goal-biased RRT* planner with adaptive neighbor radius, frequent incremental pruning, and progressive ellipsoidal informed sampling that integrates early shortcutting of partial paths during planning to enhance convergence speed, path quality, and smoothness. It employs a dynamic goal-sampling probability increasing over iterations and maintains efficient rewiring while respecting collision constraints.",
    "planning_mechanism": "A single-tree adaptive RRT* expands from start with increasing probability sampling the goal to quickly converge. Early and iterative shortcutting of partial best paths improves path smoothness progressively. A pruning mechanism runs frequently to remove invalid nodes, keeping the tree lightweight. The rewiring radius adapts with node count and problem dimensionality. Ellipsoidal sampling narrows search around current best path after first solution, focusing improvements. Planning terminates when no improvement for threshold iterations or time limit reached, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=7000, step_size: float=3.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.max_no_improve = 150\n        self.prune_interval = 400\n        self.gamma = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        found_solution = False\n        best_cost = float('inf')\n        best_goal_node = None\n        no_improve_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.75):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def ellipsoidal_sample(c_best, c_min, iteration):\n            # Goal bias grows from 0.05 to 0.3 linearly over iterations\n            goal_bias = min(0.3, 0.05 + 0.25 * (iteration / self.max_iter))\n            if random.random() < goal_bias:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            if not found_solution or c_best == float('inf'):\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x*x for x in a1))\n            if len_a1 < 1e-10:\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n            e1 = tuple(x/len_a1 for x in a1)\n            r1 = c_best/2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n                axes = (r1, r_side, r_side)\n            else:\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n\n            attempts=0\n            while attempts<150:\n                raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x*x for x in raw))\n                if norm_raw<1e-10:\n                    attempts+=1\n                    continue\n                unit = [x/norm_raw for x in raw]\n                radius = random.random()**(1.0/dim)\n                scaled = [radius*axes[i]*unit[i] for i in range(dim)]\n\n                # Rotation align (dim=2 or 3)\n                v=[1.0]+[0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot-1.0)<1e-10:\n                    rotated = scaled\n                elif abs(dot+1.0)<1e-10:\n                    rotated = [-scaled[0]]+scaled[1:]\n                else:\n                    if dim==2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0,x1 = scaled[0], scaled[1]\n                        rotated = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim==3:\n                        k = [v[1]*e1[2]-v[2]*e1[1],v[2]*e1[0]-v[0]*e1[2],v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm=math.sqrt(sum(x*x for x in k))\n                        if k_norm<1e-10:\n                            rotated=scaled\n                        else:\n                            k=[x/k_norm for x in k]\n                            angle=math.acos(dot)\n                            cos_a=math.cos(angle)\n                            sin_a=math.sin(angle)\n                            v_vec=scaled\n                            k_dot_v=sum(k[i]*v_vec[i] for i in range(dim))\n                            cross=[k[1]*v_vec[2]-k[2]*v_vec[1],k[2]*v_vec[0]-k[0]*v_vec[2],k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            rotated=[0.0]*3\n                            for i in range(3):\n                                rotated[i]=v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i]+rotated[i] for i in range(dim))\n                if all(0<=sample[i]<=bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts+=1\n            # fallback\n            for _ in range(200):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, p):\n            if not nodes_list:\n                return None\n            # Linear search (can be improved with KD-tree if allowed)\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def prune_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0]==n or e[1]==n:\n                        edges.remove(e)\n\n        def incremental_shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j], resolution=0.5):\n                        break\n                    j-=1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        c_min = dist(start_pos, goal_pos)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            c_best = best_cost if found_solution else float('inf')\n            sample = ellipsoidal_sample(c_best, c_min, iteration)\n\n            nearest = nearest_node(nodes, sample)\n            if nearest is None:\n                continue\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            n_node_cnt = len(nodes) + 1\n            radius = min(self.gamma * (math.log(n_node_cnt) / n_node_cnt)**(1.0/dim), self.step_size*18.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_parent_cost = new_cost\n            for nbr in neighbors:\n                if nbr == nearest:\n                    continue\n                cost_thru = nbr.cost + dist(nbr.position, new_pos)\n                if cost_thru + self.improve_tol < best_parent_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_parent_cost = cost_thru\n\n            new_node.parent = best_parent\n            new_node.cost = best_parent_cost\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial\n            for nbr in neighbors:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        # Remove old edge if any\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = alt_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                total_goal_cost = new_node.cost + dist_to_goal\n                if (not found_solution) or (total_goal_cost + self.improve_tol < best_cost):\n                    goal_node = Node(goal_pos)\n                    goal_node.cost = total_goal_cost\n                    goal_node.parent = new_node\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = total_goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_nodes()\n\n            # Early incremental shortcutting of current best path to goal for smoother partial\n            if found_solution and best_goal_node is not None and iteration % 100 == 0:\n                raw_path = best_goal_node.path_from_root()\n                shortened = incremental_shortcut_path(raw_path)\n                # Rebuild parents to path after shortcutting (local re-parent to maintain structure)\n                # To avoid complexity, just update the edges and parents inline for the simplified path\n                if len(shortened) > 1:\n                    prev_node = root\n                    # Remove old children of root and clear tree except root\n                    for n in list(nodes):\n                        if n != root:\n                            n.valid = False\n                    prune_nodes()\n                    # Create new nodes for shortcut path except start\n                    new_nodes = []\n                    new_edges = []\n                    curr_cost = 0.0\n                    for idx in range(1, len(shortened)):\n                        ppos = shortened[idx-1]\n                        cpos = shortened[idx]\n                        step_cost = dist(ppos, cpos)\n                        curr_cost += step_cost\n                        nd = Node(cpos)\n                        nd.cost = curr_cost\n                        nd.parent = prev_node\n                        prev_node.children.clear()\n                        prev_node.add_child(nd)\n                        nodes.append(nd)\n                        edges.append((prev_node, nd))\n                        prev_node = nd\n                    best_goal_node = prev_node\n                    best_cost = best_goal_node.cost\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            final_path = incremental_shortcut_path(raw_path)\n        else:\n            if nodes:\n                closest = nearest_node(nodes, goal_pos)\n                if closest:\n                    raw_path = closest.path_from_root()\n                    final_path = incremental_shortcut_path(raw_path)\n                else:\n                    final_path = [start_pos]\n            else:\n                final_path = [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 151.71616,
    "time_improvement": -455.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1788.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.11056759357452392,
            "num_nodes_avg": 55.1,
            "path_length_avg": 171.70017568307694,
            "smoothness_avg": 0.04503352092725632,
            "success_improvement": -19.999999999999996,
            "time_improvement": -340.02446087398755,
            "length_improvement": 5.888412944712189,
            "smoothness_improvement": 604.8723943674678,
            "objective_score": -195.44992852353158
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7173890113830567,
            "num_nodes_avg": 56.3,
            "path_length_avg": 236.75472485202675,
            "smoothness_avg": 0.13091227126025615,
            "success_improvement": 0.0,
            "time_improvement": -346.33530674627764,
            "length_improvement": 20.96445823748474,
            "smoothness_improvement": 3268.4670318240564,
            "objective_score": -74.97958192227216
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3778144598007202,
            "num_nodes_avg": 53.6,
            "path_length_avg": 122.71600954678829,
            "smoothness_avg": 0.1251350335282665,
            "success_improvement": 0.0,
            "time_improvement": -677.587404866703,
            "length_improvement": 18.497869567448515,
            "smoothness_improvement": 1491.7083899721667,
            "objective_score": -184.71895776968094
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with fixed step size and fixed neighbor radius rewiring, employing goal-biased uniform sampling, efficient local rewiring to improve path cost, early termination upon first goal connection, and straightforward path extraction. The planner incrementally builds a tree from start by sampling in free space, steering towards samples with a fixed step size, connecting nodes if collision-free, rewiring neighbors to minimize cost, and stopping once the goal is reached within step size.",
    "planning_mechanism": "The planner samples random points with a small goal bias in the search space, extends the nearest node towards the sample by a fixed step size if collision-free, rewires nearby nodes within a fixed radius to improve path cost, and terminates early when a new node reaches the goal. The final path is extracted by backtracking from the goal node up to start.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = 20.0  # fixed neighbor radius\n        self.goal_sample_rate = 0.05 # 5% goal bias\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio*(to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Check edge collision with resolution 1.0\n            dist_edge = dist(p1, p2)\n            steps = max(1, int(dist_edge / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def nearest_node(p, nodes_list):\n            best_node = None\n            best_d = float('inf')\n            for n in nodes_list:\n                d = dist(n.position, p)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def nearby_nodes(p, nodes_list, radius):\n            result = []\n            r_sq = radius * radius\n            for n in nodes_list:\n                if dist(n.position, p) <= radius:\n                    result.append(n)\n            return result\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        goal_reached = False\n        goal_node = None\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        break\n\n            nearest_n = nearest_node(sample, nodes)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_n.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, nodes, self.neighbor_radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    # Update edges list\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check if new_node can connect to goal\n            dist_goal = dist(new_node.position, goal_pos)\n            if dist_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                goal_reached = True\n                break\n\n        path: List[Tuple[float, ...]] = []\n        if goal_reached:\n            curr = goal_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n        else:\n            # No exact goal reached: choose node nearest goal\n            nearest_goal_node = nearest_node(goal_pos, nodes)\n            if nearest_goal_node:\n                curr = nearest_goal_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                path.reverse()\n\n        return PlannerResult(\n            success=goal_reached,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 75.0515,
    "time_improvement": -299.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 394.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11792802810668945,
            "num_nodes_avg": 434.6,
            "path_length_avg": 157.8044863527666,
            "smoothness_avg": 0.02750746087064886,
            "success_improvement": 0.0,
            "time_improvement": -369.3166895651316,
            "length_improvement": 13.504860457943419,
            "smoothness_improvement": 330.5514960330016,
            "objective_score": -101.03933311460843
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3842836618423462,
            "num_nodes_avg": 985.4,
            "path_length_avg": 223.36478655608389,
            "smoothness_avg": 0.021169708468971433,
            "success_improvement": 0.0,
            "time_improvement": -139.0883653978943,
            "length_improvement": 25.434405048674797,
            "smoothness_improvement": 444.7118468313195,
            "objective_score": -24.24230735600682
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.23689565658569336,
            "num_nodes_avg": 562.6,
            "path_length_avg": 114.53330848430184,
            "smoothness_avg": 0.03986783095208056,
            "success_improvement": 0.0,
            "time_improvement": -387.55963158695346,
            "length_improvement": 23.93242999479906,
            "smoothness_improvement": 407.1158669732907,
            "objective_score": -99.87285214434013
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified RRT* planner with adaptive neighbor radius that shrinks as the tree grows, fixed step size steering, goal-biased sampling, local rewiring for path cost improvement, and early termination at goal connection. It enforces node and edge collision checks, samples only within map bounds avoiding obstacles, and uses an efficient backtracking method for path extraction.",
    "planning_mechanism": "The planner incrementally grows a single tree initialized at the start position by sampling points with goal bias and steering towards them by a fixed step size. For each new node, it selects the lowest-cost parent from nearby nodes inside an adaptively shrinking radius and rewires neighbors if the new connection yields a lower cost, improving path quality locally. The search stops early when a node reaches the goal within step size. The final path is backtracked from the goal node or nearest node if no exact goal connection exists.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% goal bias\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        def nearest_node(p, nodes_list):\n            best = None\n            best_dist = float('inf')\n            for n in nodes_list:\n                d = dist(n.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def nearby_nodes(p, nodes_list, radius):\n            res = []\n            for n in nodes_list:\n                if dist(n.position, p) <= radius:\n                    res.append(n)\n            return res\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        goal_node = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                # Sample until free point found\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_free_node(sample):\n                        break\n\n            nearest = nearest_node(sample, nodes)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            node_count = len(nodes)\n            radius = min(self.max_neighbor_radius, max(self.min_neighbor_radius, \n                       self.step_size * (math.log(node_count + 1) / (node_count + 1))**(1/dim)))\n\n            neighbors = nearby_nodes(new_pos, nodes, radius)\n\n            # Choose best parent\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection\n            d_goal = dist(new_node.position, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # Extract path\n        path: List[Tuple[float, ...]] = []\n        if success:\n            curr = goal_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n        else:\n            nearest_goal_node = nearest_node(goal_pos, nodes)\n            if nearest_goal_node:\n                curr = nearest_goal_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7.74865,
    "time_improvement": -35.0,
    "length_improvement": 4.0,
    "smoothness_improvement": 51.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022745656967163085,
            "num_nodes_avg": 282.5,
            "path_length_avg": 184.72861685887193,
            "smoothness_avg": 0.00960223727348613,
            "success_improvement": 0.0,
            "time_improvement": 9.479395176900136,
            "length_improvement": -1.2526821126027472,
            "smoothness_improvement": 50.29586492203859,
            "objective_score": 2.343688610118585
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.13415906429290772,
            "num_nodes_avg": 890.9,
            "path_length_avg": 275.4582725528993,
            "smoothness_avg": 0.005716355204828838,
            "success_improvement": 0.0,
            "time_improvement": 16.530743900682502,
            "length_improvement": 8.044099995081423,
            "smoothness_improvement": 47.085936744476555,
            "objective_score": 10.021112850975987
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1117842435836792,
            "num_nodes_avg": 649.3,
            "path_length_avg": 142.7018975814953,
            "smoothness_avg": 0.012175143559591553,
            "success_improvement": 0.0,
            "time_improvement": -130.06536043926923,
            "length_improvement": 5.224194360514662,
            "smoothness_improvement": 54.86692740238824,
            "objective_score": -35.61075687846003
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An efficient adaptive informed RRT* planner that incorporates KD-tree acceleration for neighbor searches, a dynamic neighbor radius shrinking inversely with the tree growth, balanced goal biasing, and an enhanced multi-pass shortcut path smoothing step. It enforces a strict 30-second time limit and always returns the best found path. The algorithm prioritizes feasible, low-cost connections and rewiring while limiting unnecessary collision checks through spatial indexing. Post-processing uses repeated shortcut attempts along the path to significantly improve smoothness and reduce path length.",
    "planning_mechanism": "The planner grows a single tree from start and samples with goal bias and ellipsoidal informed sampling after first solution to focus search efficiently. A KD-tree (implemented via a simple grid-based spatial hash due to constraints) helps quickly find k-nearest neighbors within a shrinking radius. Nodes are rewired to minimize cost, and path improvements are tracked continuously. On timeout or iteration max, the best path is extracted and refined by iterative shortcutting before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            self.cost = new_cost\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 max_neighbor_radius: float=20.0, min_neighbor_radius: float=3.5,\n                 k_nearest: int=15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.k_nearest = k_nearest\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def steer(from_pos, to_pos, max_dist):\n            vect = tuple(to_pos[i] - from_pos[i] for i in range(dim))\n            length = math.sqrt(sum(v*v for v in vect))\n            if length <= max_dist:\n                return to_pos\n            ratio = max_dist / length\n            new_p = tuple(from_pos[i] + vect[i]*ratio for i in range(dim))\n            return new_p\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            resolution = min(1.0, self.step_size*0.3)\n            distance = dist(p1,p2)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return sample_uniform()\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n            center = tuple((x_start[i]+x_goal[i])*0.5 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Build rotation matrix (for 2D or 3D)\n            R = None\n            if dim == 2:\n                # rotation angle\n                cos_theta = a1[0]\n                sin_theta = a1[1]\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a1\n                # Create orthonormal basis starting with x_axis\n                # Gram-Schmidt-like\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1.0,0.0,0.0)\n                else:\n                    temp = (0.0,1.0,0.0)\n                v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = [[1.0, 0.0, 0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    v_unit = tuple(vi / norm_v for vi in v)\n                    w = (x_axis[1]*v_unit[2]-x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0]-x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1]-x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    R = [[R[0][0], R[1][0], R[2][0]],\n                         [R[0][1], R[1][1], R[2][1]],\n                         [R[0][2], R[1][2], R[2][2]]]\n            else:\n                # fallback uniform\n                return sample_uniform()\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                # Sample unit ball with Gaussian and normalize\n                rand_gauss = [random.gauss(0,1) for _ in range(dim)]\n                norm_gp = math.sqrt(sum(x*x for x in rand_gauss))\n                if norm_gp > 1e-10:\n                    break\n            unit_ball = [x / norm_gp for x in rand_gauss]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            # Rotate and translate sample_ball by R and center\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            # Clip to bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # --- Spatial Hash Grid for Accelerated Neighbor Search ---\n        # Grid cell size ~ adaptive radius (will update dynamically)\n        class SpatialGrid:\n            def __init__(self, dims, cell_size):\n                self.dims = dims\n                self.cell_size = cell_size\n                self.cells = dict()\n\n            def _cell_coords(self, p):\n                return tuple(int(p[i]//self.cell_size) for i in range(self.dims))\n\n            def insert(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def neighbors(self, p, radius):\n                cell_r = int(math.ceil(radius / self.cell_size))\n                center_cell = self._cell_coords(p)\n                neighbors = []\n                for dx in range(-cell_r, cell_r+1):\n                    for dy in range(-cell_r, cell_r+1):\n                        for dz in range(cell_r*0, cell_r* (1 if self.dims>2 else 0)+1):\n                            if self.dims == 2 and dz != 0:\n                                continue\n                            c = (center_cell[0]+dx, center_cell[1]+dy) if self.dims==2 else (center_cell[0]+dx, center_cell[1]+dy, center_cell[2]+dz)\n                            if c in self.cells:\n                                neighbors.extend(self.cells[c])\n                return neighbors\n\n            def clear(self):\n                self.cells.clear()\n\n        # Initialize tree and grid\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        # Initial neighbor radius parameters\n        gamma_rrt_star = self.max_neighbor_radius\n        def radius_adaptive(n):\n            if n < 2:\n                return gamma_rrt_star\n            val = (math.log(n)/n)**(1/dim)\n            r = gamma_rrt_star * val\n            r = max(r, self.min_neighbor_radius)\n            r = min(r, self.max_neighbor_radius)\n            return r\n\n        # Build spatial grid for neighbors with approximate initial radius:\n        spatial_grid = SpatialGrid(dim, self.max_neighbor_radius)\n\n        # Insert initial node\n        spatial_grid.insert(root)\n\n        def nearest_node(p):\n            # linear fallback if few nodes\n            if len(nodes)<25:\n                best = None\n                bd = float('inf')\n                for nd in nodes:\n                    d = dist_sq(p, nd.position)\n                    if d < bd:\n                        bd = d\n                        best = nd\n                return best, math.sqrt(bd)\n            # else find nearby neighbors and pick closest\n            nearns = spatial_grid.neighbors(p, radius_adaptive(len(nodes))*2.5)\n            best = None\n            bd = float('inf')\n            for nd in nearns:\n                d = dist_sq(p, nd.position)\n                if d < bd:\n                    bd = d\n                    best = nd\n            if best is None:\n                # fallback\n                best = nodes[0]\n                bd = dist(p, best.position)\n            return best, math.sqrt(bd)\n\n        def k_nearest_neighbors(p, radius, k):\n            neighbors_candidates = spatial_grid.neighbors(p, radius)\n            neighbors = []\n            r2 = radius*radius\n            for nd in neighbors_candidates:\n                d2 = dist_sq(p, nd.position)\n                if d2 <= r2:\n                    neighbors.append((d2, nd))\n            neighbors.sort(key=lambda x:x[0])\n            return [nd for (_,nd) in neighbors[:k]]\n\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path)<=2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_outer = 3  # multiple passes for better smoothing\n            for _ in range(max_outer):\n                if not improved:\n                    break\n                improved = False\n                i = 0\n                while i < len(new_path)-2:\n                    j = i+2\n                    while j < len(new_path):\n                        if is_free_edge(new_path[i], new_path[j]):\n                            # remove intermediate points between i and j\n                            del new_path[i+1:j]\n                            improved = True\n                            j = i+2  # restart inner loop\n                        else:\n                            j += 1\n                    i += 1\n            return new_path\n\n        success = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            near_node, _ = nearest_node(sample)\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            curr_radius = radius_adaptive(len(nodes))\n            neighbors = k_nearest_neighbors(new_pos, curr_radius, self.k_nearest)\n            # Always include near_node if not already in neighbors\n            if near_node not in neighbors:\n                neighbors.append(near_node)\n\n            # Choose parent with minimum cost\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                if nb == near_node:\n                    continue\n                tent_cost = nb.cost + dist(nb.position, new_pos)\n                if tent_cost < min_cost:\n                    if is_free_edge(nb.position, new_pos):\n                        min_cost = tent_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.insert(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    # Remove old edge if present\n                    old_edge = (nb.parent, nb)\n                    if old_edge in edges:\n                        edges.remove(old_edge)\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check connection to goal within step_size\n            d_goal = dist(new_pos, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                spatial_grid.insert(goal_node)\n\n                if goal_node.cost < best_goal_cost:\n                    best_goal_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success = True\n                    # Early stopping on first solution found with improved rewiring\n                    break\n\n        # Extract best path\n        if best_goal_node is not None:\n            # Extract path\n            cur = best_goal_node\n            while cur is not None:\n                extracted_path.append(cur.position)\n                cur = cur.parent\n            extracted_path.reverse()\n        else:\n            # Extract path to closest node to goal\n            best_node = None\n            min_d = float('inf')\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    best_node = n\n            if best_node is not None:\n                cur = best_node\n                while cur is not None:\n                    extracted_path.append(cur.position)\n                    cur = cur.parent\n                extracted_path.reverse()\n\n        # Post-processing shortcut to smooth path\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges)\n    \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
    "objective": 22.27113,
    "time_improvement": -135.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1937.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.065567946434021,
            "num_nodes_avg": 473.2,
            "path_length_avg": 173.25001436874106,
            "smoothness_avg": 0.0634004806256209,
            "success_improvement": 0.0,
            "time_improvement": -160.93993138051178,
            "length_improvement": 5.038921802334119,
            "smoothness_improvement": 892.3551981382319,
            "objective_score": -40.7968503420619
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.21451115608215332,
            "num_nodes_avg": 1157.3,
            "path_length_avg": 241.25812171610295,
            "smoothness_avg": 0.1362260220044085,
            "success_improvement": 0.0,
            "time_improvement": -33.4616242111676,
            "length_improvement": 19.461094741164523,
            "smoothness_improvement": 3405.193665811055,
            "objective_score": 18.66413791040371
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15021958351135253,
            "num_nodes_avg": 608.3,
            "path_length_avg": 124.22347757560189,
            "smoothness_avg": 0.12692349591278687,
            "success_improvement": 0.0,
            "time_improvement": -209.1698929796411,
            "length_improvement": 17.496681080624192,
            "smoothness_improvement": 1514.4574994927048,
            "objective_score": -44.680671748054294
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
    "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": -13.97956,
    "time_improvement": -17.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1470.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.052588915824890135,
            "num_nodes_avg": 232.6,
            "path_length_avg": 153.88454915168901,
            "smoothness_avg": 0.04347023177026047,
            "success_improvement": 0.0,
            "time_improvement": -109.28744658079108,
            "length_improvement": 15.653440153233934,
            "smoothness_improvement": 580.4035243237437,
            "objective_score": -20.492152260678246
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.048712754249572755,
            "num_nodes_avg": 358.8,
            "path_length_avg": 233.0599917365158,
            "smoothness_avg": 0.10226409696877743,
            "success_improvement": 0.0,
            "time_improvement": 69.69256321821518,
            "length_improvement": 22.197866498438458,
            "smoothness_improvement": 2531.328872858417,
            "objective_score": 46.883133228819716
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.054259729385375974,
            "num_nodes_avg": 387.5,
            "path_length_avg": 119.05752821578226,
            "smoothness_avg": 0.10995381497824393,
            "success_improvement": 0.0,
            "time_improvement": -11.673021153817839,
            "length_improvement": 20.927658669342527,
            "smoothness_improvement": 1298.6044105768708,
            "objective_score": 15.547710908344518
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "An adaptive informed RRT* planner with bidirectional trees, dynamic neighbor radius, ellipsoidal informed sampling after first solution, incremental rewiring, and path shortcutting smoothing to reduce planning time, minimize path length, and improve smoothness while respecting obstacles and bounds. Early termination occurs upon exhausted time or stagnation.",
    "planning_mechanism": "The planner grows two trees from start and goal roles alternately, sampling uniformly initially and then within an ellipsoidal informed region centered on the current best path. New nodes are added by selecting parents with minimal cost from nearby nodes within an adaptively shrinking radius, rewiring neighbors when cheaper paths exist. The algorithm attempts to connect the two trees greedily and updates the best path when successful. Post-processing shortcutting smooths the path. The search respects a strict 30-second limit, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def _norm(v):\n            return math.sqrt(sum(x * x for x in v))\n\n        def _normalize(v):\n            n = _norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x / n for x in v)\n\n        def _cross(a, b):\n            if dim < 3:\n                # 2D cross product returns scalar, extend to vector for 2D by z axis\n                return (0.0, 0.0, a[0]*b[1] - a[1]*b[0])\n            ax, ay, az = a\n            bx, by, bz = b\n            return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = _normalize(_cross(a1, ref))\n                if _norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = _normalize(_cross(a1, ref))\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (dist(n.position, p) <= radius)]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no valid neighbor edge connection\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(node_start, node_goal, start_side=True):\n            path_a = node_start.path_from_root()\n            path_b = node_goal.path_from_root()\n            if not path_a or not path_b:\n                return []\n            if path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if start_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sampling with goal bias and informed ellipsoidal sampling after first solution\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt greedy connection from other tree toward new_node\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None,\n                                         cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 41.43107,
    "time_improvement": -201.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1575.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.14945473670959472,
            "num_nodes_avg": 438.0,
            "path_length_avg": 157.4473892626623,
            "smoothness_avg": 0.04397602766973632,
            "success_improvement": 0.0,
            "time_improvement": -494.78313509082216,
            "length_improvement": 13.700591031595073,
            "smoothness_improvement": 588.3203285039162,
            "objective_score": -137.27298426577005
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07994420528411865,
            "num_nodes_avg": 469.7,
            "path_length_avg": 234.33356839308772,
            "smoothness_avg": 0.10040367479886572,
            "success_improvement": 0.0,
            "time_improvement": 50.26140514853553,
            "length_improvement": 21.772709952603243,
            "smoothness_improvement": 2483.458870418663,
            "objective_score": 40.55934186821592
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1255901575088501,
            "num_nodes_avg": 398.6,
            "path_length_avg": 121.22874351866426,
            "smoothness_avg": 0.13794000424758718,
            "success_improvement": 0.0,
            "time_improvement": -158.47958467660814,
            "length_improvement": 19.485640847330714,
            "smoothness_improvement": 1654.5866723573045,
            "objective_score": -27.579557532797494
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "An enhanced single-tree RRT* planner with adaptive rewiring radius based on tree size, goal-biased and informed sampling within an ellipsoidal region after the first solution, efficient collision checking, dynamic neighbor search, early stopping on finding a feasible path, and post-processing path shortcutting for smoothness and length minimization.",
    "planning_mechanism": "The planner incrementally builds a tree rooted at the start position by sampling points in the map space with a bias toward the goal and later focusing on the ellipsoidal informed region defined by the current best path cost. It steers from the nearest tree node to the sampled point with a fixed step size, connects new nodes by choosing the lowest cost parent from neighbors within an adaptively shrinking radius, rewires neighbors for incremental path cost improvement, and keeps track of the best path to the goal. The search halts on timeout or after no improvements for a sequence of iterations. Post-processing shortcuts the best path to remove unnecessary waypoints to improve smoothness and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1,\n                 time_limit_sec=30.0, gamma_rrt_star=30.0, improve_tol=1e-6,\n                 max_no_improve=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n        self.improve_tol = improve_tol\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i_ in range(dim):\n                for j_ in range(dim):\n                    mapped[i_] += basis[j_][i_] * radii[j_] * u[j_]\n            mapped = tuple(min(max(mapped[i_], 0.0), bounds[i_]) for i_ in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            r_sq = radius * radius\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = []\n            for n in neighbors:\n                if not is_edge_in_obstacle(n.position, pos):\n                    parents.append(n)\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        nodes = []\n        edges = []\n        tree = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        tree.append(root)\n        nodes.append(root)\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        found_solution = False\n\n        no_improve_count = 0\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Sample\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if not within_bounds(sample):\n                continue\n            if is_in_obstacle(sample):\n                continue\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(tree, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                # Extract path\n                path = goal_node.path_from_root()\n                total_cost = 0.0\n                for i in range(len(path) - 1):\n                    total_cost += dist(path[i], path[i + 1])\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count > self.max_no_improve:\n                break\n\n        if found_solution:\n            best_path = shortcut_path(best_path)\n\n        success = found_solution and len(best_path) > 1\n\n        return PlannerResult(\n            success=success,\n            path=best_path if success else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return sum(x * x for x in v) ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 170.48088,
    "time_improvement": -517.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1738.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.1947084903717041,
            "num_nodes_avg": 576.9,
            "path_length_avg": 164.73644958670076,
            "smoothness_avg": 0.061885003878333754,
            "success_improvement": -9.999999999999998,
            "time_improvement": -674.8789291109068,
            "length_improvement": 9.705341565437417,
            "smoothness_improvement": 868.6346961327584,
            "objective_score": -242.29730031334583
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6579995393753052,
            "num_nodes_avg": 1227.7,
            "path_length_avg": 245.35266204113822,
            "smoothness_avg": 0.11836514991359397,
            "success_improvement": 0.0,
            "time_improvement": -309.38517538731645,
            "length_improvement": 18.094219325859132,
            "smoothness_improvement": 2945.620562248224,
            "objective_score": -67.23091820943834
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.32326397895812986,
            "num_nodes_avg": 790.8,
            "path_length_avg": 123.74923392474486,
            "smoothness_avg": 0.11782104392084344,
            "success_improvement": -9.999999999999998,
            "time_improvement": -565.3159823938996,
            "length_improvement": 17.81165113246753,
            "smoothness_improvement": 1398.6749820283014,
            "objective_score": -201.91442912854785
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional RRT* planning algorithm enhanced with adaptive neighbor radius based on the log-scale of explored nodes, dynamic goal-biased informed sampling within an ellipsoidal region after the first path is found, and efficient rewiring leveraging a spatial hashing grid for scalability. The planner incrementally extends the tree towards sampled points, rewires nearby nodes for improved paths, performs collision checking for nodes and edges, and applies a potent multi-pass shortcutting postprocessing that locally shortcuts and smooths the final path for improved smoothness and length while respecting a 30-second hard time limit. Early stopping occurs upon stable convergence or time expiration.",
    "planning_mechanism": "The planner grows a single tree from start, sampling preferentially near the goal and inside an ellipsoidal region after finding a path, uses a spatial grid to efficiently find neighbors for adaptive-radius rewiring minimizing path costs. Tree extension occurs by steering towards sampled points with collision checks. After planning, a multi-pass shortcutting process attempts to shortcut non-adjacent node pairs and smooth the path, improving smoothness and shortening length. The best path found is returned on time limit or on early convergence.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position       # Tuple of coordinates\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost from start to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Mark node as valid or pruned\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, max_neighbor_radius: float=20.0,\n                 min_neighbor_radius: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a,b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoid after first solution\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta, sin_theta = a[0], a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    # Arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    v = [temp[i] - sum(x_axis[j]*temp[j] for j in range(3))*x_axis[i] for i in range(3)]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = [vi/norm_v for vi in v]\n                    w = [x_axis[1]*v_unit[2]-x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0]-x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1]-x_axis[1]*v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)/2.0 if val > 0 else 0.001\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    sample[i] += R[i][j] * sample_ball[j]\n                sample[i] += center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius function\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial grid for neighbor lookup\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                def expand_coords(ci, r_cells):\n                    if self.dim == 2:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                yield (ci[0]+dx, ci[1]+dy)\n                    elif self.dim == 3:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                for dz in range(-r_cells, r_cells+1):\n                                    yield (ci[0]+dx, ci[1]+dy, ci[2]+dz)\n                    else:\n                        return []\n                for c in expand_coords(ci, r_cells):\n                    if c in self.cells:\n                        neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialize start node and spatial grid\n        root = Node(start_pos)\n        nodes.append(root)\n        edges = []\n        grid_cell_size = self.max_neighbor_radius\n        spatial_grid = SpatialGrid(bounds, grid_cell_size)\n        spatial_grid.add_node(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Early stopping criteria\n        min_improve = 1e-4\n        no_improve_count = 0\n        max_no_improve = 1500\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point: goal bias + informed sampling after first success\n            if best_goal_node is not None:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node linear search\n            nearest = nodes[0]\n            min_dist = dist(nearest.position, sample)\n            for n in nodes[1:]:\n                d_ = dist(n.position, sample)\n                if d_ < min_dist:\n                    nearest = n\n                    min_dist = d_\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            radius = radius_adaptive(len(nodes))\n\n            # Candidate neighbors from spatial grid\n            candidates = spatial_grid.neighbor_candidates(new_pos, radius)\n            radius_sq = radius*radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff*diff\n                    if sum_sq > radius_sq:\n                        break\n                if sum_sq <= radius_sq:\n                    neighbors.append(c)\n\n            # Choose best parent among neighbors\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.add_node(new_node)\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check connection to goal\n            dist_goal = dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-8 < best_goal_cost:\n                    improvement = best_goal_cost - goal_cost\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                else:\n                    improvement = 0.0\n\n                if improvement < min_improve:\n                    break\n\n            if best_goal_node is not None:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        # Extract path from best goal node or closest node if none\n        def extract_path(end_node):\n            path = []\n            curr = end_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n            return path\n\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            extracted_path = extract_path(best_goal_node)\n        else:\n            # Closest node to goal fallback\n            min_d_goal = float('inf')\n            closest = None\n            for n in nodes:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d_goal:\n                    min_d_goal = d_\n                    closest = n\n            if closest is not None:\n                extracted_path = extract_path(closest)\n            else:\n                extracted_path = [start_pos]\n\n        # Multi-pass shortcutting procedure to improve smoothness and length\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            new_path = path[:]\n            max_passes = 4\n            max_iter = 250\n            for _ in range(max_passes):\n                improved = False\n                iteration = 0\n                while iteration < max_iter and len(new_path) > 2:\n                    iteration += 1\n                    # Attempt random shortcuts\n                    i = random.randint(0, len(new_path) - 3)\n                    j = random.randint(i+2, len(new_path) -1)\n                    p1 = new_path[i]\n                    p2 = new_path[j]\n                    if is_free_edge(p1, p2):\n                        # Remove intermediate nodes i+1,...,j-1\n                        del new_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": -9.18874,
    "time_improvement": -26.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1660.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04491877555847168,
            "num_nodes_avg": 257.5,
            "path_length_avg": 170.83109971963432,
            "smoothness_avg": 0.05137458565640392,
            "success_improvement": 0.0,
            "time_improvement": -78.76268587607503,
            "length_improvement": 6.364767251664998,
            "smoothness_improvement": 704.123827221081,
            "objective_score": -16.2893262757181
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.15320281982421874,
            "num_nodes_avg": 923.8,
            "path_length_avg": 233.87027954362262,
            "smoothness_avg": 0.10372010455317819,
            "success_improvement": 0.0,
            "time_improvement": 4.682359925185249,
            "length_improvement": 21.927369105584845,
            "smoothness_improvement": 2568.792996724922,
            "objective_score": 27.405094424531093
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05047609806060791,
            "num_nodes_avg": 455.9,
            "path_length_avg": 127.79099531260484,
            "smoothness_avg": 0.14213662533607357,
            "success_improvement": 0.0,
            "time_improvement": -3.8858547643932844,
            "length_improvement": 15.127305666646151,
            "smoothness_improvement": 1707.9673828405046,
            "objective_score": 16.450463884872228
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid informed bidirectional RRT* planner with adaptive shrinking neighbor radius, goal bias and ellipsoidal informed sampling, incremental rewiring with downstream cost propagation, early tree connection attempts, and path shortcutting for improved efficiency, path length, and smoothness. The planner grows two trees simultaneously towards sampled points drawn preferentially within an ellipsoidal informed subset once a solution is found, alternates growth, rewires neighbors to ensure minimal costs, propagates cost updates downstream, and attempts direct connections between trees each iteration. It stops early upon timeout or first feasible path connection, extracting and shortcutting the best path found.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal positions and grows them alternately by sampling points either via goal bias or within an ellipsoidal subset defined by the best path cost for informed exploration. For each sampled point, nearest nodes in the respective tree are steered towards the sample with capped step size. New nodes are added if collision-free, parents chosen among nearby neighbors within a radius adaptively shrinking with tree size, minimizing cumulative cost. Nearby neighbors are rewired if connecting through the new node lowers their cost, with downstream child cost propagation maintaining tree consistency. Each iteration attempts a direct collision-free connection between the two trees if feasible, enabling early path discovery. Upon timeout or connection, the best path is extracted and refined by applying multiple shortcut attempts to smooth and shorten it.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, time_limit: float = 30.0,\n                 max_neighbor_radius: float = 25.0, min_neighbor_radius: float = 2.0, shortcut_attempts: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n\n        # Two trees: forward from start, backward from goal\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        all_nodes: List[Node] = tree_start + tree_goal\n        edges: List[Tuple[Node, Node]] = []\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n        best_goal_node_start = None  # node in start tree connected to goal tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def build_rotation_matrix_2d(a):\n            # a is unit vector in 2D\n            cos_theta = a[0]\n            sin_theta = a[1]\n            return [[cos_theta, -sin_theta],\n                    [sin_theta,  cos_theta]]\n\n        def build_rotation_matrix_3d(a):\n            x_axis = a\n            # choose arbitrary vector not colinear\n            if abs(x_axis[0]) < 0.9:\n                temp = (1, 0, 0)\n            else:\n                temp = (0, 1, 0)\n            # v = temp - proj(temp on x_axis)\n            dot = sum(x_axis[i] * temp[i] for i in range(3))\n            v = tuple(temp[i] - dot * x_axis[i] for i in range(3))\n            norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n            if norm_v < 1e-10:\n                # x_axis aligned, return identity\n                return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n            v_unit = tuple(v[i] / norm_v for i in range(3))\n            w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                 x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                 x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n            # Rotation matrix columns: x_axis, v_unit, w\n            return [[x_axis[0], v_unit[0], w[0]],\n                    [x_axis[1], v_unit[1], w[1]],\n                    [x_axis[2], v_unit[2], w[2]]]\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                # no solution yet, uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = dist(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            if dim == 2:\n                R = build_rotation_matrix_2d(a1)\n            elif dim == 3:\n                R = build_rotation_matrix_3d(a1)\n            else:\n                # fallback to uniform\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            diff = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(abs(diff)) / 2.0 if diff > 1e-6 else max(self.min_neighbor_radius * 0.1, 0.001)\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                # sample inside unit ball\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        def nearest_node(tree, point):\n            best_node = tree[0]\n            best_dist = dist(best_node.position, point)\n            for node in tree[1:]:\n                dcur = dist(node.position, point)\n                if dcur < best_dist:\n                    best_dist = dcur\n                    best_node = node\n            return best_node\n\n        def nearby_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                if dim == 3:\n                    dz = node.position[2] - point[2]\n                    d2 = dx * dx + dy * dy + dz * dz\n                else:\n                    d2 = dx * dx + dy * dy\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def rewire(tree, new_node, radius):\n            neighbors = nearby_nodes(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in neighbors:\n                if node is new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_cand = node.cost + dist(node.position, new_node.position)\n                    if cost_cand < min_cost:\n                        min_parent = node\n                        min_cost = cost_cand\n\n            if min_parent is not new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if cheaper\n            for node in neighbors:\n                if node is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        # propagate cost downstream\n                        self._propagate_cost(node)\n\n        def propagate_cost_downstream(node):\n            # Recursively update children costs if parent's cost changed\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    c.parent = node\n                    propagate_cost_downstream(c)\n\n        self._propagate_cost = propagate_cost_downstream  # assign so can call easily\n\n        def attempt_connect(node_a, node_b):\n            d = dist(node_a.position, node_b.position)\n            if d <= self.step_size:\n                if not is_edge_in_obstacle(node_a.position, node_b.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_other = nearest_node(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_other):\n                return nearest_other\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]]):\n            if len(path) < 3:\n                return path\n            new_path = list(path)\n            for _ in range(self.shortcut_attempts):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        # Main loop: alternate tree growth\n        trees = [(tree_start, tree_goal), (tree_goal, tree_start)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            for tree_a, tree_b in trees:\n                # Determine best cost for informed sampling for this tree\n                c_best = best_cost if success else float(\"inf\")\n\n                # Sample either goal or informed sampling inside ellipsoid around best path\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is tree_start else start_pos\n                else:\n                    if success:\n                        sample = sample_informed(c_best, start_pos, goal_pos)\n                    else:\n                        sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        # Avoid collision\n                        tries = 0\n                        while is_in_obstacle(sample) and tries < 50:\n                            sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                            tries += 1\n                        if is_in_obstacle(sample):\n                            # fallback to root\n                            sample = tree_a[0].position\n\n                nearest_in_a = nearest_node(tree_a, sample)\n                new_pos = steer(nearest_in_a.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_in_a.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(len(tree_a))\n                neighbors = nearby_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among neighbors\n                min_cost = nearest_in_a.cost + dist(nearest_in_a.position, new_pos)\n                best_parent = nearest_in_a\n                for nb in neighbors:\n                    c_cand = nb.cost + dist(nb.position, new_pos)\n                    if c_cand < min_cost and not is_edge_in_obstacle(nb.position, new_pos):\n                        min_cost = c_cand\n                        best_parent = nb\n\n                new_node = Node(new_pos)\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors through new_node if it lowers cost\n                rewire(tree_a, new_node, radius)\n\n                # Attempt to connect trees\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n\n                # Early exit if path found with timeout not reached\n                if success and elapsed < self.time_limit - 0.01:\n                    final_path = shortcut_path(best_path)\n                    return PlannerResult(success=True, path=final_path, nodes=all_nodes, edges=edges)\n\n        # If timeout or no exact connection, try fallback best path\n        if not success:\n            # Find node closest to goal in tree_start\n            min_dist = float(\"inf\")\n            best_node = None\n            for node in tree_start:\n                dcur = dist(node.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = node\n            if best_node is not None:\n                path = []\n                cur = best_node\n                while cur is not None:\n                    path.append(cur.position)\n                    cur = cur.parent\n                path.reverse()\n                best_path = path\n\n        final_path = shortcut_path(best_path)\n\n        return PlannerResult(success=success, path=final_path, nodes=all_nodes, edges=edges)",
    "objective": -3.82731,
    "time_improvement": 15.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1484.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03457231521606445,
            "num_nodes_avg": 101.6,
            "path_length_avg": 164.18526671067906,
            "smoothness_avg": 0.0350350146362142,
            "success_improvement": -9.999999999999998,
            "time_improvement": -37.587007841142835,
            "length_improvement": 10.0074536338365,
            "smoothness_improvement": 448.3740588087334,
            "objective_score": -53.02975987799728
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04234359264373779,
            "num_nodes_avg": 289.5,
            "path_length_avg": 242.04765886772276,
            "smoothness_avg": 0.10139156095728112,
            "success_improvement": 0.0,
            "time_improvement": 73.65524128262595,
            "length_improvement": 19.197524514386973,
            "smoothness_improvement": 2508.8778928203305,
            "objective_score": 46.15947655752162
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04393608570098877,
            "num_nodes_avg": 296.4,
            "path_length_avg": 130.47564686215568,
            "smoothness_avg": 0.12536822965378452,
            "success_improvement": 0.0,
            "time_improvement": 9.57427389557051,
            "length_improvement": 13.344287936803653,
            "smoothness_improvement": 1494.6746274760087,
            "objective_score": 18.35222806813339
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius based on node count and space dimension, alternating expansion of start and goal trees, goal bias sampling, and post-processing path shortcutting for length and smoothness improvement. The planner maintains consistent cost propagation during rewiring, prunes isolated nodes periodically, and terminates early upon improvement stagnation or time limit.",
    "planning_mechanism": "The planner initializes two trees from start and goal, alternately grows them by sampling with a goal bias and adaptive sampling radius, steering nodes toward samples with fixed step size. Nearest and neighbor searches use Euclidean distance. After adding nodes, rewiring with cost update and downstream propagation refines subtree costs. The trees attempt connection each iteration; upon successful connection, shortcutting improves path smoothness and length. The planner respects map bounds and obstacle collisions for nodes and edges and enforces a 30-second time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, max_no_improve: int=150, time_limit_sec: float=30.0, gamma_rrt_star: float=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def goal_bias_sample(a_is_start_side):\n            return start_pos if not a_is_start_side else goal_pos\n\n        def nearest_node(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            res = []\n            r_sq = radius * radius\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    res.append(n)\n            return res\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, radius)\n            valid_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not valid_parents:\n                p = nearest_node(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start_side):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        def prune_nodes(nodes_list, edges_list, best_cost, margin=5.0):\n            to_remove = []\n            threshold = best_cost + margin\n            for node in nodes_list:\n                if node.cost > threshold and node.parent is not None:\n                    if all(child.valid is False for child in node.children) or len(node.children) == 0:\n                        to_remove.append(node)\n            for node in to_remove:\n                # Remove edges from parent and children\n                if node.parent:\n                    node.parent.remove_child(node)\n                    try:\n                        edges_list.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                for child in node.children[:]:\n                    child.parent = None\n                    try:\n                        edges_list.remove((node, child))\n                    except ValueError:\n                        pass\n                node.valid = False\n                nodes_list.remove(node)\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_bias_sample(a_is_start_side)\n            else:\n                sample = uniform_sample()\n\n            nearest_curr = nearest_node(curr_tree, sample)\n            new_pos = steer(nearest_curr.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_curr.position, new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest_node(other_tree, new_node.position)\n            connected_other = None\n\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, None, nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # attempt incremental connect with limited small steps\n                current = nearest_other\n                for _ in range(15):\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, None, current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n                if cost_candidate < best_cost - 1e-8:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n            else:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n\n            # Periodic pruning every 200 iterations to remove costly isolated nodes\n            if it % 200 == 0 and found_first:\n                prune_nodes(nodes, edges, best_cost, margin=5.0)\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 47.12573,
    "time_improvement": -109.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1478.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.10606772899627685,
            "num_nodes_avg": 376.6,
            "path_length_avg": 153.76108869832115,
            "smoothness_avg": 0.04829959572820716,
            "success_improvement": -9.999999999999998,
            "time_improvement": -322.11640643383606,
            "length_improvement": 15.721110784080938,
            "smoothness_improvement": 655.9935573972964,
            "objective_score": -133.92228767271575
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.0716057538986206,
            "num_nodes_avg": 456.5,
            "path_length_avg": 233.00948595027813,
            "smoothness_avg": 0.09681300889818265,
            "success_improvement": -9.999999999999998,
            "time_improvement": 55.449309058242804,
            "length_improvement": 22.214726783613045,
            "smoothness_improvement": 2391.0684505419767,
            "objective_score": -8.081028959649444
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07725024223327637,
            "num_nodes_avg": 473.0,
            "path_length_avg": 122.00606828307782,
            "smoothness_avg": 0.11700646631032185,
            "success_improvement": 0.0,
            "time_improvement": -58.99024991044834,
            "length_improvement": 18.96937875103486,
            "smoothness_improvement": 1388.3136149483316,
            "objective_score": 0.6261203522280727
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "A hybrid bidirectional informed RRT* planner introducing adaptive rewiring radius scaling with node count, progressive goal bias increment, ellipsoidal informed sampling after first solution, periodic incremental pruning of invalid nodes, and incremental path shortcutting for enhanced smoothness and path length, while enforcing strict collision checking and stopping early on time or quality stabilization.",
    "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternating expansions with an adaptive radius for rewiring and neighbor search that scales with tree size, using informed ellipsoidal sampling localized near the current best path after a first solution is found, progressively increasing goal bias to accelerate convergence, pruning disconnected nodes periodically, and incrementally shortcutting the extracted path to reduce jaggedness and shorten path length. It stops early on time limit or after stable path quality, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_every = 300\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Trees\n        tree_start = []\n        tree_goal = []\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n        tree_start.append(start_node)\n        tree_goal.append(goal_node)\n        nodes.append(start_node)\n        nodes.append(goal_node)\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        found_solution = False\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            step = self.step_size\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n\n            if dim == 2:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r1 = c_best * 0.5\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align first axis e1 (only 2D/3D cases)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def prune_disconnected_nodes():\n            to_remove = []\n            for node in nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                if node.parent is None and node not in (start_node, goal_node):\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # remove edges involving n if present\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n                if n in tree_start:\n                    tree_start.remove(n)\n                if n in tree_goal:\n                    tree_goal.remove(n)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Alternate tree expansion flag (True = start tree, False = goal tree)\n        expand_start_tree = True\n\n        for iteration in range(1, self.max_iter + 1):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively capped by max rate\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Sample with goal bias and informed sampling if solution found\n            p_rand = random.random()\n            if p_rand < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Adaptive radius, scaled with tree size\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0  # Practical tuning constant\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            best_parent = nearest_n\n            best_cost_through = nearest_n.cost + dist(nearest_n.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_n:\n                    continue\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost_through:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = cost_candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improves cost\n            for nb in neighbors:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes (within radius) for path connection\n            near_other = near_nodes(tree_b, new_pos, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_pos, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_pos, other_node.position) + other_node.cost\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n                    found_solution = True\n                    no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break\n\n            # Periodic pruning of invalid/disconnected nodes\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_disconnected_nodes()\n\n            expand_start_tree = not expand_start_tree\n\n        success_state = found_solution and best_start_node is not None and best_goal_node is not None\n        if success_state:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            raw_path = path_start + path_goal[::-1]\n            extracted_path = shortcut_path(raw_path)\n        else:\n            # Fallback: closest node in start tree to goal\n            closest = None\n            min_d = float('inf')\n            for node in tree_start:\n                d = dist(node.position, goal_pos)\n                if d < min_d and node.valid:\n                    min_d = d\n                    closest = node\n            if closest is not None:\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -9.49294,
    "time_improvement": -34.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1672.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.061150741577148435,
            "num_nodes_avg": 436.7,
            "path_length_avg": 156.22154427651856,
            "smoothness_avg": 0.04528416025938395,
            "success_improvement": 0.0,
            "time_improvement": -143.36083679340524,
            "length_improvement": 14.372496093257316,
            "smoothness_improvement": 608.7954441872863,
            "objective_score": -31.340776161130748
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06872091293334961,
            "num_nodes_avg": 579.9,
            "path_length_avg": 230.40586524632596,
            "smoothness_avg": 0.11283454594413964,
            "success_improvement": 0.0,
            "time_improvement": 57.24416004803713,
            "length_improvement": 23.083890315659026,
            "smoothness_improvement": 2803.31413858114,
            "objective_score": 45.04015289671226
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05595877170562744,
            "num_nodes_avg": 500.8,
            "path_length_avg": 122.18235555906139,
            "smoothness_avg": 0.13394741797193868,
            "success_improvement": 0.0,
            "time_improvement": -15.169853724122028,
            "length_improvement": 18.85229713622458,
            "smoothness_improvement": 1603.8012696331193,
            "objective_score": 14.779428512663735
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A unidirectional RRT* planner integrating adaptive rewiring radius based on iteration count and problem dimension, dynamic goal bias increasing with progress, informed ellipsoidal sampling post-first solution, combined with incremental lazy collision checking and iterative path shortcutting for improved smoothness and path length. The planner enforces robust collision checks, prunes unreachable nodes periodically, and terminates early upon stable solution quality or time limit.",
    "planning_mechanism": "The planner incrementally builds a single tree rooted at the start position by alternately sampling points biased increasingly towards the goal and within an informed ellipsoidal region after a first path is found. New nodes are connected using an adaptive neighbor radius for rewiring to optimize cost. It performs lazy collision checking to reduce overhead, prunes disconnected nodes regularly, and applies iterative shortcutting on the best path to improve smoothness. The search stops early if no significant path improvement occurs or time expires, returning the best feasible path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float,...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root\n        self.children = []\n        self.valid = True         # Validity flag for pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate_start = 0.07\n        self.goal_sample_rate_max = 0.3\n        self.goal_sample_rate_inc = 2e-4\n        self.prune_interval = 250\n        self.improve_tol = 1e-6\n        self.max_no_improve = 120\n        self.edge_resolution = 1.0\n        self.shortcut_iterations = 6\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        best_cost = float('inf')\n        best_node = None\n        found_solution = False\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            step = self.step_size\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.edge_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(120):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            a1 = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n\n            if dim == 2:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r1 = c_best * 0.5\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 150:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            best = None\n            min_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < min_d:\n                    min_d = d\n                    best = n\n            return best\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for node in nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                if node.parent is None and node is not start_node:\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # No explicit edges list maintenance required: edges tracked on add\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def iterative_shortcut(path):\n            curr_path = path[:]\n            for _ in range(self.shortcut_iterations):\n                curr_path = shortcut_path(curr_path)\n            return curr_path\n\n        expand_tree = nodes  # Single tree: nodes list\n\n        for iteration in range(1, self.max_iter + 1):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            p_rand = random.random()\n            if p_rand < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest_n = nearest_node(nodes, sample)\n            new_pos = steer(nearest_n.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            # Lazy edge collision check after parent selection\n\n            # Adaptive radius based on iteration count and dimension\n            n_nodes = len(nodes) + 1\n            gamma = 25.0  # slightly tuned constant\n            radius = gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = min(radius, self.step_size * 15.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent with lazy edge collision checking\n            best_parent = None\n            best_cost_through = float('inf')\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + self.improve_tol < best_cost_through:\n                    # Check edge obstacle for candidate parent to new node\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = cost_cand\n\n            if best_parent is None:\n                # Fallback to nearest if edge is collision-free\n                if not is_edge_in_obstacle(nearest_n.position, new_pos):\n                    best_parent = nearest_n\n                    best_cost_through = nearest_n.cost + dist(nearest_n.position, new_pos)\n                else:\n                    continue  # No valid connection\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if improving cost and edge valid\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n            # Check if this new node can connect to goal directly\n            if dist(new_node.position, goal_pos) <= self.step_size * 1.5:\n                if not is_edge_in_obstacle(new_node.position, goal_pos):\n                    total_cost = new_node.cost + dist(new_node.position, goal_pos)\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_node = new_node\n                        found_solution = True\n                        no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break\n\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success_state = found_solution and best_node is not None\n        if success_state:\n            path_start = best_node.path_from_root()\n            # Append goal directly\n            path_start.append(goal_pos)\n            extracted_path = iterative_shortcut(path_start)\n        else:\n            # Fallback to nearest node to goal if no solution\n            closest = None\n            min_d = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < min_d and node.valid:\n                    min_d = d\n                    closest = node\n            if closest is not None:\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 70.74222,
    "time_improvement": -298.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1671.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.045528626441955565,
            "num_nodes_avg": 335.9,
            "path_length_avg": 164.6534769738064,
            "smoothness_avg": 0.058003199835081024,
            "success_improvement": 0.0,
            "time_improvement": -81.18970176330829,
            "length_improvement": 9.750820169350009,
            "smoothness_improvement": 807.876033383455,
            "objective_score": -14.467038260465205
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2997070074081421,
            "num_nodes_avg": 1083.5,
            "path_length_avg": 231.5151290565343,
            "smoothness_avg": 0.1024940924889878,
            "success_improvement": 0.0,
            "time_improvement": -86.46761654130543,
            "length_improvement": 22.713586127423017,
            "smoothness_improvement": 2537.246823252507,
            "objective_score": 0.37410083032471597
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.401492714881897,
            "num_nodes_avg": 805.3,
            "path_length_avg": 121.89238864971628,
            "smoothness_avg": 0.13892204887400206,
            "success_improvement": 0.0,
            "time_improvement": -726.3200895025835,
            "length_improvement": 19.044879350671167,
            "smoothness_improvement": 1667.0782075183076,
            "objective_score": -198.13370820278084
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An improved simplified RRT* planner with goal bias sampling, adaptive neighbor radius based on node density, incremental rewiring with cost propagation, and early stopping on goal reach. The planner samples in the full space with goal bias, steers toward samples with a fixed step, selects minimum-cost parents efficiently, rewires neighbors adaptively to minimize path cost, and maintains collision-free nodes and edges with time-bound termination. This accelerates convergence, improves path length and smoothness, and keeps planning time within limits.",
    "planning_mechanism": "The planner grows a tree from the start node, sampling randomly with a small goal bias, steering towards samples with fixed step size. It uses an adaptive neighbor radius inversely proportional to the current node density for rewiring, improving path quality efficiently. Parents and subtree costs are updated during rewiring for consistent cost propagation. The planner halts immediately upon connecting to the goal or after a 30 second time limit, returning the best found path, ensuring a good trade-off between runtime and solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            self.cost = new_cost\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        # After parent update, propagate cost to children\n        self._propagate_cost()\n\n    def _propagate_cost(self):\n        for c in self.children:\n            new_cost = self.cost + math.dist(self.position, c.position)\n            if new_cost < c.cost:\n                c.cost = new_cost\n                c._propagate_cost()\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_d):\n            d = dist(from_p, to_p)\n            if d <= max_d:\n                return to_p\n            ratio = max_d / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                q = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(q, obstacles, is_3d):\n                    return False\n            return True\n\n        nodes = []\n        edges = []\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        # Adaptive radius scaling factor\n        def neighbor_radius():\n            n = len(nodes)\n            if n < 2:\n                return self.step_size * 5\n            gamma = 30.0  # tuning parameter\n            return min(self.step_size * 5, gamma * (math.log(n) / n) ** (1.0 / dim))\n\n        def nearest(p):\n            best_node = nodes[0]\n            best_d = dist(p, best_node.position)\n            for n in nodes[1:]:\n                dcur = dist(p, n.position)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_node = n\n            return best_node\n\n        def nearby(p, radius):\n            return [n for n in nodes if dist(p, n.position) <= radius]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = neighbor_radius()\n            neighbor_nodes = nearby(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbor_nodes:\n                cost_through_n = n.cost + dist(n.position, new_pos)\n                if cost_through_n < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_through_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in neighbor_nodes:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        path = []\n        while current:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": -2.79113,
    "time_improvement": -4.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 94.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.026886463165283203,
            "num_nodes_avg": 286.9,
            "path_length_avg": 171.06828019893766,
            "smoothness_avg": 0.013327749554946474,
            "success_improvement": 0.0,
            "time_improvement": -6.999719145899906,
            "length_improvement": 6.2347648725936375,
            "smoothness_improvement": 108.6082222062984,
            "objective_score": 2.183984290817703
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.16603438854217528,
            "num_nodes_avg": 1013.5,
            "path_length_avg": 292.23430988268535,
            "smoothness_avg": 0.006277774091656382,
            "success_improvement": 0.0,
            "time_improvement": -3.3010104204569575,
            "length_improvement": 2.4437758629378377,
            "smoothness_improvement": 61.53164907622853,
            "objective_score": 0.7836206370067582
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.049643754959106445,
            "num_nodes_avg": 472.0,
            "path_length_avg": 136.77953122732094,
            "smoothness_avg": 0.016715634742922175,
            "success_improvement": 0.0,
            "time_improvement": -2.1727929811131883,
            "length_improvement": 9.15754810017679,
            "smoothness_improvement": 112.62164011015669,
            "objective_score": 5.4057991663229
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A straightforward RRT* planner with fixed rewiring radius and goal bias, using simple nearest neighbor search and incremental rewiring to improve path cost. The planner samples uniformly with occasional goal bias, connects new nodes by steering with a fixed step, chooses parents among nearby nodes to minimize cost while ensuring collision-free edges, and rewires neighbors to enhance path quality. It stops upon finding the goal or when a 30-second timeout occurs, returning the best path found.",
    "planning_mechanism": "The algorithm grows a tree from the start, sampling random points or the goal with a fixed probability. Each iteration it finds the nearest node and steers towards the sample by a fixed step size. It selects the lowest-cost parent within a fixed radius if collision-free, adds the new node, and rewires neighbors to reduce their cost. The process ends when the goal is connected or time expires, extracting the path by backtracing parents.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_d):\n            d = dist(from_p, to_p)\n            if d <= max_d:\n                return to_p\n            ratio = max_d / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                q = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(q, obstacles, is_3d):\n                    return False\n            return True\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n        success = False\n        goal_node = None\n\n        def nearest(p):\n            nearest_node = nodes[0]\n            best_dist = dist(p, nearest_node.position)\n            for n in nodes[1:]:\n                d_cur = dist(p, n.position)\n                if d_cur < best_dist:\n                    best_dist = d_cur\n                    nearest_node = n\n            return nearest_node\n\n        def nearby(p, radius):\n            return [n for n in nodes if dist(p, n.position) <= radius]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            neighbors = nearby(new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                cost_through_n = n.cost + dist(n.position, new_pos)\n                if cost_through_n < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_through_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in neighbors:\n                if n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        path = []\n        while current:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 82.10604,
    "time_improvement": -311.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 177.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03533599376678467,
            "num_nodes_avg": 273.0,
            "path_length_avg": 168.11869481203308,
            "smoothness_avg": 0.015894130509282962,
            "success_improvement": 0.0,
            "time_improvement": -40.6262097600595,
            "length_improvement": 7.851479362327465,
            "smoothness_improvement": 148.7776571271055,
            "objective_score": -6.733087024985843
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.18710246086120605,
            "num_nodes_avg": 939.6,
            "path_length_avg": 232.5991767619583,
            "smoothness_avg": 0.011386539969888358,
            "success_improvement": 0.0,
            "time_improvement": -16.408856194311877,
            "length_improvement": 22.351699800769367,
            "smoothness_improvement": 192.98387481846498,
            "objective_score": 9.45328239626038
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4739952802658081,
            "num_nodes_avg": 888.9,
            "path_length_avg": 118.74399109779309,
            "smoothness_avg": 0.022670768194929365,
            "success_improvement": 0.0,
            "time_improvement": -875.5390518810755,
            "length_improvement": 21.135895094077775,
            "smoothness_improvement": 188.37049805746048,
            "objective_score": -249.03832601758864
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, efficient RRT* planner with a fixed rewiring radius, goal bias sampling, and fixed step size steering. It expands a tree by sampling random points or the goal, connects new nodes by steering towards the sample, chooses the best parent within a fixed radius considering path cost and collision-free edges, and rewires neighbors to improve path costs. The planner halts upon reaching the goal or after 30 seconds, returning the best known path.",
    "planning_mechanism": "The algorithm iteratively grows a tree from the start towards randomly sampled points with occasional goal bias, connecting nodes with fixed step increments while rewiring neighbors within a fixed radius to minimize path cost. Collision checks prevent invalid nodes and edges. The search stops on goal reach or timeout, then extracts the path from the goal to start by following parents.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_d):\n            d = dist(from_p, to_p)\n            if d <= max_d:\n                return to_p\n            ratio = max_d / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n        success = False\n        goal_node = None\n\n        def nearest(p):\n            best_node = nodes[0]\n            best_dist = dist(p, best_node.position)\n            for node in nodes[1:]:\n                d = dist(p, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def nearby(p, radius):\n            return [n for n in nodes if dist(p, n.position) <= radius]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            neighbors = nearby(new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                cost_thru = n.cost + dist(n.position, new_pos)\n                if cost_thru < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_thru\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                cost_thru_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_thru_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_thru_new)\n                    edges.append((new_node, n))\n\n            # Attempt to connect directly to goal if close enough\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node is not None:\n            current = goal_node\n        else:\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        path = []\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 104.26176,
    "time_improvement": -386.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 176.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03592393398284912,
            "num_nodes_avg": 269.2,
            "path_length_avg": 162.735861752065,
            "smoothness_avg": 0.016230745241512808,
            "success_improvement": 0.0,
            "time_improvement": -42.96602803986609,
            "length_improvement": 10.801895458944175,
            "smoothness_improvement": 154.04640865709322,
            "objective_score": -5.638439093307856
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.22126226425170897,
            "num_nodes_avg": 1048.0,
            "path_length_avg": 232.10161465082143,
            "smoothness_avg": 0.011152551023883562,
            "success_improvement": 0.0,
            "time_improvement": -37.66193657715527,
            "length_improvement": 22.51780035499814,
            "smoothness_improvement": 186.96317070233601,
            "objective_score": 3.1469150933639836
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5717812299728393,
            "num_nodes_avg": 833.2,
            "path_length_avg": 120.94869745922487,
            "smoothness_avg": 0.02266570602473697,
            "success_improvement": 0.0,
            "time_improvement": -1076.7942471036786,
            "length_improvement": 19.671634105650025,
            "smoothness_improvement": 188.30610762626375,
            "objective_score": -310.29376312958226
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive neighbor radius based on node count, goal bias sampling, and early stopping upon finding a connection. It uses informed elliptical sampling when a solution is found to accelerate convergence and improve path quality. The planner incrementally rewires neighbors within a dynamically shrinking radius, propagates cost updates downstream for better optimality, and returns the best path found within a strict 30-second time limit. Post-processing smooths the path by shortcutting collision-free segments.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternatively extending towards sampled points with biased sampling that switches to informed ellipsoidal region after a first solution. The neighbor radius shrinks with more nodes to limit computational overhead. New nodes choose parents minimizing total cost and neighbors are rewired to improve global cost with propagated updates. Once connected, the path is extracted, then refined by shortcut-based smoothing to improve smoothness and length before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def clamp(p):\n            return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim)))\n\n        def in_ellipse(p, c_min, c_best, start, goal):\n            if c_best == float('inf'):\n                return True\n            # Ellipsoid parameters\n            # center is midpoint between start and goal\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            # rotation aligns with goal-start vector\n            d_vec = tuple(goal[i]-start[i] for i in range(dim))\n            length_d = math.dist(start, goal)\n            if length_d == 0:\n                return dist(p, start) <= c_best / 2\n            # convert to unit vector for rotation\n            unit_d = tuple(x/length_d for x in d_vec)\n            # Translate p relative to center\n            p_c = tuple(p[i] - center[i] for i in range(dim))\n            # Project onto d_vec direction\n            x = sum(p_c[i]*unit_d[i] for i in range(dim))\n            # Components orthogonal to d_vec\n            ortho = math.sqrt(max(0, sum(p_c[i]**2 for i in range(dim)) - x*x))\n            # Ellipse condition: (x/(c_best/2))^2 + (ortho / sqrt(c_best^2 - c_min^2)/2)^2 <= 1\n            a = c_best / 2\n            if c_best**2 - c_min**2 <= 0:\n                b = 0.0\n            else:\n                b = math.sqrt(c_best**2 - c_min**2) / 2\n            if b == 0:\n                return abs(x) <= a and ortho <= 1e-10\n            val = (x / a) ** 2 + (ortho / b) ** 2\n            return val <= 1.0\n\n        def sample_free(c_best):\n            trials = 0\n            while True:\n                trials += 1\n                if c_best == float('inf'):\n                    # uniform sample\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                else:\n                    # informed sampling in ellipse\n                    # rejection sampling within bounds and ellipse\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_ellipse(p, c_min, c_best, start_pos, goal_pos):\n                        if trials > 500:\n                            # fallback to uniform sampling if stuck\n                            p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._within_bounds(p, bounds):\n                    return p\n                if trials > 1000:\n                    return start_pos  # fallback\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-10 < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    propagate_cost_to_children(child)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_to_root()\n            path_goal = node_goal.path_to_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            # Attempt shortcutting by skipping intermediate points if direct edge is free\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                        # shortcut possible, remove intermediate points\n                        del path[i+1:j]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        start_time = time.monotonic()\n        # Parameter for adaptive neighbor radius: r = gamma * (log(n)/n)^(1/d)\n        gamma_rrt_star = 50.0\n\n        # Alternate extension direction: 0 means start->goal, 1 means goal->start\n        direction = 0\n\n        total_nodes = 2  # start and goal already in trees\n\n        while (time.monotonic() - start_time) < self.time_limit_sec and total_nodes < self.max_iter:\n            elapsed = time.monotonic() - start_time\n\n            # Compute adaptive radius\n            r = min(self.step_size * 10.0, gamma_rrt_star * (math.log(total_nodes + 1) / (total_nodes + 1)) ** (1/dim))\n\n            c_best = best_cost if success else float('inf')\n            # Sample with goal bias, else informed ellipse sampling if solution found\n            if random.random() < self.goal_bias:\n                rand_point = goal_pos if direction == 0 else start_pos\n            else:\n                rand_point = sample_free(c_best)\n\n            tree_a = start_tree if direction == 0 else goal_tree\n            tree_b = goal_tree if direction == 0 else start_tree\n\n            # Find nearest in tree_a\n            nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n            new_pos = steer(nearest.position, rand_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                direction = 1 - direction\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                direction = 1 - direction\n                continue\n\n            neighbors = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            min_parent = nearest\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_candidate = nb.cost + dist(nb.position, new_pos)\n                    if cost_candidate < min_cost:\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n            total_nodes += 1\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n            # Attempt connection to other tree\n            connect_candidate = None\n            min_connect_dist = float('inf')\n            for node in tree_b:\n                d = dist(new_node.position, node.position)\n                if d <= self.step_size and d < min_connect_dist:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        min_connect_dist = d\n                        connect_candidate = node\n\n            if connect_candidate is not None:\n                # Found connection\n                path = extract_path(new_node, connect_candidate)\n                path_cost = 0.0\n                for i in range(len(path)-1):\n                    path_cost += dist(path[i], path[i+1])\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = shortcut_path(path)\n                    success = True\n                # Early stop on first feasible solution\n                if success:\n                    break\n\n            direction = 1 - direction\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=start_tree + goal_tree + nodes,\n            edges=edges\n        )\n\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.93944,
    "time_improvement": -41.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1527.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05748817920684814,
            "num_nodes_avg": 202.4,
            "path_length_avg": 163.5129673449954,
            "smoothness_avg": 0.05738580281499418,
            "success_improvement": -9.999999999999998,
            "time_improvement": -128.78498341442676,
            "length_improvement": 10.375951569432901,
            "smoothness_improvement": 798.2124293200081,
            "objective_score": -78.41886193606824
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.058248043060302734,
            "num_nodes_avg": 538.6,
            "path_length_avg": 231.99373380102716,
            "smoothness_avg": 0.09152966789426548,
            "success_improvement": -9.999999999999998,
            "time_improvement": 63.760027329428034,
            "length_improvement": 22.553814087837555,
            "smoothness_improvement": 2255.1242810744798,
            "objective_score": -6.064081943096651
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07631251811981202,
            "num_nodes_avg": 689.6,
            "path_length_avg": 125.1082500278309,
            "smoothness_avg": 0.1279455502149996,
            "success_improvement": 0.0,
            "time_improvement": -57.06030138424776,
            "length_improvement": 16.909057346190394,
            "smoothness_improvement": 1527.4579547766493,
            "objective_score": 0.6646337663231545
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "path_expert",
    "algorithm_description": "A single-tree RRT* planner with adaptive rewiring radius, dynamic downstream cost updates, and informed ellipsoidal sampling after the first solution. The planner integrates goal biasing to accelerate progress towards the goal, employs cost-propagating rewiring to improve path optimality and smoothness, and applies iterative shortcutting smoothing before returning the path. It also enforces a strict 30-second time limit and consistent node/edge management to balance efficient exploration with quality path generation.",
    "planning_mechanism": "The planner incrementally grows a single RRT* tree from start to goal, initially sampling uniformly and switching to informed ellipsoidal sampling after the first feasible path discovery. Each new node is connected to the best parent among neighbors within an adaptive radius and rewired with dynamic downstream cost updating. A goal bias sampling improves convergence speed. Iterative shortcutting refines the returned path. Planning halts either after maximum iterations, convergence on path cost improvements, or the hard runtime limit, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=8000,\n                 step_size=5.0,\n                 goal_sample_rate=0.05,\n                 post_opt_iters=300,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0,\n                 gamma_rrt_star=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import math\n        import time\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                def _cross(u, v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def _norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def _normalize(v):\n                    n = _norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = _normalize(_cross(a1, ref))\n                if _norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = _normalize(_cross(a1, ref))\n                b3 = _cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_oth = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_oth, r_oth]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x*x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0/dim_)\n                        return [x * r for x in v]\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            clipped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_ = dist(node.position, pos)\n                if d_ <= radius:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(tree, pos):\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d_ = dist(node.position, pos)\n                if d_ < best_d:\n                    best = node\n                    best_d = d_\n            return best\n\n        def add_node(tree, pos, all_nodes, edges_list):\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, radius)\n            valid_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not valid_parents:\n                # fallback to the closest if edge free\n                p = nearest(tree, pos)\n                if p is None or is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            cost_to_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, None, cost_to_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def attempt_goal_connection(tree, goal_node):\n            nearest_node = nearest(tree, goal_node.position)\n            if nearest_node is None:\n                return None\n            d = dist(nearest_node.position, goal_node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(nearest_node.position, goal_node.position):\n                # Connect goal_node\n                goal_node.parent = nearest_node\n                goal_node.cost = nearest_node.cost + d\n                nearest_node.add_child(goal_node)\n                return goal_node\n            else:\n                # Try to extend toward goal by stepping\n                new_pos = steer(nearest_node.position, goal_node.position)\n                if (within_bounds(new_pos) and not is_in_obstacle(new_pos) and\n                        not is_edge_in_obstacle(nearest_node.position, new_pos)):\n                    return new_pos\n            return None\n\n        def path_cost(path):\n            cost = 0.0\n            for i in range(len(path) - 1):\n                cost += dist(path[i], path[i + 1])\n            return cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree = [Node(start_pos, None, 0.0)]\n        nodes = [tree[0]]\n        edges = []\n        goal_node = Node(goal_pos, None, float('inf'))\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_counter = 0\n        iter_since_improve = 0\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Sample\n            if found_solution and random.random() > self.goal_sample_rate:\n                sample = informed_sample(start_pos, goal_pos, best_cost, dist(start_pos, goal_pos))\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if not within_bounds(sample) or is_in_obstacle(sample):\n                if found_solution:\n                    no_improve_counter += 1\n                    iter_since_improve += 1\n                continue\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_counter += 1\n                    iter_since_improve += 1\n                continue\n\n            new_node, neighbors = add_node(tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_solution:\n                    no_improve_counter += 1\n                    iter_since_improve += 1\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            # Try to connect to goal\n            conn_result = attempt_goal_connection(tree, goal_node)\n            if isinstance(conn_result, Node):\n                # Goal node connected\n                if conn_result.cost + self.improve_tol < best_cost:\n                    best_cost = conn_result.cost\n                    best_path = goal_node.path_from_root()\n                    found_solution = True\n                    iter_since_improve = 0\n                    no_improve_counter = 0\n            elif isinstance(conn_result, tuple) or isinstance(conn_result, list):\n                # Should not happen, defensive\n                pass\n            elif conn_result and isinstance(conn_result, tuple): \n                pass\n            elif conn_result and not isinstance(conn_result, Node):\n                # A new position extended towards goal but not connected, ignore\n                pass\n\n            if found_solution:\n                no_improve_counter += 1\n                iter_since_improve += 1\n                if no_improve_counter > self.max_no_improve or iter_since_improve > self.post_opt_iters:\n                    break\n\n        if best_path:\n            # Iterative shortcutting to smooth path\n            for _ in range(5):\n                best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )",
    "objective": 156.74346,
    "time_improvement": -585.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1531.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1442845106124878,
            "num_nodes_avg": 448.0,
            "path_length_avg": 161.40208435421067,
            "smoothness_avg": 0.05053063309341201,
            "success_improvement": 0.0,
            "time_improvement": -474.2072513492382,
            "length_improvement": 11.5329599857635,
            "smoothness_improvement": 690.9141369379342,
            "objective_score": -131.88782872862367
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7780256509780884,
            "num_nodes_avg": 1231.1,
            "path_length_avg": 229.1346441295006,
            "smoothness_avg": 0.09546923321386007,
            "success_improvement": 0.0,
            "time_improvement": -384.0613838178161,
            "length_improvement": 23.508260514526384,
            "smoothness_improvement": 2356.492134301853,
            "objective_score": -89.33099816511972
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4849684476852417,
            "num_nodes_avg": 744.7,
            "path_length_avg": 118.69045523479856,
            "smoothness_avg": 0.12928571398647568,
            "success_improvement": 0.0,
            "time_improvement": -898.1231445633559,
            "length_improvement": 21.17145106517489,
            "smoothness_improvement": 1544.5047390292252,
            "objective_score": -249.0115490347557
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner that integrates adaptive informed sampling after the first path discovery, dynamic neighbor radius rewiring using a spatial hashing grid for efficient neighbor searches, goal biasing in sampling, and early termination upon first path connection. It interleaves tree expansions with rewiring and attempts to incrementally improve the path while respecting a strict 30-second time limit. Post-processing applies a multi-pass shortcutting smoothing to refine the final path's smoothness and length.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased toward the goal and later informed by current best path cost within an ellipsoidal region, uses a dynamic neighbor radius scaled with node count for rewiring, efficiently queries neighbors via a spatial grid, rewires connections for cost improvements, and stops early when a valid connection between the trees is found or time expires. The best path is extracted by concatenating the two trees\u2019 paths at their connection node and refined via iterative shortcutting.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start in start tree, from goal in goal tree\n        self.children = []              # List[Node]\n        self.valid = True               # Mark if still valid (not pruned)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10    # Probability of sampling goal\n        self.max_neighbor_radius = 20.0\n        self.min_neighbor_radius = 4.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check if position is inside map bounds\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        # Check node collision\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Check edge collision (line segment)\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Steer from 'from_pos' toward 'to_pos' by max length step_size\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        # Heuristic cost (Euclidean)\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoidal region\n        def informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta, sin_theta = a[0], a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = [temp[i] - sum(x_axis[j] * temp[j] for j in range(3)) * x_axis[i]\n                         for i in range(3)]\n                    norm_v = math.sqrt(sum(vi * vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = [vi / norm_v for vi in v]\n                    w = [x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    # In higher dimension fallback to uniform sample\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best * c_best - c_min * c_min\n            r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.001\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                for j in range(dim):\n                    sample[i] += R[i][j] * sample_ball[j]\n                sample[i] += center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius function based on node count\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial hash grid for efficient neighborhood queries\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def remove_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells:\n                    try:\n                        self.cells[cc].remove(node)\n                        if not self.cells[cc]:\n                            del self.cells[cc]\n                    except ValueError:\n                        pass\n\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            c = (ci[0] + dx, ci[1] + dy)\n                            if c in self.cells:\n                                neighbors.extend(self.cells[c])\n                elif self.dim == 3:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            for dz in range(-r_cells, r_cells + 1):\n                                c = (ci[0] + dx, ci[1] + dy, ci[2] + dz)\n                                if c in self.cells:\n                                    neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialize trees: start_tree grows from start, goal_tree from goal\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Setup spatial grids for start and goal trees\n        grid_cell_size = self.max_neighbor_radius\n        start_grid = SpatialGrid(bounds, grid_cell_size)\n        goal_grid = SpatialGrid(bounds, grid_cell_size)\n        start_grid.add_node(start_root)\n        goal_grid.add_node(goal_root)\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        # Alternate growth\n        expand_start_tree = True\n\n        # Track current best cost for informed sampling\n        c_best = float('inf')\n\n        # Early stopping counters\n        min_improve = 1e-4\n        no_improve_count = 0\n        max_no_improve = 2000\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Select which tree to expand and corresponding grid\n            tree_a = start_tree if expand_start_tree else goal_tree\n            tree_b = goal_tree if expand_start_tree else start_tree\n            grid_a = start_grid if expand_start_tree else goal_grid\n\n            # Sample point biased to goal and informed sampling after solution found\n            if not math.isinf(c_best):\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    # Informed sampling from start to goal for start tree, reverse for goal tree\n                    sample = informed_sample(c_best, start_pos if expand_start_tree else goal_pos,\n                                             goal_pos if expand_start_tree else start_pos)\n            else:\n                # No solution found yet: goal bias then uniform sampling in bounds\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    for _ in range(100):\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if is_free_node(p):\n                            sample = p\n                            break\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Get nearest node to sample in tree A (linear search)\n            nearest = tree_a[0]\n            min_dist = dist(nearest.position, sample)\n            for node in tree_a[1:]:\n                d_ = dist(node.position, sample)\n                if d_ < min_dist:\n                    nearest = node\n                    min_dist = d_\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos) or not is_free_edge(nearest.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Determine adaptive radius for neighbor search\n            radius = radius_adaptive(len(tree_a))\n            candidates = grid_a.neighbor_candidates(new_pos, radius)\n            radius_sq = radius * radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff * diff\n                    if sum_sq > radius_sq:\n                        break\n                else:\n                    neighbors.append(c)\n\n            # Find best parent for new node among neighbors to minimize cost\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.add_node(new_node)\n\n            # Rewire neighbors to potentially improve their cost and parents\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-10 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Attempt to connect new node to closest nodes in opposite tree within same radius\n            candidates_b = (goal_grid if expand_start_tree else start_grid).neighbor_candidates(new_pos, radius)\n            neighbors_b = []\n            for c in candidates_b:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff * diff\n                    if sum_sq > radius_sq:\n                        break\n                else:\n                    neighbors_b.append(c)\n\n            # Try connections to opposite tree nodes\n            improved = False\n            for other_node in neighbors_b:\n                if is_free_edge(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + 1e-10 < best_cost:\n                        best_cost = total_cost\n                        best_start_node = new_node if expand_start_tree else other_node\n                        best_goal_node = other_node if expand_start_tree else new_node\n                        success = True\n                        improved = True\n\n            # If success, we can stop early\n            if success:\n                break\n\n            # Update no improvement count for early stopping if desired\n            if improved:\n                no_improve_count = 0\n                c_best = best_cost\n            else:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n            expand_start_tree = not expand_start_tree\n\n        # Extract the best path by concatenating paths from start and goal trees\n        def extract_full_path(s_node, g_node):\n            path_start = s_node.path_from_root()\n            path_goal = g_node.path_from_root()\n            # Avoid duplicate node at connection\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            full_path = path_start + path_goal[::-1]\n            return full_path\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            extracted_path = extract_full_path(best_start_node, best_goal_node)\n            success_state = True\n        else:\n            # Fallback: choose closest node in start tree to goal and extract path\n            min_d = float('inf')\n            closest_node = None\n            for n in start_tree:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d and n.valid:\n                    min_d = d_\n                    closest_node = n\n            if closest_node is not None:\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = [start_pos]\n            success_state = False\n\n        # Multi-pass shortcutting smoothing for final path\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            new_path = path[:]\n            max_passes = 4\n            max_iterations = 250\n            for _ in range(max_passes):\n                improved = False\n                iteration = 0\n                while iteration < max_iterations and len(new_path) > 2:\n                    iteration += 1\n                    i = random.randint(0, len(new_path) - 3)\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    p1 = new_path[i]\n                    p2 = new_path[j]\n                    if is_free_edge(p1, p2):\n                        del new_path[i + 1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": -26.30007,
    "time_improvement": 34.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1732.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03009607791900635,
            "num_nodes_avg": 129.0,
            "path_length_avg": 176.7052192288026,
            "smoothness_avg": 0.048465116378158854,
            "success_improvement": 0.0,
            "time_improvement": -19.77298259463645,
            "length_improvement": 3.1450692673096885,
            "smoothness_improvement": 658.5843150028848,
            "objective_score": -0.7519316429906975
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03749244213104248,
            "num_nodes_avg": 312.1,
            "path_length_avg": 241.13114353775876,
            "smoothness_avg": 0.12187742761150899,
            "success_improvement": 0.0,
            "time_improvement": 76.673463917486,
            "length_improvement": 19.50348371196003,
            "smoothness_improvement": 3035.993997206948,
            "objective_score": 49.88409938845656
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02688581943511963,
            "num_nodes_avg": 307.2,
            "path_length_avg": 128.33191962449385,
            "smoothness_avg": 0.12590437429446827,
            "success_improvement": 0.0,
            "time_improvement": 44.665763789727805,
            "length_improvement": 14.76804949473724,
            "smoothness_improvement": 1501.494347731425,
            "objective_score": 29.768030572417807
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An advanced bi-directional informed RRT* planner that integrates adaptive ellipsoidal informed sampling after the first path is found, efficient fixed-radius rewiring with incremental cost updates, and rigorous collision checking. It employs early stopping upon path connection, leverages dynamic neighbor radius shrinking, and performs extensive shortcutting and smoothing post-processing to yield a shorter, smoother, and more computationally efficient path. The mechanism alternates expansions between start and goal trees, samples intelligently within the informed subset to focus exploration, rewires neighbors robustly to optimize path costs, and stops once a feasible connection is made, returning a post-processed optimized path within a 30-second time constraint.",
    "planning_mechanism": "A bi-directional planner grows two trees alternately from start and goal. Before any solution is found, uniform random sampling (with goal bias) is used; once a solution exists, samples are drawn inside an informed ellipsoidal region aligned between start and goal to focus search near the current best path cost. Each iteration extends one tree by steering towards the newly sampled point up to a step size, adding the node connected to the best parent found inside a fixed radius. Rewiring attempts to reduce cost among neighbors, maintaining parent-child links and updating edges coherently. After adding a node in one tree, a connection attempt to the other tree is made. Upon successful connection, the search stops early. A comprehensive path shortcutting and smoothing post-processing removes unnecessary waypoints and jagged turns to output a smooth, short path efficiently within the specified time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\") -> None:\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\") -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float) -> None:\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.goal_sample_rate = 0.15\n        self.gamma_rrt_star = 40.0  # for neighbor radius\n        self.max_neighbor_radius = 35.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            # adaptive resolution relative to step size and distance; min resolution 0.3 for efficiency\n            dist = math.dist(p1, p2)\n            resolution = max(0.3, min(1.0, self.step_size * 0.3))\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def ellipsoidal_sample(c_best: float) -> Tuple[float, ...]:\n            # Samples within an ellipsoid defined by start and goal and current best cost c_best (> dist(start,goal))\n            c_min = math.dist(start_pos, goal_pos)\n            if c_best < float('inf'):\n                # Rotation matrix from x-axis to vector from start to goal\n                center = tuple((s + g) / 2.0 for s, g in zip(start_pos, goal_pos))\n                a1 = tuple((g - s) / c_min for s, g in zip(start_pos, goal_pos))  # unit vector along start->goal\n\n                # Construct orthonormal basis\n                def unit_vector(vec):\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm == 0:\n                        return vec\n                    return tuple(x / norm for x in vec)\n\n                def random_unit_vector(d):\n                    # Generate random vector on unit sphere surface in d dimension\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(d)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-5:\n                            return [x / norm for x in vec]\n\n                # Basis: first axis a1, generate orthonormal basis for the ellipsoid transform\n                basis = [a1]\n                # Simple Gram-Schmidt process for 2D or 3D:\n                if dim == 2:\n                    # a2 perpendicular to a1\n                    a2 = (-a1[1], a1[0])\n                    basis.append(a2)\n                else:\n                    # For 3D, find two vectors orthogonal to a1 using cross products or Gram-Schmidt\n                    import sys\n                    # Reference vector not colinear with a1\n                    ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                    # Cross a1 and ref to get basis[1]\n                    b1 = (a1[1]*ref[2] - a1[2]*ref[1],\n                          a1[2]*ref[0] - a1[0]*ref[2],\n                          a1[0]*ref[1] - a1[1]*ref[0])\n                    norm_b1 = math.sqrt(sum(x*x for x in b1))\n                    if norm_b1 < 1e-6:\n                        # fallback different ref vector\n                        ref = (0.0, 0.0, 1.0)\n                        b1 = (a1[1]*ref[2] - a1[2]*ref[1],\n                              a1[2]*ref[0] - a1[0]*ref[2],\n                              a1[0]*ref[1] - a1[1]*ref[0])\n                        norm_b1 = math.sqrt(sum(x*x for x in b1))\n                    b1 = tuple(x / norm_b1 for x in b1)\n                    # Cross a1 and b1 to get basis[2]\n                    b2 = (a1[1]*b1[2] - a1[2]*b1[1],\n                          a1[2]*b1[0] - a1[0]*b1[2],\n                          a1[0]*b1[1] - a1[1]*b1[0])\n                    basis.extend([b1, b2])\n\n                # Radii of ellipsoid axes\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n                # Sample inside unit ball\n                while True:\n                    if dim == 2:\n                        x = random.gauss(0, 1)\n                        y = random.gauss(0, 1)\n                        norm = math.sqrt(x ** 2 + y ** 2)\n                        if norm > 1e-6:\n                            u = x / norm\n                            v = y / norm\n                            r = random.uniform(0, 1) ** 0.5\n                            sample_ball = (r * u, r * v)\n                            break\n                    elif dim == 3:\n                        # Sample inside unit sphere by rejection\n                        rx, ry, rz = random.uniform(-1, 1), random.uniform(-1, 1), random.uniform(-1, 1)\n                        if rx*rx + ry*ry + rz*rz <= 1:\n                            sample_ball = (rx, ry, rz)\n                            break\n                    else:\n                        # For dimensions != 2 or 3, fallback uniform\n                        sample_ball = tuple(random.uniform(-1, 1) for _ in range(dim))\n                        break\n\n                # Scale sample_ball by ellipsoid axes radii\n                if dim == 2:\n                    sample_ellip = (r1 * sample_ball[0], r2 * sample_ball[1])\n                    # Transform back to map coordinate system\n                    sample_coords = [center[i] + sample_ellip[0] * basis[0][i] + sample_ellip[1] * basis[1][i]\n                                     for i in range(dim)]\n                elif dim == 3:\n                    sample_ellip = (r1 * sample_ball[0], r2 * sample_ball[1], r2 * sample_ball[2])\n                    sample_coords = [center[i] + sample_ellip[0] * basis[0][i] + sample_ellip[1] * basis[1][i] +\n                                     sample_ellip[2] * basis[2][i]\n                                     for i in range(dim)]\n                else:\n                    # Fallback: uniform sample in full space (should rarely occur)\n                    sample_coords = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n                sample_coords = tuple(max(0.0, min(bounds[i], sample_coords[i])) for i in range(dim))  # clamp in bounds\n                if is_free_node(sample_coords):\n                    return sample_coords\n            else:\n                # If no current best cost, fallback uniform\n                return uniform_sample()\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree_nodes[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 1.5, r))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree_nodes, new_pos)\n            neighbors = near_nodes(tree_nodes, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Check collision and cost among neighbors for better parent\n            for nb in neighbors:\n                if nb is nearest_node:\n                    continue\n                # Prune parents that cannot connect due to collision\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_candidate = nb.cost + math.dist(nb.position, new_pos)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = nb\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n            if not is_free_node(new_pos):  # Extra safety\n                return None\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.children.append(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, neighbors)\n            return new_node\n\n        def rewire(pivot: Node, neighbors: List[Node]) -> None:\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    # Remove old edge\n                    if nb.parent is not None:\n                        old_parent = nb.parent\n                        if (old_parent, nb) in edges:\n                            edges.remove((old_parent, nb))\n                        try:\n                            old_parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.update_parent(pivot, new_cost)\n                    edges.append((pivot, nb))\n                    # Propagate cost to children for consistency\n                    propagate_cost(nb)\n\n        def propagate_cost(node: Node) -> None:\n            for child in node.children:\n                new_cost = node.cost + math.dist(node.position, child.position)\n                if new_cost + 1e-15 < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def merge_trees(node_start: Node, tree_goal: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            dist_goal = math.dist(node_start.position, nearest_goal_node.position)\n            if dist_goal > self.step_size:\n                return None\n            # Check if edge free and nodes free\n            if self._is_edge_in_obstacle(node_start.position, nearest_goal_node.position, obstacles, is_3d):\n                return None\n            if not is_free_node(nearest_goal_node.position):\n                return None\n            # Connect cost\n            connecting_cost = node_start.cost + dist_goal + nearest_goal_node.cost\n            path_start = node_start.path_from_root()\n            path_goal = nearest_goal_node.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            return full_path, connecting_cost\n\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        def smooth_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            # Simple smoothing by smoothing points locally using moving average kernel, respecting collisions\n            if len(path_points) < 3:\n                return path_points\n            smoothed = [path_points[0]]\n            window = 3\n            for i in range(1, len(path_points) - 1):\n                indices = range(max(0, i - window//2), min(len(path_points), i + window//2 + 1))\n                avg_point = []\n                for dim_i in range(dim):\n                    avg_coord = sum(path_points[j][dim_i] for j in indices) / len(indices)\n                    avg_point.append(avg_coord)\n                avg_point = tuple(avg_point)\n                # Only replace with avg_point if edge from prior to avg_point and avg_point to next is collision free\n                if is_free_edge(smoothed[-1], avg_point) and is_free_edge(avg_point, path_points[i + 1]):\n                    smoothed.append(avg_point)\n                else:\n                    smoothed.append(path_points[i])\n            smoothed.append(path_points[-1])\n            return smoothed\n\n        # Initialization of trees\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample point (informed sampling if solution known)\n            if random.random() < self.goal_sample_rate and not success:\n                sample = goal_pos  # goal bias before solution found\n            else:\n                if success:\n                    sample = ellipsoidal_sample(best_cost)\n                else:\n                    sample = uniform_sample()\n\n            # Alternate tree expansions per iteration\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            # Attempt to add new node with rewiring\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            # Attempt to connect other tree to this new node\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                path_candidate, cost_candidate = merged\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    success = True\n                    # Early stop after first feasible solution\n                    break\n\n        # If no success, attempt closest approach from start tree to goal\n        if not success:\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root()\n                candidate_path.append(goal_pos)\n                best_path = candidate_path\n\n        # Post-processing shortcut and smoothing\n        if best_path:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 5.11076,
    "time_improvement": -78.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1654.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08402788639068604,
            "num_nodes_avg": 128.3,
            "path_length_avg": 165.91170089752447,
            "smoothness_avg": 0.049094790156782066,
            "success_improvement": 0.0,
            "time_improvement": -234.4047221442072,
            "length_improvement": 9.061167698926178,
            "smoothness_improvement": 668.4400769968337,
            "objective_score": -61.54251563892228
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09930214881896973,
            "num_nodes_avg": 310.0,
            "path_length_avg": 235.92807161996626,
            "smoothness_avg": 0.11143432207887453,
            "success_improvement": 0.0,
            "time_improvement": 38.217543967908384,
            "length_improvement": 21.24041888024053,
            "smoothness_improvement": 2767.2853699873845,
            "objective_score": 38.045941368453754
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06683270931243897,
            "num_nodes_avg": 225.7,
            "path_length_avg": 120.96852767756896,
            "smoothness_avg": 0.12789590921533261,
            "success_improvement": 0.0,
            "time_improvement": -37.54971956838558,
            "length_improvement": 19.658463818839408,
            "smoothness_improvement": 1526.8265249250028,
            "objective_score": 8.164295045412986
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bi-directional RRT* planner with fixed-radius rewiring, adaptive goal bias sampling, and efficient incremental cost updates, employing early stopping on first feasible path, enhanced collision checking at coarser resolution, and a path post-processing step combining shortcutting and curvature-aware smoothing for high-quality, smooth paths within 30 seconds.",
    "planning_mechanism": "The algorithm grows two trees alternately from start and goal using fixed-radius rewiring to refine paths incrementally. It samples with an adaptive goal bias that increases after finding an initial path to accelerate convergence. Each iteration steers towards sampled points, adds nodes with minimal-cost parents, and rewires neighbors for optimal local paths. After connecting trees, it stops early. Post-processing applies iterative shortcutting and curvature-aware smoothing under collision constraints to enhance smoothness and shorten paths, all bounded by a 30-second time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\") -> None:\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\") -> None:\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float) -> None:\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=6.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.initial_goal_sample_rate = 0.1\n        self.post_solution_goal_sample_rate = 0.3\n        self.rewire_radius = 20.0\n        self.collision_check_resolution = 1.0  # coarser resolution for efficiency\n        self.time_limit = 30.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        res = resolution if resolution is not None else self.collision_check_resolution\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / res))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        def steer(from_pos, to_pos, max_dist) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            # limit trials to avoid infinite loops\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n            return start_pos  # fallback\n\n        def goal_biased_sample(goal_bias_rate):\n            if random.random() < goal_bias_rate:\n                if is_free_node(goal_pos):\n                    return goal_pos\n                return uniform_sample()\n            else:\n                return uniform_sample()\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree_nodes[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            res_nodes = []\n            radius = self.rewire_radius\n            for node in tree_nodes:\n                if math.dist(node.position, point) <= radius:\n                    res_nodes.append(node)\n            return res_nodes\n\n        def propagate_cost(node: Node):\n            for child in node.children:\n                new_cost = node.cost + math.dist(node.position, child.position)\n                if new_cost + 1e-10 < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree_nodes, new_pos)\n            neighbors = near_nodes(tree_nodes, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            # Check collision and cost among neighbors for better parent\n            for nb in neighbors:\n                if nb is nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                    continue\n                cost_candidate = nb.cost + math.dist(nb.position, new_pos)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = nb\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d, self.collision_check_resolution):\n                return None\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.children.append(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors to new node\n            rewire(new_node, neighbors)\n            return new_node\n\n        def rewire(pivot: Node, neighbors: List[Node]) -> None:\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d, self.collision_check_resolution):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        if (old_parent, nb) in edges:\n                            edges.remove((old_parent, nb))\n                        try:\n                            old_parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.update_parent(pivot, new_cost)\n                    edges.append((pivot, nb))\n                    propagate_cost(nb)\n\n        def connect_trees(node_start: Node, tree_goal: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            # Try to connect node_start to nearest node in tree_goal within step_size\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            dist_goal = math.dist(node_start.position, nearest_goal_node.position)\n            if dist_goal > self.step_size:\n                return None\n            if self._is_edge_in_obstacle(node_start.position, nearest_goal_node.position, obstacles, is_3d, self.collision_check_resolution):\n                return None\n            # Build combined path\n            cost = node_start.cost + dist_goal + nearest_goal_node.cost\n            path_start = node_start.path_from_root()\n            path_goal = nearest_goal_node.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            return full_path, cost\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if is_free_edge(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:  # no shortcut found\n                    i += 1\n                    if i < len(path):\n                        shortened.append(path[i])\n            return shortened\n\n        def curvature(p_prev, p_curr, p_next):\n            # Compute discrete curvature at p_curr given neighbors\n            # Using cosine formula\n            v1 = tuple(p_curr[i] - p_prev[i] for i in range(dim))\n            v2 = tuple(p_next[i] - p_curr[i] for i in range(dim))\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-8 or norm2 < 1e-8:\n                return 0.0\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            val = max(-1.0, min(1.0, dot / (norm1 * norm2)))\n            angle = math.acos(val)\n            return angle  # radians, smaller angle = smaller curvature\n\n        def smooth_path(path: List[Tuple[float, ...]], iterations=5) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(iterations):\n                new_path = [path[0]]\n                for i in range(1, len(path) - 1):\n                    p_prev = path[i - 1]\n                    p_curr = path[i]\n                    p_next = path[i + 1]\n                    # Try averaging neighbors to reduce curvature without invalid edges\n                    avg_point = tuple((p_prev[d] + p_curr[d] + p_next[d]) / 3.0 for d in range(dim))\n                    if (is_free_node(avg_point) and\n                        is_free_edge(p_prev, avg_point) and\n                        is_free_edge(avg_point, p_next)):\n                        # Accept averaged point only if curvature decreases\n                        old_k = curvature(p_prev, p_curr, p_next)\n                        new_k = curvature(p_prev, avg_point, p_next)\n                        if new_k + 1e-5 < old_k:\n                            new_path.append(avg_point)\n                            continue\n                    new_path.append(p_curr)\n                new_path.append(path[-1])\n                path = new_path\n            return path\n\n        # Initialize trees\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n        goal_sample_rate = self.initial_goal_sample_rate\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_biased_sample(goal_sample_rate)\n\n            # Alternate tree expansion\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            connected = connect_trees(new_node, tree_b)\n            if connected is not None:\n                path_cand, cost_cand = connected\n                if cost_cand < best_cost:\n                    best_cost = cost_cand\n                    best_path = path_cand\n                    success = True\n                    goal_sample_rate = self.post_solution_goal_sample_rate\n                    break  # early stop on first solution\n\n        # If no direct path, attempt to connect closest nodes and extract best path so far\n        if not success:\n            # Find closest node to goal in start tree\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root()\n                candidate_path.append(goal_pos)\n                best_path = candidate_path\n                # Check success heuristically as path to goal exists collision free\n                success = True\n\n        # Post-process\n        if best_path:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 44.97858,
    "time_improvement": -210.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1410.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08299005031585693,
            "num_nodes_avg": 113.9,
            "path_length_avg": 160.68157268561848,
            "smoothness_avg": 0.044968501386908694,
            "success_improvement": 0.0,
            "time_improvement": -230.27445897632478,
            "length_improvement": 11.927883848556894,
            "smoothness_improvement": 603.8546973688358,
            "objective_score": -58.906333896919115
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09878621101379395,
            "num_nodes_avg": 208.9,
            "path_length_avg": 229.58841616435112,
            "smoothness_avg": 0.09731569313135649,
            "success_improvement": 0.0,
            "time_improvement": 38.53854311186122,
            "length_improvement": 23.35677834818945,
            "smoothness_improvement": 2404.002877930358,
            "objective_score": 37.595644332123825
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.262040114402771,
            "num_nodes_avg": 229.7,
            "path_length_avg": 120.30110734194594,
            "smoothness_avg": 0.10388245223206405,
            "success_improvement": 0.0,
            "time_improvement": -439.30993704396127,
            "length_improvement": 20.101732626619086,
            "smoothness_improvement": 1221.377124586845,
            "objective_score": -113.6250559142827
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A dual-tree bidirectional RRT* planner employing adaptive fixed-radius rewiring, dynamic informed elliptical sampling after initial solution, increased goal bias, and early stopping with robust collision checking and incremental cost propagation to enhance planning efficiency, path quality, and smoothness within a strict 30-second limit.",
    "planning_mechanism": "The planner grows two RRT* trees alternately from start and goal, uses informed elliptical sampling focused on the current best path after the first solution, employs goal bias sampling to expedite goal connection, rewires new nodes with neighbors in a fixed radius ensuring collision-free connections, propagates cost efficiently downstream upon rewiring, tries incremental greedy connections between trees, and applies a post-planning shortcut smoothing while stopping early if no improvement is observed, all respecting map bounds and obstacles to return the best feasible path found within the time limit.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 12000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.10,\n                 post_opt_iters: int = 250,\n                 max_no_improve: int = 60,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1., 0., 0.) if abs(a1[0]) < 0.9 else (0.,1.,0.)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0., 0., 1.)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x*x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x/norm_ for x in v]\n                        r = random.random()**(1.0/dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.5, self.step_size * 1.5)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            max_r = max(bounds) * 0.22\n            min_r = max(2.5, self.step_size * 1.2)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            r_sq = radius*radius\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            if a_is_start:\n                return merged\n            else:\n                return merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            curr_tree = tree_start if it % 2 == 0 else tree_goal\n            other_tree = tree_goal if it % 2 == 0 else tree_start\n            a_is_start_side = (it % 2 == 0)\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if not new_node:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            # Try a direct connection if within step_size and collision free\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None,\n                                  cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # Incremental greedy connection attempts (limit reduced to improve speed)\n                current = nearest_other\n                max_greedy_steps = 15\n                tries = 0\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if not other_new:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None,\n                                          cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                improved = False\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                    improved = True\n                if not improved:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": -9.38351,
    "time_improvement": -34.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1650.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.044814467430114746,
            "num_nodes_avg": 189.9,
            "path_length_avg": 154.9920457324414,
            "smoothness_avg": 0.04197078937010046,
            "success_improvement": 0.0,
            "time_improvement": -78.3475721301645,
            "length_improvement": 15.046403727917191,
            "smoothness_improvement": 556.933994669952,
            "objective_score": -11.691759428949272
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05145115852355957,
            "num_nodes_avg": 393.5,
            "path_length_avg": 237.20947427610412,
            "smoothness_avg": 0.11364820992333273,
            "success_improvement": 0.0,
            "time_improvement": 67.98882021096053,
            "length_improvement": 20.8126497904913,
            "smoothness_improvement": 2824.250298824254,
            "objective_score": 47.00548743170421
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09248323440551758,
            "num_nodes_avg": 473.4,
            "path_length_avg": 120.21573335505566,
            "smoothness_avg": 0.1311992453792897,
            "success_improvement": 0.0,
            "time_improvement": -90.34157208540037,
            "length_improvement": 20.15843396363922,
            "smoothness_improvement": 1568.8447171036246,
            "objective_score": -7.163187661918458
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with fixed step size and neighbor radius, employing goal bias sampling and early termination upon reaching the goal. The planner incrementally grows a tree by steering towards random samples or the goal, rewires the neighborhood nodes to ensure cost-optimal connections, and returns the best path found within a 30-second limit.",
    "planning_mechanism": "The planner samples points within map bounds biased toward the goal, steers from the nearest node by a fixed step, validates nodes and edges against obstacles, selects the best parent node among neighbors minimizing path cost, rewires neighbors to decrease their costs, and stops early when a path reaches the goal; finally, it extracts the path from goal to start by parent linkage.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=12.0, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        # Nearest neighbor by linear search\n        def nearest(p):\n            best_node = nodes[0]\n            best_dist = dist(p, best_node.position)\n            for node in nodes[1:]:\n                d = dist(p, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Nearby nodes within radius\n        def nearby(p, radius):\n            r2 = radius * radius\n            result = []\n            for n in nodes:\n                diff = 0.0\n                for i in range(dim):\n                    dx = n.position[i] - p[i]\n                    diff += dx * dx\n                if diff <= r2:\n                    result.append(n)\n            return result\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            neighbors = nearby(new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                c_cand = n.cost + dist(n.position, new_pos)\n                if c_cand < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, n.position)\n                if c_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, c_through_new)\n                    edges.append((new_node, n))\n\n            # Attempt connect to goal directly if close and free\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            # If no success, select node closest to goal for path extraction\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        path = []\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 59.87873,
    "time_improvement": -237.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 216.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06133792400360107,
            "num_nodes_avg": 324.5,
            "path_length_avg": 170.78703664179486,
            "smoothness_avg": 0.01714833721933736,
            "success_improvement": 0.0,
            "time_improvement": -144.10576434063805,
            "length_improvement": 6.38891892285296,
            "smoothness_improvement": 168.4087156929197,
            "objective_score": -38.55633437001504
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2795461893081665,
            "num_nodes_avg": 907.4,
            "path_length_avg": 228.87393056261044,
            "smoothness_avg": 0.013571184914536533,
            "success_improvement": 0.0,
            "time_improvement": -73.92423381850584,
            "length_improvement": 23.595294207378263,
            "smoothness_improvement": 249.19636278041338,
            "objective_score": -6.774111807222728
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.28791012763977053,
            "num_nodes_avg": 590.7,
            "path_length_avg": 119.67950895192443,
            "smoothness_avg": 0.025968458711523135,
            "success_improvement": 0.0,
            "time_improvement": -492.55352244679653,
            "length_improvement": 20.514568679936815,
            "smoothness_improvement": 230.3168780183391,
            "objective_score": -134.30573113598516
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with fixed step size and radius-based rewiring, using goal bias sampling and early stopping when the goal is reached. Neighborhood radius is fixed, rewiring is done only to neighbors within radius to maintain efficiency, and path is extracted by tracing parents.",
    "planning_mechanism": "The planner samples points within bounds with goal bias, steers from nearest node by a fixed step toward the sample, validates collisions for nodes and edges, connects to the lowest cost parent within a fixed radius, rewires neighbors based on cost improvement, stops immediately upon reaching the goal, and returns the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewire_radius=15.0, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=min(1.0, self.step_size * 0.5)):\n                return False\n            return True\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        def nearest(p):\n            best_node = nodes[0]\n            best_dist = dist(p, best_node.position)\n            for node in nodes[1:]:\n                d = dist(p, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def nearby(p, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i] - p[i])**2 for i in range(dim)) <= r2]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            rnd = random.random()\n            sample = goal_pos if rnd < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            neighbors = nearby(new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in neighbors:\n                c = n.cost + dist(n.position, new_pos)\n                if c < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = c\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, n.position)\n                if c_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, c_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        elif nodes:\n            current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n        else:\n            current = None\n\n        path = []\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 136.99741,
    "time_improvement": -502.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 281.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10354297161102295,
            "num_nodes_avg": 348.2,
            "path_length_avg": 159.32494834510467,
            "smoothness_avg": 0.021241593686624618,
            "success_improvement": 0.0,
            "time_improvement": -312.06866123682073,
            "length_improvement": 12.671471146680846,
            "smoothness_improvement": 232.47706805465174,
            "objective_score": -84.85533034276445
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6932634592056275,
            "num_nodes_avg": 984.0,
            "path_length_avg": 223.94429819701645,
            "smoothness_avg": 0.016331624883751412,
            "success_improvement": 0.0,
            "time_improvement": -331.3251998716597,
            "length_improvement": 25.240947382613783,
            "smoothness_improvement": 320.22447145285577,
            "objective_score": -82.65186917466538
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4677489519119263,
            "num_nodes_avg": 627.2,
            "path_length_avg": 115.76943254505072,
            "smoothness_avg": 0.030709503571876594,
            "success_improvement": 0.0,
            "time_improvement": -862.6833600761557,
            "length_improvement": 23.11145525155207,
            "smoothness_improvement": 290.6226186945055,
            "objective_score": -243.48502177844296
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius, goal bias sampling, informed ellipsoidal sampling after first solution, and incremental cost propagation. It attempts early direct connections between trees to quickly find better paths and applies efficient downstream cost updating, combined with an incremental path shortcutting smoothing step after planning. The planner respects a strict 30-second time limit and stops early when no significant improvement is seen.",
    "planning_mechanism": "The algorithm grows two trees from start and goal alternately, samples either uniformly or inside an informed ellipsoid after a solution is found, steering towards samples by a fixed step size, and rewires within an adaptively shrinking neighborhood radius. It connects the two trees greedily when close, propagates cost improvements downstream, and uses path shortcutting as postprocessing to improve smoothness and length under time constraints.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 80,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            r = max(min_r, min(max_r, val))\n            return r\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            radius_sq = radius * radius\n            for n in nodes_list:\n                d_sq = sum((n.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = None\n                min_d = float('inf')\n                for n_ in tree:\n                    d_ = dist(n_.position, pos)\n                    if d_ < min_d and not is_edge_in_obstacle(n_.position, pos):\n                        min_d = d_\n                        p = n_\n                if p is None:\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-12 < old_cost:\n                    child.cost = new_cost\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Attempt to jump as far as possible with collision-free segment\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            # Optionally do a second pass for minor local smoothing\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            a_side = (it % 2 == 0)\n            curr_tree = tree_start if a_side else tree_goal\n            other_tree = tree_goal if a_side else tree_start\n\n            # Sample with goal bias and informed sampling after first solution\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = None\n            min_dist = float('inf')\n            for node in curr_tree:\n                d_ = dist(node.position, sample)\n                if d_ < min_dist:\n                    min_dist = d_\n                    nearest_node = node\n\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_count = found_first and no_improve_count + 1 or 0\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count = found_first and no_improve_count + 1 or 0\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt early direct connection between trees\n            nearest_other = None\n            min_other_dist = float('inf')\n            for n in other_tree:\n                d_ = dist(n.position, new_node.position)\n                if d_ < min_other_dist:\n                    min_other_dist = d_\n                    nearest_other = n\n\n            connected_other = None\n            if min_other_dist <= self.step_size and nearest_other and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None,\n                                  cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # Incremental connection attempts with limited steps\n                if nearest_other is not None:\n                    current = nearest_other\n                    tries = 0\n                    max_connect_attempts = 15\n                    while tries < max_connect_attempts:\n                        tries += 1\n                        step_pos = steer(current.position, new_node.position)\n                        if (not within_bounds(step_pos) or is_in_obstacle(step_pos) or\n                                is_edge_in_obstacle(current.position, step_pos)):\n                            break\n                        other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                        if other_new is None:\n                            break\n                        rewire(other_tree, other_new, other_neighbors, edges)\n                        current = other_new\n                        if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None,\n                                              cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                            break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": -24.52039,
    "time_improvement": 12.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1827.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03809058666229248,
            "num_nodes_avg": 196.0,
            "path_length_avg": 152.22916850039863,
            "smoothness_avg": 0.052752916060461584,
            "success_improvement": 0.0,
            "time_improvement": -51.58862844520687,
            "length_improvement": 16.560780519391223,
            "smoothness_improvement": 725.697691136962,
            "objective_score": -1.9116317662425177
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.047767043113708496,
            "num_nodes_avg": 335.8,
            "path_length_avg": 234.22725078535373,
            "smoothness_avg": 0.12015780909025935,
            "success_improvement": 0.0,
            "time_improvement": 70.28095286904852,
            "length_improvement": 21.808201830247512,
            "smoothness_improvement": 2991.746974064038,
            "objective_score": 49.12794182918326
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03955357074737549,
            "num_nodes_avg": 267.3,
            "path_length_avg": 120.58963562966282,
            "smoothness_avg": 0.1465508180874831,
            "success_improvement": 0.0,
            "time_improvement": 18.594014514728173,
            "length_improvement": 19.910105876158166,
            "smoothness_improvement": 1764.1155888166172,
            "objective_score": 26.344845824196433
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A bidirectional RRT* planner integrating dynamic informed sampling, adaptive neighbor radius for rewiring, early goal-biased sampling, and incremental path shortcutting to minimize planning time and path length while improving smoothness. The planner alternates tree expansions from start and goal, uses ellipsoidal heuristic sampling after the first solution to focus search near optimum, and applies a fast shortcutting post-processing upon termination or timeout. Adaptive rewiring radius and thorough rewiring ensure quality paths with reduced unnecessary collision checks. Early stopping with best-path tracking guarantees efficient anytime performance under a strict 30-second limit.",
    "planning_mechanism": "The planner grows two RRT* trees bidirectionally with goal bias and uniform sampling initially, switching to ellipsoidal informed sampling after the first path is found to focus search. It uses an adaptive neighbor radius for rewiring to optimize local connections incrementally. After each expansion, it attempts greedy connections between the trees to find better solutions. The process is time-limited and interrupts as soon as a good path is found, followed by shortcut smoothing of the path to reduce jaggedness. The combination of adaptive radius, heuristic sampling, and path shortcutting reduces planning time and improves final path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Ellipsoidal informed sampling around the line connecting start and goal\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edge\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Try to connect newly added node with nearest in other tree greedily up to step_size*4 steps\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            max_greedy = 20\n            steps_taken = 0\n            while steps_taken < max_greedy:\n                steps_taken += 1\n                step_pt = steer(current.position, new_node.position)\n                if not within_bounds(step_pt) or is_in_obstacle(step_pt) or is_edge_in_obstacle(current.position, step_pt):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pt, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position)\n                        final_node.cost = current.cost + dist(current.position, new_node.position)\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                if first_solution_found:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 44.20259,
    "time_improvement": -210.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1438.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.15432941913604736,
            "num_nodes_avg": 476.4,
            "path_length_avg": 153.09921531325637,
            "smoothness_avg": 0.04706276199143273,
            "success_improvement": 0.0,
            "time_improvement": -514.1828474051357,
            "length_improvement": 16.08389407448989,
            "smoothness_improvement": 636.634423589329,
            "objective_score": -141.42134565890012
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06530447006225586,
            "num_nodes_avg": 391.7,
            "path_length_avg": 233.4809007688147,
            "smoothness_avg": 0.0966391206414232,
            "success_improvement": 0.0,
            "time_improvement": 59.369755858197294,
            "length_improvement": 22.057354948262333,
            "smoothness_improvement": 2386.594180448907,
            "objective_score": 42.97831062866112
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13431777954101562,
            "num_nodes_avg": 430.3,
            "path_length_avg": 119.64756150983757,
            "smoothness_avg": 0.10922111748703889,
            "success_improvement": 0.0,
            "time_improvement": -176.44207602812656,
            "length_improvement": 20.535786649797195,
            "smoothness_improvement": 1289.284552570846,
            "objective_score": -34.16472805570542
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "Hybrid Adaptive RRT* with Dynamic Nearby-set Pruning and Progressive Informed Sampling for efficient exploration and improved path quality including robust collision checking, adaptive radius rewiring, goal biasing, incremental parent rewiring, and iterative shortcut smoothing within hard 30-second runtime limit.",
    "planning_mechanism": "This planner grows a single RRT* tree from start toward goal, initially exploring uniformly. After finding first solution, it progressively focuses sampling inside an informed ellipsoidal subset to accelerate convergence. Adaptive neighbor radius shrinks with tree size to limit rewiring cost. Nearby-set pruning aggressively limits expensive neighbor checks. At each iteration, the planner connects new nodes to the best feasible parent from pruned neighbors and immediately rewires neighbors to reduce path cost downstream. Goal bias directs samples straight to goal with configurable probability, enhancing quick solution discovery. The planner enforces strict collision checking for nodes and edges, respects map boundaries, and upon termination (time limit or no improvements), applies multiple passes of shortcut smoothing to improve path length and smoothness before returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # cost from start along tree\n        self.children = []\n        self.valid = True               # for future collision flag if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=5.0,\n                 goal_sample_rate=0.1,\n                 max_no_improve=120,\n                 improve_tol=1e-7,\n                 time_limit=30.0,\n                 gamma_rrt_star=30.0,\n                 pruning_factor=1.8,\n                 smoothing_iters=10):\n\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit = time_limit\n        self.gamma_rrt_star = gamma_rrt_star\n        self.pruning_factor = pruning_factor  # factor to prune neighbors aggressively\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            diff = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            c_min_sq = c_min * c_min\n            c_best_sq = c_best * c_best\n\n            a1 = tuple(diff[i] / c_min for i in range(dim))  # unit vector from start to goal\n\n            # Build basis for rotation (2D or 3D)\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best_sq - c_min_sq, 0.0)) / 2.0\n                radii = [r1, r2]\n            elif dim == 3:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = [a1, b2, b3]\n\n                r1 = c_best / 2.0\n                r_oth = math.sqrt(max(c_best_sq - c_min_sq, 0.0)) / 2.0\n                radii = [r1, r_oth, r_oth]\n            else:\n                # For higher dims fallback to uniform sampling\n                return uniform_sample()\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            clipped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(clipped):\n                return uniform_sample()\n            return clipped\n\n        def dist_squared(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes_pruned(tree, pos, radius, cost_bound):\n            # Prune neighbors by approximate cost bound to reduce neighbor set size\n            radius_squared = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = dist_squared(node.position, pos)\n                if d_sq <= radius_squared:\n                    # Pruning: only add neighbors if cost-to-node + distance within factor * cost_bound\n                    if node.cost + math.sqrt(d_sq) <= cost_bound * self.pruning_factor:\n                        neighbors.append(node)\n            return neighbors\n\n        def nearest_node(tree, pos):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_ = dist(n.position, pos)\n                if d_ < best_d:\n                    best = n\n                    best_d = d_\n            return best\n\n        def add_node(tree, pos, all_nodes, edges_list, c_best):\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes_pruned(tree, pos, radius, c_best if c_best < float('inf') else float('inf'))\n\n            valid_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not valid_parents:\n                p = nearest_node(tree, pos)\n                if p is None or is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            cost_to_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, None, cost_to_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + self.improve_tol < old_cost:\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def attempt_goal_connection(tree, goal_node):\n            nearest_n = nearest_node(tree, goal_node.position)\n            if nearest_n is None:\n                return None\n            d = dist(nearest_n.position, goal_node.position)\n            if d <= self.step_size and not is_edge_in_obstacle(nearest_n.position, goal_node.position):\n                goal_node.parent = nearest_n\n                goal_node.cost = nearest_n.cost + d\n                nearest_n.add_child(goal_node)\n                return goal_node\n            else:\n                new_pos = steer(nearest_n.position, goal_node.position)\n                if (within_bounds(new_pos) and not is_in_obstacle(new_pos)\n                        and not is_edge_in_obstacle(nearest_n.position, new_pos)):\n                    return new_pos\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        tree = [Node(start_pos, None, 0.0)]\n        nodes = [tree[0]]\n        edges = []\n        goal_node = Node(goal_pos, None, float('inf'))\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for it in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time >= self.time_limit:\n                break\n\n            # Sample with goal bias and informed sampling after solution\n            prob = random.random()\n            if found_solution and prob > self.goal_sample_rate:\n                sample = informed_sample(c_best, c_min)\n            else:\n                if prob < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if not within_bounds(sample) or is_in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nearest_n = nearest_node(tree, sample)\n            new_pos = steer(nearest_n.position, sample)\n\n            if (not within_bounds(new_pos)\n                or is_in_obstacle(new_pos)\n                or is_edge_in_obstacle(nearest_n.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            new_node, neighbors = add_node(tree, new_pos, nodes, edges, c_best)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            conn_result = attempt_goal_connection(tree, goal_node)\n            if isinstance(conn_result, Node):\n                # Connected goal node\n                if conn_result.cost + self.improve_tol < best_cost:\n                    best_cost = conn_result.cost\n                    best_path = goal_node.path_from_root()\n                    found_solution = True\n                    c_best = best_cost\n                    no_improve_count = 0\n            # If conn_result is new position (not Node), ignore (will be sampled next iter)\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and best_path:\n            # Perform multiple passes of shortcut path smoothing\n            for _ in range(self.smoothing_iters):\n                smoothed = shortcut_path(best_path)\n                if len(smoothed) >= len(best_path):\n                    # No improvement\n                    break\n                best_path = smoothed\n            success_state = True\n            extracted_path = best_path\n        else:\n            # No valid goal node found; return path of best closest node to goal\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d_to_goal = dist(n.position, goal_pos)\n                if d_to_goal < best_goal_dist:\n                    best_goal_dist = d_to_goal\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 256.0605,
    "time_improvement": -920.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1674.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.13057780265808105,
            "num_nodes_avg": 374.5,
            "path_length_avg": 159.21475031832097,
            "smoothness_avg": 0.053863174966362004,
            "success_improvement": 0.0,
            "time_improvement": -419.6588381749038,
            "length_improvement": 12.731872431360475,
            "smoothness_improvement": 743.0756539801066,
            "objective_score": -114.54314972375431
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.3779773473739625,
            "num_nodes_avg": 1175.7,
            "path_length_avg": 228.4306428789069,
            "smoothness_avg": 0.11141223013388049,
            "success_improvement": 0.0,
            "time_improvement": -757.3311442892636,
            "length_improvement": 23.74327639552702,
            "smoothness_improvement": 2766.716928330503,
            "objective_score": -199.11979280781034
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.8176367998123169,
            "num_nodes_avg": 779.3,
            "path_length_avg": 118.55933235542241,
            "smoothness_avg": 0.1268036765862411,
            "success_improvement": 0.0,
            "time_improvement": -1582.7944531951537,
            "length_improvement": 21.25853663825598,
            "smoothness_improvement": 1512.933406503185,
            "objective_score": -454.51854694307656
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced, single-tree RRT* planner with adaptive radius rewiring, informed ellipsoidal sampling, and iterative path shortcutting. It employs early goal bias, dynamic neighbor radius based on tree size and dimensionality, and a strict 30-second wall-clock time limit to efficiently find shorter, smoother paths. The mechanism prioritizes exploration within an ellipsoidal informed subset once a first solution is found and incrementally refines the path by rewiring neighbors and shortcutting to improve smoothness and length.",
    "planning_mechanism": "The planner grows a single tree from start to goal, sampling points uniformly with some goal bias early on, then switching to ellipsoidal informed sampling after the first solution. Each new node selects the best parent within a dynamically calculated radius to minimize cost, and rewires neighbors if a shorter path is found. Early stopping triggers after improved solutions plateau or when timing runs out. The resulting path is shortcut iteratively for smoothness before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15,\n                 max_no_improve=100, post_opt_iters=300, improve_tol=1e-6,\n                 gamma_rrt_star=50.0, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.improve_tol = improve_tol\n        self.gamma_rrt_star = gamma_rrt_star\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s,g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s,g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size*1.2, 2.0)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        def nearest(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def add_node(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            smoothed = [path[0]]\n            i=0\n            while i<len(path)-1:\n                j=len(path)-1\n                while j>i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j-=1\n                smoothed.append(path[j])\n                i=j\n            return smoothed\n\n        start_time = time.monotonic()\n\n        tree = [Node(start_pos, cost=0.0)]\n        nodes = tree[:]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree, new_pos, nodes, edges)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter>=self.post_opt_iters or post_no_improve>=self.max_no_improve:\n                        break\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            # Check if can connect directly to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos) and not is_in_obstacle(goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.cost = new_node.cost + dist_to_goal\n                goal_node.parent = new_node\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                candidate_path = goal_node.path_from_root()\n                candidate_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    post_no_improve += 1\n                    post_iter += 1\n                if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                    break\n            else:\n                if first_solution_found:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = True\n        else:\n            success = False\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 122.42985,
    "time_improvement": -466.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1495.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.19128241539001464,
            "num_nodes_avg": 462.0,
            "path_length_avg": 168.52128699232384,
            "smoothness_avg": 0.0436983403992699,
            "success_improvement": 0.0,
            "time_improvement": -661.2442216166569,
            "length_improvement": 7.630812208828766,
            "smoothness_improvement": 583.9739197135574,
            "objective_score": -190.874909561132
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5744149923324585,
            "num_nodes_avg": 1113.2,
            "path_length_avg": 228.89554937241368,
            "smoothness_avg": 0.0958250612717643,
            "success_improvement": 0.0,
            "time_improvement": -257.3816823707537,
            "length_improvement": 23.588077226403,
            "smoothness_improvement": 2365.64784652432,
            "objective_score": -51.23341914276271
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.28192155361175536,
            "num_nodes_avg": 640.7,
            "path_length_avg": 122.42771924486105,
            "smoothness_avg": 0.12851748991558054,
            "success_improvement": 0.0,
            "time_improvement": -480.2283199128527,
            "length_improvement": 18.689338259079612,
            "smoothness_improvement": 1534.7329855518417,
            "objective_score": -125.18122809064886
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An adaptive single-tree RRT* planner integrating dynamic neighbor radius scaling, progressive goal bias increase, refined informed ellipsoidal sampling with rejection sampling, and iterative multi-level shortcut smoothing. It employs spatial hashing for faster neighbor queries and adaptive step sizing toward sampled points to accelerate convergence, reducing planning time while enhancing path length and smoothness. Early stopping triggers after stagnation or time limit.",
    "planning_mechanism": "The planner grows a single RRT* tree from start to goal within the map bounds, initially sampling uniformly and progressively biasing toward the goal. Once a first solution is found, sampling switches to a rejection-sampled informed ellipsoid to focus search in promising regions. Node insertion selects an optimal parent from dynamically sized neighborhoods found efficiently via spatial hashing. Rewiring improves path cost locally. Adaptive step sizes reduce unnecessary intermediate nodes. After planning halts on a time limit or convergence, multiple shortcutting passes refine path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit_sec = time_limit_sec\n        # Parameters for adaptive behaviors\n        self.goal_sample_rate_start = 0.1\n        self.goal_sample_rate_end = 0.4\n        self.goal_sample_rate = self.goal_sample_rate_start\n        self.improve_tol = 1e-6\n        self.max_no_improve = 120\n        self.post_opt_iters = 400\n        self.gamma_rrt_star = 60.0  # controls neighbor radius scaling\n        self.spatial_hash_cell_size = self.step_size * 3.0\n\n    def plan(self, map):\n        import time, random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            # Adaptive step size: don't always use max step, use 70%-100% step randomly to reduce over-sampling\n            adaptive_step = self.step_size * (0.7 + 0.3*random.random())\n            step_len = min(adaptive_step, d)\n            r = step_len / d\n            return tuple(from_p[i] + r*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            # Adaptive resolution: finer for short edges, coarser for longer\n            res = max(0.3, resolution * min(1.0, length / 10.0))\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            tries = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                tries += 1\n                if not is_in_obstacle(s) or tries > 100:\n                    return s\n\n        def cross(u,v):\n            return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n\n        def norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def normalize(v):\n            n = norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x/n for x in v)\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Use rejection sampling with informed ellipsoid to avoid invalid samples\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n\n            center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n            a1 = tuple((g-s)/c_min for s,g in zip(start, goal))\n\n            if dim==2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best/2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n                radii = (r1, r2)\n            else:\n                # 3D orthonormal basis construction\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best/2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x*r for x in v]\n\n            # Rejection sampling with 100 tries max\n            for _ in range(100):\n                u = sample_unit_ball(dim)\n                mapped = [center[i] for i in range(dim)]\n                for i in range(dim):\n                    for j in range(dim):\n                        mapped[i] += basis[j][i] * radii[j] * u[j]\n                mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n                if not is_in_obstacle(mapped):\n                    return mapped\n            # fallback\n            return uniform_sample()\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(3.0, self.step_size*2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(self.step_size*1.0, 2.0)\n            return max(min_r, min(max_r, val))\n\n        # Spatial hashing to speed neighbor queries\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[i]//self.cell_size) for i in range(dim))\n\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def query_radius(self, point, radius):\n                hashes = []\n                center_hash = self._hash(point)\n                r_cells = int(math.ceil(radius/self.cell_size))\n                candidates = []\n                for dx in range(-r_cells, r_cells+1):\n                    for dy in range(-r_cells, r_cells+1):\n                        if dim == 2:\n                            h = (center_hash[0]+dx, center_hash[1]+dy)\n                            if h in self.cells:\n                                candidates.extend(self.cells[h])\n                        else:\n                            for dz in range(-r_cells, r_cells+1):\n                                h = (center_hash[0]+dx, center_hash[1]+dy, center_hash[2]+dz)\n                                if h in self.cells:\n                                    candidates.extend(self.cells[h])\n                # Filter by true distance\n                return [n for n in candidates if dist(n.position, point) <= radius]\n\n            def clear(self):\n                self.cells.clear()\n\n        def nearest(nodes_list, point):\n            # Use spatial hash with very large radius, pick closest manually\n            # fallback linear if spatial hash not used\n            best = None\n            best_dist = float('inf')\n            for n in nodes_list:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def add_node(tree, pos, nodes_all, edges_list, spatial_hash):\n            r = neighbor_radius(len(tree))\n            neighbors = spatial_hash.query_radius(pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = new_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            spatial_hash.insert(new_node)\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def shortcut_path(path, passes=4):\n            # Iterative multi-pass shortcutting to improve smoothness and length\n            if len(path) < 3:\n                return path\n            for _ in range(passes):\n                new_path = [path[0]]\n                i = 0\n                while i < len(path)-1:\n                    j = len(path)-1\n                    while j > i+1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        start_time = time.monotonic()\n\n        # Initialization\n        tree = [Node(start_pos, cost=0.0)]\n        nodes = tree[:]\n        edges = []\n        spatial_hash = SpatialHash(self.spatial_hash_cell_size)\n        spatial_hash.insert(tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        post_no_improve = 0\n        post_iter = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Progressive goal bias increase from start to end of iterations\n            self.goal_sample_rate = self.goal_sample_rate_start + (self.goal_sample_rate_end - self.goal_sample_rate_start) * (it / self.max_iter)\n            self.goal_sample_rate = min(self.goal_sample_rate, self.goal_sample_rate_end)\n\n            # Sample point selection\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree, new_pos, nodes, edges, spatial_hash)\n            if new_node is None:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(tree, new_node, neighbors, edges)\n\n            # Attempt direct goal connection\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and not is_edge_in_obstacle(new_node.position, goal_pos) and not is_in_obstacle(goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.cost = new_node.cost + dist_to_goal\n                goal_node.parent = new_node\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                spatial_hash.insert(goal_node)\n\n                candidate_path = goal_node.path_from_root()\n                candidate_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    post_no_improve += 1\n                    post_iter += 1\n\n                if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                    break\n            else:\n                if first_solution_found:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path, passes=5)\n            success = True\n        else:\n            success = False\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 344.67525,
    "time_improvement": -1047.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1499.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.39608700275421144,
            "num_nodes_avg": 461.3,
            "path_length_avg": 157.5210156818421,
            "smoothness_avg": 0.05296088658644086,
            "success_improvement": -19.999999999999996,
            "time_improvement": -1476.302460889169,
            "length_improvement": 13.660235224557358,
            "smoothness_improvement": 728.9528814837632,
            "objective_score": -531.0498327245974
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7269205331802369,
            "num_nodes_avg": 1180.0,
            "path_length_avg": 227.7690904234158,
            "smoothness_avg": 0.1033708598990442,
            "success_improvement": 0.0,
            "time_improvement": -352.2654989259731,
            "length_improvement": 23.964121646901578,
            "smoothness_improvement": 2559.806680223298,
            "objective_score": -78.50214328853448
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.6866470575332642,
            "num_nodes_avg": 991.4,
            "path_length_avg": 116.81332775494384,
            "smoothness_avg": 0.10276624673696529,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1313.201876413812,
            "length_improvement": 22.418149758089243,
            "smoothness_improvement": 1207.1790730789078,
            "objective_score": -424.4737777038955
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner with fixed step size, fixed rewiring radius, and balanced goal bias sampling; it alternately expands from start and goal, rewires neighbors for cost improvement, and stops early once a path is found. It applies path shortcutting post-processing for smoother, shorter final paths, all within a 30-second time limit.",
    "planning_mechanism": "Grows two trees alternately towards sampled points biased towards goal; adds nodes with minimum-cost parents and rewires neighbors within fixed radius for local path optimization. Upon connection of two trees, constructs full path and applies shortcutting to improve smoothness and length. Stops planning after 30 seconds or on first solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = 15.0\n        self.goal_sample_rate = 0.1\n        self.time_limit = 30.0\n        self.collision_check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        res = resolution if resolution is not None else self.collision_check_resolution\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def steer(fr, to):\n            dist = math.dist(fr, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(fr[i] + ratio*(to[i] - fr[i]) for i in range(dim))\n\n        def uniform_sample():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n            return start_pos\n\n        def goal_biased_sample():\n            if random.random() < self.goal_sample_rate and is_free_node(goal_pos):\n                return goal_pos\n            return uniform_sample()\n\n        def nearest(nodes, point):\n            best = nodes[0]\n            best_d = math.dist(best.position, point)\n            for n in nodes[1:]:\n                d = math.dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near_nodes(nodes, point, radius):\n            res = []\n            r_sq = radius*radius\n            for n in nodes:\n                d_sq = sum((n.position[i]-point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def add_node(tree_nodes, pos, nodes_all, edges_list):\n            neighbors = near_nodes(tree_nodes, pos, self.rewire_radius)\n            parents = [n for n in neighbors if not self._is_edge_in_obstacle(n.position, pos, obstacles, is_3d)]\n            if not parents:\n                nearest_node = nearest(tree_nodes, pos)\n                if self._is_edge_in_obstacle(nearest_node.position, pos, obstacles, is_3d):\n                    return None, []\n                parents = [nearest_node]\n            best_parent = min(parents, key=lambda n: n.cost + math.dist(n.position, pos))\n            new_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            if not is_free_node(pos) or self._is_edge_in_obstacle(best_parent.position, pos, obstacles, is_3d):\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=new_cost)\n            best_parent.children.append(new_node)\n            tree_nodes.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree_nodes, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost(nb)\n\n        def connect_trees(node_from, other_tree):\n            nearest_other = nearest(other_tree, node_from.position)\n            dist_nodes = math.dist(nearest_other.position, node_from.position)\n            if dist_nodes > self.step_size:\n                return None\n            if self._is_edge_in_obstacle(node_from.position, nearest_other.position, obstacles, is_3d):\n                return None\n            path_from = node_from.path_from_root()\n            path_other = nearest_other.path_from_root()\n            if path_from[-1] == path_other[-1]:\n                path_other = path_other[:-1]\n            full_path = path_from + path_other[::-1]\n            cost_path = node_from.cost + math.dist(node_from.position, nearest_other.position) + nearest_other.cost\n            return full_path, cost_path\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            result = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if is_free_edge(path[i], path[j]):\n                        break\n                    j -=1\n                result.append(path[j])\n                i = j\n            return result\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_biased_sample()\n\n            if i % 2 == 0:\n                curr_tree, other_tree = tree_start, tree_goal\n            else:\n                curr_tree, other_tree = tree_goal, tree_start\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not is_free_node(new_pos):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node, neighbors = add_node(curr_tree, new_pos, nodes, edges)\n            if not new_node:\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n            connection = connect_trees(new_node, other_tree)\n\n            if connection is not None:\n                path_cand, cost_cand = connection\n                if cost_cand < best_cost:\n                    best_cost = cost_cand\n                    best_path = path_cand\n                    success = True\n                    break  # Early stopping on first found path\n\n        # If no path found, try connecting closest tree-start node to goal position if collision free\n        if not success:\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root()\n                candidate_path.append(goal_pos)\n                best_path = candidate_path\n                success = True\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 46.0101,
    "time_improvement": -209.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1360.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09858219623565674,
            "num_nodes_avg": 164.7,
            "path_length_avg": 172.4183873801415,
            "smoothness_avg": 0.045805472303584185,
            "success_improvement": 0.0,
            "time_improvement": -292.32632589702524,
            "length_improvement": 5.494749732758473,
            "smoothness_improvement": 616.955109726243,
            "objective_score": -81.31627238082127
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14745326042175294,
            "num_nodes_avg": 344.4,
            "path_length_avg": 229.11228100765237,
            "smoothness_avg": 0.0866758302960851,
            "success_improvement": 0.0,
            "time_improvement": 8.259542344815667,
            "length_improvement": 23.515725968286098,
            "smoothness_improvement": 2130.231543595389,
            "objective_score": 27.238456002393306
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.21531269550323487,
            "num_nodes_avg": 261.1,
            "path_length_avg": 119.62337477886165,
            "smoothness_avg": 0.11255090507368129,
            "success_improvement": 0.0,
            "time_improvement": -343.1393129302773,
            "length_improvement": 20.55185032486304,
            "smoothness_improvement": 1331.639204893584,
            "objective_score": -83.95248765969744
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified unidirectional RRT* planner with fixed step size and radius, balanced goal bias sampling, and lightweight rewiring based on local neighbors. It stops when a path is found or after a 30-second timeout, then applies brief shortcutting to improve smoothness and length.",
    "planning_mechanism": "The planner incrementally grows a single tree from start by sampling points biased towards the goal, extending the nearest node towards the sample with a fixed step, and rewiring neighbors within a fixed radius to locally optimize path cost. Early termination occurs upon finding a feasible solution or reaching the time limit. Finally, shortcutting smooths and shortens the path before returning it.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = 12.0\n        self.goal_sample_rate = 0.1\n        self.time_limit = 30.0\n        self.collision_check_resolution = 1.0\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        dist = 0.0\n        steps = max(1,int(math.dist(from_pos, to_pos)/self.collision_check_resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim==3)\n        start_pos, goal_pos = map.start, map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1,p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def steer(fr,to):\n            dist = math.dist(fr,to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size/dist\n            return tuple(fr[i] + ratio*(to[i]-fr[i]) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate and is_free_node(goal_pos):\n                return goal_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n            return goal_pos\n\n        def nearest(nodes, point):\n            best = nodes[0]\n            best_d = math.dist(best.position, point)\n            for n in nodes[1:]:\n                d = math.dist(n.position, point)\n                if d < best_d:\n                    best, best_d = n, d\n            return best\n\n        def near_nodes(nodes, point, radius):\n            r_sq = radius*radius\n            res = [n for n in nodes if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n            return res\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        start_time = time.monotonic()\n        root = Node(start_pos, cost=0.0)\n        nodes = [root]\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample_p = sample()\n            nearest_node = nearest(nodes, sample_p)\n            new_pos = steer(nearest_node.position, sample_p)\n\n            if not is_free_node(new_pos) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            neighbors = near_nodes(nodes, new_pos, self.rewire_radius)\n            parents = [n for n in neighbors if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d)]\n            if not parents:\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n                parents = [nearest_node]\n            best_parent = min(parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            new_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            if new_cost >= best_cost:\n                continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=new_cost)\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n                    propagate_cost(nb)\n\n            # Check if new node reached goal vicinity\n            if math.dist(new_node.position, goal_pos) <= self.step_size and is_free_edge(new_node.position, goal_pos):\n                candidate_cost = new_node.cost + math.dist(new_node.position, goal_pos)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_path = new_node.path_from_root() + [goal_pos]\n                    success = True\n                    break\n\n        # Shortcutting for smoothness\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            res = [path[0]]\n            i=0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j>i+1:\n                    if is_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                res.append(path[j])\n                i = j\n            return res\n\n        if success:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
    "objective": 289.84931,
    "time_improvement": -1026.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1166.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.34666330814361573,
            "num_nodes_avg": 383.5,
            "path_length_avg": 162.8146641911963,
            "smoothness_avg": 0.04758773104643174,
            "success_improvement": 0.0,
            "time_improvement": -1279.6116053468547,
            "length_improvement": 10.758702593351757,
            "smoothness_improvement": 644.8513292886126,
            "objective_score": -374.2040034016023
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.5796322107315064,
            "num_nodes_avg": 997.6,
            "path_length_avg": 221.40916095770984,
            "smoothness_avg": 0.07297226577499115,
            "success_improvement": 0.0,
            "time_improvement": -882.7940157096745,
            "length_improvement": 26.087249162973837,
            "smoothness_improvement": 1777.628958189077,
            "objective_score": -240.29771042417264
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4930299758911133,
            "num_nodes_avg": 473.4,
            "path_length_avg": 115.44706282633919,
            "smoothness_avg": 0.09234139313807452,
            "success_improvement": 0.0,
            "time_improvement": -914.7147350497809,
            "length_improvement": 23.325557869123855,
            "smoothness_improvement": 1074.5757047836676,
            "objective_score": -255.0462072695416
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "An improved dual-tree bidirectional RRT* planner with goal-biased and adaptive informed sampling, fixed-radius rewiring with consistent cost propagation, incremental attempt to connect trees with early termination on first feasible path, and aggressive post-planning path shortcutting for smoothness and reduced path length. The planner maintains efficient neighbor search, ensures collision-free node and edge additions, and uses down-stream cost updates to optimize tree quality under strict 30-second wall-time limitations.",
    "planning_mechanism": "Grows two trees from start and goal alternately using goal bias and adaptive informed elliptical sampling after the first solution is found. Employs fixed rewiring radius for neighbors to minimize path costs, rewires neighbor nodes with incremental downstream cost updates, and attempts greedy connections between trees on each iteration. Stops immediately after connecting trees for the first path to reduce planning time. Applies aggressive path shortcutting to improve smoothness and path length before returning.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(1, int(length / 0.5))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos  # fallback if densely occupied space\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i]*radii[j]*u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_node = n\n                    min_d = d_\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            res = []\n            r_sq = radius*radius\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    res.append(n)\n            return res\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicate node if same connecting point\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts toward new_node from closest other_tree node\n                current = nearest_other\n                max_greedy_steps = 15\n                for _ in range(max_greedy_steps):\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n                if candidate_cost + 1e-9 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    # Early termination on first found path to reduce runtime as per improvement\n                    break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 23.82938,
    "time_improvement": -85.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1504.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.07056534290313721,
            "num_nodes_avg": 84.2,
            "path_length_avg": 160.48625351254697,
            "smoothness_avg": 0.04369574074424822,
            "success_improvement": -9.999999999999998,
            "time_improvement": -180.82800722630012,
            "length_improvement": 12.034941382347744,
            "smoothness_improvement": 583.933229467227,
            "objective_score": -94.10777119114525
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09661448001861572,
            "num_nodes_avg": 273.2,
            "path_length_avg": 230.27359458661303,
            "smoothness_avg": 0.09847250486574351,
            "success_improvement": 0.0,
            "time_improvement": 39.88972107043424,
            "length_improvement": 23.128046069071043,
            "smoothness_improvement": 2433.7684770739493,
            "objective_score": 38.012586347942644
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10383167266845703,
            "num_nodes_avg": 283.1,
            "path_length_avg": 122.35153907629783,
            "smoothness_avg": 0.12535415750123452,
            "success_improvement": 0.0,
            "time_improvement": -113.69801710559241,
            "length_improvement": 18.739933499729503,
            "smoothness_improvement": 1494.495630734271,
            "objective_score": -15.392966878168671
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "A unidirectional RRT* planner with adaptive rewiring radius, goal-biased informed sampling, incremental collision checking, and real-time path shortcutting to simultaneously minimize path length and planning time while ensuring smooth paths and robustness. Early stopping triggers when a feasible and improved path is found or when the 30-second limit is reached, returning the best-known solution.",
    "planning_mechanism": "The planner incrementally samples states biased toward the goal or within an adaptive ellipsoidal informed set after the first solution, steering with a fixed step size and incrementally checking collisions for efficiency. It dynamically adapts the neighborhood radius based on the node count and problem dimension for rewiring, optimizes parent connections via local neighborhood rewiring, and continuously shortcuts the current best path during planning. Early termination upon no improvements reduces runtime.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = 50.0     # Constant for neighborhood radius scaling\n        self.improve_tol = 1e-6        # Improvement threshold for early stopping\n        self.max_no_improve = 120      # Max consecutive no improvement iters post solution\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D basis construction\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-12:\n                        v = [x/norm for x in v]\n                        r = random.random() ** (1.0/dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(nodes_list, pos, edges_list):\n            r = neighbor_radius(len(nodes_list))\n            neighbors = near_nodes(nodes_list, pos, r)\n            valid_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not valid_parents:\n                p = nearest(nodes_list, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            nodes_list.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(nodes_list, new_node, neighbors, edges_list):\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nbr.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost:\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                        try:\n                            edges_list.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nbr)\n                    nbr.cost = new_cost\n                    edges_list.append((new_node, nbr))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        c_min = dist(start_pos, goal_pos)\n\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Sample: goal bias or informed after first solution\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(nodes, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(nodes, new_pos, edges)\n            if new_node is None:\n                continue\n\n            rewire(nodes, new_node, neighbors, edges)\n\n            # Check if we can connect to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n                        # Shortcut improved path immediately\n                        current_path = best_goal_node.path_from_root()\n                        smoothed_path = shortcut_path(current_path)\n                        if len(smoothed_path) < len(current_path):\n                            # Re-assign new structure for path nodes if shorter path found\n                            best_goal_node_path_nodes = []\n                            parent_node = None\n                            prev_node_pos = None\n                            for pos in smoothed_path:\n                                node = Node(pos)\n                                if parent_node:\n                                    node.parent = parent_node\n                                    parent_node.add_child(node)\n                                    node.cost = parent_node.cost + dist(parent_node.position, pos)\n                                else:\n                                    node.cost = 0.0\n                                parent_node = node\n                                prev_node_pos = pos\n                                best_goal_node_path_nodes.append(node)\n                            best_goal_node = best_goal_node_path_nodes[-1]\n                            # Ensure best_cost updated\n                            best_cost = best_goal_node.cost\n\n                        # Early stopping triggered: found path and improved it, break to return\n                        break\n                    else:\n                        no_improve_count += 1\n                        if no_improve_count > self.max_no_improve:\n                            # No significant improvement recently, stop early\n                            break\n\n        # Extract final path\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            # No solution found: return path to closest node to goal\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=found_solution,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 96.63425,
    "time_improvement": -384.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1429.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10087225437164307,
            "num_nodes_avg": 274.1,
            "path_length_avg": 159.40542565160476,
            "smoothness_avg": 0.04810726979767406,
            "success_improvement": 0.0,
            "time_improvement": -301.4400414449564,
            "length_improvement": 12.62736025974362,
            "smoothness_improvement": 652.9832389420106,
            "objective_score": -79.59068008293069
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3707641839981079,
            "num_nodes_avg": 961.9,
            "path_length_avg": 233.04189595091694,
            "smoothness_avg": 0.0985805219659116,
            "success_improvement": 0.0,
            "time_improvement": -130.67700113818228,
            "length_improvement": 22.20390739252967,
            "smoothness_improvement": 2436.5478348628467,
            "objective_score": -13.698016731622646
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.39797732830047605,
            "num_nodes_avg": 676.5,
            "path_length_avg": 117.64067677183195,
            "smoothness_avg": 0.10204837116004635,
            "success_improvement": 0.0,
            "time_improvement": -719.0850029196292,
            "length_improvement": 21.86866393519872,
            "smoothness_improvement": 1198.0477487285623,
            "objective_score": -196.61406377112672
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A unidirectional RRT* planner with adaptive neighborhood radius, goal bias and informed sampling, efficient incremental collision checking, and incremental real-time path shortcutting to reduce path length, improve smoothness, and minimize planning time. The planner uses a KD-tree like spatial partition for efficient nearest neighbor queries and limits rewiring to a dynamic radius shrinking as the tree grows. Early termination occurs upon finding an improved goal path or reaching the 30-second time limit, always returning the best solution found.",
    "planning_mechanism": "The planner incrementally samples states biased toward the goal or within the ellipsoidal informed subset after the first solution. It steers toward sampled points with a fixed step size, validates nodes and edges against obstacles, and performs rewiring of local neighbors within an adaptively scaled radius based on tree size and dimension. Meanwhile, it performs incremental shortcutting on the current best path whenever improved, progressively smoothing and shortening the route. Early stopping is triggered by sufficient improvement or timeout, balancing solution quality and runtime efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost to come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.2, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = 50.0\n        self.improve_tol = 1e-6\n        self.max_no_improve = 100\n\n    def plan(self, map):\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist_sq(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a,b):\n            return math.sqrt(dist_sq(a,b))\n\n        def steer(fr,to):\n            d = dist(fr,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1,p2,resolution=1.0):\n            distance = dist(p1,p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n            a1 = tuple((g - s)/c_min for s,g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best/2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n                radii = [r1, r2]\n            else:\n                # 3D basis construction\n                ref = (1.0,0.0,0.0) if abs(a1[0])<0.9 else (0.0,1.0,0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1,b2)\n                basis = [a1,b2,b3]\n                r1 = c_best/2.0\n                rt = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n                radii = [r1, rt, rt]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x/norm_v for x in v]\n                        r = random.random()**(1.0/dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i]*radii[j]*u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2.0)\n            r = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, r))\n\n        # KD-tree like grid for faster nearest neighbor search\n        # (Simple spatial hashing with cell size==step_size)\n        cell_size = self.step_size*1.5\n        grid = dict()\n\n        def grid_key(pos):\n            return tuple(int(pos[i]/cell_size) for i in range(dim))\n\n        def grid_add(node):\n            key = grid_key(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        def grid_near(pos, radius):\n            r_cells = int(math.ceil(radius/cell_size))\n            base_key = grid_key(pos)\n            result = []\n            ranges = [range(base_key[d]-r_cells, base_key[d]+r_cells+1) for d in range(dim)]\n            if dim == 2:\n                for xk in ranges[0]:\n                    for yk in ranges[1]:\n                        cell = (xk, yk)\n                        if cell in grid:\n                            result.extend(grid[cell])\n            else:\n                for xk in ranges[0]:\n                    for yk in ranges[1]:\n                        for zk in ranges[2]:\n                            cell = (xk, yk, zk)\n                            if cell in grid:\n                                result.extend(grid[cell])\n            return result\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        grid_add(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        found_solution = False\n        c_min = dist(start_pos, goal_pos)\n        no_improve_count = 0\n\n        # For incremental shortcutting of best path:\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic()-start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            # Find nearest node using grid nearest approx (then exact min dist)\n            nearby_nodes = grid_near(sample, self.step_size*5)\n            if not nearby_nodes:\n                nearest_node = min(nodes, key=lambda n: dist_sq(n.position, sample))\n            else:\n                nearest_node = min(nearby_nodes, key=lambda n: dist_sq(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Neighbors for rewiring\n            r = neighbor_radius(len(nodes))\n            neighbors = [n for n in grid_near(new_pos, r) if dist_sq(n.position,new_pos)<=r*r]\n\n            # Filter parents: predator valid edge from candidate parents\n            valid_parents = []\n            for n_ in neighbors:\n                if n_ == nearest_node or n_ == None:\n                    continue\n                if not is_edge_in_obstacle(n_.position, new_pos):\n                    valid_parents.append(n_)\n            if not valid_parents:\n                # try nearest as parent if edge valid\n                if not is_edge_in_obstacle(nearest_node.position, new_pos):\n                    valid_parents = [nearest_node]\n                else:\n                    continue  # no valid parent\n\n            # Choose best parent minimizing cost + dist\n            best_parent = min(valid_parents, key=lambda n_: n_.cost + dist(n_.position, new_pos))\n            new_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, None, new_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            grid_add(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost found\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nbr.position):\n                    continue\n                new_cost_nbr = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost_nbr + self.improve_tol < nbr.cost:\n                    # Rewire: remove old edge\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    new_node.add_child(nbr)\n                    nbr.cost = new_cost_nbr\n                    edges.append((new_node, nbr))\n\n            # Check if we can connect to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost + self.improve_tol < best_cost:\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        found_solution = True\n                        no_improve_count = 0\n\n                        # Incremental shortcutting on improved best path:\n                        current_path = best_goal_node.path_from_root()\n                        smoothed_path = shortcut_path(current_path)\n                        if len(smoothed_path) < len(current_path):\n                            # Rebuild tree structure for smoothed path nodes\n                            path_nodes = []\n                            parent_node = None\n                            for idx, pos in enumerate(smoothed_path):\n                                node = Node(pos)\n                                if idx == 0:\n                                    node.cost = 0.0\n                                else:\n                                    node.cost = parent_node.cost + dist(parent_node.position, pos)\n                                if parent_node:\n                                    parent_node.add_child(node)\n                                parent_node = node\n                                path_nodes.append(node)\n                            best_goal_node = path_nodes[-1]\n                            best_cost = best_goal_node.cost\n                            # Remove edges and nodes except those in this best path plus tree nodes (keep old nodes for reuse)\n                            # For simplicity, keep all nodes/edges but rely on best_goal_node for path extraction\n\n                        # Early stopping to limit runtime after improvement\n                        break\n                    else:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            success_state = True\n        else:\n            # Return path to closest node to goal if no solution\n            closest_node = min(nodes, key=lambda n: dist_sq(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        # Cross product for 3D vectors\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x/n for x in v)",
    "objective": 128.87589,
    "time_improvement": -489.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1528.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10020086765289307,
            "num_nodes_avg": 247.8,
            "path_length_avg": 165.11231663919176,
            "smoothness_avg": 0.054216915783441434,
            "success_improvement": 0.0,
            "time_improvement": -298.7681321684214,
            "length_improvement": 9.49932287797251,
            "smoothness_improvement": 748.6124659278788,
            "objective_score": -80.18778359410351
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4656133890151978,
            "num_nodes_avg": 999.9,
            "path_length_avg": 231.0002962440567,
            "smoothness_avg": 0.10119429155637846,
            "success_improvement": 0.0,
            "time_improvement": -189.68898535344988,
            "length_improvement": 22.88545213886891,
            "smoothness_improvement": 2503.802009047699,
            "objective_score": -30.656414277475122
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5246788024902344,
            "num_nodes_avg": 772.2,
            "path_length_avg": 121.67236980394357,
            "smoothness_avg": 0.11253961091516573,
            "success_improvement": 0.0,
            "time_improvement": -979.8518104154706,
            "length_improvement": 19.19100539186182,
            "smoothness_improvement": 1331.4955440309143,
            "objective_score": -275.7834621693695
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional adaptive RRT*-like planner with dynamic neighbor radius shrinking over iterations, progressive goal biasing, and hybrid sampling (uniform + informed ellipsoidal) post first solution. The planner implements incremental rewiring with efficient neighborhood pruning, maintains a compact tree by removing unreachable nodes periodically, and applies iterative advanced shortcutting smoothing. Planning halts when time limit is reached or solution stabilizes, returning the best path found.",
    "planning_mechanism": "The planner grows a single tree rooted at start with a step-size constrained extend toward sampled points. Early iterations favor uniform random or goal-biased sampling that progressively increases. Once a feasible solution is found, sampling uses an informed ellipsoidal distribution to focus search toward improving the best path cost. New nodes connect to lowest-cost parents within a shrinking neighborhood radius that balances exploration and exploitation. Rewiring nearby nodes reduces path cost locally. Intermittent pruning removes invalid or disconnected nodes to preserve efficiency. Iterative shortcutting after search yields a short, smooth final path. Execution strictly respects 30 seconds time bound, aborting immediately if exceeded to return best path so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate_start = 0.07\n        self.goal_sample_rate_max = 0.3\n        self.goal_sample_rate_inc = 0.00025\n        self.prune_interval = 200\n        self.improve_tol = 1e-6\n        self.max_no_improve = 100\n        self.edge_resolution = 1.0\n        self.shortcut_iterations = 8\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start_time = time.monotonic()\n\n        bounds = map.size  # Tuple[int,...]\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.edge_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample(attempts=120):\n            for _ in range(attempts):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            # Fall back to start if can't find free sample\n            return start_pos\n\n        def informed_sample(c_best):\n            # If no solution yet or infinite best cost, sample uniform\n            if c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            a1 = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            len_a1 = math.sqrt(sum(x*x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            if dim == 2:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best*c_best - len_a1*len_a1, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r1 = c_best * 0.5\n                r_side = math.sqrt(max(c_best*c_best - len_a1*len_a1, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            max_attempts = 150\n            attempts = 0\n            while attempts < max_attempts:\n                # Sample point in unit n-ball\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm_raw = math.sqrt(sum(x*x for x in raw))\n                if norm_raw < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm_raw for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Align to ellipsoid orientation\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                # Rotation for 2D\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(c*c for c in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [c/k_norm for c in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2]-k[2]*v_vec[1],\n                                     k[2]*v_vec[0]-k[0]*v_vec[2],\n                                     k[0]*v_vec[1]-k[1]*v_vec[0]]\n                            rotated = [0.0]*3\n                            for i in range(3):\n                                rotated[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius*radius\n            return [n for n in tree if (dist(n.position, point) <= radius)]\n\n        def prune_invalid_nodes():\n            # Remove unreachable or invalid nodes iteratively\n            removed_any = False\n            to_remove = []\n            for node in nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                if node.parent is None and node is not start_node:\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                    removed_any = True\n            return removed_any\n\n        def shortcut_path(path):\n            # Linear shortcutting: skip intermediate nodes if collision free\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def iterative_shortcut(path):\n            curr_path = path[:]\n            for _ in range(self.shortcut_iterations):\n                curr_path = shortcut_path(curr_path)\n            return curr_path\n\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        best_cost = float('inf')\n        best_node = None\n        found_solution = False\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        for iteration in range(1, self.max_iter + 1):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            # Sampling strategy\n            sample_rand = random.random()\n            if sample_rand < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                if found_solution:\n                    sample = informed_sample(best_cost)\n                else:\n                    sample = uniform_sample()\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                continue\n            # Edge collision check deferred till parent selection for efficiency\n\n            n_nodes = len(nodes) + 1\n            gamma = 25.0\n            radius = gamma * (math.log(n_nodes)/n_nodes) ** (1.0/dim)\n            radius = max(radius, self.step_size)\n            radius = min(radius, self.step_size*15.0)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            # Choose best parent with validated edge\n            best_parent = None\n            best_cost_through = float('inf')\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost_through:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = cost_candidate\n\n            # Fallback to nearest if no valid neighbor parent\n            if best_parent is None:\n                if not is_edge_in_obstacle(nearest.position, new_pos):\n                    best_parent = nearest\n                    best_cost_through = nearest.cost + dist(nearest.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Detach old parent edge\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n            # Check connection to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size * 1.5:\n                if not is_edge_in_obstacle(new_node.position, goal_pos):\n                    total_cost = new_node.cost + dist_to_goal\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_node = new_node\n                        found_solution = True\n                        no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Periodic pruning to remove invalid/unreachable nodes\n            if iteration % self.prune_interval == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success_state = found_solution and best_node is not None\n        if success_state:\n            path = best_node.path_from_root()\n            # Append goal pos explicitly\n            path.append(goal_pos)\n            extracted_path = iterative_shortcut(path)\n        else:\n            # Try fallback path: closest valid node to goal\n            closest_node = None\n            min_dist_goal = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < min_dist_goal:\n                    closest_node = n\n                    min_dist_goal = d\n            if closest_node is not None:\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 51.60656,
    "time_improvement": -235.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1632.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06193296909332276,
            "num_nodes_avg": 406.7,
            "path_length_avg": 163.8298055401998,
            "smoothness_avg": 0.049629902669963415,
            "success_improvement": 0.0,
            "time_improvement": -146.47385779673755,
            "length_improvement": 10.202287534018877,
            "smoothness_improvement": 676.8157498435428,
            "objective_score": -34.43670606939222
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.36646504402160646,
            "num_nodes_avg": 1131.3,
            "path_length_avg": 228.8939660366379,
            "smoothness_avg": 0.10458596165670349,
            "success_improvement": 0.0,
            "time_improvement": -128.00222088686843,
            "length_improvement": 23.588605789458754,
            "smoothness_improvement": 2591.0721236502914,
            "objective_score": -11.292142174133819
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2580716609954834,
            "num_nodes_avg": 715.1,
            "path_length_avg": 120.17026113801076,
            "smoothness_avg": 0.13582950514645686,
            "success_improvement": 0.0,
            "time_improvement": -431.14238467464537,
            "length_improvement": 20.188634445046155,
            "smoothness_improvement": 1627.7412795717662,
            "objective_score": -109.09082833750708
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid single-tree planner combining adaptive informed sampling with fixed-radius rewiring, cost-to-go heuristic pruning, and progressive smoothing. It uses ellipsoidal informed sampling once a solution is found to restrict exploration to promising regions. The rewiring radius adapts to node count and dimension to balance speed and path quality. Downstream cost propagation after rewiring ensures consistent cost updates. The planner employs incremental iterative smoothing with collision checks to improve path smoothness without excessive computation, all under a strict 30-second time budget.",
    "planning_mechanism": "The algorithm grows a single tree from the start node with goal bias sampling initially. After the first feasible path is found, it switches to informed ellipsoidal sampling inside a prolate hyperspheroid defined by the current best cost, start, and goal positions. Each sampled point is steered towards with a fixed step size, and a set of nearby neighbors are examined within an adaptive radius to select the best parent minimizing cost. Rewiring improves path costs for all neighbors with safe edges, propagating downstream cost updates recursively to children. Once the time limit or iteration limit is reached, the best path is extracted and refined by shortcut attempts iteratively, producing shorter, smoother paths with fewer waypoints and sharper turns eliminated.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float,...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root to this node\n        self.children = []            # List of children nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def propagate_cost_update(self, obstacles, is_3d, planner):\n        # Recursively update costs of descendants if their costs can be lowered\n        stack = [self]\n        while stack:\n            current = stack.pop()\n            for c in current.children:\n                new_cost = current.cost + planner._dist(current.position, c.position)\n                if new_cost + planner.improve_tol < c.cost:\n                    c.cost = new_cost\n                    c.parent = current\n                    stack.append(c)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=7.0, goal_sample_rate=0.1, gamma=40.0,\n                 time_limit_sec=30.0, improve_tol=1e-6, smooth_iters=150, shortcut_resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # r-radius constant for rewiring\n        self.time_limit_sec = time_limit_sec\n        self.improve_tol = improve_tol\n        self.smooth_iters = smooth_iters\n        self.shortcut_resolution = shortcut_resolution\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def uniform_sample():\n            # Sample uniformly within bounds, retry if inside obstacle (limit attempts)\n            for _ in range(50):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            # fallback: try start or mid-point to avoid deadlocks\n            fallback = tuple(bounds[i]*0.5 for i in range(dim))\n            if not self._is_in_obstacle(fallback, obstacles, is_3d):\n                return fallback\n            return start_pos\n\n        def informed_sample(c_best, c_min):\n            # Sample inside prolate hyperspheroid between start and goal if solution found,\n            # else uniform sampling.\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n                radii = (r1, r2)\n            else:\n                # 3D case: define orthonormal basis (a1,a2,a3)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    return tuple(x/n if n>1e-12 else 0 for x in v)\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2)<1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1,b2)\n                basis = (a1, b2, b3)\n                r1 = c_best * 0.5\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if self._is_in_obstacle(mapped, obstacles, is_3d):\n                return uniform_sample()\n            return mapped\n\n        def steer(from_p, to_p):\n            d = self._dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(3.0, self.step_size * 2)\n            val = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds)*0.25\n            min_r = max(self.step_size*1.1, 3.0)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, point, radius):\n            # Linear search - could be improved with spatial data structures\n            return [n for n in nodes_list if self._dist(n.position, point) <= radius]\n\n        def nearest(nodes_list, point):\n            best = None\n            best_d = float('inf')\n            for n in nodes_list:\n                d = self._dist(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best = n\n            return best\n\n        # Data structures\n        tree = [Node(start_pos, None, 0.0)]\n        nodes = tree[:]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n\n        start_time = time.monotonic()\n\n        post_no_improve = 0\n        max_no_improve = 150\n        max_post_iterations = 300\n        post_iter = 0\n\n        c_min = self._dist(start_pos, goal_pos)\n\n        # Incremental smoothing helper\n        def attempt_shortcut(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.shortcut_resolution):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        def iterative_path_smoothing(path):\n            # Perform iterative shortcutting with early stopping on no improvement\n            cur_path = path\n            no_improve_counter = 0\n            max_no_improve_local = 40\n            iter_count = 0\n            while iter_count < self.smooth_iters and no_improve_counter < max_no_improve_local:\n                new_path = attempt_shortcut(cur_path)\n                if len(new_path) < len(cur_path) - 1:\n                    cur_path = new_path\n                    no_improve_counter = 0\n                else:\n                    no_improve_counter += 1\n                iter_count += 1\n            return cur_path\n\n        # Downstream cost propagation recursive helper\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    new_cost = curr.cost + self._dist(curr.position, c.position)\n                    if new_cost + self.improve_tol < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        stack.append(c)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Sampling\n            if first_solution_found:\n                sample = goal_pos if random.random() < self.goal_sample_rate * 0.9 else informed_sample(best_cost, c_min)\n            else:\n                sample = goal_pos if random.random() < self.goal_sample_rate else uniform_sample()\n\n            # Nearest node to sample\n            nearest_node = nearest(tree, sample)\n\n            # Steer toward sample\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                # Post no-improve increment if after first solution\n                if first_solution_found:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                        break\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                if first_solution_found:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                        break\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.shortcut_resolution):\n                if first_solution_found:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                        break\n                continue\n\n            # Find neighbors within radius\n            radius = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Select best parent minimizing cost + dist, check edge collision\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                cost_thru = nb.cost + self._dist(nb.position, new_pos)\n                if cost_thru + self.improve_tol < min_cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.shortcut_resolution):\n                        min_cost = cost_thru\n                        best_parent = nb\n\n            # Add new node\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cost improves. Propagate cost downstream to children.\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + self.improve_tol < nb.cost:\n                    # Check edge collision\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.shortcut_resolution):\n                        # Rewire nb to new_node\n                        if nb.parent is not None:\n                            nb.parent.remove_child(nb)\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = cost_through_new\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n                        # Propagate cost changes downstream\n                        nb.propagate_cost_update(obstacles, is_3d, self)\n\n            # Check if can connect directly to goal (steer within step_size)\n            dist_to_goal = self._dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d, self.shortcut_resolution)):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = new_node\n                    goal_node.cost = new_node.cost + dist_to_goal\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    candidate_path = goal_node.path_from_root()\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path) - 1):\n                        candidate_cost += self._dist(candidate_path[i], candidate_path[i+1])\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        first_solution_found = True\n                        # Reset counters on improvement\n                        post_iter = 0\n                        post_no_improve = 0\n                    else:\n                        # No improvement - increment no improve counters\n                        post_no_improve += 1\n                        post_iter += 1\n                    if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                        break\n                else:\n                    if first_solution_found:\n                        post_no_improve += 1\n                        post_iter += 1\n                        if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                            break\n            else:\n                # After first solution found, count no improvement iterations\n                if first_solution_found:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_no_improve >= max_no_improve or post_iter >= max_post_iterations:\n                        break\n\n        # If no solution found, pick best node closest to goal to form partial path\n        if not first_solution_found:\n            if nodes:\n                best_node = min(nodes, key=lambda n: self._dist(n.position, goal_pos) + n.cost)\n                best_path = best_node.path_from_root()\n                success = False\n            else:\n                best_path = []\n                success = False\n        else:\n            success = True\n\n        # Path smoothing: iterative shortcutting to improve smoothness and shorten path\n        if best_path and len(best_path) > 2:\n            best_path = iterative_path_smoothing(best_path)\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _dist(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w_, h_ = obs\n                px, py = pos\n                if x <= px <= x + w_ and y <= py <= y + h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 577.12175,
    "time_improvement": -1988.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1416.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.1791323184967042,
            "num_nodes_avg": 1320.1,
            "path_length_avg": 156.5922024196232,
            "smoothness_avg": 0.04373898442484212,
            "success_improvement": 0.0,
            "time_improvement": -4592.578050872546,
            "length_improvement": 14.169332491567529,
            "smoothness_improvement": 584.6100869736769,
            "objective_score": -1366.3487653319546
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6121307373046875,
            "num_nodes_avg": 1070.6,
            "path_length_avg": 227.63025579198197,
            "smoothness_avg": 0.10023957549396442,
            "success_improvement": 0.0,
            "time_improvement": -280.84714996815967,
            "length_improvement": 24.01046864300749,
            "smoothness_improvement": 2479.2364771076013,
            "objective_score": -57.451681419105405
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5780305862426758,
            "num_nodes_avg": 909.7,
            "path_length_avg": 116.93100191247731,
            "smoothness_avg": 0.10107067067090696,
            "success_improvement": 0.0,
            "time_improvement": -1089.6561707222525,
            "length_improvement": 22.33999618569674,
            "smoothness_improvement": 1185.6114706730523,
            "objective_score": -307.5647961518924
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, efficient unidirectional RRT* planner with goal bias sampling, fixed step steering and adaptive shrinking rewiring radius. The planner grows a tree from the start toward random or goal samples, connects new nodes by steering with a fixed step size, chooses the best parent among nearby nodes within an adaptive radius to minimize path cost, and rewires neighbors to reduce their costs. It terminates when reaching the goal or after 30 seconds, returning the best found path without post-processing smoothing for generalization and robustness.",
    "planning_mechanism": "A single tree grows by sampling points (with goal bias), steering fixed step toward samples. An adaptive neighbor radius shrinks with tree size allowing efficient rewiring. New nodes attach to lowest cost parents avoiding collisions. Neighbors are rewired through new nodes if cost improves. The best path to goal is extracted at termination, favoring simplicity and general applicability.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 max_neighbor_radius: float = 20.0, min_neighbor_radius: float = 2.0, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Check edge collision with resolution = step_size * 0.5 for efficiency\n            resolution = min(1.0, self.step_size * 0.5)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.max_neighbor_radius\n            r = self.max_neighbor_radius * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearest_node(point):\n            best_node = nodes[0]\n            best_dist = dist(point, best_node.position)\n            for node in nodes[1:]:\n                d = dist(point, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def nearby_nodes(point, radius):\n            r2 = radius * radius\n            result = []\n            for node in nodes:\n                d2 = 0\n                for i in range(dim):\n                    dx = node.position[i] - point[i]\n                    d2 += dx * dx\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        start_time = time.monotonic()\n        nodes: List[Node] = [Node(start_pos)]\n        edges: List[Tuple[Node, Node]] = []\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit:\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            radius = neighbor_radius(len(nodes))\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for n in neighbors:\n                c_cand = n.cost + dist(n.position, new_pos)\n                if c_cand < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for n in neighbors:\n                if n is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            # Check if close enough to goal to connect\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node is not None:\n            current = goal_node\n        else:\n            # fallback: closest node to goal\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        path = []\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 59.0158,
    "time_improvement": -192.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 66.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04353854656219482,
            "num_nodes_avg": 306.3,
            "path_length_avg": 188.75491231571505,
            "smoothness_avg": 0.010851826068917332,
            "success_improvement": 0.0,
            "time_improvement": -73.26980590704487,
            "length_improvement": -3.4595584532327686,
            "smoothness_improvement": 69.85464309603768,
            "objective_score": -23.707403628572933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.20679478645324706,
            "num_nodes_avg": 906.6,
            "path_length_avg": 312.32841885073185,
            "smoothness_avg": 0.00611285411704552,
            "success_improvement": 0.0,
            "time_improvement": -28.66075864083266,
            "length_improvement": -4.264216087453753,
            "smoothness_improvement": 57.288139342434754,
            "objective_score": -10.870316548009876
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.27934672832489016,
            "num_nodes_avg": 647.7,
            "path_length_avg": 151.4415853287187,
            "smoothness_avg": 0.013477894974105292,
            "success_improvement": 0.0,
            "time_improvement": -474.9290211145624,
            "length_improvement": -0.5802901019823982,
            "smoothness_improvement": 71.43782923589616,
            "objective_score": -142.46969124937866
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined unidirectional RRT* planner with fixed step steering, simplified goal bias sampling, and a constant neighbor radius for rewiring. The planner incrementally grows a tree from start toward random samples or the goal, connects tree nodes by fixed step size while avoiding collisions, and rewires neighbors within a fixed radius to reduce costs. It returns the best found path within 30 seconds without extensive bookkeeping or adaptive radius adjustments to enhance generalization and robustness.",
    "planning_mechanism": "A single tree is grown by sampling points biased toward the goal, steering fixed steps from nearest nodes while ensuring collision-free nodes and edges. Nearby nodes within a constant radius are considered for selecting parents and rewiring to lower path costs. The search terminates either upon reaching the goal or the 30-second time limit, returning the best found path and connectivity information.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=10.0, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            resolution = min(1.0, self.step_size * 0.5)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution)\n\n        def nearest_node(point):\n            best = nodes[0]\n            best_dist = dist(point, best.position)\n            for node in nodes[1:]:\n                d = dist(point, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def nearby_nodes(point, radius):\n            r2 = radius*radius\n            result = []\n            for node in nodes:\n                d2 = 0\n                pos = node.position\n                for i in range(dim):\n                    dx = pos[i] - point[i]\n                    d2 += dx*dx\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        nodes = [Node(start_pos)]\n        edges = []\n        goal_reached = False\n        goal_node = None\n        start_time = time.monotonic()\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            neighbors = nearby_nodes(new_pos, self.neighbor_radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for n in neighbors:\n                c = n.cost + dist(n.position, new_pos)\n                if c < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = c\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in neighbors:\n                if n is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                goal_reached = True\n                break\n\n        if goal_reached and goal_node:\n            current = goal_node\n        else:\n            current = min(nodes, key=lambda n: dist(n.position, goal_pos)) if nodes else None\n\n        path = []\n        while current:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=goal_reached, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 23.20659,
    "time_improvement": -113.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 171.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02675905227661133,
            "num_nodes_avg": 195.0,
            "path_length_avg": 170.6119908964307,
            "smoothness_avg": 0.015299138334289305,
            "success_improvement": 0.0,
            "time_improvement": -6.492663635466562,
            "length_improvement": 6.484864269664385,
            "smoothness_improvement": 139.46473754226685,
            "objective_score": 2.6404431588699966
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.28504366874694825,
            "num_nodes_avg": 922.6,
            "path_length_avg": 232.46302743291304,
            "smoothness_avg": 0.011551064853479832,
            "success_improvement": 0.0,
            "time_improvement": -77.34458056581589,
            "length_improvement": 22.39715036564582,
            "smoothness_improvement": 197.21721857575733,
            "objective_score": -8.778997857478487
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.17203187942504883,
            "num_nodes_avg": 480.8,
            "path_length_avg": 120.83483179842305,
            "smoothness_avg": 0.02184101084069103,
            "success_improvement": 0.0,
            "time_improvement": -254.06221018386304,
            "length_improvement": 19.747258255854486,
            "smoothness_improvement": 177.81604575786588,
            "objective_score": -63.481227872856884
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius, informed elliptical sampling after first solution, and consistent downstream cost propagation. The planner alternates tree expansions, uses goal bias and adaptive sampling to accelerate convergence, incrementally rewires neighbors to improve path quality, and iteratively shortcuts the path to enhance smoothness and minimize length under a 30-second time limit.",
    "planning_mechanism": "Grows two RRT* trees from start and goal positions, sampling uniformly initially and switching to informed sampling after solution discovery. Each expansion connects nodes via lowest-cost parent among collision-free neighbors within an adaptive radius, rewiring them with downstream cost updates. Trees attempt connections frequently to find feasible paths, which are shortcut iteratively to reduce length and smoothness. Planning stops after time or improvement thresholds are met, returning the best feasible path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i]+(to[i]-fr[i])*r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1,p2)\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials=0\n            while True:\n                s = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials+=1\n                if trials>1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s+g)*0.5 for s,g in zip(start, goal))\n            a1 = tuple((g - s)/c_min for s,g in zip(start, goal))\n            if dim==2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best/2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.,0.,0.) if abs(a1[0])<0.9 else (0.,1.,0.)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2)<1e-12:\n                    ref = (0.,0.,1.)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1,b2)\n                basis = [a1,b2,b3]\n                r1 = c_best/2.\n                r_other = math.sqrt(max(c_best**2 - c_min**2,0))/2.\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x*x for x in v))\n                    if norm_>1e-12:\n                        v = [x/norm_ for x in v]\n                        r = random.random()**(1./dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                mapped[i] += sum(basis[j][i]*radii[j]*u[j] for j in range(dim))\n            mapped = tuple(min(max(mapped[i],0.0),bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node, min_d = None, float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_<min_d:\n                    min_d=d_\n                    min_node=n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2.)\n            val = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1./dim))\n            max_r = max(bounds)*0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r,val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius*radius\n            res = []\n            for n in nodes_list:\n                if dist(n.position, p) <= radius:\n                    res.append(n)\n            return res\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # eliminate double end\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            curr_tree = tree_start if it % 2 == 0 else tree_goal\n            other_tree = tree_goal if it % 2 == 0 else tree_start\n            a_is_start_side = it % 2 == 0\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Direct connect if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, cost=nearest_other.cost+dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current,new_node):\n                        final_node = Node(new_node.position, cost=current.cost+dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.\n                for i in range(len(candidate_path)-1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x/n for x in v)",
    "objective": 9.72972,
    "time_improvement": -96.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1551.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1015120267868042,
            "num_nodes_avg": 323.6,
            "path_length_avg": 154.35886563217852,
            "smoothness_avg": 0.04735711684069112,
            "success_improvement": 0.0,
            "time_improvement": -303.9861356753023,
            "length_improvement": 15.393459774252028,
            "smoothness_improvement": 641.2417161820088,
            "objective_score": -78.75355625712943
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.059991860389709474,
            "num_nodes_avg": 337.5,
            "path_length_avg": 233.83394029020943,
            "smoothness_avg": 0.09899070204007733,
            "success_improvement": 0.0,
            "time_improvement": 62.67508285679152,
            "length_improvement": 21.939500194341583,
            "smoothness_improvement": 2447.1020636118965,
            "objective_score": 44.20173529170189
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07120814323425292,
            "num_nodes_avg": 364.7,
            "path_length_avg": 121.7065252055058,
            "smoothness_avg": 0.1309464224617562,
            "success_improvement": 0.0,
            "time_improvement": -46.55488657608455,
            "length_improvement": 19.168321000449634,
            "smoothness_improvement": 1565.628828254045,
            "objective_score": 5.362670768714641
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A unidirectional RRT*-Informed planner integrating adaptive neighbor radius, ellipsoidal informed sampling after first solution, dynamic rewiring for quick path cost improvements, and a post-planning shortcut smoothing step to minimize path length and reduce planning time under a strict 30-second limit. It balances exploration and exploitation by focusing sampling inside an ellipsoidal informed subset and stops early when improvements stagnate.",
    "planning_mechanism": "The planner grows a single tree from the start using RRT* logic, initially sampling uniformly and switching to ellipsoidal informed sampling after the first path is found. It uses an adaptive neighbor radius proportional to the number of nodes and problem dimension to choose parents and rewire nearby nodes for cost optimization. After termination or timeout, it applies shortcut smoothing to reduce path length and sharp turns, returning the best path found within the time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For potential future use\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 8000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n        self.gamma_rrt_star = 50.0    # Scaled theoretical radius constant\n        self.improve_tol = 1e-7       # Tolerance for cost improvement stagnation\n        self.max_no_improve = 120     # Max post-improvement iterations before early stop\n        self.post_opt_iters = 400     # Max post optimization iterations\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(30):  # Limit attempts\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n            # fallback to start_pos to avoid infinite loops (rare)\n            return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # Build orthonormal basis for 3D\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n                mapped[i] = min(max(mapped[i], 0.0), bounds[i])\n            if is_in_obstacle(tuple(mapped)):\n                return uniform_sample()\n            return tuple(mapped)\n\n        def nearest(nodes_list, p):\n            # Linear search is simple; can be optimized (k-d tree omitted per constraints)\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            radius_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree_nodes, pos, all_nodes, edges_list):\n            r = neighbor_radius(len(tree_nodes))\n            neighbors = near_nodes(tree_nodes, pos, r)\n            # Only parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree_nodes, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree_nodes, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect_to_goal(node):\n            if is_in_obstacle(goal_pos):\n                return False\n            if is_edge_in_obstacle(node.position, goal_pos):\n                return False\n            return True\n\n        def extract_path(goal_node):\n            return goal_node.path_from_root()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        nodes = []\n        edges = []\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        post_no_improve = 0\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if found_solution:\n                # Informed sampling focused in ellipsoidal subset\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                # Uniform + goal bias sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if not within_bounds(sample):\n                continue\n            if is_in_obstacle(sample):\n                continue\n\n            near_node = nearest(nodes, sample)\n            new_pos = steer(near_node.position, sample)\n\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(near_node.position, new_pos):\n                continue\n\n            new_node, neighbors = add_node_rrt_star(nodes, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire(nodes, new_node, neighbors, edges)\n\n            # Check if can connect directly to goal (within step size)\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size and can_connect_to_goal(new_node):\n                goal_cost = new_node.cost + dist_to_goal\n                if goal_cost + 1e-12 < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    # Reset post optimization counters after a better solution found\n                    post_iter = 0\n                    post_no_improve = 0\n\n            if found_solution:\n                post_iter += 1\n                # If no significant improvement in last iterations, break early\n                if abs(best_cost - (best_goal_node.cost if best_goal_node else float('inf'))) > self.improve_tol:\n                    post_no_improve = 0\n                else:\n                    post_no_improve += 1\n                if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                    break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n            success_state = True\n        else:\n            # Fallback: closest node to goal\n            closest = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = extract_path(closest)\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 174.34443,
    "time_improvement": -644.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1608.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2230374813079834,
            "num_nodes_avg": 871.4,
            "path_length_avg": 161.68501773450217,
            "smoothness_avg": 0.05574498679637853,
            "success_improvement": 0.0,
            "time_improvement": -787.6194578756803,
            "length_improvement": 11.377879716659416,
            "smoothness_improvement": 772.5300955396596,
            "objective_score": -225.5964590550101
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0060866594314575,
            "num_nodes_avg": 2196.4,
            "path_length_avg": 232.2595409774655,
            "smoothness_avg": 0.10430493836229607,
            "success_improvement": 0.0,
            "time_improvement": -525.9532702974478,
            "length_improvement": 22.465080001507083,
            "smoothness_improvement": 2583.8411918722913,
            "objective_score": -131.38772712896866
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.34939942359924314,
            "num_nodes_avg": 1098.7,
            "path_length_avg": 119.59870710196465,
            "smoothness_avg": 0.12329796933749533,
            "success_improvement": 0.0,
            "time_improvement": -619.1058574141408,
            "length_improvement": 20.56823342130948,
            "smoothness_improvement": 1468.341069063531,
            "objective_score": -166.0491118261389
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive neighbor radius and ellipsoidal informed sampling after first solution. It employs goal biasing, dynamic rewiring with downstream cost propagation, greedy incremental tree connections, and post-planning path shortcutting to efficiently find shorter, smoother paths within a 30-second limit. The planner alternates expansions from start and goal trees, focuses sampling inside an informed ellipsoid after the first path, and stops early on stagnation to reduce planning time.",
    "planning_mechanism": "The planner initializes two trees at start and goal and alternately expands them by sampling (uniformly before first solution and ellipsoidally after), steering toward samples with a fixed step size. Each new node is connected to the best parent within an adaptive radius, followed by rewiring nearby nodes with proper cost and parent updates propagated downstream. The two trees attempt to connect greedily via incremental steps. The best path merges the two trees\u2019 paths and is smoothed by shortcutting before returning. Early termination occurs on timeout or no improvement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=10000,\n                 step_size=5.0,\n                 goal_sample_rate=0.05,\n                 max_no_improve=100,\n                 post_opt_iters=300,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0,\n                 gamma_rrt_star=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            possible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not possible_parents:\n                p = nearest(tree, pos)\n                if not p or is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                possible_parents = [p]\n            best_parent = min(possible_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n1, n2, n1_is_start):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            # Remove duplicate connection node if any\n            if path1 and path2 and path1[-1] == path2[-1]:\n                combined = path1 + path2[-2::-1]\n            else:\n                combined = path1 + path2[::-1]\n            return combined if n1_is_start else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal[:]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                curr_is_start = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                curr_is_start = False\n\n            # Sampling\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbor_nodes = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbor_nodes, edges)\n\n            # Attempt greedy connection\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                current = nearest_other\n                tries = 0\n                max_steps = 20\n                while tries < max_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if (not within_bounds(step_pos)) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(other_tree, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, curr_is_start)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    post_no_improve = 0\n                    post_iter = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": -13.77791,
    "time_improvement": -18.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1598.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06372268199920654,
            "num_nodes_avg": 287.6,
            "path_length_avg": 152.576090368934,
            "smoothness_avg": 0.046970337316992926,
            "success_improvement": 0.0,
            "time_improvement": -153.59635572828506,
            "length_improvement": 16.370627145918192,
            "smoothness_improvement": 635.1877767309533,
            "objective_score": -33.08059154727984
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04632420539855957,
            "num_nodes_avg": 360.9,
            "path_length_avg": 238.06797499023278,
            "smoothness_avg": 0.10759340578586915,
            "success_improvement": 0.0,
            "time_improvement": 71.17863795197799,
            "length_improvement": 20.526057541542208,
            "smoothness_improvement": 2668.4558272681725,
            "objective_score": 47.01150504685958
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.035000181198120116,
            "num_nodes_avg": 282.6,
            "path_length_avg": 121.55600159653787,
            "smoothness_avg": 0.1250353575595627,
            "success_improvement": 0.0,
            "time_improvement": 27.965435515449506,
            "length_improvement": 19.268291614362116,
            "smoothness_improvement": 1490.440519007569,
            "objective_score": 27.40280821828997
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "An efficient unidirectional RRT*-inspired planner combining adaptive neighbor radius rewiring, dynamic goal biasing, and iterative path shortcutting. It grows a single tree from start, progressively biasing sampling toward the goal. The planner dynamically adjusts rewiring radius based on node count and problem dimension, ensuring dense local connectivity and effective cost improvements. Incremental rewiring reduces path cost and improves smoothness. Multiple iterations of collision-checked path shortcutting refine the final trajectory. A strict 30-second time bound enforces early termination returning the best path found.",
    "planning_mechanism": "A single tree grows from start by steering towards adaptively sampled points, increasingly biased towards the goal. Each new sample connects through the lowest-cost parent within a shrinking neighborhood radius and rewires neighbors to locally improve costs. The planner applies multiple iterative shortcut attempts on path extraction for smoothness. Collisions are rigorously checked on nodes and edges. The search halts on time expiry or stable solution quality, returning the shortest, smoothest feasible path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate_min = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 0.0005\n        self.improve_tol = 1e-7\n        self.max_no_improve = 80\n        self.edge_resolution = 1.0\n        self.shortcut_iterations = 10\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        distance = math.dist(from_pos, to_pos)\n        if resolution is None:\n            resolution = min(self.step_size * 0.3, 1.0)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_free_node(p):\n            if not within_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def uniform_sample(attempts=100):\n            for _ in range(attempts):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n            return start_pos\n\n        def adaptive_goal_sample_rate(iteration):\n            rate = self.goal_sample_rate_min + iteration * self.goal_sample_rate_inc\n            return min(rate, self.goal_sample_rate_max)\n\n        def informed_sample(c_best):\n            # Ellipsoidal sampling focused near current best cost path\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length = math.sqrt(sum(d * d for d in direction))\n            if length < 1e-10:\n                return uniform_sample()\n            unit_dir = tuple(d / length for d in direction)\n\n            radii = [c_best * 0.5] + [math.sqrt(c_best * c_best - c_min * c_min) * 0.5] * (dim - 1)\n            # Sample random point in unit ball\n            for _ in range(150):\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                if norm_vec < 1e-10:\n                    continue\n                unit_vec = [x / norm_vec for x in vec]\n                radius = random.random() ** (1/dim)\n                sample_ball = [radius * radii[i] * unit_vec[i] for i in range(dim)]\n\n                # Build orthonormal basis with unit_dir as first axis\n                basis = [unit_dir]\n                if dim == 2:\n                    a2 = (-unit_dir[1], unit_dir[0])\n                    basis.append(a2)\n                elif dim == 3:\n                    ref = (1.0, 0.0, 0.0) if abs(unit_dir[0]) < 0.9 else (0.0, 1.0, 0.0)\n                    k = (unit_dir[1]*ref[2]-unit_dir[2]*ref[1],\n                         unit_dir[2]*ref[0]-unit_dir[0]*ref[2],\n                         unit_dir[0]*ref[1]-unit_dir[1]*ref[0])\n                    k_norm = math.sqrt(sum(c*c for c in k))\n                    if k_norm < 1e-10:\n                        basis.append((0.0, 0.0, 0.0))\n                        basis.append((0.0, 0.0, 0.0))\n                    else:\n                        k = tuple(c / k_norm for c in k)\n                        b1 = k\n                        b2 = (unit_dir[1]*b1[2]-unit_dir[2]*b1[1],\n                              unit_dir[2]*b1[0]-unit_dir[0]*b1[2],\n                              unit_dir[0]*b1[1]-unit_dir[1]*b1[0])\n                        basis.extend([b1, b2])\n                else:\n                    # High-dimension fallback: axis aligned\n                    for i in range(1, dim):\n                        axis = [0]*dim\n                        axis[i] = 1\n                        basis.append(tuple(axis))\n\n                sample_coords = []\n                for i in range(dim):\n                    coord = center[i]\n                    for j in range(dim):\n                        coord += sample_ball[j] * basis[j][i]\n                    sample_coords.append(coord)\n                sample_coords = tuple(max(0.0, min(bounds[i], sample_coords[i])) for i in range(dim))\n                if is_free_node(sample_coords):\n                    return sample_coords\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            best = tree[0]\n            best_dist = dist(best.position, point)\n            for n in tree[1:]:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best\n\n        def near_nodes(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes(tree_nodes, start_node):\n            to_remove = []\n            for node in tree_nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                elif node.parent is None and node is not start_node:\n                    # Unreachable node\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in tree_nodes:\n                    tree_nodes.remove(n)\n            return len(to_remove) > 0\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if is_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def iterative_shortcut(path):\n            curr_path = path[:]\n            for _ in range(self.shortcut_iterations):\n                curr_path = shortcut_path(curr_path)\n            return curr_path\n\n        # Initialization\n        nodes = []\n        edges = []\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        best_cost = float('inf')\n        best_node = None\n        found_solution = False\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_min\n\n        for iteration in range(1, self.max_iter + 1):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            if random.random() < goal_sample_rate and is_free_node(goal_pos):\n                sample = goal_pos\n            elif found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                sample = uniform_sample()\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos) or not is_free_node(new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            gamma_rrt_star = 25.0\n            radius = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = max(radius, self.step_size)\n            radius = min(radius, self.step_size * 15.0)\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            best_parent = None\n            best_cost_through = float('inf')\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + self.improve_tol < best_cost_through:\n                    if is_free_edge(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = candidate_cost\n\n            if best_parent is None:\n                if is_free_edge(nearest.position, new_pos):\n                    best_parent = nearest\n                    best_cost_through = nearest.cost + dist(nearest.position, new_pos)\n                else:\n                    continue\n\n            new_node = Node(new_pos, best_parent, best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node\n            for nb in neighbors:\n                if nb is new_node or nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    if is_free_edge(new_node.position, nb.position):\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size * 1.5:\n                if is_free_edge(new_node.position, goal_pos):\n                    total_cost = new_node.cost + dist_to_goal\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_node = new_node\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Periodic pruning\n            if iteration % 200 == 0 and found_solution:\n                prune_invalid_nodes(nodes, start_node)\n\n        success_state = found_solution and best_node is not None\n        if success_state:\n            path = best_node.path_from_root()\n            path.append(goal_pos)\n            extracted_path = iterative_shortcut(path)\n        else:\n            # Fallback: closest node near goal\n            closest_node = None\n            min_dist_goal = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < min_dist_goal:\n                    closest_node = n\n                    min_dist_goal = d\n            if closest_node is not None:\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 47.95655,
    "time_improvement": -227.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1806.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05048511028289795,
            "num_nodes_avg": 344.2,
            "path_length_avg": 160.26303169966323,
            "smoothness_avg": 0.060578115418306974,
            "success_improvement": 0.0,
            "time_improvement": -100.91495813755778,
            "length_improvement": 12.1572927951653,
            "smoothness_improvement": 848.1790537796254,
            "objective_score": -18.73921649527003
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.5690364122390748,
            "num_nodes_avg": 1332.2,
            "path_length_avg": 230.13155996482865,
            "smoothness_avg": 0.11977652657552543,
            "success_improvement": 0.0,
            "time_improvement": -254.03531079585093,
            "length_improvement": 23.175461314062577,
            "smoothness_improvement": 2981.9363003332396,
            "objective_score": -47.395634948651534
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.20701069831848146,
            "num_nodes_avg": 616.2,
            "path_length_avg": 120.11688116999946,
            "smoothness_avg": 0.1328085971300273,
            "success_improvement": 0.0,
            "time_improvement": -326.05280848704325,
            "length_improvement": 20.22408687811833,
            "smoothness_improvement": 1589.315552583017,
            "objective_score": -77.7348126563269
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT*-informed planner that combines progressive goal bias and ellipsoidal informed sampling with spatial hashing for efficient neighbor searches, adaptive and dynamic rewiring radius, incremental small-step connection attempts, and multi-pass shortcut path smoothing to improve planning speed, path length, and smoothness while enforcing a strict time limit. The planner alternately grows start and goal trees with greedy connection attempts, continuously rewires nodes within adaptive radii for cost optimization, and applies refined shortcut smoothing on the best found path before terminating early on stagnation or time limit.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, iteratively expanding them alternately. Sampling is goal-biased and switches to ellipsoidal informed sampling once a first solution is found for focused search in promising regions. Spatial hashing accelerates neighbor searches for adaptive-radius rewiring, improving local path optimality. Incremental small-step attempts connect the two trees robustly. Multi-pass shortcutting refines the final path for smoothness and length. The algorithm obeys all collision checks, boundary constraints, cleans invalid nodes, and respects a 30-second wall-clock time limit, returning the best solution found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit_sec = 30.0\n        # Parameters for progressive goal bias increase\n        self.goal_sample_rate_start = 0.1\n        self.goal_sample_rate_end = 0.4\n        self.improve_tol = 1e-6\n        self.max_no_improve = 120\n        self.gamma_rrt_star = 60.0\n        self.spatial_hash_cell_size = self.step_size * 3.0\n        # Maximum incremental steps when connecting trees\n        self.max_connect_steps = 15\n        # Shortcutting passes\n        self.shortcut_passes = 5\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_pos(p):\n            return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            # Adaptive step size to reduce unnecessary intermediate nodes\n            adaptive_factor = 0.7 + 0.3*random.random()\n            step_len = min(self.step_size * adaptive_factor, d)\n            ratio = step_len / d\n            new_p = tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n            return clamp_pos(new_p)\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            # Adaptive resolution: finer for short edges, coarser for longer edges\n            res = max(0.3, resolution * min(1.0, length / 10.0))\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            tries = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                tries += 1\n                if not is_in_obstacle(s) or tries > 100:\n                    return s\n\n        def cross(u,v):\n            if dim==3:\n                return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n            return None\n\n        def norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def normalize(v):\n            n = norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x/n for x in v)\n\n        def informed_sample(start, goal, c_best, c_min):\n            # Rejection sampling inside ellipsoid defined by start, goal, and best cost\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5*(start[i]+goal[i]) for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n\n            # Generate orthonormal basis\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x*r for x in v]\n\n            for _ in range(100):\n                u = sample_unit_ball(dim)\n                mapped = [center[i] for i in range(dim)]\n                for i in range(dim):\n                    for j in range(dim):\n                        mapped[i] += basis[j][i] * radii[j] * u[j]\n                mapped = clamp_pos(tuple(mapped))\n                if not is_in_obstacle(mapped):\n                    return mapped\n            return uniform_sample()\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(3.0, self.step_size*2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            max_r = max(bounds)*0.25\n            min_r = max(self.step_size*1.0, 2.0)\n            return max(min_r, min(max_r, val))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[i]//self.cell_size) for i in range(dim))\n\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def query_radius(self, point, radius):\n                center_hash = self._hash(point)\n                r_cells = int(math.ceil(radius/self.cell_size))\n                candidates = []\n                if dim == 2:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            h = (center_hash[0]+dx, center_hash[1]+dy)\n                            if h in self.cells:\n                                candidates.extend(self.cells[h])\n                else:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            for dz in range(-r_cells, r_cells+1):\n                                h = (center_hash[0]+dx, center_hash[1]+dy, center_hash[2]+dz)\n                                if h in self.cells:\n                                    candidates.extend(self.cells[h])\n                return [n for n in candidates if dist(n.position, point) <= radius]\n\n            def clear(self):\n                self.cells.clear()\n\n        def nearest_node(nodes_list, point):\n            best = None\n            best_dist = float('inf')\n            for n in nodes_list:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def add_node(tree, pos, nodes_all, edges_list, spatial_hash):\n            r = neighbor_radius(len(tree))\n            neighbors = spatial_hash.query_radius(pos, r)\n            valid_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not valid_parents:\n                p = nearest_node(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                valid_parents = [p]\n            best_parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            spatial_hash.insert(new_node)\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_to_children(c)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_paths(n_start, n_goal, start_tree_side):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                path = path_start + path_goal[-2::-1]\n            else:\n                path = path_start + path_goal[::-1]\n            return path if start_tree_side else path[::-1]\n\n        def shortcut_path(path, passes=5):\n            if len(path) < 3:\n                return path\n            for _ in range(passes):\n                new_path = [path[0]]\n                i = 0\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        def prune_invalid_nodes(nodes_list, edges_list, best_cost, margin=5.0):\n            # Remove costly isolated invalid nodes periodically\n            to_remove = []\n            threshold = best_cost + margin\n            for node in nodes_list:\n                if not node.valid:\n                    continue\n                if node.cost > threshold and node.parent is not None:\n                    if all((not c.valid) for c in node.children) or len(node.children) == 0:\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                    try:\n                        edges_list.remove((node.parent, node))\n                    except Exception:\n                        pass\n                for c in node.children[:]:\n                    c.parent = None\n                    try:\n                        edges_list.remove((node, c))\n                    except Exception:\n                        pass\n                node.valid = False\n                nodes_list.remove(node)\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, parent=None, cost=0.0)]\n        tree_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        spatial_start = SpatialHash(self.spatial_hash_cell_size)\n        spatial_goal = SpatialHash(self.spatial_hash_cell_size)\n        spatial_start.insert(tree_start[0])\n        spatial_goal.insert(tree_goal[0])\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            # Alternate trees: even iter start, odd iter goal\n            if it % 2 == 0:\n                tree_curr, tree_other = tree_start, tree_goal\n                spatial_curr, spatial_other = spatial_start, spatial_goal\n                a_is_start_side = True\n            else:\n                tree_curr, tree_other = tree_goal, tree_start\n                spatial_curr, spatial_other = spatial_goal, spatial_start\n                a_is_start_side = False\n\n            # Progressive goal bias increase\n            ratio = min(1.0, it / self.max_iter)\n            goal_sample_rate = self.goal_sample_rate_start + ratio * (self.goal_sample_rate_end - self.goal_sample_rate_start)\n\n            if found_first:\n                # Sample in informed ellipsoid or goal biased\n                if random.random() < goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                # Uniform or goal biased sampling\n                if random.random() < goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_curr = nearest_node(tree_curr, sample)\n            new_pos = steer(nearest_curr.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_curr.position, new_pos):\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node(tree_curr, new_pos, nodes, edges, spatial_curr)\n            if new_node is None:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(tree_curr, new_node, neighbors, edges)\n\n            # Attempt connect trees by nearest node(s)\n            nearest_other = nearest_node(tree_other, new_node.position)\n            connected_other_node = None\n            dist_new_other = dist(new_node.position, nearest_other.position)\n\n            if dist_new_other <= self.step_size and can_connect(new_node, nearest_other):\n                goal_cost = nearest_other.cost + dist_new_other\n                final_node = Node(new_node.position, parent=None, cost=goal_cost)\n                nearest_other.add_child(final_node)\n                tree_other.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                spatial_other.insert(final_node)\n                connected_other_node = final_node\n            else:\n                # Incremental connect attempts in max_connect_steps steps\n                current_connect = nearest_other\n                for _ in range(self.max_connect_steps):\n                    step_pos = steer(current_connect.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current_connect.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node(tree_other, step_pos, nodes, edges, spatial_other)\n                    if other_new is None:\n                        break\n                    rewire(tree_other, other_new, other_neighbors, edges)\n                    current_connect = other_new\n                    if dist(current_connect.position, new_node.position) <= self.step_size and can_connect(current_connect, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current_connect.cost + dist(current_connect.position, new_node.position))\n                        current_connect.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current_connect, final_node))\n                        spatial_other.insert(final_node)\n                        connected_other_node = final_node\n                        break\n\n            if connected_other_node is not None:\n                candidate_path = stitch_paths(new_node, connected_other_node, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n            else:\n                no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n\n            # Prune costly isolated invalid nodes every 150 iterations to keep performance\n            if it % 150 == 0 and found_first:\n                prune_invalid_nodes(nodes, edges, best_cost, margin=5.0)\n\n        if best_path:\n            best_path = shortcut_path(best_path, passes=self.shortcut_passes)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 305.05372,
    "time_improvement": -1026.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1461.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.5017773389816285,
            "num_nodes_avg": 319.9,
            "path_length_avg": 153.84582557769912,
            "smoothness_avg": 0.03982677604489746,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1896.9169620695152,
            "length_improvement": 15.674665157752091,
            "smoothness_improvement": 523.3755303310708,
            "objective_score": -607.0534118745479
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3885685205459595,
            "num_nodes_avg": 440.7,
            "path_length_avg": 230.07782419968254,
            "smoothness_avg": 0.10443432596359528,
            "success_improvement": 0.0,
            "time_improvement": -141.75426032170228,
            "length_improvement": 23.19339985916659,
            "smoothness_improvement": 2587.170428047842,
            "objective_score": -15.674386040771518
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.5529465436935425,
            "num_nodes_avg": 562.3,
            "path_length_avg": 118.9140178766575,
            "smoothness_avg": 0.1078923431655074,
            "success_improvement": 0.0,
            "time_improvement": -1038.0302071219326,
            "length_improvement": 21.022971403361197,
            "smoothness_improvement": 1272.3826412808835,
            "objective_score": -292.43336608815855
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "A hybrid RRT* planner with adaptive informed sampling, adaptive rewiring radius decreasing with tree size, progressive goal bias increase, collision-checked incremental rewiring, and post-planning path shortcutting to improve planning efficiency, path length, and smoothness within a 30-second hard time limit.",
    "planning_mechanism": "The planner begins with uniform sampling, then focuses sampling inside an ellipsoidal informed region after the first solution. A rewiring radius is adaptively shrunk according to the logarithm of the tree size to reduce unnecessary rewiring overhead. Each iteration extends towards sampled points with fixed step size, performs collision checks, updates parent-child connections to minimize costs, incrementally rewires neighbors for better costs, and updates the best path. The goal sampling bias increases progressively to accelerate convergence. After stopping conditions are met (time limit or no improvement), the best path is extracted and shortcut using collision-checked edges to reduce path length and sharp turns, producing a smoother path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # fallback if no valid sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n                # Rotate scaled vector to align with e1 axis (only 2D/3D)\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            rotated = [0.0]*3\n                            for i in range(3):\n                                rotated[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            prob = random.random()\n            if prob < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            gamma = 30.0\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n\n            best_parent = nearest\n            best_cost_through = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            smoothed_path = shortcut_path(raw_path)\n            extracted_path = smoothed_path\n        else:\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 34.67083,
    "time_improvement": -177.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1502.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.044861435890197754,
            "num_nodes_avg": 405.5,
            "path_length_avg": 165.34507182140698,
            "smoothness_avg": 0.05115144220660012,
            "success_improvement": 0.0,
            "time_improvement": -78.53449191975163,
            "length_improvement": 9.371746074358468,
            "smoothness_improvement": 700.6311476678947,
            "objective_score": -14.434144192970933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.21433520317077637,
            "num_nodes_avg": 1242.8,
            "path_length_avg": 227.5324989711747,
            "smoothness_avg": 0.09398146358164036,
            "success_improvement": 0.0,
            "time_improvement": -33.352152229542284,
            "length_improvement": 24.043102683567025,
            "smoothness_improvement": 2318.2107500676884,
            "objective_score": 16.011269691615972
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2518099308013916,
            "num_nodes_avg": 767.5,
            "path_length_avg": 119.32155974896223,
            "smoothness_avg": 0.12477290235705107,
            "success_improvement": 0.0,
            "time_improvement": -418.254994038068,
            "length_improvement": 20.752301496834924,
            "smoothness_improvement": 1487.1021082040495,
            "objective_score": -105.58960677229919
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius shrinks as the tree grows, implementing goal-biased sampling, dynamic rewiring radius based on neighborhood size and dimensionality, early stopping once the goal vicinity is reached, and post-processing shortcut path smoothing to achieve faster convergence, shorter and smoother paths within a 30-second time limit.",
    "planning_mechanism": "The planner incrementally grows a tree from the start by sampling points with goal bias, steering towards samples with fixed step size, and connecting new nodes to the lowest cost neighbor within an adaptively shrinking radius. It rewires neighbors efficiently to locally optimize costs. The search terminates early upon connecting near the goal. Once complete, the path is extracted and shortcut smoothing is applied to reduce unnecessary waypoints and smooth angular deviations, ensuring efficient planning, improved path length, and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.07, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n        def dist(a,b):\n            return math.dist(a,b)\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio*(to_p[i] - from_p[i]) for i in range(dim))\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n        def is_free_edge(p1,p2):\n            res = min(1.0, self.step_size * 0.3)\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=res):\n                return False\n            return True\n        # Adaptive neighbor radius based on RRT* theoretical bounds\n        def adaptive_radius(n):\n            gamma_rrt = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.prod(bounds)) / math.pi )**(1/dim) )\n            r = min(gamma_rrt * (math.log(max(n,1))/max(n,1))**(1/dim), self.step_size*25)\n            return max(r, self.step_size * 2.5)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n        success = False\n        goal_node = None\n        start_time = time.monotonic()\n\n        def nearest(point):\n            best_node = nodes[0]\n            best_dist = dist(point, best_node.position)\n            for node in nodes[1:]:\n                d = dist(point, node.position)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def neighbors_in_radius(point, radius):\n            r2 = radius*radius\n            return [n for n in nodes if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r2]\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = adaptive_radius(len(nodes))\n            neighbs = neighbors_in_radius(new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbd in neighbs:\n                c = nbd.cost + dist(nbd.position, new_pos)\n                if c < min_cost and is_free_edge(nbd.position, new_pos):\n                    min_cost = c\n                    best_parent = nbd\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbd in neighbs:\n                if nbd is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, nbd.position)\n                if c_through_new < nbd.cost and is_free_edge(new_node.position, nbd.position):\n                    if nbd.parent is not None:\n                        try:\n                            edges.remove((nbd.parent, nbd))\n                        except ValueError:\n                            pass\n                    nbd.update_parent(new_node, c_through_new)\n                    edges.append((new_node, nbd))\n\n            # Early stopping if within step size of goal and connection collision-free\n            d_goal = dist(new_node.position, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # If no direct goal node, find node nearest goal to extract best path\n        if success and goal_node:\n            current = goal_node\n        elif nodes:\n            current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n        else:\n            current = None\n\n        extracted_path = []\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Post processing shortcut smoothing\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if is_free_edge(smoothed[-1], path[j]):\n                        next_idx = j\n                        break\n                smoothed.append(path[next_idx])\n                idx = next_idx\n            return smoothed\n\n        if extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 99.58758,
    "time_improvement": -395.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1220.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09126157760620117,
            "num_nodes_avg": 240.5,
            "path_length_avg": 155.57127456474961,
            "smoothness_avg": 0.04369029856020466,
            "success_improvement": 0.0,
            "time_improvement": -263.19255205289164,
            "length_improvement": 14.728919226460851,
            "smoothness_improvement": 583.8480474690534,
            "objective_score": -67.20117384264572
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.6353962898254395,
            "num_nodes_avg": 966.3,
            "path_length_avg": 221.5039879366064,
            "smoothness_avg": 0.08141442519595056,
            "success_improvement": 0.0,
            "time_improvement": -295.3221939905816,
            "length_improvement": 26.055593187974917,
            "smoothness_improvement": 1994.8518007320122,
            "objective_score": -62.98904328072947
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.35322859287261965,
            "num_nodes_avg": 488.4,
            "path_length_avg": 115.15608836840326,
            "smoothness_avg": 0.0929598823193924,
            "success_improvement": 0.0,
            "time_improvement": -626.9867463553704,
            "length_improvement": 23.518809249370157,
            "smoothness_improvement": 1082.4428415179084,
            "objective_score": -168.5725241493995
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced single-tree RRT* planner with dynamically scaled step size and adaptive neighbor radius that decrease as the tree grows, combined with goal-biased sampling and an efficient rewiring strategy. It incorporates incremental cost updates, early stopping upon goal reach, and iterative post-planning path shortcutting and smoothing to improve convergence speed, path length, and smoothness within a 30-second time limit.",
    "planning_mechanism": "The planner samples points biased toward the goal and steers from the nearest tree node using a step size that shrinks as the tree expands, allowing finer path refinement over iterations. It uses an adaptive neighbor radius for rewiring, balancing exploration and exploitation. New nodes connect to the lowest-cost neighbor, and neighbors are rewired to reduce costs. Early stopping occurs upon reaching proximity to the goal with a collision-free edge. After planning completes or time expires, the best path is extracted and iteratively shortcut and smoothed to remove unnecessary waypoints and reduce sharp turns.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, max_step_size=7.5, min_step_size=1.5, goal_sample_rate=0.10, time_limit=30.0):\n        self.max_iter = max_iter\n        self.max_step_size = max_step_size\n        self.min_step_size = min_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p, max_dist):\n            d = dist(from_p, to_p)\n            if d <= max_dist:\n                return to_p\n            ratio = max_dist / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            resolution = 0.3\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def adaptive_step_size(n):\n            frac = min(n / self.max_iter, 1.0)\n            step = self.max_step_size * (1 - frac)**0.75 + self.min_step_size * frac**0.75\n            return max(self.min_step_size, min(self.max_step_size, step))\n\n        def adaptive_radius(n):\n            unit_ball_volume = math.pi if dim == 2 else 4/3*math.pi\n            bound_vol = 1.0\n            for b in bounds:\n                bound_vol *= b\n            gamma_rrt = 2.0 * (1 + 1/dim)**(1/dim) * (bound_vol / unit_ball_volume)**(1/dim)\n            r = gamma_rrt * (math.log(n+1)/(n+1))**(1/dim)\n            return min(max(r, self.min_step_size*2.0), self.max_step_size*10.0)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        def nearest(point):\n            best = nodes[0]\n            best_d = dist(point, best.position)\n            for node in nodes[1:]:\n                d = dist(point, node.position)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def neighbors_in_radius(point, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r2]\n\n        iteration = 0\n        while iteration < self.max_iter:\n            iteration += 1\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            step = adaptive_step_size(len(nodes))\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = adaptive_radius(len(nodes))\n            neighbors = neighbors_in_radius(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                c = nbr.cost + dist(nbr.position, new_pos)\n                if c < min_cost and is_free_edge(nbr.position, new_pos):\n                    min_cost = c\n                    best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if c_through_new < nbr.cost and is_free_edge(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, c_through_new)\n                    edges.append((new_node, nbr))\n\n            d_goal = dist(new_node.position, goal_pos)\n            if d_goal <= step and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # Extract best path\n        if success and goal_node:\n            current = goal_node\n        elif nodes:\n            current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n        else:\n            current = None\n\n        extracted_path: List[Tuple[float, ...]] = []\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Iterative shortcut and smoothing\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(smoothed[-1], path[j]):\n                        next_idx = j\n                        break\n                smoothed.append(path[next_idx])\n                idx = next_idx\n            return smoothed\n\n        def smooth_path(path, iterations=3):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                new_path = [path[0]]\n                for i in range(1, len(path) - 1):\n                    prev_pt = new_path[-1]\n                    curr_pt = path[i]\n                    next_pt = path[i + 1]\n                    # Weighted average to smooth around curr_pt\n                    smoothed_pt = tuple((prev_pt[d] + 2*curr_pt[d] + next_pt[d]) / 4 for d in range(dim))\n                    if is_free_edge(prev_pt, smoothed_pt) and is_free_edge(smoothed_pt, next_pt):\n                        new_path.append(smoothed_pt)\n                    else:\n                        new_path.append(curr_pt)\n                new_path.append(path[-1])\n                path = new_path\n            return path\n\n        if extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n            extracted_path = smooth_path(extracted_path, iterations=3)\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 355.45541,
    "time_improvement": -1022.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1250.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.22162554264068604,
            "num_nodes_avg": 247.8,
            "path_length_avg": 163.8608738269864,
            "smoothness_avg": 0.0531448997078527,
            "success_improvement": 0.0,
            "time_improvement": -782.0003833278934,
            "length_improvement": 10.185258513722637,
            "smoothness_improvement": 731.8330864247473,
            "objective_score": -224.82979445801067
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.690515398979187,
            "num_nodes_avg": 766.2,
            "path_length_avg": 224.39123000114273,
            "smoothness_avg": 0.07990332104594207,
            "success_improvement": 0.0,
            "time_improvement": -329.61544925565727,
            "length_improvement": 25.091748682177727,
            "smoothness_improvement": 1955.9700025479679,
            "objective_score": -74.04973555465071
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.9987703561782837,
            "num_nodes_avg": 766.7,
            "path_length_avg": 115.72055339414548,
            "smoothness_avg": 0.09125291601919892,
            "success_improvement": -40.0,
            "time_improvement": -1955.5890045291055,
            "length_improvement": 23.14391845620828,
            "smoothness_improvement": 1060.7303561745932,
            "objective_score": -767.4866985041336
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "An efficient unidirectional RRT*-inspired planner with fixed step size, goal bias sampling, fixed neighborhood radius for rewiring, and downstream cost propagation for consistent path cost updates. The planner balances exploration with incremental improvements and early stopping once a feasible path is found, ensuring efficient search and improved path quality without overcomplexity.",
    "planning_mechanism": "The algorithm samples towards the goal with some randomness, extends the tree towards random samples using fixed step sizes, finds neighbors within a fixed radius for optimal parent selection, rewires neighbors if improved costs are found with proper cost propagation, and stops as soon as a collision-free direct connection to the goal is made. It maintains valid node and edge checks, respects map bounds and obstacle collisions, and returns the best path found within 30 seconds.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent and self.cost == new_cost:\n            return\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\n        self._propagate_cost()\n    def _propagate_cost(self):\n        from math import dist\n        for c in self.children:\n            new_cost = self.cost + dist(self.position, c.position)\n            if new_cost < c.cost:\n                c.cost = new_cost\n                c._propagate_cost()\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                q = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(q, obstacles, is_3d):\n                    return False\n            return True\n\n        nodes = []\n        edges = []\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        def nearest(p):\n            best_node = nodes[0]\n            best_distance = dist(p, best_node.position)\n            for n in nodes[1:]:\n                dcur = dist(p, n.position)\n                if dcur < best_distance:\n                    best_distance = dcur\n                    best_node = n\n            return best_node\n\n        def neighbors(p):\n            return [n for n in nodes if dist(p, n.position) <= self.neighbor_radius]\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = neighbors(new_pos)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                cost_through_n = n.cost + dist(n.position, new_pos)\n                if cost_through_n < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_through_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in near_nodes:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal_pos) <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal_pos))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            if nodes:\n                current = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            else:\n                current = None\n\n        extracted_path = []\n        while current:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": 9.55641,
    "time_improvement": -71.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 174.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.043404889106750486,
            "num_nodes_avg": 294.2,
            "path_length_avg": 161.7965368439174,
            "smoothness_avg": 0.015535847402791046,
            "success_improvement": 0.0,
            "time_improvement": -72.73789101342784,
            "length_improvement": 11.31675432565555,
            "smoothness_improvement": 143.16974848628857,
            "objective_score": -14.315465966203579
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.20979743003845214,
            "num_nodes_avg": 1015.9,
            "path_length_avg": 229.36549657733866,
            "smoothness_avg": 0.011247440646146224,
            "success_improvement": 0.0,
            "time_improvement": -30.52890245734931,
            "length_improvement": 23.431195322718757,
            "smoothness_improvement": 189.40474902938664,
            "objective_score": 5.847070201573396
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10159854888916016,
            "num_nodes_avg": 398.3,
            "path_length_avg": 121.49541818323023,
            "smoothness_avg": 0.022714427647909555,
            "success_improvement": 0.0,
            "time_improvement": -109.10198093163162,
            "length_improvement": 19.30852823280892,
            "smoothness_improvement": 188.9258430767629,
            "objective_score": -20.200848124420315
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT* planner with fixed step size, goal-biased sampling, fixed-radius rewiring for local path cost improvements, and early stopping upon connecting to the goal. The planner ensures efficient exploration by pruning invalid samples and edges, maintains coherent node and edge relationships, and incrementally builds a near-optimal path within a 30-second computation budget.",
    "planning_mechanism": "The planner samples randomly with a fixed probability towards the goal, extends the tree by steering at a fixed step size, rewires neighbors within a fixed radius if a better cost can be achieved, and terminates as soon as a valid connection to the goal is made. It performs necessary collision checks for nodes and edges before adding them and returns the shortest feasible path found within the time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% goal bias\n        self.neighbor_radius = 15.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        goal_node = None\n        success = False\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_free_node(sample):\n                        break\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Find neighbors within fixed radius (no adaptive radius for simplicity)\n            neighbors = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Select best parent minimizing cost + cost from parent to new_pos\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Early stopping if goal reachable within step_size\n            d_goal = dist(new_node.position, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # Extract path\n        path = []\n        if success:\n            curr = goal_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n        else:\n            # Return path to closest node near goal if no success\n            nearest_goal_node = min(nodes, key=lambda n: dist(n.position, goal_pos)) if nodes else None\n            if nearest_goal_node is not None:\n                curr = nearest_goal_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.28033,
    "time_improvement": -91.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 294.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.061039304733276366,
            "num_nodes_avg": 328.6,
            "path_length_avg": 162.74273188203128,
            "smoothness_avg": 0.02234733828496275,
            "success_improvement": 0.0,
            "time_improvement": -142.9173529880599,
            "length_improvement": 10.798129831845484,
            "smoothness_improvement": 249.78437218147076,
            "objective_score": -35.147406136403326
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.18186416625976562,
            "num_nodes_avg": 864.7,
            "path_length_avg": 225.07833401601823,
            "smoothness_avg": 0.016929538517514164,
            "success_improvement": 0.0,
            "time_improvement": -13.149765532672417,
            "length_improvement": 24.862373584819792,
            "smoothness_improvement": 335.60921990935435,
            "objective_score": 12.650540590636922
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10586245059967041,
            "num_nodes_avg": 450.5,
            "path_length_avg": 116.60796858638871,
            "smoothness_avg": 0.031233332580941863,
            "success_improvement": 0.0,
            "time_improvement": -117.87760129150658,
            "length_improvement": 22.554539539690797,
            "smoothness_improvement": 297.2856850247802,
            "objective_score": -20.344128238513594
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements a unidirectional informed RRT* planner with adaptive neighbor radius, goal-biased and informed ellipsoidal sampling after first solution, dynamic rewiring, and path shortcutting smoothing. It grows a single tree from the start toward the goal, rewires locally for optimal connections, improves success rate and path quality by focusing sampling dynamically in the subset of space likely to contain better paths, and accelerates planning by early termination and caching collision checks.",
    "planning_mechanism": "The planner starts from the start node and samples points in free space with a small goal bias. After the first path is found, it switches to informed sampling inside an ellipsoid shaped by the best path cost to focus the search. Each sampled point is connected by steering from the nearest node, then neighbors inside an adaptive radius are considered to select a minimal cost parent and to rewire for lower cost. The algorithm shortcuts and smooths the current best path periodically. Planning stops early once time limit is reached or no improvement is found after many iterations.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=7.0, goal_bias: float=0.1, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n        self.resolution = 1.0  # Collision checking resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        # Data structures\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_node = Node(start_pos, cost=0.0)\n        nodes.append(start_node)\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if success and best_cost < float('inf'):\n                # Informed sampling inside ellipse after first solution\n                return self._informed_sample(start_pos, goal_pos, best_cost, bounds, obstacles, is_3d)\n            else:\n                if random.random() < self.goal_bias:\n                    return goal_pos\n                for _ in range(50):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                return start_pos\n\n        def nearest_node(tree_nodes, point):\n            # Linear nearest; small optimization: could implement kd-tree but disallowed imports\n            min_n = None\n            min_d = float('inf')\n            for n in tree_nodes:\n                dd = dist(n.position, point)\n                if dd < min_d:\n                    min_d = dd\n                    min_n = n\n            return min_n\n\n        def near_nodes(tree_nodes, point, radius):\n            # Return nodes within radius\n            ret = []\n            r_sq = radius * radius\n            for n in tree_nodes:\n                dd = dist(n.position, point)\n                if dd <= radius:\n                    ret.append(n)\n            return ret\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            # Attempt to shortcut via direct connections, removing intermediate points\n            if len(path) <= 2:\n                return path[:]\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for test_idx in range(len(path)-1, idx, -1):\n                    if not self._is_edge_in_obstacle(path[idx], path[test_idx], obstacles, is_3d, self.resolution):\n                        next_idx = test_idx\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        iteration = 0\n        no_improve_iters = 0\n        MAX_NO_IMPROVE = 300\n\n        while iteration < self.max_iter:\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit_sec:\n                break\n\n            rnd_point = sample_free()\n            nearest = nearest_node(nodes, rnd_point)\n            new_pos = steer(nearest.position, rnd_point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iteration += 1\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                iteration += 1\n                continue\n\n            # Adaptive radius: gamma * (log(n)/n)^{1/d} (theoretical for RRT*)\n            n = len(nodes) + 1\n            gamma = 30.0\n            radius = min(self.step_size * 5.0, gamma * (math.log(n) / n) ** (1.0 / dim))\n\n            neighbors = near_nodes(nodes, new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            min_parent = nearest\n            for nb in neighbors:\n                if nb == nearest:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, self.resolution):\n                    continue\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to the new node if improves cost\n            for nb in neighbors:\n                if nb == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, self.resolution):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new + 1e-10 < nb.cost:\n                    # Rewire nb\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                            nb.parent.remove_child(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n            # Check if new_node can connect to goal\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d, self.resolution):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    path = goal_node.path_to_root()\n                    path_cost = goal_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(path)\n                        success = True\n                        no_improve_iters = 0\n            if success:\n                no_improve_iters +=1\n                # Periodically shortcut to smooth (every 50 iters)\n                if no_improve_iters % 50 == 0:\n                    best_path = shortcut_path(best_path)\n\n                # Early stop criteria: no improvement for many iterations\n                if no_improve_iters > MAX_NO_IMPROVE:\n                    break\n\n            iteration += 1\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _informed_sample(self, start, goal, cost_bound, bounds, obstacles, is_3d):\n        # Ellipsoid sampling strategy\n        dim = len(bounds)\n        c_best = cost_bound\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return goal  # start == goal\n\n        # Ellipse parameters\n        center = tuple((s+g)/2 for s,g in zip(start, goal))\n\n        # Unit vector from start to goal\n        e_vec = tuple((g - s)/c_min for s,g in zip(start, goal))\n\n        # Rotation matrix to align with x-axis\n        # For dim=2 or 3, build rotation matrix that rotates e_vec -> [1,0,(0)]\n        # We'll do a simple construct for 2D or 3D\n\n        def rotation_matrix(vec):\n            if dim == 2:\n                # angle between e_vec and x-axis\n                a = math.atan2(vec[1], vec[0])\n                cos_a = math.cos(-a)\n                sin_a = math.sin(-a)\n                return [[cos_a, -sin_a],[sin_a, cos_a]]\n            elif dim ==3:\n                # Rodrigues rotation formula to rotate e_vec to (1,0,0)\n                vx, vy, vz = vec\n                # Target vector is (1,0,0)\n                if vx == 1.0 and vy == 0.0 and vz == 0.0:\n                    # Identity\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                # Cross product u x v\n                ux, uy, uz = (0,0,0)\n                u = (0,0,0)\n                # For brevity fallback: identity\n                return [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                return None # not supported\n\n        R = rotation_matrix(e_vec)\n\n        # Sample random point in unit ball\n        def sample_unit_ball():\n            while True:\n                if dim == 2:\n                    x = random.uniform(-1,1)\n                    y = random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        return (x,y)\n                elif dim ==3:\n                    x = random.uniform(-1,1)\n                    y = random.uniform(-1,1)\n                    z = random.uniform(-1,1)\n                    if x*x + y*y + z*z <=1:\n                        return (x,y,z)\n                else:\n                    return tuple(random.uniform(-1,1) for _ in range(dim))\n\n        # Scaling matrix diag([c_best/2, sqrt(c_best^2 - c_min^2)/2, ...])\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0)) / 2.0\n\n        # For 2D ellipse radii: [r1, r2]\n        # For 3D: [r1, r2, r2]\n\n        # Compose point\n        while True:\n            x_ball = sample_unit_ball()\n            if dim == 2:\n                # scale\n                sample_ellipsoid = (\n                    r1 * x_ball[0],\n                    r2 * x_ball[1]\n                )\n                # rotate\n                rx = R[0][0]*sample_ellipsoid[0] + R[0][1]*sample_ellipsoid[1]\n                ry = R[1][0]*sample_ellipsoid[0] + R[1][1]*sample_ellipsoid[1]\n                final = (center[0] + rx, center[1] + ry)\n                # clamp inside bounds and check collision\n                final = tuple(min(max(final[d],0.0), bounds[d]) for d in range(2))\n            elif dim == 3:\n                # fallback: uniform random sampling since full rotation omitted\n                final = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                final = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            if not self._is_in_obstacle(final, obstacles, is_3d):\n                return final",
    "objective": 28.53318,
    "time_improvement": -155.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1983.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09087915420532226,
            "num_nodes_avg": 519.4,
            "path_length_avg": 170.6467674700531,
            "smoothness_avg": 0.0550208332835064,
            "success_improvement": 0.0,
            "time_improvement": -261.6706264564562,
            "length_improvement": 6.465802678591877,
            "smoothness_improvement": 761.1955205386884,
            "objective_score": -70.81572872708828
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.17486357688903809,
            "num_nodes_avg": 999.9,
            "path_length_avg": 242.23968785083002,
            "smoothness_avg": 0.12851223067259493,
            "success_improvement": 0.0,
            "time_improvement": -8.794234356965589,
            "length_improvement": 19.133419712577957,
            "smoothness_improvement": 3206.712258824172,
            "objective_score": 24.875342814577955
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.14336936473846434,
            "num_nodes_avg": 575.7,
            "path_length_avg": 128.08931942575154,
            "smoothness_avg": 0.16359728947200097,
            "success_improvement": 0.0,
            "time_improvement": -195.07132237122963,
            "length_improvement": 14.929172995361824,
            "smoothness_improvement": 1980.9454465880506,
            "objective_score": -39.65916568121154
        }
    ],
    "success_rate": 1.0
}
