[
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
          "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -31.88223,
          "time_improvement": 70.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 318.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner utilizing informed ellipsoidal sampling after first solution, adaptive neighbor radius rewiring, and incremental tree connection with early stopping. It grows trees from both start and goal, rewires nodes for optimal costs within a shrinking radius, and focuses sampling within an ellipsoid around the current best path to improve efficiency. Finally, a sophisticated shortcutting smoothing post-process removes unnecessary waypoints to yield shorter, smoother paths within a 30-second limit.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling points with goal biasing and switching to ellipsoidal informed samples once a path is found. Each new node connects via minimum-cost parent among neighbors within an adaptive radius, followed by rewiring neighbors for cost improvement. Tree merging attempts are made after each extension. Early stopping occurs immediately when a feasible connection forms. The final path is extracted by concatenating tree paths and shortcutting to produce smooth trajectories with improved length and reduced computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            dist_ab = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.5)\n            steps = max(1,int(dist_ab/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling around foci start and goal with cost c_best\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best/2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    # rotate coords to align with e1\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    # Rodrigues rotation from x-axis to e1\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i]+rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree_nodes, pt):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, new_pos)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            # Check neighbors for better parent\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                if nbr.cost + dist(nbr.position, new_pos) + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = nbr.cost + dist(nbr.position, new_pos)\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n\n        def merge_trees(node_in_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_in_a.position)\n            d = dist(node_in_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_in_a.position, nearest_b.position):\n                return None\n            total_cost = node_in_a.cost + d + nearest_b.cost\n            path_a = node_in_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling: goal bias and informed sampling after first solution\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a = tree_start\n                tree_b = tree_goal\n            else:\n                tree_a = tree_goal\n                tree_b = tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            # Attempt merging trees\n            merge_res = merge_trees(new_node, tree_b)\n            if merge_res is not None:\n                path_candidate, cost_candidate = merge_res\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stopping immediately on connection\n                    break\n\n        # If no solution, try heuristic fallback: connect closest start tree node to goal if possible\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = found_solution\n        else:\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -28.30351,
          "time_improvement": 33.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1540.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020982789993286132,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 162.3763992712687,
                    "smoothness_avg": 0.04901655517737587,
                    "success_improvement": 0.0,
                    "time_improvement": 16.49505469064301,
                    "length_improvement": 10.998922540716148,
                    "smoothness_improvement": 667.2155296791497,
                    "objective_score": 14.88394758001834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034110093116760255,
                    "num_nodes_avg": 312.1,
                    "path_length_avg": 232.1285408403566,
                    "smoothness_avg": 0.101967152153144,
                    "success_improvement": 0.0,
                    "time_improvement": 78.77784767700604,
                    "length_improvement": 22.508811617903905,
                    "smoothness_improvement": 2523.688268871463,
                    "objective_score": 49.75708261820147
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04627988338470459,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 121.2062870795032,
                    "smoothness_avg": 0.12018983540199198,
                    "success_improvement": 0.0,
                    "time_improvement": 4.7504575721442865,
                    "length_improvement": 19.50055534496077,
                    "smoothness_improvement": 1428.805834822511,
                    "objective_score": 20.2694996527323
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.893579481866173,
          "time_improvement": 56.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 178.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0102372407913208,
                    "num_nodes_avg": 117.5,
                    "path_length_avg": 167.09773058241916,
                    "smoothness_avg": 0.01743061917619911,
                    "success_improvement": 0.0,
                    "time_improvement": 59.25898163821438,
                    "length_improvement": 8.411086034792367,
                    "smoothness_improvement": 172.82704130288656,
                    "objective_score": 23.688481318854166
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02068014144897461,
                    "num_nodes_avg": 270.5,
                    "path_length_avg": 254.91986206815108,
                    "smoothness_avg": 0.010869990893363076,
                    "success_improvement": 0.0,
                    "time_improvement": 87.1335117617854,
                    "length_improvement": 14.900412580258132,
                    "smoothness_improvement": 179.6926950242082,
                    "objective_score": 35.978764551811544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03835470676422119,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 131.0348919324295,
                    "smoothness_avg": 0.02219113712511561,
                    "success_improvement": 0.0,
                    "time_improvement": 21.061420166541545,
                    "length_improvement": 12.97286398951632,
                    "smoothness_improvement": 182.26962625211246,
                    "objective_score": 15.013492574932817
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -24.394856704415727,
          "time_improvement": 84.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037204265594482423,
                    "num_nodes_avg": 58.5,
                    "path_length_avg": 184.8763674372614,
                    "smoothness_avg": 0.010656061011327317,
                    "success_improvement": 0.0,
                    "time_improvement": 85.19386523557586,
                    "length_improvement": -1.3336665458757502,
                    "smoothness_improvement": 66.79049483412726,
                    "objective_score": 25.091912117317943
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007217264175415039,
                    "num_nodes_avg": 195.5,
                    "path_length_avg": 293.476072886139,
                    "smoothness_avg": 0.006583639266204931,
                    "success_improvement": 0.0,
                    "time_improvement": 95.50966105071444,
                    "length_improvement": 2.0292396302187403,
                    "smoothness_improvement": 69.4017803231431,
                    "objective_score": 30.217450994961293
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014179682731628418,
                    "num_nodes_avg": 216.3,
                    "path_length_avg": 159.7621915423607,
                    "smoothness_avg": 0.012486187243912596,
                    "success_improvement": 0.0,
                    "time_improvement": 70.81651479687723,
                    "length_improvement": -6.106440564392849,
                    "smoothness_improvement": 58.82338010809535,
                    "objective_score": 17.875207000967936
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -23.298298969701534,
          "time_improvement": 51.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 174.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016666102409362792,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 171.93676993008617,
                    "smoothness_avg": 0.017258852621246313,
                    "success_improvement": 0.0,
                    "time_improvement": 33.67412195140466,
                    "length_improvement": 5.758731888850669,
                    "smoothness_improvement": 170.1385217208312,
                    "objective_score": 14.408168327335954
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026815319061279298,
                    "num_nodes_avg": 207.7,
                    "path_length_avg": 254.55172472875432,
                    "smoothness_avg": 0.010846570009997185,
                    "success_improvement": 0.0,
                    "time_improvement": 83.31641066589374,
                    "length_improvement": 15.023307420394557,
                    "smoothness_improvement": 179.09005882582343,
                    "objective_score": 34.90435794613397
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0310056209564209,
                    "num_nodes_avg": 214.5,
                    "path_length_avg": 128.32906870441866,
                    "smoothness_avg": 0.02145278500029813,
                    "success_improvement": 0.0,
                    "time_improvement": 36.186718876507044,
                    "length_improvement": 14.769942940104954,
                    "smoothness_improvement": 172.8778417239189,
                    "objective_score": 20.58237063563468
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.256651771997145,
          "time_improvement": 85.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005163788795471191,
                    "num_nodes_avg": 88.6,
                    "path_length_avg": 194.6296584579342,
                    "smoothness_avg": 0.01167543363104651,
                    "success_improvement": 0.0,
                    "time_improvement": 79.44973470673519,
                    "length_improvement": -6.679599905092896,
                    "smoothness_improvement": 82.74588993580629,
                    "objective_score": 20.24088991864385
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014127516746520996,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 298.3796473209629,
                    "smoothness_avg": 0.007304556076322401,
                    "success_improvement": 0.0,
                    "time_improvement": 91.21033439240306,
                    "length_improvement": 0.3922853423102244,
                    "smoothness_improvement": 87.95148910285546,
                    "objective_score": 28.03822896862133
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007713985443115234,
                    "num_nodes_avg": 141.8,
                    "path_length_avg": 161.00482297708567,
                    "smoothness_avg": 0.014351820764112542,
                    "success_improvement": 0.0,
                    "time_improvement": 84.12369414062309,
                    "length_improvement": -6.931737195586904,
                    "smoothness_improvement": 82.55410077829661,
                    "objective_score": 21.490836428726265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "\\frac{\\log n",
          "planning_mechanism": "= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.shortcut_attempts = 40  # Reduced shortcut attempts for quick smoothing\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []  # nodes excluding roots\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                # Uniform random free sample\n                while True:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n\n            for tree_a, tree_b in trees:\n                # Extend tree_a toward sample\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                # Skip invalid positions or edges\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire neighbors within adaptive radius\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to the opposite tree to shortcut search\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n\n                        # Early stopping immediately when connection found\n                        # Proceed to final path shortcutting before returning\n                        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n                        return PlannerResult(success=True, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n        # If no solution, try to return partial best path from closest node in start tree to start pos\n        if not success:\n            closest_node = min(all_nodes + start_tree, key=lambda n: dist(n.position, goal_pos))\n            best_path = []\n            cur = closest_node\n            while cur:\n                best_path.append(cur.position)\n                cur = cur.parent\n            best_path.reverse()\n\n        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n\n        return PlannerResult(success=success, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d: bool, dim: int, attempts: int = 40) -> List[Tuple[float, ...]]:\n        \"\"\"Path shortcutting by attempting to replace 2+ node segments with a single edge.\"\"\"\n        if len(path) < 3:\n            return path\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(f_pos, t_pos, resolution=1.0):\n            distance = math.dist(f_pos, t_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[d] + (t_pos[d] - f_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        new_path = list(path)\n        for _ in range(attempts):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                # Shortcut by removing intermediate nodes\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path",
          "objective": -21.73093,
          "time_improvement": 32.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 949.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018609023094177245,
                    "num_nodes_avg": 265.4,
                    "path_length_avg": 174.46813050769455,
                    "smoothness_avg": 0.02052379402865142,
                    "success_improvement": 0.0,
                    "time_improvement": 25.941904949863755,
                    "length_improvement": 4.371253044288279,
                    "smoothness_improvement": 221.24194468046562,
                    "objective_score": 11.511533034934422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030954933166503905,
                    "num_nodes_avg": 599.4,
                    "path_length_avg": 246.56024222272634,
                    "smoothness_avg": 0.07105362816383905,
                    "success_improvement": 0.0,
                    "time_improvement": 80.74088204453314,
                    "length_improvement": 17.691094302976712,
                    "smoothness_improvement": 1728.2610305153203,
                    "objective_score": 43.47822634772257
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.053578948974609374,
                    "num_nodes_avg": 618.0,
                    "path_length_avg": 128.47415638420375,
                    "smoothness_avg": 0.07830938655910784,
                    "success_improvement": 0.0,
                    "time_improvement": -10.27189353903225,
                    "length_improvement": 14.67358261152458,
                    "smoothness_improvement": 896.0896168341985,
                    "objective_score": 10.203029589376065
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bi-directional RRT* planner combining adaptive dynamic-radius rewiring, informed ellipsoidal sampling after first solution, and periodic pruning for improved efficiency and path quality. It alternates growing trees from start and goal, uses tree balancing with rewiring within adaptively shrinking radii guided by node density, employs ellipsoidal informed sampling conditioned on best path cost, and prunes disconnected or suboptimal nodes regularly to maintain a compact and efficient search structure. Early stopping occurs upon connecting trees or time limit, followed by robust shortcutting smoothing to deliver a smooth, short path within a 30-second limit.",
          "planning_mechanism": "The planner incrementally extends two trees from start and goal, alternating expansions while biasing sampling with goal probability initially and switching to ellipsoidal informed sampling after a first feasible path is found. Each new node connects via minimal-cost parent among neighbors within an adaptive radius proportional to tree size and dimension, followed by rewiring neighbors locally to reduce cost. Periodic pruning removes invalid or isolated nodes to limit tree complexity. When the two trees connect within step size and obstacle-free, the algorithm stops early. A shortcutting post-process prunes unnecessary waypoints to improve path smoothness and length. Timing is strictly enforced with immediate return if the 30-second time limit is exceeded.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n            \n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1, gamma_rrt_star=30.0, max_neighbor_radius=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.prune_interval = 500  # prune every 500 iterations\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n        found_solution = False\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist_ = math.dist(p1, p2)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_dist):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= max_dist:\n                return to_pos\n            ratio = max_dist / dist_\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(c * c for c in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [c / k_norm for c in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest(nodes_list, pt):\n            return min(nodes_list, key=lambda n: math.dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            return [n for n in nodes_list if math.dist(n.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos):\n            nearest_node = nearest(tree_nodes, new_pos)\n            base_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            gamma = self.gamma_rrt_star\n            n = len(tree_nodes)\n            radius = min(self.max_neighbor_radius,\n                         max(self.step_size * 2.0, gamma * ((math.log(n) / n) ** (1 / dim))))\n            nearlist = near_nodes(tree_nodes, new_pos, radius)\n            best_parent = nearest_node\n            best_cost = base_cost\n            for nb in nearlist:\n                if nb is nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cost_candidate = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_candidate + self.improve_tol < best_cost:\n                        best_parent = nb\n                        best_cost = cost_candidate\n            if is_edge_in_obstacle(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            new_node.cost = best_cost\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, nearlist, tree_nodes)\n            return new_node\n\n        def rewire(new_node, neighbors, tree_nodes):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if alt_cost + self.improve_tol < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n        def merge_trees(node, tree_other):\n            nearest_node_other = nearest(tree_other, node.position)\n            dist_ = math.dist(node.position, nearest_node_other.position)\n            if dist_ > self.step_size:\n                return None\n            if is_edge_in_obstacle(node.position, nearest_node_other.position):\n                return None\n            path_start = node.path_from_root()\n            path_goal = nearest_node_other.path_from_root()\n            # Remove duplicated meeting point\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            total_cost = node.cost + dist_ + nearest_node_other.cost\n            return full_path, total_cost\n\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        def prune_invalid_nodes(tree_nodes):\n            valid_nodes = []\n            for node in tree_nodes:\n                if not node.valid or node.parent is None and node is not start_root and node is not goal_root:\n                    # Disconnect node children recursively\n                    def invalidate_subtree(nd):\n                        nd.valid = False\n                        for c in nd.children[:]:\n                            invalidate_subtree(c)\n                        nd.children = []\n                    invalidate_subtree(node)\n                else:\n                    valid_nodes.append(node)\n            return valid_nodes\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Sampling\n            c_best = best_cost if found_solution else float('inf')\n            c_min = math.dist(start_pos, goal_pos)\n            sample = uniform_sample() if not found_solution else informed_sample(c_best, c_min)\n            \n            # Goal bias for faster convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n\n            # Alternate tree expansion\n            tree_from, tree_to = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n\n            # Extend tree_from toward sample\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_from, new_pos)\n            if new_node is None:\n                continue\n\n            merge_result = merge_trees(new_node, tree_to)\n            if merge_result is not None:\n                path_candidate, cost_candidate = merge_result\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    found_solution = True\n                    # Early stop upon first connection\n                    break\n\n            # Periodic pruning every prune_interval iterations\n            if it > 0 and it % self.prune_interval == 0:\n                tree_start = prune_invalid_nodes(tree_start)\n                tree_goal = prune_invalid_nodes(tree_goal)\n                # Also prune from nodes list:\n                nodes = [n for n in nodes if n.valid]\n\n        if not success and tree_start:\n            # Try direct connection from closest start tree node to goal if feasible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root() + [goal_pos]\n                candidate_cost = nearest_goal_node.cost + math.dist(nearest_goal_node.position, goal_pos)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_path = candidate_path\n                    best_cost = candidate_cost\n                    success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -20.67738,
          "time_improvement": 9.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03827791213989258,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 160.6466233769438,
                    "smoothness_avg": 0.04725787452949247,
                    "success_improvement": 0.0,
                    "time_improvement": -52.33412529129126,
                    "length_improvement": 11.947040118448713,
                    "smoothness_improvement": 639.6883585036219,
                    "objective_score": -5.333571723800039
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05289309024810791,
                    "num_nodes_avg": 298.2,
                    "path_length_avg": 232.68903229137203,
                    "smoothness_avg": 0.09180706801300251,
                    "success_improvement": 0.0,
                    "time_improvement": 67.0916988049012,
                    "length_improvement": 22.32170343870305,
                    "smoothness_improvement": 2262.261985932813,
                    "objective_score": 44.83184163435625
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042598557472229,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 121.23262798955986,
                    "smoothness_avg": 0.12021932172282064,
                    "success_improvement": 0.0,
                    "time_improvement": 12.327067171100092,
                    "length_improvement": 19.48306096672048,
                    "smoothness_improvement": 1429.180898646998,
                    "objective_score": 22.533861224597302
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bi-directional RRT* planner with adaptive neighbor radius, goal bias sampling, early stopping, and integrated path shortcutting for improved planning speed, path length, and smoothness. The planner alternates tree expansions between start and goal, rewires neighbors dynamically using a radius shrinking with the number of nodes, and stops immediately upon connecting both trees. Post-processing shortcutting removes unnecessary waypoints to smooth and shorten the final path. Efficient collision checking and incremental best path updates ensure robustness and quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the goal and within map boundaries. Each new node connects to its best parent among neighbors inside an adaptive radius, rewiring neighbors that can be improved by the new node. After adding a node, an attempt is made to connect the other tree within step size increments. When a connection is found, planning stops early, and a combined path is extracted and shortcut. This method uses dynamic radii to limit neighbor searching overhead and improves path quality with minimal wasted exploration.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=30.0, max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree_nodes[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree_nodes, new_pos)\n            neighbors = near_nodes(tree_nodes, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges)\n            return new_node\n\n        def rewire(pivot: Node, neighbors: List[Node], edges: List[Tuple[Node,Node]]) -> None:\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        def merge_trees(node_start: Node, tree_goal: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            dist_goal = math.dist(node_start.position, nearest_goal_node.position)\n            if dist_goal > self.step_size or not is_free_edge(node_start.position, nearest_goal_node.position):\n                return None\n            # connect goal node parent chain if needed\n            # Create a connecting node at goal node's position attached to start tree node\n            connecting_cost = node_start.cost + dist_goal + nearest_goal_node.cost\n            path_start = node_start.path_from_root()\n            path_goal = nearest_goal_node.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            return full_path, connecting_cost\n\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            # Alternate tree expansions\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                path_candidate, cost_candidate = merged\n                if cost_candidate < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    break  # Early stopping\n\n        if not success:\n            # Try connecting start tree node nearest goal to form path if possible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                path_candidate = nearest_goal_node.path_from_root() + [goal_pos]\n                best_path = path_candidate\n                success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.2797,
          "time_improvement": -14.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1551.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.037523436546325686,
                    "num_nodes_avg": 119.5,
                    "path_length_avg": 159.4209224416483,
                    "smoothness_avg": 0.0499161308278024,
                    "success_improvement": 0.0,
                    "time_improvement": -49.33154826515664,
                    "length_improvement": 12.618866223558411,
                    "smoothness_improvement": 681.295842068116,
                    "objective_score": -3.821665535071364
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06830766201019287,
                    "num_nodes_avg": 321.3,
                    "path_length_avg": 231.84012711924962,
                    "smoothness_avg": 0.09872843875579924,
                    "success_improvement": 0.0,
                    "time_improvement": 57.50127086883818,
                    "length_improvement": 22.60509241953809,
                    "smoothness_improvement": 2440.353840406813,
                    "objective_score": 43.01520591440838
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07245962619781494,
                    "num_nodes_avg": 278.3,
                    "path_length_avg": 123.63111074361593,
                    "smoothness_avg": 0.12815608053053237,
                    "success_improvement": 0.0,
                    "time_improvement": -49.13058839116163,
                    "length_improvement": 17.890102924951922,
                    "smoothness_improvement": 1530.135884850495,
                    "objective_score": 3.645564661875139
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
          "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -13.97956,
          "time_improvement": -17.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1470.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052588915824890135,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 153.88454915168901,
                    "smoothness_avg": 0.04347023177026047,
                    "success_improvement": 0.0,
                    "time_improvement": -109.28744658079108,
                    "length_improvement": 15.653440153233934,
                    "smoothness_improvement": 580.4035243237437,
                    "objective_score": -20.492152260678246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048712754249572755,
                    "num_nodes_avg": 358.8,
                    "path_length_avg": 233.0599917365158,
                    "smoothness_avg": 0.10226409696877743,
                    "success_improvement": 0.0,
                    "time_improvement": 69.69256321821518,
                    "length_improvement": 22.197866498438458,
                    "smoothness_improvement": 2531.328872858417,
                    "objective_score": 46.883133228819716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.054259729385375974,
                    "num_nodes_avg": 387.5,
                    "path_length_avg": 119.05752821578226,
                    "smoothness_avg": 0.10995381497824393,
                    "success_improvement": 0.0,
                    "time_improvement": -11.673021153817839,
                    "length_improvement": 20.927658669342527,
                    "smoothness_improvement": 1298.6044105768708,
                    "objective_score": 15.547710908344518
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An advanced unidirectional RRT* variant with integrated informed sampling after initial solution, adaptive neighbor radius neighborhood search, and efficient incremental rewiring supported by a basic spatial grid for fast neighbor queries. The planner employs dynamic goal biasing, early stopping upon acceptable solution discovery or time limit, and post-processing path shortcutting to significantly improve planning time, path length, and smoothness.",
          "planning_mechanism": "The planner grows a tree from the start position by sampling either uniformly or within an ellipsoidal informed subset after first solution found, extending the nearest node by a limited step. It then efficiently finds neighbors within an adaptive radius using a grid-based spatial hashing structure for faster rewiring. Nodes are connected to the best parent minimizing cost and neighbors are rewired to improve paths. Early termination is triggered when a sufficiently good path is found or the time limit expires. Finally, shortcutting post-processing removes unnecessary waypoints for smoother paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0, goal_sample_rate: float = 0.15, max_neighbor_radius: float = 20.0, min_neighbor_radius: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Distance metric\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        # Clamp point inside bounds\n        def clamp_point(p):\n            return tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoid region after first solution found\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix using Gram-Schmidt for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    # 2D rotate so that x-axis aligns with a\n                    cos_theta, sin_theta = a\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    # find orthogonal vector\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = [temp[i] - sum(x_axis[j]*temp[j] for j in range(3))*x_axis[i] for i in range(3)]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = [vi/norm_v for vi in v]\n                    w = [x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius for rewiring based on theory\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # --- Basic spatial grid for neighbor search ---\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                # Iterate over neighboring cells in grid\n                def expand_coords(ci, r_cells):\n                    if self.dim == 2:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                yield (ci[0]+dx, ci[1]+dy)\n                    elif self.dim == 3:\n                        for dx in range(-r_cells,r_cells+1):\n                            for dy in range(-r_cells,r_cells+1):\n                                for dz in range(-r_cells,r_cells+1):\n                                    yield (ci[0]+dx, ci[1]+dy, ci[2]+dz)\n                    else:\n                        return [] # Not supported\n                for c in expand_coords(ci, r_cells):\n                    if c in self.cells:\n                        neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialization\n        root = Node(start_pos)\n        nodes.append(root)\n        edges = []\n        grid_cell_size = self.max_neighbor_radius  # Reasonable cell size for approximate neighbors\n        spatial_grid = SpatialGrid(bounds, grid_cell_size)\n        spatial_grid.add_node(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Early stopping parameters\n        min_improvement_cost = 1e-4\n        no_improve_count = 0\n        max_no_improve = 1500\n\n        for it in range(self.max_iter):\n            cur_time = time.monotonic()\n            if cur_time - start_time > time_limit:\n                break\n\n            # Sample point\n            if best_goal_node is not None:\n                # After first solution, sample informed\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                # Before first solution sample uniformly with some goal bias\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search by linear - fallback for safety if spatial grid empty\n            def nearest_node(p):\n                best = nodes[0]\n                best_d = dist(p, best.position)\n                for n in nodes[1:]:\n                    d_ = dist(p, n.position)\n                    if d_ < best_d:\n                        best = n\n                        best_d = d_\n                return best, best_d\n\n            nearest, _ = nearest_node(sample)\n\n            # Steer new node position\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius neighborhood\n            radius = radius_adaptive(len(nodes))\n\n            # Retrieve candidate neighbors from spatial grid\n            candidates = spatial_grid.neighbor_candidates(new_pos, radius)\n            # Filter candidates strictly within radius (squared distances)\n            radius_sq = radius * radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                pos_c = c.position\n                for i in range(dim):\n                    diff = pos_c[i] - new_pos[i]\n                    sum_sq += diff*diff\n                    if sum_sq > radius_sq:\n                        break\n                if sum_sq <= radius_sq:\n                    neighbors.append(c)\n\n            # Select the best parent (lowest cost) among neighbors + nearest\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.add_node(new_node)\n\n            # Rewire neighbors with better cost through new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check and connect\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-8 < best_goal_cost:\n                    improved = best_goal_cost - goal_cost\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                else:\n                    improved = 0.0\n\n                # Early stopping: break if cost improvement small or solution sufficient\n                if improved < min_improvement_cost:\n                    break\n\n            # Track no improvement streak and possibly early terminate\n            if best_goal_node is not None:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        # Extract path from best goal node or closest node\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            current = best_goal_node\n        else:\n            # Find node closest to goal to extract partial path\n            min_d = float('inf')\n            current = None\n            for n in nodes:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d:\n                    min_d = d_\n                    current = n\n            if current is None:\n                current = root\n\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Post-process shortcutting to smooth and shorten path\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iter = 200\n            iteration = 0\n            while improved and iteration < max_iter and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -13.86985,
          "time_improvement": -13.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1697.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023928070068359376,
                    "num_nodes_avg": 242.3,
                    "path_length_avg": 170.20756672600876,
                    "smoothness_avg": 0.05125578115753204,
                    "success_improvement": 0.0,
                    "time_improvement": 4.7737606364002065,
                    "length_improvement": 6.706535565983733,
                    "smoothness_improvement": 702.2642788256377,
                    "objective_score": 8.967370924638491
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1532435417175293,
                    "num_nodes_avg": 964.5,
                    "path_length_avg": 231.25080942683635,
                    "smoothness_avg": 0.10406023561585567,
                    "success_improvement": 0.0,
                    "time_improvement": 4.6570241332318485,
                    "length_improvement": 22.801823627834896,
                    "smoothness_improvement": 2577.544813954116,
                    "objective_score": 27.965925486441073
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0716317892074585,
                    "num_nodes_avg": 607.7,
                    "path_length_avg": 125.84121677266735,
                    "smoothness_avg": 0.15017270596541038,
                    "success_improvement": 0.0,
                    "time_improvement": -47.426800724264325,
                    "length_improvement": 16.422255734395755,
                    "smoothness_improvement": 1810.185735283898,
                    "objective_score": 4.676241899777645
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An adaptive informed bi-directional RRT* planner with dynamic neighbor radius, goal bias, and ellipsoidal informed sampling after first solution. It alternates tree expansions, incrementally rewires nodes within shrinking neighborhood for optimized paths, and applies iterative shortcutting post-processing. Planning halts early either on time limit or upon satisfying a quality threshold, ensuring efficient search with shorter, smoother paths.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points with goal bias initially, then informed ellipsoidal sampling post first solution to focus near best path. Each new node connects to best parent found in a radius adaptively decreasing with node count, followed by rewiring neighbors to minimize path cost. Trees attempt connection after each extension, and upon success, iterative path shortcutting improves smoothness and length. Planning respects a hard 30-second limit and returns the best path found so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05, gamma_rrt_star: float = 25.0, max_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        TIME_LIMIT = 30.0\n        t_start = time.monotonic()\n\n        nodes_all: List[Node] = []\n        edges_all: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def sample_goal():\n            if is_free_node(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        def sample_ellipsoid(c_best, c_min, x_center, C):\n            # Sample uniformly inside unit ball and transform via C*ball + x_center\n            # Returns point in informed subset ellipsoid focusing near optimal path.\n            while True:\n                ball = self._sample_unit_ball(dim)\n                if ball is None:\n                    return sample_uniform()  # fallback\n                point_local = tuple(ball[i] * c_best / 2 if i == 0 else ball[i] * math.sqrt(c_best**2 - c_min**2) / 2 for i in range(dim))\n                p = tuple(sum(C[i][j] * point_local[j] for j in range(dim)) + x_center[i] for i in range(dim))\n                if in_bounds(p) and is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for n in tree_nodes[1:]:\n                d = math.dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def rewire(new_node: Node, neighbors: List[Node], edges: List[Tuple[Node, Node]]):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Update parent and edges\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.update_parent(new_node, new_cost)\n                        edges.append((new_node, nb))\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            nearest_node = nearest(tree_nodes, new_pos)\n            if nearest_node is None:\n                return None\n            neighbors = near_nodes(tree_nodes, new_pos)\n            # Candidate parent nodes include nearest\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cand_cost = nb.cost + math.dist(nb.position, new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            nodes_all.append(new_node)\n            tree_nodes.append(new_node)\n            edges_all.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges_all)\n            return new_node\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            if not other_tree:\n                return None\n            nearest_other = nearest(other_tree, new_node.position)\n            if nearest_other is None:\n                return None\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between > self.step_size:\n                return None\n            if not is_free_edge(new_node.position, nearest_other.position):\n                return None\n            path1 = new_node.path_from_root()\n            path2 = nearest_other.path_from_root()\n            # Avoid duplication of meeting node\n            if path1[-1] == path2[-1]:\n                path2 = path2[:-1]\n            full_path = path1 + path2[::-1]\n            total_cost = new_node.cost + nearest_other.cost + dist_between\n            return full_path, total_cost\n\n        def shortcut_path(path: List[Tuple[float, ...]], timeout_sec=5.0) -> List[Tuple[float, ...]]:\n            n = len(path)\n            if n < 3:\n                return path\n            t0 = time.monotonic()\n            shortened = [path[0]]\n            i = 0\n            while i < n - 1:\n                end = n - 1\n                while end > i + 1:\n                    if time.monotonic() - t0 > timeout_sec:\n                        break\n                    if is_free_edge(path[i], path[end]):\n                        shortened.append(path[end])\n                        i = end\n                        break\n                    end -= 1\n                else:\n                    i += 1\n                    if i < n:\n                        shortened.append(path[i])\n                    continue\n            return shortened\n\n        def compute_rotation_matrix(unit_x: Tuple[float, ...]) -> List[List[float]]:\n            # Returns rotation matrix C such that C * (c_min/2,0,..0) aligns with unit_x\n            if dim == 2:\n                x, y = unit_x\n                norm = math.hypot(x, y)\n                if norm < 1e-14:\n                    return [[1, 0], [0, 1]]\n                x /= norm\n                y /= norm\n                return [[x, -y],[y, x]]\n            elif dim == 3:\n                # Use SVD on unit_x to generate rotation matrix\n                import math\n                ux, uy, uz = unit_x\n                norm = math.sqrt(ux*ux+uy*uy+uz*uz)\n                if norm < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux /= norm\n                uy /= norm\n                uz /= norm\n                # Pick arbitrary vector not colinear to unit_x\n                v = (0,0,1) if abs(uz) < 0.9 else (0,1,0)\n                # Compute axis = unit_x cross v\n                ax = uy*v[2] - uz*v[1]\n                ay = uz*v[0] - ux*v[2]\n                az = ux*v[1] - uy*v[0]\n                axis_length = math.sqrt(ax*ax + ay*ay + az*az)\n                if axis_length < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ax /= axis_length\n                ay /= axis_length\n                az /= axis_length\n                angle = math.acos(ux*0 + uy*0 + uz*1)\n                c = math.cos(angle)\n                s = math.sin(angle)\n                t = 1 - c\n                C = [[0.0]*3 for _ in range(3)]\n                C[0][0] = t*ax*ax + c\n                C[0][1] = t*ax*ay - s*az\n                C[0][2] = t*ax*az + s*ay\n                C[1][0] = t*ax*ay + s*az\n                C[1][1] = t*ay*ay + c\n                C[1][2] = t*ay*az - s*ax\n                C[2][0] = t*ax*az - s*ay\n                C[2][1] = t*ay*az + s*ax\n                C[2][2] = t*az*az + c\n                return C\n            else:\n                # For higher dims, just identity\n                return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf'):\n                return sample_uniform()\n            # Define ellipse parameters\n            midpoint = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            norm_diff = math.dist(start, goal)\n            if norm_diff < 1e-14:\n                return sample_uniform()\n            unit_x = tuple(d / norm_diff for d in diff)\n            C = compute_rotation_matrix(unit_x)\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            # Create diagonal scaling matrix but use in sample_ellipsoid logic\n            while True:\n                # Sample in unit n-ball\n                u = self._sample_unit_ball(dim)\n                if u is None:\n                    return sample_uniform()\n                # Scale sample: first dimension scaled by r1, others by r2\n                local = [0.0]*dim\n                local[0] = u[0]*r1\n                for i in range(1, dim):\n                    local[i] = u[i]*r2\n                # Rotate and translate\n                point = []\n                for i in range(dim):\n                    s = 0.0\n                    for j in range(dim):\n                        s += C[i][j]*local[j]\n                    point.append(s + midpoint[i])\n                if in_bounds(point) and is_free_node(tuple(point)):\n                    return tuple(point)\n\n        def _sample_unit_ball(d: int) -> Optional[Tuple[float, ...]]:\n            # Rejection sample from unit ball\n            for _ in range(100):\n                coord = tuple(random.uniform(-1,1) for _ in range(d))\n                norm = math.sqrt(sum(x*x for x in coord))\n                if norm <= 1 and norm > 1e-14:\n                    return tuple(x / norm for x in coord)\n            return None\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes_all.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - t_start > TIME_LIMIT:\n                break\n\n            if found_solution:\n                sample = informed_sample(best_cost, math.dist(start_pos, goal_pos), start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = sample_goal()\n                else:\n                    sample = sample_uniform()\n\n            # Alternate tree expansion\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            connect_result = try_connect(new_node, tree_b)\n            if connect_result is not None:\n                path_candidate, cost_candidate = connect_result\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stop on good solution or keep searching until time runs out\n                    # Here we break immediately to reduce planning time\n                    break\n\n        # If no path found, try direct connection if feasible\n        if not found_solution:\n            nearest_goal = nearest(tree_start, goal_pos)\n            if nearest_goal and is_free_edge(nearest_goal.position, goal_pos):\n                p = nearest_goal.path_from_root() + [goal_pos]\n                best_path = p\n                found_solution = False\n\n        if best_path:\n            # Iterative shortcutting to further improve smoothness & length within small time to not exceed time limit\n            t_sc_start = time.monotonic()\n            time_for_shortcut = max(1.0, TIME_LIMIT - (time.monotonic() - t_start) - 0.5)\n            # Multiple iterations of shortcutting limited by remaining time\n            for _ in range(8):\n                best_path = shortcut_path(best_path, timeout_sec=time_for_shortcut)\n                if time.monotonic() - t_sc_start > time_for_shortcut:\n                    break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges_all\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.16731,
          "time_improvement": -25.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1490.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05280606746673584,
                    "num_nodes_avg": 104.3,
                    "path_length_avg": 159.03977593430037,
                    "smoothness_avg": 0.045831156313335134,
                    "success_improvement": 0.0,
                    "time_improvement": -110.1516422374204,
                    "length_improvement": 12.827778663888708,
                    "smoothness_improvement": 617.3571202525652,
                    "objective_score": -22.262039871630073
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06106133460998535,
                    "num_nodes_avg": 251.7,
                    "path_length_avg": 229.1376515349893,
                    "smoothness_avg": 0.0943546418960893,
                    "success_improvement": 0.0,
                    "time_improvement": 62.009691978774306,
                    "length_improvement": 23.507256556010894,
                    "smoothness_improvement": 2327.812896887935,
                    "objective_score": 44.3463260116785
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06167628765106201,
                    "num_nodes_avg": 241.0,
                    "path_length_avg": 120.7672251338709,
                    "smoothness_avg": 0.12772867393374066,
                    "success_improvement": 0.0,
                    "time_improvement": -26.9371862625311,
                    "length_improvement": 19.792159383366613,
                    "smoothness_improvement": 1524.6993044871776,
                    "objective_score": 11.417636273696527
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
          "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.90364,
          "time_improvement": -8.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025247907638549803,
                    "num_nodes_avg": 233.8,
                    "path_length_avg": 170.12946546952813,
                    "smoothness_avg": 0.014816791053862539,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4787803341404643,
                    "length_improvement": 6.749344102254376,
                    "smoothness_improvement": 131.91495516970375,
                    "objective_score": 4.565547136959005
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12624733448028563,
                    "num_nodes_avg": 859.5,
                    "path_length_avg": 236.88602288914717,
                    "smoothness_avg": 0.011656507882273733,
                    "success_improvement": 0.0,
                    "time_improvement": 21.453156004545612,
                    "length_improvement": 20.920627173489493,
                    "smoothness_improvement": 199.93034365416824,
                    "objective_score": 19.98797482372822
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07023768424987793,
                    "num_nodes_avg": 492.5,
                    "path_length_avg": 121.35915641758058,
                    "smoothness_avg": 0.02178086692654423,
                    "success_improvement": 0.0,
                    "time_improvement": -44.55756576526181,
                    "length_improvement": 19.399026809465404,
                    "smoothness_improvement": 177.0510196092805,
                    "objective_score": -0.842598545852899
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
          "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.73775,
          "time_improvement": -3.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 143.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031192827224731445,
                    "num_nodes_avg": 228.2,
                    "path_length_avg": 173.47041072322037,
                    "smoothness_avg": 0.016212433782287948,
                    "success_improvement": 0.0,
                    "time_improvement": -24.137702006209146,
                    "length_improvement": 4.918119068040286,
                    "smoothness_improvement": 153.759794556254,
                    "objective_score": -3.521640188257302
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1286400556564331,
                    "num_nodes_avg": 775.0,
                    "path_length_avg": 247.3898406969005,
                    "smoothness_avg": 0.00894525060365523,
                    "success_improvement": 0.0,
                    "time_improvement": 19.964485390459707,
                    "length_improvement": 17.414150453629286,
                    "smoothness_improvement": 130.16774103563074,
                    "objective_score": 17.088674594493636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050321340560913086,
                    "num_nodes_avg": 417.3,
                    "path_length_avg": 125.51343547763591,
                    "smoothness_avg": 0.01937830391026074,
                    "success_improvement": 0.0,
                    "time_improvement": -3.567345296452773,
                    "length_improvement": 16.639952463287656,
                    "smoothness_improvement": 146.4905953809094,
                    "objective_score": 9.64622086594131
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Enhanced bidirectional RRT* with adaptive rewiring radius and integrated incremental path shortcutting, combining efficient collision checking and goal bias sampling for faster convergence and smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending toward sampled points (with goal bias). It uses an adaptive neighbor radius based on logarithmic scaling for efficient rewiring optimizing path cost. Incremental path shortcutting is applied during planning to improve smoothness and path length progressively. The planner enforces strict collision checks on nodes and edges, respects map boundaries, and halts immediately when time limit is reached, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n\n        def dist(a,b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=0.5):\n            distance = dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_p[d] + (to_p[d]-from_p[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            res = []\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                if is_3d:\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    res.append(node)\n            return res\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1: \n                return self.step_size*2.5\n            gamma = 15.0\n            return max(gamma * ((math.log(num_nodes)/num_nodes) ** (1/dim)), self.step_size*0.5)\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node is new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    c = node.cost + dist(node.position, new_node.position)\n                    if c < min_cost:\n                        min_parent = node\n                        min_cost = c\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            for node in near_nodes:\n                if node is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through\n                        new_node.add_child(node)\n\n        def try_connect(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if dist(new_node.position, nearest_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_node.position):\n                    return nearest_node\n            return None\n\n        def incremental_shortcut(path, attempts=20):\n            if len(path) < 3:\n                return path\n            new_path = list(path)\n            for _ in range(attempts):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1]+new_path[j:]\n            return new_path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        trees = [(start_tree, goal_tree),(goal_tree, start_tree)]\n        for itr in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else None\n            if sample is None:\n                for _ in range(10):\n                    q = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n                if sample is None:\n                    continue  # failed to sample a free point after tries\n\n            for treeA, treeB in trees:\n                nearest_node = nearest(treeA, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not is_in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n                nearest_node.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                radius = neighbor_radius(len(treeA))\n                rewire(treeA, new_node, radius)\n\n                connect_node = try_connect(new_node, treeB)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        best_path = incremental_shortcut(best_path, attempts=15)\n                        success = True\n            if success:\n                # incremental shortcut again to polish slightly before stopping\n                best_path = incremental_shortcut(best_path, attempts=25)\n                break\n\n        if not success and all_nodes:\n            # fallback: best node nearest goal in start tree\n            candidate = min(start_tree + all_nodes, key=lambda n: dist(n.position, goal_pos))\n            path_fallback = []\n            cur = candidate\n            while cur:\n                path_fallback.append(cur.position)\n                cur = cur.parent\n            path_fallback.reverse()\n            best_path = incremental_shortcut(path_fallback, attempts=15)\n            success = False\n\n        nodes = start_tree + goal_tree + all_nodes\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": 1.31504,
          "time_improvement": -38.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 771.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03619341850280762,
                    "num_nodes_avg": 424.2,
                    "path_length_avg": 180.94077229406216,
                    "smoothness_avg": 0.022140176054999076,
                    "success_improvement": 0.0,
                    "time_improvement": -44.03849219301509,
                    "length_improvement": 0.8234955156076187,
                    "smoothness_improvement": 246.54183342255664,
                    "objective_score": -11.484741181427172
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053159022331237794,
                    "num_nodes_avg": 853.6,
                    "path_length_avg": 256.15880215041796,
                    "smoothness_avg": 0.048649242083894054,
                    "success_improvement": 0.0,
                    "time_improvement": 66.92624480990813,
                    "length_improvement": 14.486818719884454,
                    "smoothness_improvement": 1151.7800394513142,
                    "objective_score": 34.52886487215968
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11569452285766602,
                    "num_nodes_avg": 1265.8,
                    "path_length_avg": 125.77827142101594,
                    "smoothness_avg": 0.079658761276128,
                    "success_improvement": 0.0,
                    "time_improvement": -138.11318347538923,
                    "length_improvement": 16.464061039827072,
                    "smoothness_improvement": 913.2535636342143,
                    "objective_score": -26.989250600549454
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bi-directional RRT* planner that combines goal bias sampling, adaptive neighbor radius, and continuous rewiring to optimize path cost and smoothness efficiently. The planner grows two trees from start and goal, incrementally connects and rewires nodes within adaptive radii, and employs early stopping once a connection is found. Post-processing shortcutting refines the path for smoothness and shorter length. Efficient collision checking with adaptive resolution and early exits reduce planning time while maintaining robust performance.",
          "planning_mechanism": "The planner alternates growth between two trees started from start and goal. It samples with goal bias to guide exploration, steers incrementally towards samples, and maintains an adaptive neighbor radius for rewiring to locally optimize paths. Trees attempt connection after each iteration, early stopping on success. Periodic shortcutting post-processes the extracted path to improve smoothness and length before returning the final solution within a strict time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=50.0, max_neighbor_radius: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = math.dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], n_nodes: int) -> List[Node]:\n            if n_nodes < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2.0, r))\n            result = [node for node in tree if math.dist(node.position, point) <= radius]\n            return result\n\n        def choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges):\n            nearest_node_ = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos, len(tree))\n            min_cost = nearest_node_.cost + math.dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n            for nb in neighbors:\n                if nb == nearest_node_:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None, []\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire_from(pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path_nodes: List[Node] = []\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling: alternate sampling randomly or goal\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_free()\n\n            # Alternate expansion trees each iteration\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node, neighbors = choose_parent_and_add(tree_a, steer(nearest(tree_a, sample).position, sample, self.step_size),\n                                                       obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n\n            rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect the other tree to new node\n            nearest_in_b = nearest(tree_b, new_node.position)\n            dist_to_near_b = math.dist(new_node.position, nearest_in_b.position)\n            last_connect_node = None\n            curr_pos = new_node.position\n\n            while dist_to_near_b > self.step_size:\n                next_pos = steer(curr_pos, nearest_in_b.position, self.step_size)\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(curr_pos, next_pos, obstacles, is_3d):\n                    break\n                chosen_node, nbs = choose_parent_and_add(tree_b, next_pos, obstacles, is_3d, nodes, edges)\n                if chosen_node is None:\n                    break\n                rewire_from(chosen_node, nbs, obstacles, is_3d, edges)\n                curr_pos = chosen_node.position\n                dist_to_near_b = math.dist(curr_pos, nearest_in_b.position)\n                last_connect_node = chosen_node\n\n            # Try to connect directly if within step size\n            if last_connect_node is not None and math.dist(last_connect_node.position, nearest_in_b.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(last_connect_node.position, nearest_in_b.position, obstacles, is_3d) and \\\n                    not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d):\n\n                    final_node = Node(nearest_in_b.position, None,\n                                      last_connect_node.cost + math.dist(last_connect_node.position, nearest_in_b.position))\n                    last_connect_node.children.append(final_node)\n                    final_node.parent = last_connect_node\n                    nodes.append(final_node)\n                    tree_b.append(final_node)\n                    edges.append((last_connect_node, final_node))\n\n                    # Extract combined path\n                    path_start = new_node.path_from_root()\n                    path_goal = final_node.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        # Avoid duplicate at connection point\n                        path_goal = path_goal[:-1]\n                    full_path = path_start + path_goal[::-1]\n\n                    # Update best path if cost better\n                    path_cost = final_node.cost + new_node.cost - math.dist(new_node.position, nearest_in_b.position)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path_nodes = full_path\n                        success = True\n\n                    # Early stopping on first valid path\n                    break\n\n        # If no path connected, try closest nodes\n        if not best_path_nodes:\n            # Find node closest to goal in start tree\n            goal_nearest_node = min(tree_start, key=lambda n: math.dist(n.position, goal_pos))\n            # Backtrack\n            best_path_nodes = goal_nearest_node.path_from_root()\n            success = False\n\n        # Path shortcutting/post-processing\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        best_path_nodes = shortcut_path(best_path_nodes)\n\n        return PlannerResult(\n            success=success if 'success' in locals() else False,\n            path=best_path_nodes,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 1.81366,
          "time_improvement": -64.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1609.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06511895656585694,
                    "num_nodes_avg": 107.1,
                    "path_length_avg": 167.86838334936317,
                    "smoothness_avg": 0.042074717464123695,
                    "success_improvement": 0.0,
                    "time_improvement": -159.153092051829,
                    "length_improvement": 7.9886790414557955,
                    "smoothness_improvement": 558.5606950248841,
                    "objective_score": -40.15991671555079
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09056892395019531,
                    "num_nodes_avg": 264.7,
                    "path_length_avg": 234.50722182399244,
                    "smoothness_avg": 0.10901757476160132,
                    "success_improvement": 0.0,
                    "time_improvement": 43.651062656985864,
                    "length_improvement": 21.71473943903038,
                    "smoothness_improvement": 2705.100720801212,
                    "objective_score": 39.64966606452005
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08601047992706298,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 124.56625372840308,
                    "smoothness_avg": 0.13072121654165783,
                    "success_improvement": 0.0,
                    "time_improvement": -77.01986819959468,
                    "length_improvement": 17.26902548118002,
                    "smoothness_improvement": 1562.7642255733656,
                    "objective_score": -4.930724043303564
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bi-directional RRT* planner with goal biasing and adaptive neighbor radius to improve search efficiency, enhanced rewiring to optimize path cost and smoothness, and early stopping. The algorithm maintains two growing trees from start and goal, samples strategically, efficiently rewires within a dynamically adjusted neighborhood, and attempts connection after each extension to find and return the best feasible path within a 30-second limit. Path extraction returns a smooth, near-optimal route with coherent parent-child node relationships.",
          "planning_mechanism": "The planner grows two trees alternatingly with goal bias sampling in a bounded domain while avoiding obstacles. Each new node is added after steering and collision checks, then rewiring rewires neighbors within an adaptive radius shrinking as sqrt((log n)/n) to improve path quality with fewer neighbors checked. After each extension, it attempts to connect the two trees efficiently. Early stopping occurs once a successful connection is found. The final path is extracted by concatenating parent pointers from both trees.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []  # Nodes other than tree roots\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            min_node = tree[0]\n            min_dist = dist(min_node.position, point)\n            for node in tree[1:]:\n                cd = dist(node.position, point)\n                if cd < min_dist:\n                    min_node = node\n                    min_dist = cd\n            return min_node\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius * radius\n            for node in tree:\n                d = 0.0\n                # Use squared distance for efficiency\n                if is_3d:\n                    d = (node.position[0]-point[0])**2 + (node.position[1]-point[1])**2 + (node.position[2]-point[2])**2\n                else:\n                    d = (node.position[0]-point[0])**2 + (node.position[1]-point[1])**2\n                if d <= r2:\n                    result.append(node)\n            return result\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def get_cost(node):\n            return node.cost\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            # Choose best parent\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                edge_free = not is_edge_in_obstacle(node.position, new_node.position)\n                if edge_free:\n                    cost_via_node = node.cost + dist(node.position, new_node.position)\n                    if cost_via_node < min_cost:\n                        min_parent = node\n                        min_cost = cost_via_node\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except Exception:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            # Try rewiring neighbors to new_node\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                edge_free = not is_edge_in_obstacle(new_node.position, node.position)\n                if edge_free:\n                    cost_via_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_via_new < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except Exception:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_via_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size and not is_edge_in_obstacle(n1.position, n2.position):\n                return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Adaptive neighbor radius factor: gamma_RRTstar ~ 2*(1+1/dim)**(1/dim) * (volume_free / zeta_ball)^(1/dim)\n        # For simplicity use basic radius proportional to (log(n)/n)^(1/dim), multiplied by a constant (20)\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            const_gamma = 20.0\n            r = const_gamma * ((math.log(n) / n) ** (1.0 / dim))\n            return max(r, self.step_size*0.5)\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sampled = False\n                while not sampled:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        sampled = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Extend tree_a toward sample\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire around new_node\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to other tree\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n                        # Early stop on first solution found\n                        return PlannerResult(success=True, path=best_path, nodes=start_tree+goal_tree+all_nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree+goal_tree+all_nodes, edges=edges)",
          "objective": 3.22753,
          "time_improvement": -10.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016430163383483888,
                    "num_nodes_avg": 257.8,
                    "path_length_avg": 184.39486315113612,
                    "smoothness_avg": 0.01233865967299053,
                    "success_improvement": 0.0,
                    "time_improvement": 34.6130855238688,
                    "length_improvement": -1.0697464167268138,
                    "smoothness_improvement": 93.12681771063177,
                    "objective_score": 10.20771189567771
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02988572120666504,
                    "num_nodes_avg": 601.0,
                    "path_length_avg": 307.0134488211298,
                    "smoothness_avg": 0.006656269561980515,
                    "success_improvement": 0.0,
                    "time_improvement": 81.40610975293004,
                    "length_improvement": -2.489926108642665,
                    "smoothness_improvement": 71.2706101469364,
                    "objective_score": 23.284230311428093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11988391876220703,
                    "num_nodes_avg": 1194.6,
                    "path_length_avg": 149.44686458452543,
                    "smoothness_avg": 0.014141411739318493,
                    "success_improvement": 0.0,
                    "time_improvement": -146.73546196385547,
                    "length_improvement": 0.7445084379161084,
                    "smoothness_improvement": 79.877713513695,
                    "objective_score": -43.1745449588385
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved informed RRT* planner that integrates adaptive neighbor radius, goal bias sampling, and incremental rewiring within an ellipsoidal informed set for focused exploration and faster convergence. The planner combines efficient spatial bounds checks, early termination upon finding a path, and path shortcutting to reduce overall planning time and yield shorter, smoother paths.",
          "planning_mechanism": "A single-tree informed RRT* sampling nodes adaptively in an ellipsoid defined by the best known path cost, with a neighbor radius that shrinks dynamically for better local rewiring. Each iteration samples either the goal (with probability goal_sample_rate) or informed samples, steers within step limits, and checks collision. Upon adding a new node, it rewires surrounding neighbors if a better path is found. The planner halts early upon detecting a valid path and applies post-processing shortcutting to improve smoothness and reduce path length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & bounds check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0:\n                return x_start\n\n            # Center and unit vector for ellipse\n            center = tuple((x_start[i] + x_goal[i]) / 2.0 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix aligning x-axis to a1 for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j] * temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i] * v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = tuple(v[i] / norm_v for i in range(3))\n                    w = (x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(abs(c_best * c_best - c_min * c_min)) / 2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node search linear\n        def nearest_node(p):\n            best_i = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                dcur = dist(nodes[i].position, p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_i = i\n            return nodes[best_i], best_d\n\n        # Neighbor radius shrinks as tree grows (adaptive)\n        def neighbor_radius(n):\n            # Following RRT* radius formula (Karaman & Frazzoli) with min/max caps\n            gamma_rrt_star = self.max_neighbor_radius\n            r = gamma_rrt_star * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        def nearby_nodes(p, radius):\n            result = []\n            for node in nodes:\n                if dist(node.position, p) <= radius:\n                    result.append(node)\n            return result\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            radius = neighbor_radius(n_nodes)\n\n            neighbors = nearby_nodes(new_pos, radius)\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    success = True\n                    break\n\n        # Extract path from best goal node or closest node to goal\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No solution found: closest node to goal\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Post-processing shortcutting to smooth and shorten path\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 4.05717,
          "time_improvement": -77.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1607.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03238720893859863,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 156.8355269466239,
                    "smoothness_avg": 0.04571460503828216,
                    "success_improvement": 0.0,
                    "time_improvement": -28.890967883954104,
                    "length_improvement": 14.03596246259457,
                    "smoothness_improvement": 615.5328397028414,
                    "objective_score": 2.831951310884718
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.147990083694458,
                    "num_nodes_avg": 859.9,
                    "path_length_avg": 231.82003384026544,
                    "smoothness_avg": 0.10402068439578667,
                    "success_improvement": 0.0,
                    "time_improvement": 7.925548965645519,
                    "length_improvement": 22.611800134415976,
                    "smoothness_improvement": 2576.527132574148,
                    "objective_score": 28.827380433213982
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15016646385192872,
                    "num_nodes_avg": 570.8,
                    "path_length_avg": 123.61458665916646,
                    "smoothness_avg": 0.13595502682176802,
                    "success_improvement": 0.0,
                    "time_improvement": -209.06056635900154,
                    "length_improvement": 17.901077435050915,
                    "smoothness_improvement": 1629.3379060166778,
                    "objective_score": -43.83083391658651
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner with fixed neighbor radius and optimized rewiring to improve path smoothness and planning efficiency. It grows two trees from start and goal, repeatedly samples collision-free configurations, and rewires locally to reduce path cost. The planner attempts connections between the trees after each extension, terminating early when an optimal path is found or time limit is reached. The fixed neighbor radius speeds up neighbor searches and collisions checks, while consistent rewiring improves the path smoothness.",
          "planning_mechanism": "The planner alternates extending two trees toward random free samples within bounds, rewires the trees locally within a fixed radius, and attempts to connect them. The search terminates when a feasible path from start to goal is found or a 30-second timeout occurs. The output is the best path found to date with node and edge information.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        best_path = []\n        success = False\n\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(len(from_p)))\n\n        def is_colliding(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_colliding(p1, p2):\n            d = dist(p1, p2)\n            step_count = max(1, int(d / 1.0))\n            for i in range(step_count + 1):\n                inter = tuple(p1[j] + (p2[j] - p1[j]) * (i / step_count) for j in range(len(p1)))\n                if is_colliding(inter):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_start.reverse()\n\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n\n            # Remove duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        # Attempt to connect two nodes by straight-line if collision free\n        def can_connect(n1, n2):\n            return dist(n1.position, n2.position) <= self.step_size and not is_edge_colliding(n1.position, n2.position)\n\n        def try_connect_tree(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if can_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        def rewire(tree, new_node):\n            near_nodes = near(tree, new_node.position, self.radius)\n            # Choose best parent from near nodes\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if not is_edge_colliding(near_node.position, new_node.position):\n                    cost_through_near = near_node.cost + dist(near_node.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near_node\n            # Re-assign parent if better\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Try rewiring near nodes to new_node\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                edge_free = not is_edge_colliding(new_node.position, near_node.position)\n                if edge_free:\n                    potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if potential_cost < near_node.cost:\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n\n        # Update best solution path and cost\n        def update_best_path(node_start, node_goal):\n            nonlocal best_cost, best_path, success\n            candidate_path = extract_path(node_start, node_goal)\n            candidate_cost = node_start.cost + node_goal.cost + dist(node_start.position, node_goal.position)\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                success = True\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            rand_sample = None\n            # Goal bias 5%\n            if random.random() < 0.05:\n                rand_sample = goal_pos\n            else:\n                found_sample = False\n                while not found_sample:\n                    dim = len(bounds)\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_colliding(sample):\n                        rand_sample = sample\n                        found_sample = True\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rand_sample)\n                new_pos = steer(nearest_node.position, rand_sample, self.step_size)\n\n                if is_colliding(new_pos):\n                    continue\n                if is_edge_colliding(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire within fixed radius\n                rewire(tree_a, new_node)\n\n                # Try connect trees\n                connect_node = try_connect_tree(new_node, tree_b)\n                if connect_node:\n                    update_best_path(new_node, connect_node)\n\n            if success:\n                # Early stop on first solution\n                break\n\n        return PlannerResult(success, best_path, start_tree + goal_tree + nodes, edges)",
          "objective": 5.46059,
          "time_improvement": -53.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 293.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06232309341430664,
                    "num_nodes_avg": 267.2,
                    "path_length_avg": 168.2463107739374,
                    "smoothness_avg": 0.02259680420437422,
                    "success_improvement": 0.0,
                    "time_improvement": -148.0264306480139,
                    "length_improvement": 7.781531031403382,
                    "smoothness_improvement": 253.68905554417486,
                    "objective_score": -38.47056529784127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08523426055908204,
                    "num_nodes_avg": 568.0,
                    "path_length_avg": 241.3226903680994,
                    "smoothness_avg": 0.016808760155440354,
                    "success_improvement": 0.0,
                    "time_improvement": 46.970110737287854,
                    "length_improvement": 19.439539866622514,
                    "smoothness_improvement": 332.5015056600573,
                    "objective_score": 27.41726466946015
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07625963687896728,
                    "num_nodes_avg": 483.4,
                    "path_length_avg": 124.7326333683994,
                    "smoothness_avg": 0.03084680379066026,
                    "success_improvement": 0.0,
                    "time_improvement": -56.951465457596676,
                    "length_improvement": 17.15852404644154,
                    "smoothness_improvement": 292.3690673429857,
                    "objective_score": -5.328479872699152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified RRT* planner with adaptive neighbor radius that shrinks as the tree grows, fixed step size steering, goal-biased sampling, local rewiring for path cost improvement, and early termination at goal connection. It enforces node and edge collision checks, samples only within map bounds avoiding obstacles, and uses an efficient backtracking method for path extraction.",
          "planning_mechanism": "The planner incrementally grows a single tree initialized at the start position by sampling points with goal bias and steering towards them by a fixed step size. For each new node, it selects the lowest-cost parent from nearby nodes inside an adaptively shrinking radius and rewires neighbors if the new connection yields a lower cost, improving path quality locally. The search stops early when a node reaches the goal within step size. The final path is backtracked from the goal node or nearest node if no exact goal connection exists.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% goal bias\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_free_node(p):\n            return in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        def nearest_node(p, nodes_list):\n            best = None\n            best_dist = float('inf')\n            for n in nodes_list:\n                d = dist(n.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def nearby_nodes(p, nodes_list, radius):\n            res = []\n            for n in nodes_list:\n                if dist(n.position, p) <= radius:\n                    res.append(n)\n            return res\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        goal_node = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sampling with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                # Sample until free point found\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if is_free_node(sample):\n                        break\n\n            nearest = nearest_node(sample, nodes)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            node_count = len(nodes)\n            radius = min(self.max_neighbor_radius, max(self.min_neighbor_radius, \n                       self.step_size * (math.log(node_count + 1) / (node_count + 1))**(1/dim)))\n\n            neighbors = nearby_nodes(new_pos, nodes, radius)\n\n            # Choose best parent\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if cheaper\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection\n            d_goal = dist(new_node.position, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        # Extract path\n        path: List[Tuple[float, ...]] = []\n        if success:\n            curr = goal_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n        else:\n            nearest_goal_node = nearest_node(goal_pos, nodes)\n            if nearest_goal_node:\n                curr = nearest_goal_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 7.74865,
          "time_improvement": -35.0,
          "length_improvement": 4.0,
          "smoothness_improvement": 51.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022745656967163085,
                    "num_nodes_avg": 282.5,
                    "path_length_avg": 184.72861685887193,
                    "smoothness_avg": 0.00960223727348613,
                    "success_improvement": 0.0,
                    "time_improvement": 9.479395176900136,
                    "length_improvement": -1.2526821126027472,
                    "smoothness_improvement": 50.29586492203859,
                    "objective_score": 2.343688610118585
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.13415906429290772,
                    "num_nodes_avg": 890.9,
                    "path_length_avg": 275.4582725528993,
                    "smoothness_avg": 0.005716355204828838,
                    "success_improvement": 0.0,
                    "time_improvement": 16.530743900682502,
                    "length_improvement": 8.044099995081423,
                    "smoothness_improvement": 47.085936744476555,
                    "objective_score": 10.021112850975987
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1117842435836792,
                    "num_nodes_avg": 649.3,
                    "path_length_avg": 142.7018975814953,
                    "smoothness_avg": 0.012175143559591553,
                    "success_improvement": 0.0,
                    "time_improvement": -130.06536043926923,
                    "length_improvement": 5.224194360514662,
                    "smoothness_improvement": 54.86692740238824,
                    "objective_score": -35.61075687846003
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional informed RRT* planner with goal bias and adaptive rewiring radius. It alternates growth of start and goal trees, uses ellipsoidal informed sampling after finding initial path, applies goal-biased sampling to accelerate convergence, and features efficient rewiring and dynamic radius reduction. Early stopping occurs after no improvement or time limit. Path stitching includes shortcutting for smoothness.",
          "planning_mechanism": "The planner maintains two RRT* trees grown alternately. Sampling is uniform initially, then uses informed ellipsoid around best path cost. To accelerate progress, samples near goal are biased. Nodes are added by best-parent selection within a shrinking neighbor radius, followed by rewiring neighbors to improve costs. Connections between trees are attempted greedily each iteration. The best path found is stitched and shortcut to reduce unnecessary waypoints for better smoothness. The process respects collision constraints and time limit, returning best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0,\n                 goal_sample_rate=0.15,  # goal bias\n                 post_opt_iters=500,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = 50.0  # constant for neighbor radius\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))  # unit axis\n            # orthonormal basis\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.5, self.step_size * 2)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.5, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Select best parent candidate with collision free edge\n            parent_candidates = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parent_candidates:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parent_candidates = [p]\n            best_parent = min(parent_candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list, nodes_all):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # rewire nb\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            # simple shortcutting smoothing: try to connect nodes directly and skip intermediates\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialization\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n\n        use_informed_sampling = False\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sampling: goal bias + informed sampling after first found path\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            # Rewire neighbors with new node\n            rewire(curr_tree, new_node, neighbors, edges, nodes)\n\n            # Try connecting other tree greedily toward new_node\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            while True:\n                tries += 1\n                if tries > 20:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges, nodes)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            # If connected, update best path\n            if connected_other is not None:\n                path_candidate = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(path_candidate) - 1):\n                    cost_candidate += dist(path_candidate[i], path_candidate[i+1])\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                    use_informed_sampling = True\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        # Final path smoothing by shortcutting to improve smoothness\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": 7.8919,
          "time_improvement": -88.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1619.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09003095626831055,
                    "num_nodes_avg": 267.5,
                    "path_length_avg": 161.63330626011182,
                    "smoothness_avg": 0.04679719999052493,
                    "success_improvement": 0.0,
                    "time_improvement": -258.29506379942467,
                    "length_improvement": 11.406223595193513,
                    "smoothness_improvement": 632.477801598007,
                    "objective_score": -67.48239597472127
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07056128978729248,
                    "num_nodes_avg": 391.4,
                    "path_length_avg": 233.9831879924015,
                    "smoothness_avg": 0.11503521981583464,
                    "success_improvement": 0.0,
                    "time_improvement": 56.0991394879233,
                    "length_improvement": 21.889677015492953,
                    "smoothness_improvement": 2859.939062381173,
                    "objective_score": 44.263243367578625
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07899618148803711,
                    "num_nodes_avg": 394.7,
                    "path_length_avg": 121.73083260912676,
                    "smoothness_avg": 0.11520848273010573,
                    "success_improvement": 0.0,
                    "time_improvement": -62.58360198829204,
                    "length_improvement": 19.152177180358766,
                    "smoothness_improvement": 1365.4433965213254,
                    "objective_score": -0.4565573056657257
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined single-tree RRT* planner with goal bias sampling, fixed-radius rewiring, early stopping, and incremental cost optimization to efficiently find collision-free paths. The planner balances exploration and refinement by sampling with goal bias, connecting nodes with collision-checked edges, rewiring neighbors within a fixed radius to reduce path cost, and terminating early upon discovering a feasible path to the goal.",
          "planning_mechanism": "The planner samples mostly uniform points with a small probability to sample the goal directly to speed reaching it. Each iteration extends the tree toward the sample while respecting a fixed step size and avoiding collisions. Nearby nodes within a fixed radius are evaluated to select the lowest-cost valid parent for the new node. The planner then attempts to rewire these neighbors to the new node if it improves their cost and is collision-free. This local rewiring refines the path incrementally. The algorithm halts immediately when a node can connect to the goal without collision, returning the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper via new_node\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Check if new node can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        extracted_path = []\n        if success and goal_node:\n            node = goal_node\n            while node:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 9.11942,
          "time_improvement": -70.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 182.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02458224296569824,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 160.91673392411104,
                    "smoothness_avg": 0.01622189562126349,
                    "success_improvement": 0.0,
                    "time_improvement": 2.170356988333177,
                    "length_improvement": 11.798988247370831,
                    "smoothness_improvement": 153.90789288293342,
                    "objective_score": 8.50003950933712
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16582508087158204,
                    "num_nodes_avg": 988.6,
                    "path_length_avg": 230.06388904405716,
                    "smoothness_avg": 0.011826311396694525,
                    "success_improvement": 0.0,
                    "time_improvement": -3.170786229848748,
                    "length_improvement": 23.198051815215557,
                    "smoothness_improvement": 204.29951038474306,
                    "objective_score": 13.989092772098425
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14947149753570557,
                    "num_nodes_avg": 650.0,
                    "path_length_avg": 121.70930984019235,
                    "smoothness_avg": 0.022669727327406998,
                    "success_improvement": 0.0,
                    "time_improvement": -207.63024245189973,
                    "length_improvement": 19.166471578680884,
                    "smoothness_improvement": 188.3572582994048,
                    "objective_score": -49.84740349686436
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid RRT*-based planner combining adaptive ellipsoidal informed sampling after initial solution, progressive goal bias to accelerate convergence, dynamic rewiring radius scaling with node count, and incremental path shortcutting for enhanced smoothness and reduced length. It enforces strict node and edge collision checks, prunes disconnected nodes periodically, and terminates early on time limit or path quality stabilization.",
          "planning_mechanism": "The planner grows a single tree rooted at start by sampling uniformly initially, then biases samples within an informed ellipsoidal region as solutions are found and increasingly towards the goal. It performs fixed-step steering ensuring collision-free nodes and connects new nodes to the cost-optimal neighbor within an adaptively shrinking radius. Rewiring neighbors improves path costs iteratively. Periodic incremental pruning removes invalid/disconnected nodes to maintain efficiency. Upon termination, it extracts the best path and applies local shortcutting to reduce unnecessary waypoints and sharp turns, improving smoothness and path length. Early stopping is triggered either on 30 seconds elapsed or no improvement over a threshold number of iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=100000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_every = 400\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_goal_node = None\n        best_cost = float('inf')\n        no_improve_count = 0\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = math.dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # Fallback\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align first axis e1 (only 2D/3D cases)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            return [n for n in nodes_list if math.dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for n in nodes:\n                if not n.valid:\n                    to_remove.append(n)\n                    continue\n                if n.parent is None and n != root:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        iteration = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        while iteration < self.max_iter:\n            iteration += 1\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively capped by max rate\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            # Sample with goal bias (biased towards informed if solution found)\n            prob = random.random()\n            if prob < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                continue\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius for neighbor search\n            n_nodes = len(nodes) + 1\n            gamma = 30.0  # practical constant between 20 and 40\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            near = near_nodes(nodes, new_pos, radius)\n            # Select parent minimizing cost + dist\n            best_parent = nearest\n            best_cost_through = nearest.cost + math.dist(nearest.position, new_pos)\n            for nb in near:\n                if nb == nearest:\n                    continue\n                cost_through = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through + self.improve_tol < best_cost_through and not is_edge_in_obstacle(nb.position, new_pos):\n                    best_parent = nb\n                    best_cost_through = cost_through\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improves cost\n            for nb in near:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Check if can connect to goal\n            dist_goal = math.dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_pos, goal_pos):\n                goal_cost = new_node.cost + dist_goal\n                if not found_solution or goal_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal_pos, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    best_goal_node = goal_node\n                    best_cost = goal_cost\n                    found_solution = True\n                    no_improve_count = 0\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            # Incremental pruning to keep tree light\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_invalid_nodes()\n\n        success = found_solution and best_goal_node is not None\n        if success:\n            raw_path = best_goal_node.path_from_root()\n            smoothed_path = shortcut_path(raw_path)\n            extracted_path = smoothed_path\n        else:\n            # fallback: closest to goal\n            if nodes:\n                closest_node = min(nodes, key=lambda n: math.dist(n.position, goal_pos))\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 14.04548,
          "time_improvement": -109.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1717.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05759344100952148,
                    "num_nodes_avg": 482.9,
                    "path_length_avg": 169.84128169423337,
                    "smoothness_avg": 0.04532420523685691,
                    "success_improvement": 0.0,
                    "time_improvement": -129.2038924860142,
                    "length_improvement": 6.907302196057579,
                    "smoothness_improvement": 609.4222350437985,
                    "objective_score": -31.569675252950724
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1714890718460083,
                    "num_nodes_avg": 1146.4,
                    "path_length_avg": 229.8773660277296,
                    "smoothness_avg": 0.11527027308817159,
                    "success_improvement": 0.0,
                    "time_improvement": -6.694730852452992,
                    "length_improvement": 23.260318566833043,
                    "smoothness_improvement": 2865.9871523804313,
                    "objective_score": 26.277707646266084
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1416875123977661,
                    "num_nodes_avg": 753.3,
                    "path_length_avg": 119.78501316134012,
                    "smoothness_avg": 0.13949436748541644,
                    "success_improvement": 0.0,
                    "time_improvement": -191.60986883749686,
                    "length_improvement": 20.444497807613494,
                    "smoothness_improvement": 1674.358058011333,
                    "objective_score": -36.844471676624295
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An efficient informed RRT* planner that combines heuristic-driven sampling within an ellipsoidal informed set to focus exploration near the start-to-goal path, employs a fixed-radius rewiring strategy, and terminates early once a feasible path is found. This approach leverages heuristic pruning to reduce planning time and improves path quality by iterative rewiring focused on promising regions.",
          "planning_mechanism": "The planner grows a single tree from start, samples points preferentially within an ellipsoidal subset defined by the current best path cost to the goal (informed sampling), uses a fixed neighbor radius for rewiring new nodes, and updates parents to minimize path cost. Collision checks are conducted for each node and edge before insertion. The algorithm halts immediately when a path to the goal is found or when a 30-second time limit expires, returning the best path discovered so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.15, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision check\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Edge collision check with adaptive resolution\n            dist_edge = dist(p1,p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1,int(dist_edge/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Informed sampling related functions\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Calculate ellipse parameters for informed sampling\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path found yet, sample uniformly\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Calculate unit vector between start and goal\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal\n                return x_start\n\n            # Ellipsoid parameters\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Rotation matrix aligning x-axis to unit vector a1\n            # For 2D and 3D, we compute a rotation matrix using Gram-Schmidt or an identity fallback.\n            # We'll only build rotation matrix for 2D and 3D\n            def build_rotation_matrix(a):\n                # a: unit vector\n                # Build full basis with a and orthogonals\n                if dim == 2:\n                    # 2D rotation matrix rotating x-axis to a\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim == 3:\n                    # Use standard basis and Gram Schmidt for orthonormal frame\n                    x_axis = a\n                    # Choose arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    # Orthogonalize\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        # Degenerate case fallback to identity\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    # Third axis is cross product\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    # Transpose R to get column vectors\n                    return [[R[0][0],R[1][0],R[2][0]],\n                            [R[0][1],R[1][1],R[2][1]],\n                            [R[0][2],R[1][2],R[2][2]]]\n                else:\n                    # For other dims fallback uniform sampling\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best/2.0\n            if c_best < c_min:\n                # numerical safety\n                r2 = 0.0001\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            # For dim==2, ellipse radii = [r1, r2],\n            # For dim==3, radii = [r1, r2, r2]\n\n            radii = [r1] + [r2]*(dim-1)\n\n            # Sample point in unit n-ball via Gaussian and normalize\n            while True:\n                # Sample n dim gaussian\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            # Scale by uniform radius in [0,1]^(1/dim)\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            # Rotation and translation back to world frame: sample = R * sample_ball + center\n            sample = [0.0]*dim\n            # Matrix multiplication: sample = R * sample_ball\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            # Clamp sample inside bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [start_pos]\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Fixed radius pruning upper bound to avoid huge neighbors\n        fixed_radius = self.neighbor_radius\n\n        # Nearest neighbor search (linear)\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(positions[0], p)\n            for i in range(1,len(positions)):\n                dcur = dist(positions[i], p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        # Find neighbors within fixed radius\n        def nearby_nodes(p, radius):\n            result = []\n            for i, pos in enumerate(positions):\n                if dist(pos,p) <= radius:\n                    result.append(nodes[i])\n            return result\n\n        for iter in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Find nearest node\n            near_node, _ = nearest_node(sample)\n\n            # Steer toward sample\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            # Node collision & bounds check\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision from nearest to new_pos\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Find neighbors for rewiring\n            neighbors = nearby_nodes(new_pos, fixed_radius)\n\n            # Choose best parent among neighbors\n            min_cost = near_node.cost + dist(near_node.position,new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position,new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position,new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check goal connection possibility\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                positions.append(goal_pos)\n                edges.append((new_node, goal_node))\n\n                # Update best solution cost and node\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early stop on first found path\n                    break\n\n        # If best path found, extract it\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            # Find closest node\n            min_dist = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 18.33169,
          "time_improvement": -104.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 277.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03312251567840576,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 163.67692862769394,
                    "smoothness_avg": 0.020726203772078875,
                    "success_improvement": 0.0,
                    "time_improvement": -31.81725886398311,
                    "length_improvement": 10.28608179225304,
                    "smoothness_improvement": 224.41009670489822,
                    "objective_score": -2.251478100318617
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2541221618652344,
                    "num_nodes_avg": 968.5,
                    "path_length_avg": 223.78483919358527,
                    "smoothness_avg": 0.016494501307333334,
                    "success_improvement": 0.0,
                    "time_improvement": -58.106259320137475,
                    "length_improvement": 25.29417938773204,
                    "smoothness_improvement": 324.4153991467646,
                    "objective_score": -0.633293167668195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15669703483581543,
                    "num_nodes_avg": 482.5,
                    "path_length_avg": 117.3805344167902,
                    "smoothness_avg": 0.030113844927462913,
                    "success_improvement": 0.0,
                    "time_improvement": -222.5012635370204,
                    "length_improvement": 22.04143810076968,
                    "smoothness_improvement": 283.0458847045111,
                    "objective_score": -52.11028677712176
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified single-tree RRT* planner with goal bias sampling, fixed rewiring radius, early stopping upon finding the first valid path within a 30-second time limit. The planner incrementally builds a tree by sampling points, extending towards them with fixed step size while avoiding obstacles. Upon adding new nodes, neighbors within a fixed radius are rewired to reduce path cost, improving path quality and smoothness. The algorithm prioritizes efficiency and path optimization through adaptive rewiring and goal bias, returning the best found path in time.",
          "planning_mechanism": "The planner samples states biased towards the goal with a fixed goal sample rate. Each sample is steered from the nearest tree node with a fixed step size, checked for collision, and connected if valid. Then, neighbors within a fixed radius are rewired to potentially improve path costs. The planner stops early once a feasible path to the goal is found or after 30 seconds. Finally, the path is extracted from the best goal-reaching node or the closest node to goal if none.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.rewire_radius = 15.0  # Fixed radius for neighbor rewiring\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: dist(n.position, point))\n\n        def near_nodes(nodes_list, point, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, point) <= radius]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for _ in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = uniform_sample()\n\n            nearest = nearest_node(nodes, sample)\n            new_pos = steer(nearest.position, sample)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            # Find best parent among near nodes\n            neighbors = near_nodes(nodes, new_pos, self.rewire_radius)\n            best_parent = nearest\n            best_cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < best_cost_to_new:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        best_parent = nbr\n                        best_cost_to_new = tentative_cost\n\n            new_node = Node(new_pos, best_parent, best_cost_to_new)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better cost\n            for nbr in neighbors:\n                if nbr == best_parent or nbr == new_node:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if rewired_cost < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        old_parent = nbr.parent\n                        if old_parent:\n                            old_parent.remove_child(nbr)\n                            try:\n                                edges.remove((old_parent, nbr))\n                            except ValueError:\n                                pass\n                        new_node.add_child(nbr)\n                        nbr.cost = rewired_cost\n                        edges.append((new_node, nbr))\n\n            # Check if goal can be connected directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_cost:\n                        goal_node = Node(goal_pos, new_node, goal_cost)\n                        new_node.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_cost = goal_cost\n                        # Early stopping on first path found\n                        break\n\n        success = best_goal_node is not None\n        if success:\n            extracted_path = best_goal_node.path_from_root()\n        else:\n            closest_node = min(nodes, key=lambda n: dist(n.position, goal_pos))\n            extracted_path = closest_node.path_from_root()\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 19.84466,
          "time_improvement": -109.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 289.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.048426270484924316,
                    "num_nodes_avg": 279.7,
                    "path_length_avg": 160.81894805919956,
                    "smoothness_avg": 0.021476210214576158,
                    "success_improvement": 0.0,
                    "time_improvement": -92.72141929999013,
                    "length_improvement": 11.852586229445006,
                    "smoothness_improvement": 236.1493261950383,
                    "objective_score": -19.52412742135484
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2466820478439331,
                    "num_nodes_avg": 968.6,
                    "path_length_avg": 224.33104868500922,
                    "smoothness_avg": 0.016593750167991854,
                    "success_improvement": 0.0,
                    "time_improvement": -53.47727069439503,
                    "length_improvement": 25.111838937726233,
                    "smoothness_improvement": 326.9691438175732,
                    "objective_score": 0.6587678734050977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13675882816314697,
                    "num_nodes_avg": 424.7,
                    "path_length_avg": 119.83094620225563,
                    "smoothness_avg": 0.03180515707284166,
                    "success_improvement": 0.0,
                    "time_improvement": -181.46604642946517,
                    "length_improvement": 20.413991268933778,
                    "smoothness_improvement": 304.5592503540521,
                    "objective_score": -40.66862291570902
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, unidirectional RRT* algorithm with goal bias sampling, fixed step extension, fixed-radius rewiring, and immediate termination upon successful goal connection, emphasizing efficient local cost improvements and early path discovery for improved planning time and path quality.",
          "planning_mechanism": "A tree grows from the start by sampling mostly uniformly with occasional sampling of the goal to speed convergence. Each iteration extends towards the sampled point by a fixed step size clipped within map bounds, checks node and edge collisions, selects the lowest-cost parent within a fixed radius, adds the new node, rewires neighbors to improve local path costs, and terminates immediately when a collision-free connection to the goal vicinity is found. The final path is extracted by tracing parents from goal to start.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n        self.time_limit_sec = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        start_time = time.monotonic()\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Goal bias sampling\n            sample = goal_pos if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors within rewiring radius\n            neighbors = [n for n in nodes if dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select best parent minimizing cost + distance, checking edge collision\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if better and collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # Early stopping if new node close enough to goal and collision free connection\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 21.50785,
          "time_improvement": -106.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 173.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06068551540374756,
                    "num_nodes_avg": 318.7,
                    "path_length_avg": 168.18065361864075,
                    "smoothness_avg": 0.015896461857993056,
                    "success_improvement": 0.0,
                    "time_improvement": -141.5093820450733,
                    "length_improvement": 7.817518758625687,
                    "smoothness_improvement": 148.81414779702322,
                    "objective_score": -37.018232619361456
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1837256908416748,
                    "num_nodes_avg": 894.7,
                    "path_length_avg": 236.1022438834725,
                    "smoothness_avg": 0.01116483989364266,
                    "success_improvement": 0.0,
                    "time_improvement": -14.307943497623887,
                    "length_improvement": 21.18227516541151,
                    "smoothness_improvement": 187.2793721725527,
                    "objective_score": 9.353378910822503
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.12804923057556153,
                    "num_nodes_avg": 504.7,
                    "path_length_avg": 122.2273744873662,
                    "smoothness_avg": 0.022171094224557604,
                    "success_improvement": 0.0,
                    "time_improvement": -163.54065154347794,
                    "length_improvement": 18.822397707615522,
                    "smoothness_improvement": 182.01468203642764,
                    "objective_score": -36.85868342829193
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An efficient adaptive informed RRT* planner that incorporates KD-tree acceleration for neighbor searches, a dynamic neighbor radius shrinking inversely with the tree growth, balanced goal biasing, and an enhanced multi-pass shortcut path smoothing step. It enforces a strict 30-second time limit and always returns the best found path. The algorithm prioritizes feasible, low-cost connections and rewiring while limiting unnecessary collision checks through spatial indexing. Post-processing uses repeated shortcut attempts along the path to significantly improve smoothness and reduce path length.",
          "planning_mechanism": "The planner grows a single tree from start and samples with goal bias and ellipsoidal informed sampling after first solution to focus search efficiently. A KD-tree (implemented via a simple grid-based spatial hash due to constraints) helps quickly find k-nearest neighbors within a shrinking radius. Nodes are rewired to minimize cost, and path improvements are tracked continuously. On timeout or iteration max, the best path is extracted and refined by iterative shortcutting before returning.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            self.cost = new_cost\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 max_neighbor_radius: float=20.0, min_neighbor_radius: float=3.5,\n                 k_nearest: int=15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.k_nearest = k_nearest\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def steer(from_pos, to_pos, max_dist):\n            vect = tuple(to_pos[i] - from_pos[i] for i in range(dim))\n            length = math.sqrt(sum(v*v for v in vect))\n            if length <= max_dist:\n                return to_pos\n            ratio = max_dist / length\n            new_p = tuple(from_pos[i] + vect[i]*ratio for i in range(dim))\n            return new_p\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            resolution = min(1.0, self.step_size*0.3)\n            distance = dist(p1,p2)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return sample_uniform()\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n            center = tuple((x_start[i]+x_goal[i])*0.5 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            # Build rotation matrix (for 2D or 3D)\n            R = None\n            if dim == 2:\n                # rotation angle\n                cos_theta = a1[0]\n                sin_theta = a1[1]\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a1\n                # Create orthonormal basis starting with x_axis\n                # Gram-Schmidt-like\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1.0,0.0,0.0)\n                else:\n                    temp = (0.0,1.0,0.0)\n                v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = [[1.0, 0.0, 0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    v_unit = tuple(vi / norm_v for vi in v)\n                    w = (x_axis[1]*v_unit[2]-x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0]-x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1]-x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    R = [[R[0][0], R[1][0], R[2][0]],\n                         [R[0][1], R[1][1], R[2][1]],\n                         [R[0][2], R[1][2], R[2][2]]]\n            else:\n                # fallback uniform\n                return sample_uniform()\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                # Sample unit ball with Gaussian and normalize\n                rand_gauss = [random.gauss(0,1) for _ in range(dim)]\n                norm_gp = math.sqrt(sum(x*x for x in rand_gauss))\n                if norm_gp > 1e-10:\n                    break\n            unit_ball = [x / norm_gp for x in rand_gauss]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            # Rotate and translate sample_ball by R and center\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            # Clip to bounds\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # --- Spatial Hash Grid for Accelerated Neighbor Search ---\n        # Grid cell size ~ adaptive radius (will update dynamically)\n        class SpatialGrid:\n            def __init__(self, dims, cell_size):\n                self.dims = dims\n                self.cell_size = cell_size\n                self.cells = dict()\n\n            def _cell_coords(self, p):\n                return tuple(int(p[i]//self.cell_size) for i in range(self.dims))\n\n            def insert(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def neighbors(self, p, radius):\n                cell_r = int(math.ceil(radius / self.cell_size))\n                center_cell = self._cell_coords(p)\n                neighbors = []\n                for dx in range(-cell_r, cell_r+1):\n                    for dy in range(-cell_r, cell_r+1):\n                        for dz in range(cell_r*0, cell_r* (1 if self.dims>2 else 0)+1):\n                            if self.dims == 2 and dz != 0:\n                                continue\n                            c = (center_cell[0]+dx, center_cell[1]+dy) if self.dims==2 else (center_cell[0]+dx, center_cell[1]+dy, center_cell[2]+dz)\n                            if c in self.cells:\n                                neighbors.extend(self.cells[c])\n                return neighbors\n\n            def clear(self):\n                self.cells.clear()\n\n        # Initialize tree and grid\n        root = Node(start_pos)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_goal_cost = float('inf')\n\n        # Initial neighbor radius parameters\n        gamma_rrt_star = self.max_neighbor_radius\n        def radius_adaptive(n):\n            if n < 2:\n                return gamma_rrt_star\n            val = (math.log(n)/n)**(1/dim)\n            r = gamma_rrt_star * val\n            r = max(r, self.min_neighbor_radius)\n            r = min(r, self.max_neighbor_radius)\n            return r\n\n        # Build spatial grid for neighbors with approximate initial radius:\n        spatial_grid = SpatialGrid(dim, self.max_neighbor_radius)\n\n        # Insert initial node\n        spatial_grid.insert(root)\n\n        def nearest_node(p):\n            # linear fallback if few nodes\n            if len(nodes)<25:\n                best = None\n                bd = float('inf')\n                for nd in nodes:\n                    d = dist_sq(p, nd.position)\n                    if d < bd:\n                        bd = d\n                        best = nd\n                return best, math.sqrt(bd)\n            # else find nearby neighbors and pick closest\n            nearns = spatial_grid.neighbors(p, radius_adaptive(len(nodes))*2.5)\n            best = None\n            bd = float('inf')\n            for nd in nearns:\n                d = dist_sq(p, nd.position)\n                if d < bd:\n                    bd = d\n                    best = nd\n            if best is None:\n                # fallback\n                best = nodes[0]\n                bd = dist(p, best.position)\n            return best, math.sqrt(bd)\n\n        def k_nearest_neighbors(p, radius, k):\n            neighbors_candidates = spatial_grid.neighbors(p, radius)\n            neighbors = []\n            r2 = radius*radius\n            for nd in neighbors_candidates:\n                d2 = dist_sq(p, nd.position)\n                if d2 <= r2:\n                    neighbors.append((d2, nd))\n            neighbors.sort(key=lambda x:x[0])\n            return [nd for (_,nd) in neighbors[:k]]\n\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path)<=2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_outer = 3  # multiple passes for better smoothing\n            for _ in range(max_outer):\n                if not improved:\n                    break\n                improved = False\n                i = 0\n                while i < len(new_path)-2:\n                    j = i+2\n                    while j < len(new_path):\n                        if is_free_edge(new_path[i], new_path[j]):\n                            # remove intermediate points between i and j\n                            del new_path[i+1:j]\n                            improved = True\n                            j = i+2  # restart inner loop\n                        else:\n                            j += 1\n                    i += 1\n            return new_path\n\n        success = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            if time.monotonic()-start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            near_node, _ = nearest_node(sample)\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            curr_radius = radius_adaptive(len(nodes))\n            neighbors = k_nearest_neighbors(new_pos, curr_radius, self.k_nearest)\n            # Always include near_node if not already in neighbors\n            if near_node not in neighbors:\n                neighbors.append(near_node)\n\n            # Choose parent with minimum cost\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                if nb == near_node:\n                    continue\n                tent_cost = nb.cost + dist(nb.position, new_pos)\n                if tent_cost < min_cost:\n                    if is_free_edge(nb.position, new_pos):\n                        min_cost = tent_cost\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.insert(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    # Remove old edge if present\n                    old_edge = (nb.parent, nb)\n                    if old_edge in edges:\n                        edges.remove(old_edge)\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check connection to goal within step_size\n            d_goal = dist(new_pos, goal_pos)\n            if d_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_node.update_parent(new_node, new_node.cost + d_goal)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                spatial_grid.insert(goal_node)\n\n                if goal_node.cost < best_goal_cost:\n                    best_goal_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success = True\n                    # Early stopping on first solution found with improved rewiring\n                    break\n\n        # Extract best path\n        if best_goal_node is not None:\n            # Extract path\n            cur = best_goal_node\n            while cur is not None:\n                extracted_path.append(cur.position)\n                cur = cur.parent\n            extracted_path.reverse()\n        else:\n            # Extract path to closest node to goal\n            best_node = None\n            min_d = float('inf')\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    best_node = n\n            if best_node is not None:\n                cur = best_node\n                while cur is not None:\n                    extracted_path.append(cur.position)\n                    cur = cur.parent\n                extracted_path.reverse()\n\n        # Post-processing shortcut to smooth path\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges)\n    \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
          "objective": 22.27113,
          "time_improvement": -135.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1937.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.065567946434021,
                    "num_nodes_avg": 473.2,
                    "path_length_avg": 173.25001436874106,
                    "smoothness_avg": 0.0634004806256209,
                    "success_improvement": 0.0,
                    "time_improvement": -160.93993138051178,
                    "length_improvement": 5.038921802334119,
                    "smoothness_improvement": 892.3551981382319,
                    "objective_score": -40.7968503420619
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21451115608215332,
                    "num_nodes_avg": 1157.3,
                    "path_length_avg": 241.25812171610295,
                    "smoothness_avg": 0.1362260220044085,
                    "success_improvement": 0.0,
                    "time_improvement": -33.4616242111676,
                    "length_improvement": 19.461094741164523,
                    "smoothness_improvement": 3405.193665811055,
                    "objective_score": 18.66413791040371
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15021958351135253,
                    "num_nodes_avg": 608.3,
                    "path_length_avg": 124.22347757560189,
                    "smoothness_avg": 0.12692349591278687,
                    "success_improvement": 0.0,
                    "time_improvement": -209.1698929796411,
                    "length_improvement": 17.496681080624192,
                    "smoothness_improvement": 1514.4574994927048,
                    "objective_score": -44.680671748054294
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved single-tree RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping. The planner dynamically adjusts neighbor search radius based on the number of nodes to balance exploration and exploitation, incorporates goal bias with a higher sampling rate for faster convergence, and performs incremental rewiring using efficient neighbor queries. Collision checks are optimized with adaptive edge resolution, and the planner terminates immediately once the goal is connected, ensuring reduced planning time with high-quality, smooth paths.",
          "planning_mechanism": "The algorithm incrementally grows a single tree from start, sampling randomly with goal bias, and steering toward samples with fixed step size. It dynamically computes neighbors within an adaptive radius proportional to log(n)/n for better rewiring efficiency. For each new node, the best parent minimizing cost and verified for collision is chosen, followed by local rewiring to improve path cost and smoothness. Early termination upon reaching the goal with collision-free connection guarantees fast runtime and high success rates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        success = False\n        final_path = []\n\n        # To accelerate nearest neighbor queries, store positions separately\n        positions = [root.position]\n\n        # Adaptive neighbor radius: r = gamma * (log(n)/n)^{1/d} with gamma tuned for good rewiring\n        # Gamma chosen as 30.0 for moderate neighbor count\n        gamma = 30.0\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return gamma\n            return min(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 20)\n\n        # Optimized collision checking resolution based on step_size and distance\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            resolution = min(1.0, self.step_size/2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        # Main loop\n        for iter_id in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                # Time limit reached, break with best path if any\n                break\n\n            # Sample with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search (linear, as no k-d tree available)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Check node collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Check edge collision from nearest_node to new_pos\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius search\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Choose best parent minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improving cost\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list carefully\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if goal can connect directly\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n\n                    # Backtrack path\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success but nodes exist, extract path from best node near goal\n        if not success and len(nodes) > 1:\n            # Find node closest to goal\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                # Extract path backwards\n                path = []\n                current = closest_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 24.4788,
          "time_improvement": -89.0,
          "length_improvement": 3.0,
          "smoothness_improvement": 112.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015737581253051757,
                    "num_nodes_avg": 191.3,
                    "path_length_avg": 179.56403283207513,
                    "smoothness_avg": 0.01421437809371725,
                    "success_improvement": 0.0,
                    "time_improvement": 37.36934591357285,
                    "length_improvement": 1.5781082305555436,
                    "smoothness_improvement": 122.48588418274917,
                    "objective_score": 12.770098133318925
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14423696994781493,
                    "num_nodes_avg": 916.7,
                    "path_length_avg": 303.4419163034794,
                    "smoothness_avg": 0.007145793076982586,
                    "success_improvement": 0.0,
                    "time_improvement": 10.260610067476575,
                    "length_improvement": -1.2976457533873764,
                    "smoothness_improvement": 83.86640277747577,
                    "objective_score": 2.7189275820979253
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20188889503479004,
                    "num_nodes_avg": 778.9,
                    "path_length_avg": 137.83772884194133,
                    "smoothness_avg": 0.01816319064757809,
                    "success_improvement": 0.0,
                    "time_improvement": -315.51152394832013,
                    "length_improvement": 8.454743630501442,
                    "smoothness_improvement": 131.03444436991745,
                    "objective_score": -88.92543878434559
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighbor radius, dynamic goal bias adjustment, informed sampling region pruning, and incremental shortcutting smoothing to improve planning efficiency, path quality, and smoothness within a 30-second hard time limit. The planner grows two trees simultaneously from the start and goal, alternates expansions considering heuristic cost-to-go, adapts neighbor radius based on iteration count and tree size for rewiring, prunes sampling to an informed ellipsoidal region to focus search, ensures collision-free node and edge additions, connects trees when beneficial, and incrementally shortcuts the combined path to reduce jaggedness, ensuring robust and timely path planning.",
          "planning_mechanism": "A bidirectional planner expanding start and goal trees alternately, sampling partially biased toward the goal and within an ellipsoidal informed subset that shrinks with best path cost found; steering with fixed step size; rewiring neighbors inside an adaptively shrinking radius; attempting connections between trees within neighborhood; verifying collision-free nodes and edges strictly; upon feasible path found or 30s elapsed, returns best path merged from both trees with an iterative shortcutting post-process for smoothness and shortened length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=8000, step_size: float=4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit_sec = 30.0\n        self.goal_sample_rate_min = 0.05\n        self.goal_sample_rate_max = 0.15\n        self.neighbor_gamma = 40.0  # heuristic for radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Helpers\n        def dist(a,b): return math.dist(a,b)\n\n        def clamp_pos(p):\n            return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n\n        def steer(from_pos, to_pos, step=None):\n            step = step if step is not None else self.step_size\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return clamp_pos(to_pos)\n            ratio = step / d\n            return clamp_pos(tuple(from_pos[i] + (to_pos[i]-from_pos[i]) * ratio for i in range(dim)))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=0.5):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Adaptive neighbor radius depending on iteration and tree size\n        def neighbor_radius(num_nodes, iteration):\n            if num_nodes < 2:\n                return max(10.0, self.step_size*3.0)\n            r_max = max(bounds)*0.3\n            r_min = max(self.step_size, 3.0)\n            radius = self.neighbor_gamma * ((math.log(num_nodes) / num_nodes) ** (1/dim))\n            decay = 1.0 - min(iteration/self.max_iter,1.0)\n            return max(r_min, min(r_max, radius * decay))\n\n        # Compute an ellipsoid (in 2D or 3D) for informed sampling given start, goal and cost c_best\n        # Returns a function that returns samples uniformly inside that ellipsoid (or nothing if not informed)\n        def informed_sampler(c_best):\n            if c_best == float('inf'):\n                # No solution found, uniform in all bounds\n                def sampler():\n                    while True:\n                        p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                        if not is_in_obstacle(p):\n                            return p\n                return sampler\n            else:\n                c_min = dist(start_pos, goal_pos)\n                if c_best < c_min:\n                    # Numerical safeguard\n                    c_best = c_min\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                # Coordinate transform for ellipse axes\n                vec = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n                length = dist(start_pos, goal_pos)\n                if length == 0:\n                    unit_vec = tuple(1.0 for _ in range(dim))\n                else:\n                    unit_vec = tuple(v/length for v in vec)\n\n                # Rotation matrix to align x-axis to unit_vec\n                import numpy as np\n                # Construct rotation matrix via SVD or Gram-Schmidt\n                # But since imports disallowed, proceed with simple 2D rotation or identity in 3D\n                # Approximate by sampling inside axis-aligned box scaled using ellipse radii\n                # Ellipsoid radii:\n                r1 = c_best * 0.5  # major axis radius\n                r2 = math.sqrt(c_best**2 - length**2) * 0.5 if c_best**2 - length**2 > 0 else 0.0\n                if dim==2:\n                    # rotate samples after axis-aligned sampling\n                    # angle of line from start to goal\n                    angle = math.atan2(unit_vec[1], unit_vec[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n\n                    def sampler():\n                        for _ in range(100):\n                            # sample in unit disk with radii r1,r2\n                            # Uniform sampling inside ellipse:\n                            u = random.uniform(0,1)\n                            theta = random.uniform(0, 2*math.pi)\n                            r = math.sqrt(u)\n                            x_ell = r * math.cos(theta)\n                            y_ell = r * math.sin(theta)\n                            # scale\n                            x_s = x_ell * r1\n                            y_s = y_ell * r2\n                            # rotate back\n                            px = center[0] + x_s * cos_a - y_s * sin_a\n                            py = center[1] + x_s * sin_a + y_s * cos_a\n                            p = (px, py)\n                            if 0.0 <= px <= bounds[0] and 0.0 <= py <= bounds[1] and not is_in_obstacle(p):\n                                return p\n                        # fallback uniform if fail\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n                elif dim==3:\n                    # Approximate axis-aligned ellipsoid sampling (no rotation)\n                    def sampler():\n                        for _ in range(100):\n                            # sample in unit ball then scale axes by r1, r2\n                            while True:\n                                x = random.uniform(-1,1)\n                                y = random.uniform(-1,1)\n                                z = random.uniform(-1,1)\n                                if x*x + y*y + z*z <= 1:\n                                    break\n                            px = center[0] + x * r1\n                            py = center[1] + y * r2\n                            pz = center[2] + z * r2\n                            if (0.0 <= px <= bounds[0] and 0.0 <= py <= bounds[1] and 0.0 <= pz <= bounds[2]):\n                                p = (px, py, pz)\n                                if not is_in_obstacle(p):\n                                    return p\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n                else:\n                    # fallback to uniform sampling\n                    def sampler():\n                        while True:\n                            p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(p):\n                                return p\n                    return sampler\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in tree:\n                # squared distance\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def reconstruct_path(node_start: Node, node_goal: Node) -> List[Tuple[float,...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                # Should not happen as they should connect at different nodes\n                return path_start\n            # Remove duplicate connecting point if any\n            # Reverse goal path so it goes from connection to goal\n            path_goal_rev = path_goal[::-1]\n            # If connection point matches start path end and goal path start, remove duplication\n            if path_start[-1] == path_goal_rev[0]:\n                path_goal_rev = path_goal_rev[1:]\n            return path_start + path_goal_rev\n\n        # Incremental shortcutting to smooth path by iteratively removing collisions-free shortcuts\n        def shortcut_path(path: List[Tuple[float,...]], max_iterations=20) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize start and goal trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_tree_start = True\n\n        # Initial uninformed sampler (no cost known)\n        sample_func = informed_sampler(best_cost)\n\n        # Dynamic goal bias (adapts to iteration count)\n        def dynamic_goal_bias(iteration):\n            # Linear interpolation from max to min over iterations\n            return self.goal_sample_rate_max - (self.goal_sample_rate_max - self.goal_sample_rate_min)*(iteration/self.max_iter)\n\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit_sec:\n                break\n\n            # Refresh informed sampling when better cost found\n            sample_func = informed_sampler(best_cost)\n            goal_bias = dynamic_goal_bias(iteration)\n\n            # Select which tree to expand\n            tree_a = tree_start if expand_tree_start else tree_goal\n            tree_b = tree_goal if expand_tree_start else tree_start\n\n            # Goal bias with informed sampling\n            if random.random() < goal_bias:\n                sample = goal_pos if not is_in_obstacle(goal_pos) else sample_func()\n            else:\n                sample = sample_func()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_tree_start = not expand_tree_start\n                continue\n\n            nradius = neighbor_radius(len(tree_a), iteration)\n            neighbors = near_nodes(tree_a, new_pos, nradius)\n\n            # Determine best parent for new node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors for potential cost improvements\n            for nb in neighbors:\n                if nb in (best_parent, new_node):\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if alt_cost + 1e-12 < nb.cost:\n                        # Remove old edge\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        nb.parent = new_node\n                        edges.append((new_node, nb))\n\n            # Attempt to connect new_node to nodes in other tree within radius\n            near_other = near_nodes(tree_b, new_node.position, nradius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_tree_start else other_node\n                    best_goal_node = other_node if expand_tree_start else new_node\n                    success = True\n\n            if success:\n                break\n\n            expand_tree_start = not expand_tree_start\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            extracted_path = reconstruct_path(best_start_node, best_goal_node)\n            # Apply incremental shortcutting smoothing\n            extracted_path = shortcut_path(extracted_path, max_iterations=25)\n\n        elif tree_start:\n            # Return best partial path nearest to goal from start tree\n            best_partial = None\n            best_dist = float('inf')\n            for node in tree_start:\n                dd = dist(node.position, goal_pos)\n                if dd < best_dist and node.valid:\n                    best_dist = dd\n                    best_partial = node\n            if best_partial:\n                extracted_path = best_partial.path_from_root()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)",
          "objective": 29.60407,
          "time_improvement": -139.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 751.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08773047924041748,
                    "num_nodes_avg": 173.1,
                    "path_length_avg": 172.33390380845606,
                    "smoothness_avg": 0.03223173666731344,
                    "success_improvement": 0.0,
                    "time_improvement": -249.13988431847338,
                    "length_improvement": 5.541056517127125,
                    "smoothness_improvement": 404.4966711798946,
                    "objective_score": -69.39484802936627
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08908915519714355,
                    "num_nodes_avg": 325.8,
                    "path_length_avg": 239.0912319858932,
                    "smoothness_avg": 0.03733854897441827,
                    "success_improvement": 0.0,
                    "time_improvement": 44.57172498917517,
                    "length_improvement": 20.1844649035712,
                    "smoothness_improvement": 860.7477589815499,
                    "objective_score": 29.785935233803023
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15108349323272705,
                    "num_nodes_avg": 396.4,
                    "path_length_avg": 127.61080596635233,
                    "smoothness_avg": 0.08542311378049142,
                    "success_improvement": 0.0,
                    "time_improvement": -210.94792264699964,
                    "length_improvement": 15.246978850732443,
                    "smoothness_improvement": 986.5757020094738,
                    "objective_score": -49.20331097361306
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced informed RRT* planner with adaptive neighbor radius decreasing as the tree grows, combined with fast k-nearest neighbor search optimization, intelligent goal biasing, and efficient path shortcutting for improved smoothness and shorter path lengths. It terminates early upon first path discovery within a hard 30-second limit and always maintains valid collision-free nodes and edges.",
          "planning_mechanism": "The planner grows a tree rooted at the start node by sampling points biased towards the goal and within an ellipsoidal informed subset if a solution exists. It adaptively adjusts neighbor radius inversely proportional to the logarithm of the tree size to reduce rewiring overhead and enhances local rewiring quality. After path discovery, it applies an iterative shortcutting pass to remove unnecessary waypoints, improving smoothness. A combination of efficient collision checking and early pruning ensures fast and robust exploration within the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0, goal_sample_rate=0.2, max_neighbor_radius=20.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float,...], b: Tuple[float,...]) -> float:\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        def sample_informed(c_best, x_start, x_goal):\n            # If no solution yet, sample uniform\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(vi / norm_v for vi in v)\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                val = c_best*c_best - c_min*c_min\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n\n            radii = [r1] + [r2]*(dim - 1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # K-Nearest linear search as a proxy for efficient neighbor search\n        def nearest_node(p):\n            best_idx = 0\n            best_d = dist(nodes[0].position, p)\n            for i in range(1, len(nodes)):\n                di = dist(nodes[i].position, p)\n                if di < best_d:\n                    best_d = di\n                    best_idx = i\n            return nodes[best_idx], best_d\n\n        def radius_adaptive(num_nodes):\n            # Decrease with number of nodes for efficiency but keep lower bound\n            # Formula inspired by theoretical RRT* radius: gamma*(log(n)/n)^(1/d)\n            if num_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(num_nodes)/num_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        def nearby_nodes(p, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in nodes:\n                # squared distance to avoid sqrt cost\n                d2 = 0.0\n                pos = node.position\n                for i in range(dim):\n                    diff = pos[i] - p[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        # Shortcutting to improve smoothness & shorten path after solution found.\n        def shortcut_path(path: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iterations = 200\n            iteration = 0\n            while improved and iteration < max_iterations and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sampling with goal bias and informed sampling if path found\n            if (random.random() < self.goal_sample_rate):\n                sample = goal_pos\n            else:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Nearest node\n            near_node, _ = nearest_node(sample)\n            new_pos = steer(near_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(near_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            curr_radius = radius_adaptive(len(nodes))\n\n            neighbors = nearby_nodes(new_pos, curr_radius)\n\n            # Choose best parent among neighbors (including near_node)\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper to go via new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost < best_goal_cost:\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    # Early terminate on first found path\n                    break\n\n        success = False\n        extracted_path = []\n\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n            # Apply shortcutting for smoothness & length improvement\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # No exact goal reached: extract path from node closest to goal\n            min_d = float('inf')\n            best_node = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    best_node = n\n            if best_node is not None:\n                current = best_node\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 29.88804,
          "time_improvement": -160.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1607.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024425053596496583,
                    "num_nodes_avg": 213.1,
                    "path_length_avg": 166.19028261184675,
                    "smoothness_avg": 0.04801196561764766,
                    "success_improvement": 0.0,
                    "time_improvement": 2.795921543027604,
                    "length_improvement": 8.908472646896378,
                    "smoothness_improvement": 651.4915215682581,
                    "objective_score": 9.441317658887398
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.29114747047424316,
                    "num_nodes_avg": 1011.8,
                    "path_length_avg": 232.2715272372731,
                    "smoothness_avg": 0.09733131184942458,
                    "success_improvement": 0.0,
                    "time_improvement": -81.14216064167789,
                    "length_improvement": 22.461078642977945,
                    "smoothness_improvement": 2404.4047587959576,
                    "objective_score": 1.1560227872631899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.24303045272827148,
                    "num_nodes_avg": 613.8,
                    "path_length_avg": 123.0584057279423,
                    "smoothness_avg": 0.14673052153342167,
                    "success_improvement": 0.0,
                    "time_improvement": -400.1857767440491,
                    "length_improvement": 18.27046632708009,
                    "smoothness_improvement": 1766.4014033846272,
                    "objective_score": -100.26144621004354
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with goal bias sampling, fixed rewiring radius, and early termination to efficiently find and improve paths. It grows two trees from start and goal positions, alternates between them to expand new nodes by steering toward sampled points, rewires near neighbors within a fixed radius to optimize costs, and attempts to connect the two trees when nodes are close enough. Upon connection, it immediately returns the optimized path, ensuring faster convergence and higher path quality through continuous rewiring.",
          "planning_mechanism": "The planner maintains two trees and alternately extends them by sampling points with a small probability of sampling the goal directly (goal bias). Each new node chooses its parent from nearby nodes that yields minimal cost without collision, then rewires neighbors to improve their costs if possible. When the trees are close enough and a collision-free edge can connect them, the algorithm generates the combined path and stops early, returning an optimized, smooth path quickly.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_to_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0, goal_bias: float=0.05, time_limit_sec: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_bias = goal_bias\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n\n        def clamp(p):\n            return tuple(\n                min(max(p[d], 0.0), bounds[d]) for d in range(dim)\n            )\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp(to_pos)\n            ratio = self.step_size / d\n            return clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim)))\n\n        def sample_free():\n            if random.random() < self.goal_bias:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if dist(node.position, pos) <= self.radius]\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                # Time limit reached; return best found\n                return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n            rand_point = sample_free()\n            # Alternate trees each iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if time.monotonic() - start_time > self.time_limit_sec:\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: dist(n.position, rand_point))\n                new_pos = steer(nearest.position, rand_point)\n\n                # Check node and edge collisions\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Find best parent in radius\n                neighbors = near_nodes(tree_a, new_pos)\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                min_parent = nearest\n                for nb in neighbors:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        cost = nb.cost + dist(nb.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for nb in neighbors:\n                    if nb is min_parent:\n                        continue\n                    if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-10 < nb.cost:\n                        # Update parent/edges\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n                # Check connection to other tree\n                connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                connect_dist = dist(new_node.position, connect_node.position)\n                if connect_dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connect trees and extract path\n                    path_from_start = new_node.path_to_root()\n                    path_from_goal = connect_node.path_to_root()\n                    # Remove duplicate node at connection point if any\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        path_from_goal = path_from_goal[:-1]\n                    full_path = path_from_start + path_from_goal[::-1]\n\n                    success = True\n                    best_path = full_path\n                    # Early stop on connection\n                    return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n        return PlannerResult(success=success, path=best_path, nodes=start_tree + goal_tree + nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 34.17936,
          "time_improvement": -148.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 307.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06862092018127441,
                    "num_nodes_avg": 284.0,
                    "path_length_avg": 170.5991073480199,
                    "smoothness_avg": 0.023639461522089605,
                    "success_improvement": 0.0,
                    "time_improvement": -173.08981258681808,
                    "length_improvement": 6.491925946701232,
                    "smoothness_improvement": 270.00890673302524,
                    "objective_score": -46.68174367435956
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09145197868347169,
                    "num_nodes_avg": 589.8,
                    "path_length_avg": 238.92126140318732,
                    "smoothness_avg": 0.017217767150899767,
                    "success_improvement": 0.0,
                    "time_improvement": 43.10165571180447,
                    "length_improvement": 20.24120597641038,
                    "smoothness_improvement": 343.0255502490592,
                    "objective_score": 26.790348050632865
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20080511569976806,
                    "num_nodes_avg": 632.2,
                    "path_length_avg": 125.97622721535136,
                    "smoothness_avg": 0.03204491385721169,
                    "success_improvement": 0.0,
                    "time_improvement": -313.2809762847595,
                    "length_improvement": 16.332588226871458,
                    "smoothness_improvement": 307.60893895423396,
                    "objective_score": -82.6466952545338
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified RRT* planner with goal-biased sampling, fixed rewiring radius, and early termination upon first goal reach. The planner samples randomly with a small probability of sampling the goal directly, extends the nearest node toward the sample by a fixed step size, determines the best parent among neighbors to minimize cost if connection is collision-free, and rewires nodes nearby to improve path cost and smoothness. The search stops immediately after first path to goal is found, ensuring efficient planning time and decent path quality.",
          "planning_mechanism": "A single tree grows incrementally from start toward goal, using goal bias sampling to accelerate goal approach. Each new node rewires neighbors to optimize path cost locally. Collision checking ensures all nodes and edges are valid. Upon connecting to the goal, the planner terminates early, returning the extracted path by tracing parents.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_time = time.monotonic()\n        time_limit = 30.0  # seconds hard time limit\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n        path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors for rewiring and parent selection\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent minimizing cost + distance\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new node\n            for neighbor in near_nodes:\n                if neighbor == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                            neighbor.update_parent(new_node, alt_cost)\n                            edges.append((new_node, neighbor))\n                        except Exception:\n                            # Edge may already removed; ignore\n                            pass\n\n            # Check if goal can be connected\n            if dist(new_pos, goal_pos) <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist(new_pos, goal_pos)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Extract path\n                    path_tmp = []\n                    current = goal_node\n                    while current:\n                        path_tmp.append(current.position)\n                        current = current.parent\n                    path = path_tmp[::-1]\n                    success = True\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 34.24822,
          "time_improvement": -158.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 287.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05595297813415527,
                    "num_nodes_avg": 282.7,
                    "path_length_avg": 160.14345768443917,
                    "smoothness_avg": 0.020991279248420664,
                    "success_improvement": 0.0,
                    "time_improvement": -122.67536302290098,
                    "length_improvement": 12.22283320768113,
                    "smoothness_improvement": 228.55910353025726,
                    "objective_score": -28.326113464610327
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.23264851570129394,
                    "num_nodes_avg": 948.8,
                    "path_length_avg": 225.03802962507376,
                    "smoothness_avg": 0.017004339084283518,
                    "success_improvement": 0.0,
                    "time_improvement": -44.746079145276,
                    "length_improvement": 24.875828350614626,
                    "smoothness_improvement": 337.5338923690004,
                    "objective_score": 3.189342728630977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19719173908233642,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 118.75610965494363,
                    "smoothness_avg": 0.030953946710724024,
                    "success_improvement": 0.0,
                    "time_improvement": -305.8442144725285,
                    "length_improvement": 21.127846525442067,
                    "smoothness_improvement": 293.73191737772913,
                    "objective_score": -77.60789683960466
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved adaptive single-tree RRT* planner with goal bias, dynamic neighbor radius based on node count, and early stopping upon goal reach. The planner favors efficient rewiring with careful collision checking and incremental path cost updates. It employs adaptive edge resolution during collision checks and maintains structural cleanliness in parent-child relationships and edge lists for performance and path quality improvements.",
          "planning_mechanism": "The planner grows a single tree from start, sampling with goal bias and steering towards samples in fixed increments. It dynamically adjusts the neighborhood radius for rewiring based on the number of nodes, enhancing path optimality. Each new node selects the best feasible parent minimizing cost after collision checks, followed by rewiring neighbors. Early termination triggers upon first successful connection to the goal, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node: \"Node\"):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=4.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], max_dist: float) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        # Adaptive neighbor radius with gamma tuned for rewiring efficiency\n        gamma_rrt_star = 28.0\n\n        def adaptive_radius(n: int) -> float:\n            if n <= 1:\n                return gamma_rrt_star\n            return min(gamma_rrt_star * (math.log(n) / n) ** (1.0 / dim), self.step_size * 15)\n\n        def edge_collision_check(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            length = dist(p1, p2)\n            resolution = max(0.3, min(1.0, self.step_size / 3))\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions = [root.position]\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest neighbor (linear search)\n            nearest_idx = 0\n            min_dist = dist(positions[0], sample)\n            for idx in range(1, len(nodes)):\n                d_cur = dist(positions[idx], sample)\n                if d_cur < min_dist:\n                    min_dist = d_cur\n                    nearest_idx = idx\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            near_indices = []\n            for i, p in enumerate(positions):\n                if dist(p, new_pos) <= radius:\n                    near_indices.append(i)\n\n            # Select best parent by cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is nearest_node:\n                    continue\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost reduction feasible and collision free\n            for i in near_indices:\n                neighbor = nodes[i]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-10 < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        # Update edge list\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Early check if goal can be connected from new node\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_pos, obstacles, is_3d)\n                    and not edge_collision_check(new_pos, goal_pos)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    edges.append((new_node, goal_node))\n                    # Extract path backward\n                    current = goal_node\n                    path = []\n                    while current is not None:\n                        path.append(current.position)\n                        current = current.parent\n                    final_path = path[::-1]\n                    success = True\n                    break\n\n        # If no success, extract path to closest node to goal\n        if not success and len(nodes) > 1:\n            closest_node = None\n            closest_dist = float('inf')\n            for node in nodes:\n                d = dist(node.position, goal_pos)\n                if d < closest_dist:\n                    closest_dist = d\n                    closest_node = node\n            if closest_node is not None:\n                path = []\n                curr = closest_node\n                while curr is not None:\n                    path.append(curr.position)\n                    curr = curr.parent\n                final_path = path[::-1]\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": 40.62874,
          "time_improvement": -147.0,
          "length_improvement": 5.0,
          "smoothness_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03078000545501709,
                    "num_nodes_avg": 301.4,
                    "path_length_avg": 169.94015754806077,
                    "smoothness_avg": 0.01172918236728063,
                    "success_improvement": 0.0,
                    "time_improvement": -22.494800403822644,
                    "length_improvement": 6.853106773786617,
                    "smoothness_improvement": 83.58717437511913,
                    "objective_score": -2.218640184999227
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.24716124534606934,
                    "num_nodes_avg": 1153.3,
                    "path_length_avg": 288.1457264228053,
                    "smoothness_avg": 0.005382166606022733,
                    "success_improvement": 0.0,
                    "time_improvement": -53.775411257902796,
                    "length_improvement": 3.8086627051955624,
                    "smoothness_improvement": 38.48702339087716,
                    "objective_score": -13.654990637299115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.22617616653442382,
                    "num_nodes_avg": 649.7,
                    "path_length_avg": 142.22787312528027,
                    "smoothness_avg": 0.01278763446880862,
                    "success_improvement": 0.0,
                    "time_improvement": -365.4976373084453,
                    "length_improvement": 5.539018833713711,
                    "smoothness_improvement": 62.657766558253144,
                    "objective_score": -106.01259105951408
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An adaptive informed RRT* planner with bidirectional trees, dynamic neighbor radius, ellipsoidal informed sampling after first solution, incremental rewiring, and path shortcutting smoothing to reduce planning time, minimize path length, and improve smoothness while respecting obstacles and bounds. Early termination occurs upon exhausted time or stagnation.",
          "planning_mechanism": "The planner grows two trees from start and goal roles alternately, sampling uniformly initially and then within an ellipsoidal informed region centered on the current best path. New nodes are added by selecting parents with minimal cost from nearby nodes within an adaptively shrinking radius, rewiring neighbors when cheaper paths exist. The algorithm attempts to connect the two trees greedily and updates the best path when successful. Post-processing shortcutting smooths the path. The search respects a strict 30-second limit, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, step_size=5.0, goal_sample_rate=0.15, post_opt_iters=400,\n                 max_no_improve=120, improve_tol=1e-6, time_limit_sec=30.0, gamma_rrt_star=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def _norm(v):\n            return math.sqrt(sum(x * x for x in v))\n\n        def _normalize(v):\n            n = _norm(v)\n            if n < 1e-12:\n                return v\n            return tuple(x / n for x in v)\n\n        def _cross(a, b):\n            if dim < 3:\n                # 2D cross product returns scalar, extend to vector for 2D by z axis\n                return (0.0, 0.0, a[0]*b[1] - a[1]*b[0])\n            ax, ay, az = a\n            bx, by, bz = b\n            return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = _normalize(_cross(a1, ref))\n                if _norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = _normalize(_cross(a1, ref))\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if (dist(n.position, p) <= radius)]\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no valid neighbor edge connection\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(node_start, node_goal, start_side=True):\n            path_a = node_start.path_from_root()\n            path_b = node_goal.path_from_root()\n            if not path_a or not path_b:\n                return []\n            if path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if start_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            # Sampling with goal bias and informed ellipsoidal sampling after first solution\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt greedy connection from other tree toward new_node\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None,\n                                         cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 41.43107,
          "time_improvement": -201.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1575.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.14945473670959472,
                    "num_nodes_avg": 438.0,
                    "path_length_avg": 157.4473892626623,
                    "smoothness_avg": 0.04397602766973632,
                    "success_improvement": 0.0,
                    "time_improvement": -494.78313509082216,
                    "length_improvement": 13.700591031595073,
                    "smoothness_improvement": 588.3203285039162,
                    "objective_score": -137.27298426577005
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07994420528411865,
                    "num_nodes_avg": 469.7,
                    "path_length_avg": 234.33356839308772,
                    "smoothness_avg": 0.10040367479886572,
                    "success_improvement": 0.0,
                    "time_improvement": 50.26140514853553,
                    "length_improvement": 21.772709952603243,
                    "smoothness_improvement": 2483.458870418663,
                    "objective_score": 40.55934186821592
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1255901575088501,
                    "num_nodes_avg": 398.6,
                    "path_length_avg": 121.22874351866426,
                    "smoothness_avg": 0.13794000424758718,
                    "success_improvement": 0.0,
                    "time_improvement": -158.47958467660814,
                    "length_improvement": 19.485640847330714,
                    "smoothness_improvement": 1654.5866723573045,
                    "objective_score": -27.579557532797494
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm implements an adaptive-radius informed RRT* planner with enhanced sampling, dynamic rewiring radius scaling, and post-processing path shortcutting to improve planning time, path smoothness, and length. It uses a single tree, switching to ellipsoidal informed sampling after the first solution and incorporates goal biasing. The rewiring radius shrinks as the tree grows to limit computation while maintaining path quality. When a valid path is found, the algorithm performs iterative shortcutting to smooth the path before returning it. The planner enforces collision checking on nodes and edges and respects a strict hard 30-second time limit for efficient termination.",
          "planning_mechanism": "The planner incrementally samples and extends a search tree rooted at the start position within map bounds, rejecting samples inside obstacles and edges colliding with obstacles. Initially, uniform random samples explore the space; upon first solution discovery, ellipsoidal informed sampling focused on the current best path is used with goal biasing to accelerate improvement. The rewiring radius adapts by shrinking with the logarithm of node count to reduce expensive neighbor checks as the tree grows. Each iteration selects the best parent among neighbors for the new node and rewires neighbor nodes when beneficial, propagating cost downstream for consistency. After stopping early when no improvement is detected or after reaching iteration or time limits, the current best path undergoes iterative shortcutting by connecting nonconsecutive nodes directly when collision-free, thereby smoothing and shortening the path to improve quality before returning the final result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 max_no_improve: int = 150, improve_tol: float = 1e-8,\n                 goal_sample_prob: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map):\n        import math, random, time\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def point_in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def informed_sample(c_best, c_min):\n            if random.random() < self.goal_sample_prob:\n                return goal_pos\n            if c_best == float('inf'):\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal_pos[d] - start_pos[d] for d in range(dim))\n            length = math.sqrt(sum(x * x for x in diff))\n            if length < 1e-10:\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            e1 = tuple(x / length for x in diff)\n\n            if dim == 2:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r2)\n            elif dim == 3:\n                r1 = c_best / 2.0\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) / 2.0\n                radii = (r1, r_side, r_side)\n            else:\n                for _ in range(50):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            for _ in range(100):\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_raw))\n                if norm < 1e-12:\n                    continue\n                x_unit = [x/norm for x in x_raw]\n                radius_scale = random.random() ** (1.0/dim)\n                x_scaled = [radius_scale * radii[i] * x_unit[i] for i in range(dim)]\n\n                if dim == 2:\n                    cos_a, sin_a = e1[0], e1[1]\n                    x_r = x_scaled[0]*cos_a - x_scaled[1]*sin_a\n                    y_r = x_scaled[0]*sin_a + x_scaled[1]*cos_a\n                    x_rot = (x_r, y_r)\n                elif dim == 3:\n                    v = (1.0,0.0,0.0)\n                    u = e1\n                    dot = sum(v[i]*u[i] for i in range(3))\n                    if abs(dot - 1.0) < 1e-12:\n                        x_rot = x_scaled\n                    elif abs(dot + 1.0) < 1e-12:\n                        x_rot = tuple(-x for x in x_scaled)\n                    else:\n                        k = (v[1]*u[2] - v[2]*u[1], v[2]*u[0] - v[0]*u[2], v[0]*u[1] - v[1]*u[0])\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        k = tuple(kk/k_norm for kk in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = x_scaled\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1], k[2]*v_vec[0]-k[0]*v_vec[2], k[0]*v_vec[1]-k[1]*v_vec[0])\n                        x_rot = [0,0,0]\n                        for i in range(3):\n                            x_rot[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                        x_rot = tuple(x_rot)\n                else:\n                    x_rot = tuple(x_scaled)\n\n                sample = tuple(center[d] + x_rot[d] for d in range(dim))\n                if point_in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n\n            for _ in range(50):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest_node(tree, point):\n            best = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    best = node\n            return best\n\n        def near_nodes(tree, point, radius):\n            res = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i]-point[i]\n                    d_sq += delta*delta\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def propagate_cost_downstream(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if c.cost + self.improve_tol < old_cost:\n                    propagate_cost_downstream(c)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(new_path[-1], path[j]):\n                        new_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    new_path.append(path[i+1])\n                    i += 1\n            return new_path\n\n        root = Node(start_pos, None, 0.0)\n        nodes = [root]\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        for iteration in range(1, self.max_iter + 1):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            x_rand = informed_sample(c_best, c_min)\n            x_nearest = nearest_node(nodes, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if not point_in_bounds(x_new_pos):\n                continue\n            if is_in_obstacle(x_new_pos):\n                continue\n            if is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                continue\n\n            gamma_rrt = 30.0\n            n_nodes = len(nodes) + 1\n            radius = min(\n                gamma_rrt * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)),\n                self.step_size * 4.0\n            )\n\n            near = near_nodes(nodes, x_new_pos, radius)\n            if x_nearest not in near:\n                near.append(x_nearest)\n\n            best_parent = None\n            best_cost_parent = float('inf')\n            for candidate in near:\n                if candidate is best_goal_node:\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, x_new_pos)\n                if candidate_cost < best_cost_parent:\n                    if not is_edge_in_obstacle(candidate.position, x_new_pos):\n                        best_parent = candidate\n                        best_cost_parent = candidate_cost\n\n            if best_parent is None:\n                continue\n\n            x_new = Node(x_new_pos)\n            x_new.parent = best_parent\n            x_new.cost = best_cost_parent\n            best_parent.add_child(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for candidate in near:\n                if candidate is best_parent or candidate is x_new:\n                    continue\n                new_cost = x_new.cost + dist(x_new.position, candidate.position)\n                if new_cost + self.improve_tol < candidate.cost:\n                    if not is_edge_in_obstacle(x_new.position, candidate.position):\n                        old_parent = candidate.parent\n                        if old_parent:\n                            old_parent.remove_child(candidate)\n                            try:\n                                edges.remove((old_parent, candidate))\n                            except ValueError:\n                                pass\n                        candidate.parent = x_new\n                        candidate.cost = new_cost\n                        x_new.add_child(candidate)\n                        edges.append((x_new, candidate))\n                        propagate_cost_downstream(candidate)\n\n            if dist(x_new.position, goal_pos) <= self.step_size:\n                if not is_edge_in_obstacle(x_new.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + dist(x_new.position, goal_pos)\n                    x_new.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    if goal_node.cost + self.improve_tol < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = best_cost\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n        if found_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            # Iterative path shortcutting for smoothness\n            for _ in range(15):\n                new_path = shortcut_path(extracted_path)\n                if len(new_path) >= len(extracted_path):\n                    break\n                extracted_path = new_path\n            success = True\n        else:\n            # fallback: closest node to goal\n            best_node = None\n            best_goal_dist = float('inf')\n            for n in nodes:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < best_goal_dist:\n                    best_goal_dist = d\n                    best_node = n\n            if best_node:\n                extracted_path = best_node.path_from_root()\n            else:\n                extracted_path = []\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 45.48621,
          "time_improvement": -213.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1742.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09093654155731201,
                    "num_nodes_avg": 568.4,
                    "path_length_avg": 162.3128190850525,
                    "smoothness_avg": 0.0546003075997768,
                    "success_improvement": 0.0,
                    "time_improvement": -261.89901017906345,
                    "length_improvement": 11.03377184827377,
                    "smoothness_improvement": 754.6133804021819,
                    "objective_score": -68.17637304274386
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.48117191791534425,
                    "num_nodes_avg": 1256.8,
                    "path_length_avg": 236.54555351247677,
                    "smoothness_avg": 0.12021348492094926,
                    "success_improvement": 0.0,
                    "time_improvement": -199.36897857746058,
                    "length_improvement": 21.03428565128971,
                    "smoothness_improvement": 2993.1795532893693,
                    "objective_score": -32.22422441601749
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.13512969017028809,
                    "num_nodes_avg": 549.9,
                    "path_length_avg": 125.50091367068515,
                    "smoothness_avg": 0.124008874996231,
                    "success_improvement": 0.0,
                    "time_improvement": -178.11308533659152,
                    "length_improvement": 16.64826885123998,
                    "smoothness_improvement": 1477.3837365690517,
                    "objective_score": -36.05804560738821
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified and general RRT* planner employing goal bias sampling and fixed-radius rewiring for efficient exploration and path improvement, with early termination upon connecting to the goal. The algorithm incrementally grows a tree from the start, samples guided by the goal, chooses minimum-cost parents from nearby nodes, rewires neighbors for path cost reduction, and respects a fixed 30-second runtime limit. It ensures collision-free nodes and edges within map bounds, resulting in improved planning time, path length, and smoothness.",
          "planning_mechanism": "The planner samples randomly with goal bias, steers towards samples with a fixed step, selects a parent with minimal cost within a fixed radius, rewires nearby nodes to reduce costs, stops early after reaching the goal, and continuously updates the best path within a 30-second limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            d = dist(a,b)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * (i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(a,b,max_dist):\n            d = dist(a,b)\n            if d <= max_dist:\n                return b\n            ratio = max_dist / d\n            return tuple(a[i] + ratio * (b[i]-a[i]) for i in range(dim))\n\n        def nearest(p, nodes):\n            best = nodes[0]\n            best_dist = dist(best.position, p)\n            for n in nodes[1:]:\n                nd = dist(n.position, p)\n                if nd < best_dist:\n                    best = n\n                    best_dist = nd\n            return best\n\n        def neighbors(p, nodes, radius):\n            return [n for n in nodes if dist(n.position, p) <= radius]\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            sample = goal if random.random() < self.goal_sample_rate else tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(sample, nodes)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            near = neighbors(new_pos, nodes, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near:\n                cost_through_n = n.cost + dist(n.position, new_pos)\n                if cost_through_n < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = cost_through_n\n                    best_parent = n\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for n in near:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new < n.cost and is_free_edge(new_node.position, n.position):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            if dist(new_pos, goal) <= self.step_size and is_free_node(goal) and is_free_edge(new_pos, goal):\n                goal_node = Node(goal)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_pos, goal))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                success = True\n                break\n\n        if success and goal_node:\n            current = goal_node\n        else:\n            current = min(nodes, key=lambda n: dist(n.position, goal)) if nodes else None\n\n        path = []\n        while current:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
          "objective": 47.68358,
          "time_improvement": -195.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 176.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03592822551727295,
                    "num_nodes_avg": 269.5,
                    "path_length_avg": 163.59940352519504,
                    "smoothness_avg": 0.016146991351320243,
                    "success_improvement": 0.0,
                    "time_improvement": -42.98310700541212,
                    "length_improvement": 10.328574529396546,
                    "smoothness_improvement": 152.73547840109603,
                    "objective_score": -5.934109991980229
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.21809957027435303,
                    "num_nodes_avg": 1031.2,
                    "path_length_avg": 233.93696853869142,
                    "smoothness_avg": 0.011299153915374298,
                    "success_improvement": 0.0,
                    "time_improvement": -35.69421479144476,
                    "length_improvement": 21.90510639949459,
                    "smoothness_improvement": 190.73536869418726,
                    "objective_score": 3.388476245734263
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2950052976608276,
                    "num_nodes_avg": 556.0,
                    "path_length_avg": 123.6548444034732,
                    "smoothness_avg": 0.0222822811958645,
                    "success_improvement": 0.0,
                    "time_improvement": -507.15623205900096,
                    "length_improvement": 17.874340158150158,
                    "smoothness_improvement": 183.42897210448282,
                    "objective_score": -140.50512066228777
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 69.43496400372943,
          "time_improvement": -276.0,
          "length_improvement": 21.0,
          "smoothness_improvement": 165.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05916297435760498,
                    "num_nodes_avg": 394.9,
                    "path_length_avg": 155.53505227340733,
                    "smoothness_avg": 0.014549204278916808,
                    "success_improvement": 0.0,
                    "time_improvement": -135.4501446019083,
                    "length_improvement": 14.748773238324494,
                    "smoothness_improvement": 127.72664106782084,
                    "objective_score": -31.14714623223869
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.580695104598999,
                    "num_nodes_avg": 1589.2,
                    "path_length_avg": 226.77578579094256,
                    "smoothness_avg": 0.011489796720712679,
                    "success_improvement": 0.0,
                    "time_improvement": -261.2889569322687,
                    "length_improvement": 24.29571532390974,
                    "smoothness_improvement": 195.64074539000617,
                    "objective_score": -62.831054158384745
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.25779869556427004,
                    "num_nodes_avg": 856.3,
                    "path_length_avg": 115.47581220588968,
                    "smoothness_avg": 0.02144048255314569,
                    "success_improvement": 0.0,
                    "time_improvement": -430.58058912720264,
                    "length_improvement": 23.30646390012476,
                    "smoothness_improvement": 172.72135550421203,
                    "objective_score": -114.32669162056487
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT*-InformedConnect planner with dynamic informed sampling, priority rewiring, and early post-optimization termination to improve planning efficiency, path smoothness and length, and success rate under hard time constraints.",
          "planning_mechanism": "This planner grows two RRT* trees from start and goal alternately, using uniform sampling initially and ellipsoidal informed sampling after the first path found. It employs best-parent selection and incremental rewiring within a dynamically adapted neighborhood radius. After connecting the trees greedily with stepwise attempts, it continuously updates the best path and applies shortcutting smoothing before termination at a time limit or post-optimization stagnation threshold.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 8000,\n        step_size: float = 5.0,\n        goal_sample_rate: float = 0.15,\n        post_opt_iters: int = 400,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-6,\n        time_limit_sec: float = 30.0,\n        gamma_rrt_star: float = 50.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                # Construct orthonormal basis {a1, a2}\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                # For 3D, build orthonormal basis {a1, b2, b3}\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            return min(nodes_list, key=lambda n: dist(n.position, p))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            # Candidate parents with collision-free edges\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                # fallback to nearest if no neighbors valid\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return (not is_edge_in_obstacle(n1.position, n2.position)) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_current = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_current.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_current.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            current = nearest_other\n            connected_other = None\n            tries = 0\n            max_greedy_steps = 20\n\n            while True:\n                tries += 1\n                if tries > max_greedy_steps:\n                    break\n                step_pos = steer(current.position, new_node.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos):\n                    break\n                if is_edge_in_obstacle(current.position, step_pos):\n                    break\n                other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                if other_new is None:\n                    break\n                rewire(other_tree, other_new, other_neighbors, edges)\n                current = other_new\n\n                if dist(current.position, new_node.position) <= self.step_size:\n                    if can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": 70.02349,
          "time_improvement": -295.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1330.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.18990304470062255,
                    "num_nodes_avg": 574.6,
                    "path_length_avg": 151.92005163885307,
                    "smoothness_avg": 0.0438427966152012,
                    "success_improvement": 0.0,
                    "time_improvement": -655.754757440736,
                    "length_improvement": 16.73021236947447,
                    "smoothness_improvement": 586.234973184576,
                    "objective_score": -183.7571249446132
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06414504051208496,
                    "num_nodes_avg": 382.5,
                    "path_length_avg": 235.82771215538,
                    "smoothness_avg": 0.09195275777999899,
                    "success_improvement": 0.0,
                    "time_improvement": 60.0911139159804,
                    "length_improvement": 21.273921758206445,
                    "smoothness_improvement": 2266.01068857373,
                    "objective_score": 42.12174067258664
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.18937287330627442,
                    "num_nodes_avg": 510.0,
                    "path_length_avg": 118.45844668308948,
                    "smoothness_avg": 0.09740963788912176,
                    "success_improvement": 0.0,
                    "time_improvement": -289.7520523276069,
                    "length_improvement": 21.32554009816004,
                    "smoothness_improvement": 1139.043403918075,
                    "objective_score": -68.43507461979567
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 71.35259809409325,
          "time_improvement": -285.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 406.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.15097854137420655,
                    "num_nodes_avg": 375.4,
                    "path_length_avg": 150.76257022061387,
                    "smoothness_avg": 0.03392657193105306,
                    "success_improvement": 0.0,
                    "time_improvement": -500.847401340509,
                    "length_improvement": 17.364646276278172,
                    "smoothness_improvement": 431.0245234511015,
                    "objective_score": -137.6803100191303
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1728947401046753,
                    "num_nodes_avg": 649.8,
                    "path_length_avg": 238.74738839156012,
                    "smoothness_avg": 0.016703858220063185,
                    "success_improvement": 0.0,
                    "time_improvement": -7.569290350104155,
                    "length_improvement": 20.29924979234869,
                    "smoothness_improvement": 329.8023033049928,
                    "objective_score": 11.55777428690293
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21681342124938965,
                    "num_nodes_avg": 472.1,
                    "path_length_avg": 116.30409151558926,
                    "smoothness_avg": 0.04370027229081557,
                    "success_improvement": 0.0,
                    "time_improvement": -346.2279862409406,
                    "length_improvement": 22.756360221044645,
                    "smoothness_improvement": 455.8642379206061,
                    "objective_score": -87.93525855005237
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 73.40333338576892,
          "time_improvement": -288.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 389.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.16166269779205322,
                    "num_nodes_avg": 366.6,
                    "path_length_avg": 156.66138543147994,
                    "smoothness_avg": 0.03327697545139476,
                    "success_improvement": 0.0,
                    "time_improvement": -543.3670041976302,
                    "length_improvement": 14.131412186493867,
                    "smoothness_improvement": 420.8569279231159,
                    "objective_score": -152.42696930777717
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11132118701934815,
                    "num_nodes_avg": 537.4,
                    "path_length_avg": 239.26410796616088,
                    "smoothness_avg": 0.017889281630668625,
                    "success_improvement": 0.0,
                    "time_improvement": 30.739702773186362,
                    "length_improvement": 20.126753925398656,
                    "smoothness_improvement": 360.3041014858415,
                    "objective_score": 23.099483694624308
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.21873629093170166,
                    "num_nodes_avg": 477.3,
                    "path_length_avg": 119.85461749636617,
                    "smoothness_avg": 0.03827330701031982,
                    "success_improvement": 0.0,
                    "time_improvement": -350.185482327656,
                    "length_improvement": 20.398269922491448,
                    "smoothness_improvement": 386.8336401296087,
                    "objective_score": -90.88251454415389
               }
          ],
          "success_rate": 1.0
     }
]