{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid RRT* planner that combines adaptive neighbor radius with bidirectional tree growth for faster convergence. It initially grows two trees from start and goal, alternating expansion between them. It uses adaptive rewiring radius shrinking as the tree grows, and switches from uniform random sampling to informed ellipsoidal sampling after finding the first feasible path to improve efficiency and path quality. Upon termination or timeout, it applies iterative path shortcutting to improve smoothness and reduce path length. The planner enforces strict collision checking and respects map bounds, returning the best found path within a hard 30-second limit.",
    "planning_mechanism": "The planner maintains two RRT* trees grown from start and goal respectively, using collision-checked incremental extensions and rewiring with adaptive neighborhood radius. Sampling is biased towards informed ellipsoidal regions after the first solution is found, improving search focus. After completion or timeout, iterative shortcutting smooths the returned path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=4.0, goal_sample_rate=0.05, max_time=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_time = max_time\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n\n        best_cost = float('inf')\n        best_path_endnode_start = None\n        best_path_endnode_goal = None\n        found_solution = False\n\n        start_time = time.monotonic()\n\n        def sample():\n            if found_solution:\n                # Informed sampling inside ellipsoid\n                return self._informed_sample(start_pos, goal_pos, best_cost, bounds, is_3d)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def nearest_node(nodes, point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(nodes, point, radius):\n            return [n for n in nodes if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            return tuple(from_pos[d] + direction[d] * self.step_size for d in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree_nodes, other_tree_nodes):\n            if time.monotonic() - start_time > self.max_time:\n                return None, None, True  # Timeout\n\n            x_rand = sample()\n            x_near = nearest_node(tree_nodes, x_rand)\n            x_new_pos = steer(x_near.position, x_rand)\n            if not collision_free_node(x_new_pos) or not collision_free_edge(x_near.position, x_new_pos):\n                return None, None, False\n\n            # Adaptive neighbor radius\n            gamma_rrt_star = 50.0  # higher to ensure connectivity, adjust as needed\n            n = len(tree_nodes) + 1\n            dim = len(bounds)\n            radius = min(gamma_rrt_star * (math.log(n) / n) ** (1/dim), self.step_size * 15)\n\n            near = near_nodes(tree_nodes, x_new_pos, radius)\n\n            min_cost = x_near.cost + math.dist(x_near.position, x_new_pos)\n            best_parent = x_near\n            for node_near in near:\n                cost_through = node_near.cost + math.dist(node_near.position, x_new_pos)\n                if cost_through < min_cost and collision_free_edge(node_near.position, x_new_pos):\n                    min_cost = cost_through\n                    best_parent = node_near\n\n            new_node = Node(x_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and collision_free_edge(new_node.position, neighbor.position):\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect to other tree\n            near_other = near_nodes(other_tree_nodes, x_new_pos, radius)\n            connected_node_other = None\n            connecting_cost = float('inf')\n            for node_other in near_other:\n                if collision_free_edge(new_node.position, node_other.position):\n                    cost_connect = new_node.cost + math.dist(new_node.position, node_other.position) + node_other.cost\n                    if cost_connect < connecting_cost:\n                        connecting_cost = cost_connect\n                        connected_node_other = node_other\n\n            if connected_node_other and connecting_cost < best_cost:\n                # Update best path info\n                nonlocal best_cost, best_path_endnode_start, best_path_endnode_goal, found_solution\n                best_cost = connecting_cost\n                found_solution = True\n                if tree_nodes is nodes_start:\n                    best_path_endnode_start = new_node\n                    best_path_endnode_goal = connected_node_other\n                else:\n                    best_path_endnode_start = connected_node_other\n                    best_path_endnode_goal = new_node\n                return new_node, connected_node_other, False\n\n            return new_node, None, False\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.monotonic() - start_time > self.max_time:\n                break\n            # Alternate tree growth\n            t1, t2 = (nodes_start, nodes_goal) if iteration % 2 == 0 else (nodes_goal, nodes_start)\n\n            new_node_t1, connect_node_t2, timeout_occurred = try_extend(t1, t2)\n            if timeout_occurred:\n                break\n            if connect_node_t2 is not None:\n                # Path found, continue to improve within time and iteration limit\n                pass\n\n            iteration += 1\n\n        # Extract best path if found\n        extracted_path = []\n        if found_solution and best_path_endnode_start and best_path_endnode_goal:\n            path_start = []\n            node = best_path_endnode_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = best_path_endnode_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            extracted_path = path_start + path_goal\n\n            # Smooth path by shortcutting iteratively\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d)\n\n        success_state = found_solution\n\n        # Collect all nodes from both trees\n        all_nodes = nodes_start + nodes_goal\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=all_nodes,\n                             edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, bounds, is_3d):\n        # Informed sampling inside prolate hyperspheroid\n        # Reference: Gammell et al., Informed RRT*\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = [g - s for s, g in zip(start, goal)]\n        dist = math.dist(start, goal)\n        if dist == 0:\n            return goal\n\n        # Create rotation matrix via SVD\n        import numpy as np\n        a1 = np.array(a1)\n        a1_norm = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1_norm, I[:,0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1)+[np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if dim > 1:\n            r2 = math.sqrt(c_best**2 - dist**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n        else:\n            L = np.array([[r1]])\n\n        while True:\n            x_ball = np.random.normal(0,1,dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-10:\n                x_ball = x_ball / norm * random.random()**(1/dim)\n            else:\n                continue\n\n            x_random = C @ (L @ x_ball) + center\n            if all(0 <= x_random[d] <= bounds[d] for d in range(dim)):\n                return tuple(float(x_random[d]) for d in range(dim))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Iterative path shortcutting to improve smoothness & length\n        max_attempts = 200\n        path_len = len(path)\n        if path_len < 3:\n            return path\n\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i+2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut possible; remove intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps +1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid single-tree RRT* planner combining adaptive neighbor radius rewiring, ellipsoidal informed sampling after the first solution, and an intelligent pruning mechanism to maintain tree quality. The planner starts with uniform random sampling and transitions to focused sampling inside a prolate hyperspheroid guided by the best path length, accelerating convergence to shorter, smoother paths. It dynamically adapts rewiring radius based on tree size for efficient local optimization and prunes distant or stale nodes to reduce computational overhead. The search terminates early when no improvements occur or the time limit is reached, returning the best-found path.",
    "planning_mechanism": "Two-phase planning: Phase one grows a tree from start with uniform random sampling and adaptive rewiring to discover an initial solution. Phase two restricts sampling within an informed ellipsoidal subset defined by start, goal, and current best path cost, refining path length and smoothness. Periodic pruning removes less promising nodes beyond certain cost thresholds or distance to reduce overhead. The planner incrementally chooses parents minimizing cost with careful collision checking and rewires neighbors within an adaptive radius. Early stopping ensures efficient runtime within a hard 30-second limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=6.0, goal_sample_rate: float=0.05,\n                 prune_interval: int=200, no_improve_iter_limit: int=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.no_improve_iter_limit = no_improve_iter_limit\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        t_start = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        positions = [start]\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        found_first_solution = False\n        no_improve_counter = 0\n\n        gamma_rrt_star = 35.0  # Scaling factor for adaptive radius\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to, max_dist):\n            d = dist(frm, to)\n            if d <= max_dist:\n                return to\n            ratio = max_dist / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return gamma_rrt_star\n            return min(gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20)\n\n        def edge_collision_check(p1, p2):\n            length = dist(p1, p2)\n            # Resolution scales with step size for balance between overhead and accuracy\n            resolution = max(0.5, self.step_size / 2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return True\n            return False\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(start, goal, c_best, c_min):\n            # Uses an ellipsoidal informed sampling inside prolate hyperspheroid\n            import numpy as np\n\n            x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x ** 2 for x in a1))\n            if norm_a1 < 1e-10:\n                # Start and goal are too close\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = [x / norm_a1 for x in a1]\n\n            if c_best == float(\"inf\"):\n                # No path found yet: uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Build rotation matrix C via SVD\n            I = np.eye(dim)\n            M = np.outer(a1, I[:,0])  # shape (dim, dim)\n            U, _, Vt = np.linalg.svd(M)\n            det_U = np.linalg.det(U)\n            det_Vt = np.linalg.det(Vt)\n            det = det_U * det_Vt\n            S = np.diag([1] * (dim -1) + [det])\n            C = U @ S @ Vt\n\n            L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n            L = np.diag(L_diag)\n\n            while True:\n                x_ball = np.random.normal(0,1,dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball\n                r = random.random() ** (1.0 / dim)\n                x_ball = x_ball * r\n                x_rand = (C @ (L @ x_ball)) + np.array(x_center)\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def prune_nodes():\n            # Remove nodes far from best path or with cost much higher than best_cost (pruning)\n            nonlocal nodes, edges, positions, best_cost, best_goal_node\n\n            if not found_first_solution:\n                return  # no pruning without a solution\n\n            max_cost_factor = 1.3  # prune nodes with cost > best_cost * factor\n            max_dist_factor = 3.0  # prune nodes farther than this times best_cost from line start-goal\n\n            new_nodes = []\n            new_positions = []\n            valid_nodes_set = set()\n\n            # Precompute unit vector of start->goal\n            start_goal_vec = [g - s for s, g in zip(start, goal)]\n            sg_norm = math.sqrt(sum(x*x for x in start_goal_vec))\n            if sg_norm < 1e-12:\n                return  # degenerate case\n\n            start_goal_unit = [x / sg_norm for x in start_goal_vec]\n\n            # Project point p onto start->goal vector to find distance from path line\n            def dist_to_line(p):\n                sp = [p[d] - start[d] for d in range(dim)]\n                proj = sum(sp[d] * start_goal_unit[d] for d in range(dim))\n                closest = [start[d] + proj * start_goal_unit[d] for d in range(dim)]\n                return math.dist(p, closest)\n\n            # Keep best_goal_node and its ancestors to avoid disconnecting path\n            good_nodes = set()\n            if best_goal_node is not None:\n                q = best_goal_node\n                while q is not None:\n                    good_nodes.add(q)\n                    q = q.parent\n\n            # Collect nodes to keep\n            for node in nodes:\n                if node in good_nodes:\n                    valid_nodes_set.add(node)\n                    continue\n                if node.cost > best_cost * max_cost_factor:\n                    continue\n                if dist_to_line(node.position) > best_cost * max_dist_factor:\n                    continue\n                valid_nodes_set.add(node)\n\n            # Rebuild nodes and edges keeping only valid nodes\n            # Also fix parent-child relationships accordingly\n            new_nodes = []\n            new_positions = []\n            # Build a map old_node -> new_node to preserve references\n            node_map = {}\n\n            for node in nodes:\n                if node in valid_nodes_set:\n                    new_node = Node(node.position, None, node.cost)\n                    node_map[node] = new_node\n                    new_nodes.append(new_node)\n                    new_positions.append(new_node.position)\n\n            # Rebuild parents and children respecting valid nodes\n            for old_node, new_node in node_map.items():\n                if old_node.parent in node_map:\n                    p_new = node_map[old_node.parent]\n                    new_node.parent = p_new\n                    p_new.add_child(new_node)\n\n            # Rebuild edges list\n            new_edges = []\n            for old_node, new_node in node_map.items():\n                if new_node.parent is not None:\n                    new_edges.append((new_node.parent, new_node))\n\n            nodes[:] = new_nodes\n            positions[:] = new_positions\n            edges[:] = new_edges\n\n            # Update best_goal_node reference if pruned\n            if best_goal_node not in node_map:\n                # lost best goal node, best_cost invalidated\n                # worsen best_cost to force more exploration\n                nonlocal found_first_solution\n                found_first_solution = False\n                best_goal_node = None\n                best_cost = float(\"inf\")\n            else:\n                best_goal_node = node_map[best_goal_node]\n                best_cost = best_goal_node.cost\n\n        iter_count = 0\n\n        while iter_count < self.max_iter:\n            if time.monotonic() - t_start > time_limit:\n                break\n\n            iter_count += 1\n\n            # Sample: before first solution uniform, after that informed ellipse\n            if not found_first_solution:\n                x_rand = sample_uniform()\n            else:\n                c_min = math.dist(start, goal)\n                x_rand = sample_informed(start, goal, best_cost, c_min)\n\n            # Goal bias sampling occasionally\n            if random.random() < self.goal_sample_rate:\n                x_rand = goal\n\n            # Nearest neighbor search - linear scan\n            nearest_idx = 0\n            dmin = dist(positions[0], x_rand)\n            for i in range(1, len(nodes)):\n                dd = dist(positions[i], x_rand)\n                if dd < dmin:\n                    dmin = dd\n                    nearest_idx = i\n            nearest_node = nodes[nearest_idx]\n\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if edge_collision_check(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive neighbor radius\n            n_nodes = len(nodes) + 1\n            radius = adaptive_radius(n_nodes)\n\n            # Find neighbors within radius\n            neighbor_indices = []\n            for idx, pos in enumerate(positions):\n                if dist(pos, new_pos) <= radius:\n                    neighbor_indices.append(idx)\n\n            # Choose best parent among neighbors minimizing cost + dist with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for idx in neighbor_indices:\n                neighbor = nodes[idx]\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not edge_collision_check(neighbor.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            positions.append(new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if improved by new node\n            for idx in neighbor_indices:\n                neighbor = nodes[idx]\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-12 < neighbor.cost:\n                    if not edge_collision_check(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect goal if close enough\n            dist_to_goal = dist(new_pos, goal)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal, obstacles, is_3d)\n                        and not edge_collision_check(new_pos, goal)):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    positions.append(goal)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost + 1e-9 < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        found_first_solution = True\n                        no_improve_counter = 0\n                    else:\n                        no_improve_counter += 1\n            else:\n                no_improve_counter += 1\n\n            if found_first_solution and no_improve_counter >= self.no_improve_iter_limit:\n                # Early termination if no improvement for many iterations\n                break\n\n            if iter_count % self.prune_interval == 0 and found_first_solution:\n                prune_nodes()\n\n        if found_first_solution and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n            success_state = True\n        else:\n            # If no full goal reached, return path to node nearest goal\n            if len(nodes) > 0:\n                nearest_goal_node = None\n                dist_goal_min = float(\"inf\")\n                for node in nodes:\n                    d = dist(node.position, goal)\n                    if d < dist_goal_min:\n                        dist_goal_min = d\n                        nearest_goal_node = node\n                if nearest_goal_node is not None:\n                    extracted_path = nearest_goal_node.path_from_root()\n                    success_state = False\n                else:\n                    extracted_path = []\n                    success_state = False\n            else:\n                extracted_path = []\n                success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nSyntaxError: name 'found_first_solution' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "An enhanced probabilistic roadmap (PRM) planner employing batch processing, lazy collision checking, dynamic connection radius based on the number of nodes, and post-processing shortcut smoothing for efficient path planning. The planning mechanism constructs a roadmap by sampling collision-free nodes in batches, incrementally connects them using a dynamic radius based on the roadmap size to limit neighbors, defers expensive collision checks until necessary (lazy evaluation) to reduce planning time, and finally searches for the shortest path using A* on the roadmap graph. After path extraction, iterative shortcutting smooths and shortens the path, all under a strict 30-second planning time constraint.",
    "planning_mechanism": "A batch-sampling PRM builds a graph of collision-free samples connected within a radius that shrinks adaptively as nodes increase. By performing lazy collision checks only when edges are required during graph search, the planner avoids redundant costly checks. An A* search finds the shortest path on the constructed graph. Post-processing shortcutting eliminates unnecessary waypoints iteratively. Planning halts at 30 seconds, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], index: int):\n        self.position = position\n        self.index = index\n        self.neighbors: List['Node'] = []\n        self.edges_valid: dict = {}  # neighbor index \u2192 bool lazy collision check result\nclass Planner:\n    def __init__(self, max_samples=1500, batch_size=100, max_connection_radius=50.0):\n        self.max_samples = max_samples\n        self.batch_size = batch_size\n        self.max_connection_radius = max_connection_radius\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_node_free(p) -> bool:\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_free(p1, p2) -> bool:\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, dist / 10.0)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def dist_sq(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        # Start with start and goal nodes\n        nodes: List[Node] = []\n        idx_map = {}  # maps position to node index for quick lookup\n\n        start_node = Node(start_pos, 0)\n        goal_node = Node(goal_pos, 1)\n        nodes.append(start_node)\n        nodes.append(goal_node)\n        idx_map[start_pos] = 0\n        idx_map[goal_pos] = 1\n\n        # Ensure start and goal are collision free\n        if not is_node_free(start_pos) or not is_node_free(goal_pos):\n            return PlannerResult(False, [], nodes, [])\n\n        # Sampling uniformly in bounds for batch\n        def sample_batch(n):\n            samples = []\n            count = 0\n            while count < n:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_node_free(p):\n                    samples.append(p)\n                    count += 1\n            return samples\n\n        # Adaptive connection radius: shrinking as samples grow (formula inspired by PRM*)\n        def connection_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_connection_radius\n            gamma_prm = self.max_connection_radius\n            r = gamma_prm * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(1.0, min(gamma_prm, r))\n\n        # Add nodes in batches until max_samples reached or time up\n        next_node_index = 2\n        while next_node_index < self.max_samples:\n            if time.monotonic() - start_time > time_limit:\n                break\n            batch_n = min(self.batch_size, self.max_samples - next_node_index)\n            batch_samples = sample_batch(batch_n)\n            for p in batch_samples:\n                if time.monotonic() - start_time > time_limit:\n                    break\n                node = Node(p, next_node_index)\n                nodes.append(node)\n                idx_map[p] = next_node_index\n                next_node_index += 1\n\n            # Connect new batch nodes to all existing nodes within radius (bi-directional edges)\n            radius = connection_radius(len(nodes))\n            radius_sq = radius * radius\n\n            # Build a spatial index for efficiency (simple grid not implemented due to constraints)\n            # Use naive search (ok for small batches)\n            for i in range(len(nodes) - batch_n, len(nodes)):\n                n_i = nodes[i]\n                for j in range(len(nodes)):\n                    if i == j:\n                        continue\n                    n_j = nodes[j]\n                    if dist_sq(n_i.position, n_j.position) <= radius_sq:\n                        # Lazily add neighbor link; collision check deferred\n                        n_i.neighbors.append(n_j)\n                        n_j.neighbors.append(n_i)\n\n        # Graph search with lazy collision checking and A* for shortest path\n        def heuristic(p):\n            return math.dist(p, goal_pos)\n\n        open_set = []\n        came_from = {}\n        g_score = {}\n        f_score = {}\n\n        # Initialize search from start\n        g_score[start_node.index] = 0.0\n        f_score[start_node.index] = heuristic(start_node.position)\n        open_set.append((f_score[start_node.index], start_node))\n\n        closed_set = set()\n\n        def edge_valid(n1: Node, n2: Node) -> bool:\n            # Check cached edge validity first\n            if n2.index in n1.edges_valid:\n                return n1.edges_valid[n2.index]\n            valid = is_edge_free(n1.position, n2.position)\n            n1.edges_valid[n2.index] = valid\n            n2.edges_valid[n1.index] = valid\n            return valid\n\n        found_path = False\n        best_path = []\n        best_path_cost = float('inf')\n\n        while open_set:\n            if time.monotonic() - start_time > time_limit:\n                break\n            open_set.sort(key=lambda x: x[0])  # sort by f_score, simple priority queue\n            current = open_set.pop(0)[1]\n            if current.index == goal_node.index:\n                # Reconstruct path\n                total_path = [current.position]\n                cur_idx = current.index\n                while cur_idx in came_from:\n                    cur_idx = came_from[cur_idx]\n                    total_path.append(nodes[cur_idx].position)\n                best_path = total_path[::-1]\n                best_path_cost = g_score[current.index]\n                found_path = True\n                break\n\n            closed_set.add(current.index)\n\n            for neighbor in current.neighbors:\n                if neighbor.index in closed_set:\n                    continue\n                if not edge_valid(current, neighbor):\n                    continue\n                tentative_g = g_score[current.index] + math.dist(current.position, neighbor.position)\n                if neighbor.index not in g_score or tentative_g < g_score[neighbor.index]:\n                    came_from[neighbor.index] = current.index\n                    g_score[neighbor.index] = tentative_g\n                    f_score[neighbor.index] = tentative_g + heuristic(neighbor.position)\n                    if not any(n[1].index == neighbor.index for n in open_set):\n                        open_set.append((f_score[neighbor.index], neighbor))\n\n        # If no path found, fallback best effort with empty path\n        if not found_path:\n            return PlannerResult(False, [], nodes, [])\n\n        # Post-processing: iterative shortcutting for path smoothing\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            improved = True\n            while improved and time.monotonic() - start_time < time_limit:\n                improved = False\n                i = 0\n                while i < len(path_points) - 2:\n                    j = len(path_points) - 1\n                    while j > i + 1:\n                        if is_edge_free(path_points[i], path_points[j]):\n                            # Remove intermediate points between i and j\n                            del path_points[i+1:j]\n                            improved = True\n                            break\n                        j -= 1\n                    i += 1\n            return path_points\n\n        final_path = shortcut_path(best_path)\n\n        # Build edges list from path for output coherence\n        edges_out = []\n        for i in range(len(final_path) - 1):\n            # find nodes corresponding to these positions\n            n_from = None\n            n_to = None\n            for n in nodes:\n                if n.position == final_path[i]:\n                    n_from = n\n                if n.position == final_path[i+1]:\n                    n_to = n\n                if n_from and n_to:\n                    break\n            if n_from and n_to:\n                edges_out.append((n_from, n_to))\n\n        return PlannerResult(True, final_path, nodes, edges_out)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced bidirectional informed RRT* planner with adaptive neighbor radius, goal bias, and early stopping that grows two trees simultaneously from start and goal aiming to connect quickly. It employs efficient ellipsoidal informed sampling after the first solution to focus search, uses spatial pruning to reduce rewiring costs, and applies aggressive multi-pass shortcutting for smooth, short paths. The planner respects collision and boundary constraints, stops immediately on connection, and returns the best found solution within 30 seconds.",
    "planning_mechanism": "A bidirectional RRT* alternates growth from start and goal trees, sampling mostly inside an ellipsoid defined by the current best path cost with occasional goal bias sampling. Each newly added node is rewired using an adaptive neighbor radius computed based on node count and dimension to optimize local connections. When the two trees are connected (nodes within step size), early stopping happens. Post-planning applies multiple passes of shortcutting to smooth and shorten the path. Collision checks are carefully performed on nodes and edges. The 30-second limit is enforced strictly to return the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is new_parent:\n            if abs(self.cost - new_cost) > 1e-9:\n                self.cost = new_cost  # update cost if changed\n            return\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.2,\n                 max_neighbor_radius=30.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        # Edge collision with adaptive resolution (smaller step than half step_size for smooth check)\n        def is_free_edge(p1, p2):\n            distance = dist(p1, p2)\n            res = min(self.step_size*0.4, 1.0)\n            steps = max(1, int(distance / res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            r = max_dist/d\n            return tuple(from_pos[i] + r*(to_pos[i]-from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        # Ellipsoidal informed sampling centered between start and goal, aligned with line start->goal\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            c_min = heuristic_cost(x_start,x_goal)\n            if c_min == 0:\n                return x_start\n\n            center = tuple((x_start[i]+x_goal[i])*0.5 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_t, sin_t = a[0], a[1]\n                    return [[cos_t, -sin_t],[sin_t, cos_t]]\n                elif dim ==3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            r1 = c_best*0.5\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                diff = c_best*c_best - c_min*c_min\n                r2 = math.sqrt(abs(diff))/2 if diff>=0 else 0.001\n                if r2 < 0.001: r2=0.001\n            radii = [r1]+[r2]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s=0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0,min(sample[i],bounds[i])) for i in range(dim))\n            return clipped\n\n        # Nearest node linear search in nodes list\n        def nearest_node(p, nodeset):\n            best = nodeset[0]\n            best_d = dist(best.position,p)\n            for nd in nodeset[1:]:\n                dcur = dist(nd.position,p)\n                if dcur < best_d:\n                    best_d = dcur\n                    best = nd\n            return best, best_d\n\n        # Adaptive neighbor radius decreasing with node count and dimension using Karaman-Frazzoli formula\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1: return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            r = gamma*(math.log(n_nodes)/n_nodes)**(1.0/dim)\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # Nearby nodes within radius in given nodes list\n        def nearby_nodes(p, radius, nodeset):\n            result = []\n            r2 = radius*radius\n            for nd in nodeset:\n                if squared_dist(nd.position,p) <= r2:\n                    result.append(nd)\n            return result\n\n        def squared_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        # Reconstruct path from node to root\n        def extract_path(node):\n            path = []\n            current = node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n            return path\n\n        # Bidirectional trees initialization\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n\n        # root nodes have no parent, cost zero\n        tree_start[0].cost = 0.0\n        tree_start[0].parent = None\n        tree_start[0].children = []\n        tree_goal[0].cost = 0.0\n        tree_goal[0].parent = None\n        tree_goal[0].children = []\n\n        # All nodes and edges combined for returning later\n        all_nodes = []\n        all_edges = []\n\n        # To track which nodes belong to which tree for rewiring\n        tree_start_nodes = tree_start\n        tree_goal_nodes = tree_goal\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        def connectable(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if is_free_edge(n1.position, n2.position):\n                    return True\n            return False\n\n        def connect_trees(nstart, ngoal):\n            # Connect goal node to start node, fix parents\n            cost_connect = nstart.cost + dist(nstart.position, ngoal.position) + ngoal.cost\n            # From goal to its root must be reversed to start with nstart as root\n            # We'll connect ngoal as child of nstart for simplicity (start tree remains root)\n            # We \"reverse\" goal tree from ngoal to goal root for path extraction later:\n            if cost_connect < best_cost:\n                nonlocal best_cost, best_start_node, best_goal_node\n                best_cost = cost_connect\n                best_start_node = nstart\n                best_goal_node = ngoal\n\n        # Main iteration alternately extend one of the trees\n        iteration = 0\n        extend_start_tree = True  # alternate between start and goal tree growth\n\n        # Combined for neighbor searches to reduce cost where needed\n        def combine_lists(listA, listB):\n            return listA + listB\n\n        # For sampling within informed set after first solution found\n        def informed_sample():\n            if math.isinf(best_cost):\n                # Initial uninformed, uniform random\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # With goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal if extend_start_tree else start\n            return sample_informed(best_cost, start, goal)\n\n        def try_rewire(new_node, nodeset, radius):\n            nonlocal all_edges\n            neighbors = nearby_nodes(new_node.position, radius, nodeset)\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_node.position)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_node.position):\n                    min_cost = tentative_cost\n                    best_parent = nb\n            if best_parent is not new_node.parent:\n                # Change parent\n                new_node.update_parent(best_parent, min_cost)\n\n            # Now rewire neighbors if detour via new_node is better\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not nb.valid:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    old_parent = nb.parent\n                    nb.update_parent(new_node, alt_cost)\n                    if old_parent is not None:\n                        try:\n                            all_edges.remove((old_parent, nb))\n                        except ValueError:\n                            pass\n                    all_edges.append((new_node, nb))\n\n        def add_node_to_tree(new_pos, nearest_node, nodeset):\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.update_parent(nearest_node, new_cost)\n            nodeset.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((nearest_node, new_node))\n            return new_node\n\n        # Multi-pass shortcut to improve path length and smoothness\n        def shortcut_path(path_points, passes=3):\n            if len(path_points) < 3:\n                return path_points\n            for _ in range(passes):\n                i = 0\n                new_path = [path_points[0]]\n                while i < len(path_points)-1:\n                    j = len(path_points)-1\n                    while j > i+1:\n                        if is_free_edge(path_points[i], path_points[j]):\n                            new_path.append(path_points[j])\n                            i = j\n                            break\n                        j -= 1\n                    else:\n                        i += 1\n                        if i < len(path_points):\n                            new_path.append(path_points[i])\n                path_points = new_path\n            return path_points\n\n        # Initialize combined node lists for neighbor searching\n        all_nodes.extend(tree_start)\n        all_nodes.extend(tree_goal)\n\n        while iteration < self.max_iter:\n            iteration += 1\n            now = time.monotonic()\n            if now - start_time > time_limit:\n                break\n\n            if extend_start_tree:\n                tree_nodes = tree_start_nodes\n                other_tree_nodes = tree_goal_nodes\n                fixed_goal = goal\n            else:\n                tree_nodes = tree_goal_nodes\n                other_tree_nodes = tree_start_nodes\n                fixed_goal = start\n\n            # Sample point: goal bias or informed\n            if math.isinf(best_cost):\n                sample_pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = fixed_goal\n                else:\n                    sample_pt = sample_informed(best_cost, start, goal)\n\n            # Nearest in current tree\n            nearest, _ = nearest_node(sample_pt, tree_nodes)\n            new_pos = steer(nearest.position, sample_pt, self.step_size)\n\n            if not is_free_node(new_pos):\n                extend_start_tree = not extend_start_tree\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                extend_start_tree = not extend_start_tree\n                continue\n\n            new_node = add_node_to_tree(new_pos, nearest, tree_nodes)\n            radius = neighbor_radius(len(tree_nodes))\n            try_rewire(new_node, tree_nodes, radius)\n\n            # Try to connect to other tree\n            near_others = nearby_nodes(new_node.position, self.step_size*1.2, other_tree_nodes)\n            connected = False\n            for n_other in near_others:\n                if connectable(new_node, n_other):\n                    connect_trees(new_node, n_other)\n                    connected = True\n                    break\n\n            if connected:\n                # Early stopping immediately when trees connected\n                success_state = True\n                break\n\n            extend_start_tree = not extend_start_tree\n\n        # Build path from best nodes if connected\n        path = []\n        if best_start_node is not None and best_goal_node is not None and success_state:\n            # Extract path start->best_start_node root\n            path_start = extract_path(best_start_node)\n            # Extract path goal->best_goal_node root and reverse\n            path_goal_rev = extract_path(best_goal_node)\n            path_goal = list(reversed(path_goal_rev))\n            # Skip duplicate connecting node in concatenation\n            if dist(path_start[-1], path_goal[0]) < 1e-9:\n                path_goal = path_goal[1:]\n            path = path_start + path_goal\n        else:\n            # No full solution: find closest node pairs between trees, best partial path\n            min_d = float('inf')\n            best_pair = None\n            for ns in tree_start_nodes:\n                for ng in tree_goal_nodes:\n                    d = dist(ns.position, ng.position)\n                    if d < min_d:\n                        min_d = d\n                        best_pair = (ns, ng)\n            if best_pair is not None:\n                ns, ng = best_pair\n                path_start = extract_path(ns)\n                path_goal_rev = extract_path(ng)\n                path_goal = list(reversed(path_goal_rev))\n                if dist(path_start[-1], path_goal[0]) < 1e-9:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal\n            success_state = False\n\n        # Apply multi-pass shortcutting to smooth and shorten path\n        path = shortcut_path(path, passes=4)\n\n        # Gather all nodes and edges from both trees\n        # They are in all_nodes and all_edges lists already\n\n        return PlannerResult(\n            success=success_state,\n            path=path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nSyntaxError: name 'best_cost' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
