[
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* algorithm with goal bias, adaptive rewiring radius, and post-processing shortcut smoothing to enhance planning time, path length, and smoothness. It grows two trees from start and goal using goal-biased sampling and adaptive neighbor radius for rewiring, continually optimizing path cost. After the first solution, it performs a shortcut smoothing to remove unnecessary waypoints, yielding shorter and smoother paths. Early stopping applies when the two trees connect.",
          "planning_mechanism": "A bidirectional RRT* planner grows start and goal trees toward randomly sampled points biased toward the goal, with an adaptive neighbor radius shrinking as the tree grows for efficient rewiring and collision checks. Upon connecting the trees, it performs post-planning shortcut smoothing to improve path smoothness and shorten path length, while enforcing node and edge collision checks and bounded planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample():\n            # Goal biased sampling: with some probability sample the goal\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # Otherwise sample uniformly inside bounds but avoid obstacles via rejection\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if no free sample found in 100 tries (unlikely)\n            return goal_pos\n\n        def steer(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            norm = dist(from_pos, to_pos)\n            if norm <= self.step_size:\n                new_pos = to_pos\n            else:\n                scale = self.step_size / norm\n                new_pos = tuple(from_pos[d] + vec[d] * scale for d in range(dim))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clip to bounds if numerics cause issues\n            clipped = tuple(min(max(new_pos[d], 0), bounds[d]) for d in range(dim))\n            return clipped\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        def adaptive_radius(n):\n            # Adaptive rewiring radius: \u03b3*(log(n)/n)^(1/d); \u03b3 chosen heuristically\n            gamma = 50.0  # Tuned constant, can be adjusted\n            if n < 2:\n                return self.step_size * 5.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Alternate between trees: grow_start -> grow_goal -> grow_start etc\n            if i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            sample_point = sample()\n            nearest = min(tree_from, key=lambda n: dist(n.position, sample_point))\n            new_pos = steer(nearest.position, sample_point)\n\n            # Validate new_pos node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            r = adaptive_radius(len(nodes))\n\n            # Find neighbors in tree_from within radius r\n            neighbors = [n for n in tree_from if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + distance via collision-free edge\n            min_cost = nearest.cost + line_cost(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_through_nbr = nbr.cost + line_cost(nbr.position, new_pos)\n                if cost_through_nbr < min_cost:\n                    if not self._is_edge_in_obstacle(nbr.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nbr\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                cost_through_new = new_node.cost + line_cost(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except Exception:\n                            pass\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n\n            # Try connecting the other tree to new_node to check if paths can be connected\n            nearest_to = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            while True:\n                connect_pos = steer(nearest_to.position, new_node.position)\n                # Check collision for edge\n                if self._is_in_obstacle(connect_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(nearest_to.position, connect_pos, obstacles, is_3d):\n                    break\n                # Add node to tree_to\n                new_to_node = Node(connect_pos)\n                new_to_node.update_parent(nearest_to, nearest_to.cost + line_cost(nearest_to.position, connect_pos))\n                tree_to.append(new_to_node)\n                nodes.append(new_to_node)\n                edges.append((nearest_to, new_to_node))\n\n                if dist(connect_pos, new_node.position) <= self.step_size:\n                    # Check final edge to new_node\n                    if not self._is_edge_in_obstacle(connect_pos, new_node.position, obstacles, is_3d):\n                        final_connect = Node(new_node.position)\n                        final_connect.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, connect_pos))\n                        tree_to.append(final_connect)\n                        nodes.append(final_connect)\n                        edges.append((new_to_node, final_connect))\n\n                        # Found a path connecting both trees\n                        total_cost = final_connect.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            # We return combined path by remembering nodes connecting trees\n                            best_start_node = new_node if tree_from is tree_start else final_connect\n                            best_goal_node = final_connect if tree_to is tree_goal else new_node\n                        break\n                    else:\n                        break\n                nearest_to = new_to_node\n\n            if success:\n                break\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # path_goal is from goal_root to connection, reverse except overlap connection node\n            extracted_path = path_start + path_goal[-2::-1]\n\n            # Perform path shortcutting smoothing\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        import math\n        def can_connect(a, b):\n            if a == b:\n                return True\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                return False\n            return True\n\n        if len(path) < 3:\n            return path\n\n        # Iteratively try to shortcut path by connecting farther points directly\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if can_connect(path[i], path[j]):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -38.54314,
          "time_improvement": 66.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1649.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0124739408493042,
                    "num_nodes_avg": 97.8,
                    "path_length_avg": 161.16050378318585,
                    "smoothness_avg": 0.047350045450239985,
                    "success_improvement": 0.0,
                    "time_improvement": 50.357614561905564,
                    "length_improvement": 11.665374124831326,
                    "smoothness_improvement": 641.1310335656783,
                    "objective_score": 25.312164011298858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021719694137573242,
                    "num_nodes_avg": 248.5,
                    "path_length_avg": 233.695774193213,
                    "smoothness_avg": 0.10749915802083503,
                    "success_improvement": 0.0,
                    "time_improvement": 86.48673705408524,
                    "length_improvement": 21.985624014409588,
                    "smoothness_improvement": 2666.030764389923,
                    "objective_score": 52.46754934682094
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018388795852661132,
                    "num_nodes_avg": 200.2,
                    "path_length_avg": 122.948486694335,
                    "smoothness_avg": 0.13675427801112314,
                    "success_improvement": 0.0,
                    "time_improvement": 62.15365591556138,
                    "length_improvement": 18.34346931542014,
                    "smoothness_improvement": 1639.504322150689,
                    "objective_score": 37.84969997467394
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT*-like planner with dynamic goal bias adjustment, radius annealing for neighbor search, downstream cost propagation for rewiring, and integrated incremental path shortcutting to efficiently improve path optimality and smoothness during construction, while enforcing time constraints and collision checks.",
          "planning_mechanism": "The planner grows two trees from start and goal with a gradually decreasing rewiring radius based on iteration count to balance exploration and refinement. Sampling bias toward the goal dynamically decreases over time to incentivize exploration early and exploitation later. When connecting nodes, parent rewiring propagates cost improvements downstream ensuring globally consistent shortest paths. Incremental shortcutting is applied progressively on partial paths when an improved connection is found to enhance smoothness. Early stopping occurs upon solution discovery or hard time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position  # coordinate tuple\n        self.parent = parent      # parent Node\n        self.cost = cost          # cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True         # for collision checks etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        \n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= self.step_size:\n                new_pos = to_pos\n            else:\n                scale = self.step_size / length\n                new_pos = tuple(from_pos[d] + vec[d]*scale for d in range(dim))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clip if out of bounds (numeric safety)\n            clipped = tuple(min(max(new_pos[d], 0), bounds[d]) for d in range(dim))\n            return clipped\n\n        def sample_point(iteration):\n            # Dynamic goal bias decaying exponentially from 0.15 down to 0.02 over iterations\n            bias_max = 0.15\n            bias_min = 0.02\n            decay_rate = 0.0005\n            goal_bias = bias_min + (bias_max - bias_min) * math.exp(-decay_rate * iteration)\n            if random.random() < goal_bias:\n                return goal_pos\n            # Uniform sampling with rejection capped at 100 tries\n            for _ in range(100):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def adaptive_radius(iteration, n_nodes):\n            # Anneal rewiring radius: start large -> shrink to minimal bound\n            gamma = 40.0  # tuned scaling factor\n            if n_nodes < 2:\n                return self.step_size * 6.0\n            rmax = self.step_size * 10\n            rmin = self.step_size * 1.5\n            # Exponential annealing of radius w.r.t normalized iteration count\n            alpha = min(1.0, iteration / self.max_iter)\n            radius = rmax * (1 - alpha) + rmin * alpha\n            # Also scale by theoretical formula for asymptotic RRT*\n            r_theoretical = gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            radius = min(radius, max(r_theoretical, rmin))\n            return radius\n\n        # Initialize nodes and trees\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_path_start = None\n        best_path_goal = None\n        success = False\n\n        def collision_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=1.0)\n\n        def propagate_cost_updates(node):\n            # BFS propagation of cost updates downstream children:\n            queue = [node]\n            while queue:\n                curr = queue.pop(0)\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + 1e-8 < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        queue.append(c)\n\n        def incremental_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting applied incrementally\n            if len(path) < 3:\n                return path\n\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if collision_free_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def connect_trees(node_from: Node, other_tree: List[Node], iteration: int):\n            nonlocal best_cost, best_path_start, best_path_goal, success\n\n            # Find closest in other tree\n            nearest_o = min(other_tree, key=lambda n: dist(n.position, node_from.position))\n            \n            # Attempt direct connection when within step size (attempt shortcut)\n            if dist(nearest_o.position, node_from.position) <= self.step_size:\n                if collision_free_edge(nearest_o.position, node_from.position):\n                    # Merge using nearest_o as parent\n                    new_node = Node(node_from.position)\n                    new_node.update_parent(nearest_o, nearest_o.cost + dist(nearest_o.position, node_from.position))\n                    other_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest_o, new_node))\n\n                    total_cost = new_node.cost + node_from.cost\n                    if total_cost + 1e-8 < best_cost:\n                        best_cost = total_cost\n                        success = True\n                        best_path_start = node_from if node_from in tree_start else new_node\n                        best_path_goal = new_node if new_node in tree_goal else node_from\n                    return\n\n            # Incrementally extend other tree toward node_from position (limited steps)\n            cur_node = nearest_o\n            for _ in range(5):\n                new_pos = steer(cur_node.position, node_from.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return\n                if not collision_free_edge(cur_node.position, new_pos):\n                    return\n                if dist(new_pos, cur_node.position) < 1e-6:\n                    return  # no progression\n\n                new_node = Node(new_pos)\n                new_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, new_pos))\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((cur_node, new_node))\n\n                cur_node = new_node\n\n                # If close enough, try final connection to node_from\n                if dist(cur_node.position, node_from.position) <= self.step_size:\n                    if collision_free_edge(cur_node.position, node_from.position):\n                        final_node = Node(node_from.position)\n                        final_node.update_parent(cur_node, cur_node.cost + dist(cur_node.position, node_from.position))\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((cur_node, final_node))\n                        total_cost = final_node.cost + node_from.cost\n                        if total_cost + 1e-8 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            best_path_start = node_from if node_from in tree_start else final_node\n                            best_path_goal = final_node if final_node in tree_goal else node_from\n                        return\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Alternate expanding trees\n            if i % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            # Sample point\n            q_rand = sample_point(i)\n            # Find nearest node in tree_from\n            nearest = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest.position, q_rand)\n\n            # Validate node and edge collision\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(nearest.position, q_new_pos):\n                continue\n\n            r = adaptive_radius(i, len(nodes))\n\n            neighbors = [n for n in tree_from if dist(n.position, q_new_pos) <= r]\n\n            # Choose best parent via minimal cost + edge length and collision free\n            min_cost = nearest.cost + dist(nearest.position, q_new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                cost_thru_nbr = nbr.cost + dist(nbr.position, q_new_pos)\n                if cost_thru_nbr + 1e-8 < min_cost:\n                    if collision_free_edge(nbr.position, q_new_pos):\n                        best_parent = nbr\n                        min_cost = cost_thru_nbr\n\n            new_node = Node(q_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-8 < nbr.cost:\n                    if collision_free_edge(new_node.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, nbr))\n                        # Propagate cost updates downstream recursively\n                        propagate_cost_updates(nbr)\n\n            # Try to connect the other tree to this new node (potential short circuit)\n            connect_trees(new_node, tree_to, i)\n\n            # If found a path, perform incremental shortcutting on extracted path for smoothness\n            if success:\n                path_start = best_path_start.path_from_root()\n                path_goal = best_path_goal.path_from_root()\n                # goal tree path reversed (excluding overlapped connection node)\n                combined_path = path_start + path_goal[-2::-1]\n                # Incremental shortcutting\n                combined_path = incremental_shortcut(combined_path)\n                return PlannerResult(success, combined_path, nodes, edges)\n\n        # After loop: return best found path or failure\n        if success:\n            path_start = best_path_start.path_from_root()\n            path_goal = best_path_goal.path_from_root()\n            combined_path = path_start + path_goal[-2::-1]\n            combined_path = incremental_shortcut(combined_path)\n            return PlannerResult(True, combined_path, nodes, edges)\n\n        # No feasible path found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        length = math.dist(from_pos, to_pos)\n        steps = max(1, int(length / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -38.53073,
          "time_improvement": 67.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1825.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01083357334136963,
                    "num_nodes_avg": 99.1,
                    "path_length_avg": 164.690717897958,
                    "smoothness_avg": 0.050677075966852836,
                    "success_improvement": 0.0,
                    "time_improvement": 56.885764492451095,
                    "length_improvement": 9.730407828702308,
                    "smoothness_improvement": 693.2062859130726,
                    "objective_score": 26.370005474522074
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026892876625061034,
                    "num_nodes_avg": 306.0,
                    "path_length_avg": 237.81555451648507,
                    "smoothness_avg": 0.12641290240664743,
                    "success_improvement": 0.0,
                    "time_improvement": 83.26815695908788,
                    "length_improvement": 20.610322761199686,
                    "smoothness_improvement": 3152.695030456311,
                    "objective_score": 53.110115896727734
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0188523530960083,
                    "num_nodes_avg": 260.8,
                    "path_length_avg": 126.4424197417197,
                    "smoothness_avg": 0.13582463246786344,
                    "success_improvement": 0.0,
                    "time_improvement": 61.19959959370538,
                    "length_improvement": 16.02296534856016,
                    "smoothness_improvement": 1627.6792994597215,
                    "objective_score": 36.11205558454632
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with goal bias sampling, adaptive neighbor radius based on tree size and dimension, incremental rewiring, early stopping immediately after first path found, and final path shortcutting for improved smoothness and length. The algorithm alternately expands start and goal trees, rewires locally to optimize path cost, and efficiently connects trees upon proximity. It enforces strict collision checks for nodes and edges at every addition, respects map bounds, and robustly handles 2D/3D rectangular obstacles under a strict 30-second time limit. Final path extraction merges two parent chains cleanly and applies shortcutting to smooth and shorten the path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal with goal-biased sampling, chooses parent nodes by minimizing path cost within an adaptive radius, rewires neighbors upon discovery of better costs, attempts incremental connections between trees, and stops early on finding a valid connection. It applies shortcutting to the final path to improve smoothness and length before returning results with all explored nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10  # 10% chance sample goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback uniform sample without obstacle check\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            # Remove unnecessary waypoints by attempting direct connections skipping intermediate points\n            if len(path) <= 2:\n                return path[:]\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortcut_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, proceed next node\n                    shortcut_path.append(path[i+1])\n                    i += 1\n            return shortcut_path\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Adaptive radius for neighbor search (approximate RRT* radius)\n            n = len(tree_a)\n            min_radius = self.step_size * 2.5\n            gamma_rrt = 50.0  # tuning constant, increased slightly for larger graphs\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n+1) / (n+1))**(1/dim)), self.step_size * 30))\n\n            # Choose best parent in radius neighbors\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with new_node if better cost found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt to connect to opposing tree within radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path, removing duplicate connection point if overlapping\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                # Avoid duplicate middle point\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n\n                # Apply shortcutting to smooth path and reduce length\n                smooth_path = shortcut_path(combined_path)\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # Time limit or max_iter reached with no full path\n        # Return best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -37.37284,
          "time_improvement": 65.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1594.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013492751121520995,
                    "num_nodes_avg": 116.9,
                    "path_length_avg": 167.48639160694592,
                    "smoothness_avg": 0.046124220571561826,
                    "success_improvement": 0.0,
                    "time_improvement": 46.30306814127721,
                    "length_improvement": 8.198054768521205,
                    "smoothness_improvement": 621.9442122930357,
                    "objective_score": 21.91947436496106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023199057579040526,
                    "num_nodes_avg": 285.8,
                    "path_length_avg": 234.67161709331359,
                    "smoothness_avg": 0.11706785284768806,
                    "success_improvement": 0.0,
                    "time_improvement": 85.56632689312731,
                    "length_improvement": 21.659859566275518,
                    "smoothness_improvement": 2912.240174337157,
                    "objective_score": 53.227014679389285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0182589054107666,
                    "num_nodes_avg": 226.6,
                    "path_length_avg": 120.43817791147322,
                    "smoothness_avg": 0.10596483217621462,
                    "success_improvement": 0.0,
                    "time_improvement": 62.42098600050051,
                    "length_improvement": 20.010696880938188,
                    "smoothness_improvement": 1247.864843771141,
                    "objective_score": 36.972038147568774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with goal bias sampling, adaptive rewiring radius, early stopping upon path connection, and basic path shortcutting post-processing within a strict 30-second time limit. The planner alternately grows start and goal trees by sampling free space points biased toward the goal, extends trees with collision-checked edges using fixed step size steering, rewires locally for minimum cost, and attempts greedy connection of trees each iteration to find a shortest feasible path efficiently. Once connected or time expires, it extracts and smooths the path by shortcutting to provide improved path length and smoothness while reducing planning time.",
          "planning_mechanism": "The planner grows two trees from start and goal points alternately using goal-biased random sampling within map bounds and obstacle free space. Each sampled point extends the respective tree using a fixed step size and adaptive radius neighbor search to choose the best parent minimizing path cost while performing collision checks on nodes and edges. Local rewiring optimizes cost-to-come values dynamically. After extension, it attempts to connect the two trees greedily. The planner terminates early upon successful connection or after 30 seconds, returning the best path found with shortcut smoothing applied.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                scale = self.step_size / d\n                new_p = tuple(from_p[i] + (to_p[i] - from_p[i]) * scale for i in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(min(max(new_p[i], 0), bounds[i]) for i in range(dim))\n\n        def sample():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return goal_pos\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n)/n) ** (1/dim), self.step_size * 10)\n\n        def neighbors_within_radius(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_from, tree_to = nodes_start, nodes_goal\n            else:\n                tree_from, tree_to = nodes_goal, nodes_start\n\n            q_rand = sample()\n            nearest_node = min(tree_from, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = neighbors_within_radius(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                c_through_nb = nb.cost + dist(nb.position, new_pos)\n                if c_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = c_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_via_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                        nb.update_parent(new_node, c_via_new)\n                        edges.append((new_node, nb))\n\n            # Try connection from tree_to to new_node\n            nearest_other = min(tree_to, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                steered_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(steered_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, steered_pos, obstacles, is_3d):\n                    break\n\n                new_to_node = Node(steered_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, steered_pos))\n                tree_to.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n\n                if dist(steered_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(steered_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_node.position, steered_pos))\n                        tree_to.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_start_node = new_node if tree_from is nodes_start else final_node\n                            best_goal_node = final_node if tree_to is nodes_goal else new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n\n            if connected:\n                break\n\n        extracted_path = []\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            extracted_path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges,\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shorthand = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shorthand.append(path[j])\n            i = j\n        return shorthand\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.47883,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1917.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01217057704925537,
                    "num_nodes_avg": 83.6,
                    "path_length_avg": 152.90926987361797,
                    "smoothness_avg": 0.04401612878654404,
                    "success_improvement": 0.0,
                    "time_improvement": 51.56490765972629,
                    "length_improvement": 16.188006179833796,
                    "smoothness_improvement": 588.9479980629259,
                    "objective_score": 28.12701599613279
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02094416618347168,
                    "num_nodes_avg": 271.3,
                    "path_length_avg": 235.2451134926445,
                    "smoothness_avg": 0.14098320673972334,
                    "success_improvement": 0.0,
                    "time_improvement": 86.96924445494005,
                    "length_improvement": 21.468409961000273,
                    "smoothness_improvement": 3527.5994555123716,
                    "objective_score": 56.60981659064404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.043598508834838866,
                    "num_nodes_avg": 369.6,
                    "path_length_avg": 124.37076435048513,
                    "smoothness_avg": 0.13647305078069294,
                    "success_improvement": 0.0,
                    "time_improvement": 10.26904751389891,
                    "length_improvement": 17.398860217789284,
                    "smoothness_improvement": 1635.9271325376515,
                    "objective_score": 21.6996660475315
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive rewiring radius, improved goal biasing, and early termination on first feasible path. It uses an incremental rewiring strategy focused on local neighbor nodes, efficient collision checking, and a final iterative shortcut smoothing step. The planner alternates expansions between start and goal trees, dynamically adjusts rewiring radius based on the current number of nodes and dimensionality, and carefully combines partial paths to provide shorter, smoother trajectories within a strict 30-second limit.",
          "planning_mechanism": "A bidirectional RRT* planner grows two trees alternately from start and goal with goal-biased sampling. For each new sample, it selects the best parent within an adaptive radius minimizing total cost and collision-free edges, then rewires neighbors to improve path quality locally. After each node addition, it attempts to connect the two trees to find a feasible path. Upon finding the first path, the planner performs shortcutting smoothing and terminates. It respects map boundaries and obstacles with strict node and edge collision checks and returns the best-path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 6.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(goal_bias=self.goal_sample_rate):\n            if random.random() < goal_bias and not is_in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # Fallback sampling without obstacle checking\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i + 1])\n                    i += 1\n            return shortened\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            n = len(tree_a)\n            gamma_rrt = 40.0\n            min_radius = self.step_size * 2.0\n            radius = max(min_radius, min(gamma_rrt * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 25))\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n\n                # Avoid duplicates of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                elif path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                combined_path = path_start + path_goal[::-1]\n                smooth_path = combined_path\n                # Perform iterative shortcutting for smoothing (3 passes or until no changes)\n                for _ in range(3):\n                    shortened_path = shortcut_path(smooth_path)\n                    if len(shortened_path) == len(smooth_path):\n                        break\n                    smooth_path = shortened_path\n\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n            expand_start_tree = not expand_start_tree\n\n        # No full path found, attempt best partial path from start tree closest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            if not node.valid:\n                continue\n            d = dist(node.position, goal_pos)\n            if d < best_dist:\n                best_dist = d\n                best_partial_node = node\n\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            smooth_partial = shortcut_path(partial_path)\n            return PlannerResult(False, smooth_partial, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -33.51759,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1395.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016870689392089844,
                    "num_nodes_avg": 109.1,
                    "path_length_avg": 169.23046316696446,
                    "smoothness_avg": 0.04606696226265718,
                    "success_improvement": 0.0,
                    "time_improvement": 32.859929710568466,
                    "length_improvement": 7.242101509892628,
                    "smoothness_improvement": 621.0479954202699,
                    "objective_score": 17.308479796207465
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020358180999755858,
                    "num_nodes_avg": 252.1,
                    "path_length_avg": 234.6956628422056,
                    "smoothness_avg": 0.09618350961117793,
                    "success_improvement": 0.0,
                    "time_improvement": 87.33382472111715,
                    "length_improvement": 21.65183240317686,
                    "smoothness_improvement": 2374.8709804773357,
                    "objective_score": 51.06560176062794
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024741458892822265,
                    "num_nodes_avg": 258.9,
                    "path_length_avg": 121.67835462081044,
                    "smoothness_avg": 0.10130145493652461,
                    "success_improvement": 0.0,
                    "time_improvement": 49.07911459176714,
                    "length_improvement": 19.1870305614652,
                    "smoothness_improvement": 1188.5470294969864,
                    "objective_score": 32.17868786189419
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An efficient bidirectional RRT* planner with adaptive neighbor radius and lazy collision checking, combined with goal-biased informed sampling and progressive rewiring. The planner grows start and goal trees alternately, attempts direct connection every iteration, and employs an incremental collision checking approach to minimize unnecessary computations. Early stopping on first valid connection and a multi-pass shortcutting post-processing step ensure high-quality, smooth, and short paths within a strict 30-second time limit.",
          "planning_mechanism": "The planner alternately extends two trees rooted at start and goal by sampling points biased toward the goal and within an informed ellipsoid around the current best path cost. Neighborhood radius adapts dynamically shrinking as nodes increase. New nodes are connected via minimal-cost parents, rewiring neighbors for better paths if collision free. Trees attempt direct connection every iteration to find a path. Lazy collision checks reduce edge validation calls. When a path is found, iterative shortcutting is applied to smooth and shorten before returning. Timing is strictly enforced to return the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=6.0,\n                 goal_sample_rate: float=0.15, gamma_rrt_star: float=50.0,\n                 max_neighbor_radius: float=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free(best_cost: float):\n            # Goal biased informed sampling\n            if best_cost < float('inf'):\n                c_best = best_cost\n                c_min = dist(start_pos, goal_pos)\n                if c_best < c_min:\n                    c_best = c_min + 1e-3\n                # Sample inside an ellipsoid between start and goal\n                center = tuple((s + g) / 2.0 for s, g in zip(start_pos, goal_pos))\n                diff = tuple(g - s for s, g in zip(start_pos, goal_pos))\n                unit_vec = tuple(d / c_min for d in diff)\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        p = goal_pos\n                    else:\n                        # Sample inside unit n-ball scaled to current cost radius\n                        while True:\n                            x = [random.uniform(-1,1) for _ in range(dim)]\n                            norm_x = math.sqrt(sum(v*v for v in x))\n                            if norm_x <= 1:\n                                break\n                        scale = c_best / 2.0\n                        sample = tuple(center[i] + scale * x[i] for i in range(dim))\n                        p = sample\n                    if in_bounds(p) and is_free_node(p):\n                        return p\n            else:\n                # Uniform random sampling\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if is_free_node(p):\n                        return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree[0]\n            best_dist = dist(best_node.position, point)\n            for node in tree[1:]:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], point: Tuple[float, ...], n_nodes: int) -> List[Node]:\n            if n_nodes < 2:\n                return []\n            r = self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2.0, r))\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def lazy_collision_check_edge(parent_pos, new_pos):\n            # Lazy collision: Check only after rewiring to reduce calls\n            # Here we'll do a coarse resolution check\n            length = dist(parent_pos, new_pos)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(parent_pos[d] + (new_pos[d] - parent_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def choose_parent_and_add(tree: List[Node], new_pos: Tuple[float, ...], nodes_ref: List[Node], edges_ref: List[Tuple[Node,Node]]) -> Optional[Tuple[Node,List[Node]]]:\n            nearest_node_ = nearest(tree, new_pos)\n            neighbors = near_nodes(tree, new_pos, len(tree))\n            min_cost = nearest_node_.cost + dist(nearest_node_.position, new_pos)\n            best_parent = nearest_node_\n            for nb in neighbors:\n                if nb is nearest_node_:\n                    continue\n                new_cost = nb.cost + dist(nb.position, new_pos)\n                if new_cost < min_cost and lazy_collision_check_edge(nb.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = nb\n            if not lazy_collision_check_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes_ref.append(new_node)\n            tree.append(new_node)\n            edges_ref.append((best_parent, new_node))\n            return (new_node, neighbors)\n\n        def rewire(node: Node, neighbors: List[Node], edges_ref: List[Tuple[Node, Node]]):\n            n_updated = []\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                potential_cost = node.cost + dist(node.position, nb.position)\n                if potential_cost + 1e-15 < nb.cost:\n                    if lazy_collision_check_edge(node.position, nb.position):\n                        # Remove old parent edge\n                        if nb.parent is not None:\n                            try:\n                                edges_ref.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = node\n                        nb.cost = potential_cost\n                        node.children.append(nb)\n                        edges_ref.append((node, nb))\n                        n_updated.append(nb)\n            return n_updated\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float,...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path_points: List[Tuple[float,...]]) -> List[Tuple[float,...]]:\n            # Iterative shortcutting, max 20 iterations\n            if len(path_points) < 3:\n                return path_points\n            for _ in range(20):\n                changed = False\n                i = 0\n                while i < len(path_points) - 2:\n                    j = len(path_points) -1\n                    while j > i+1:\n                        if self._is_edge_in_obstacle(path_points[i], path_points[j], obstacles, is_3d) == False:\n                            # Remove intermediate points between i and j\n                            del path_points[i+1:j]\n                            changed = True\n                            break\n                        j -= 1\n                    i += 1\n                if not changed:\n                    break\n            return path_points\n\n        # Initialize trees\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float('inf')\n        best_path_nodes: List[Tuple[float,...]] = []\n        success = False\n\n        for iteration in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > time_limit:\n                break\n\n            # Goal biased informed sampling\n            sample = sample_free(best_cost)\n\n            # Alternate tree expansion (start and goal)\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node_a = nearest(tree_a, sample)\n            new_pos = steer(nearest_node_a.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            result = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if result is None:\n                continue\n            new_node, neighbors = result\n\n            # Rewire neighbors for better cost and smoothness\n            rewired_list = rewire(new_node, neighbors, edges)\n            # Rewire descendants of rewired nodes to propagate cost changes\n            stack = rewired_list[:]\n            while stack:\n                current = stack.pop()\n                nbs = near_nodes(tree_a, current.position, len(tree_a))\n                updated = rewire(current, nbs, edges)\n                stack.extend(updated)\n\n            # Attempt direct connection between the trees\n            nearest_in_b = nearest(tree_b, new_node.position)\n            d_connect = dist(new_node.position, nearest_in_b.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_b.position, obstacles, is_3d) and \\\n                   not self._is_in_obstacle(nearest_in_b.position, obstacles, is_3d):\n                    # Connect nodes\n                    connection_cost = new_node.cost + d_connect + nearest_in_b.cost\n                    if connection_cost < best_cost:\n                        best_cost = connection_cost\n                        success = True\n                        best_path_nodes = extract_path(new_node, nearest_in_b)\n                        break\n\n        if not success:\n            # No full path found: fallback to closest node to goal in start tree\n            nearest_to_goal = min(tree_start, key=lambda n: dist(n.position, goal_pos))\n            best_path_nodes = nearest_to_goal.path_from_root()\n\n        # Post processing shortcutting for smoothness and path length reduction\n        best_path_nodes = shortcut_path(best_path_nodes)\n\n        return PlannerResult(success=success, path=best_path_nodes, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.74393,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1472.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021446037292480468,
                    "num_nodes_avg": 113.1,
                    "path_length_avg": 176.47272688924454,
                    "smoothness_avg": 0.04248383520373107,
                    "success_improvement": 0.0,
                    "time_improvement": 14.651475243090614,
                    "length_improvement": 3.2725020026983387,
                    "smoothness_improvement": 564.9642760631306,
                    "objective_score": 9.18376515486184
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03069620132446289,
                    "num_nodes_avg": 216.9,
                    "path_length_avg": 230.6354170258171,
                    "smoothness_avg": 0.09651290874646615,
                    "success_improvement": 0.0,
                    "time_improvement": 80.90185629176865,
                    "length_improvement": 23.00725932438326,
                    "smoothness_improvement": 2383.3466574849085,
                    "objective_score": 49.99164576958509
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01662287712097168,
                    "num_nodes_avg": 151.1,
                    "path_length_avg": 120.51235911651352,
                    "smoothness_avg": 0.1233196053310919,
                    "success_improvement": 0.0,
                    "time_improvement": 65.78812814964205,
                    "length_improvement": 19.961429256679807,
                    "smoothness_improvement": 1468.6162773050767,
                    "objective_score": 39.05637738542588
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired path planner with goal bias sampling, fixed-radius rewiring, and early termination that balances fast convergence, improved path quality, and smoothness by incrementally optimizing connections and limiting search to feasible regions.",
          "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternately sampling with a small goal bias, steering towards sampled points with fixed step size, rewiring neighbors in a fixed radius for cost optimization, and stopping early upon first valid path connection. The final path excludes duplicate nodes and is constructed by concatenating and smoothing the two tree branches.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.05  # 5% samples biased to goal\n        self.rewire_radius = 15.0     # fixed radius for rewiring neighbors\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        time_limit = 30.0  # 30 s wall-clock hard limit\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist=None):\n            d = dist(from_pos, to_pos)\n            step = max_dist if max_dist is not None else self.step_size\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=1.0):\n            distance = dist(a,b)\n            steps = max(1,int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            return min(tree, key = lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position, p) <= radius]\n\n        # Goal bias sampling: occasionally return goal directly, else uniform random in bounds free space\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback if unlucky\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Initialize trees and supporting structures\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        success = False\n        path = []\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        # Alternate tree growth\n        expand_start_tree = True\n\n        for iter_count in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            x_rand = sample_free()\n\n            nearest_node = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_node.position, x_rand, self.step_size)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n\n            # Choose best parent among neighbors\n            radius = self.rewire_radius\n            neighbors = near_nodes(tree_a, new_pos, radius)\n            best_parent = nearest_node\n            min_cost = new_cost\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = tentative_cost\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire other neighbors if better connection found\n            for nb in neighbors:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge if exists\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = alt_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes in radius\n            near_other = near_nodes(tree_b, new_node.position, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                # Calculate total cost of connection\n                total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    success = True\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n\n            if success:\n                # Extract combined path with duplicate connection point removed\n                path_start = best_start_node.path_from_root()\n                path_goal = best_goal_node.path_from_root()\n                if path_start[-1] == path_goal[0]:\n                    path_goal = path_goal[1:]\n                path = path_start + path_goal[::-1]\n                break\n\n            expand_start_tree = not expand_start_tree\n\n        # If success, return full path\n        if success:\n            return PlannerResult(\n                success=True,\n                path=path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # Otherwise return best partial path from start tree nearest to goal\n        best_partial_node = None\n        best_dist = float('inf')\n        for node in tree_start:\n            d = dist(node.position, goal_pos)\n            if d < best_dist and node.valid:\n                best_dist = d\n                best_partial_node = node\n        if best_partial_node:\n            partial_path = best_partial_node.path_from_root()\n            return PlannerResult(\n                success=False,\n                path=partial_path,\n                nodes=nodes,\n                edges=edges\n            )\n\n        # No progress case\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -31.88223,
          "time_improvement": 70.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 318.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012917828559875489,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 167.70136746333029,
                    "smoothness_avg": 0.02325991201186068,
                    "success_improvement": 0.0,
                    "time_improvement": 48.591080225594155,
                    "length_improvement": 8.080223095126494,
                    "smoothness_improvement": 264.06813269298925,
                    "objective_score": 20.74579858821909
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019352173805236815,
                    "num_nodes_avg": 256.2,
                    "path_length_avg": 239.51954011716208,
                    "smoothness_avg": 0.01718477585351879,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95972855101965,
                    "length_improvement": 20.041483321187638,
                    "smoothness_improvement": 342.17666040477565,
                    "objective_score": 40.123691860042356
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013465619087219239,
                    "num_nodes_avg": 182.0,
                    "path_length_avg": 122.07168904397376,
                    "smoothness_avg": 0.03515560414413786,
                    "success_improvement": 0.0,
                    "time_improvement": 72.28614329245853,
                    "length_improvement": 18.92579656617262,
                    "smoothness_improvement": 347.1766897966619,
                    "objective_score": 34.77720437642444
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "return a hybrid bidirectional RRT* with adaptive informed sampling, dynamic spatial hashing neighbor radius rewiring, downstream cost propagation, goal biasing, early stopping on first connection, and multi-pass path shortcut smoothing for enhanced efficiency, path quality, and smoothness",
          "planning_mechanism": "The planner grows forward and backward trees alternately using goal-biased and informed samples inside an ellipsoid around the best cost, steering towards samples with a capped step size, adding collision-free nodes choosing best parent minimizing cost within a dynamic radius efficiently queried with spatial hashing, rewiring neighbors with downstream cost propagation for optimal cost updates, attempts direct tree connections each iteration with early stopping, and applies multi-pass shortcutting to refine the final concatenated path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start (or goal)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=4.0, goal_sample_rate=0.07, time_limit=30.0,\n                 max_neighbor_radius=25.0, min_neighbor_radius=2.5, shortcut_passes=4, shortcut_attempts=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_free_node(p):\n            return in_bounds(p) and not is_in_obstacle(p)\n\n        def is_edge_in_obstacle(p1,p2, resolution= min(1.0, self.step_size*0.35)):\n            distance = dist(p1,p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p,to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step/d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        # Rotation matrices for informed sampling\n        def build_rotation_matrix(a):\n            if dim == 2:\n                cos_theta, sin_theta = a[0], a[1]\n                return [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                # Choose a vector not colinear with x_axis\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                dot = sum(x_axis[i]*temp[i] for i in range(3))\n                v = tuple(temp[i] - dot*x_axis[i] for i in range(3))\n                norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(v[i]/norm_v for i in range(3))\n                w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                return [[x_axis[0], v_unit[0], w[0]],\n                        [x_axis[1], v_unit[1], w[1]],\n                        [x_axis[2], v_unit[2], w[2]]]\n            else:\n                return None\n\n        def informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            c_min = dist(x_start, x_goal)\n            if c_min <= 0.0:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i])/2.0 for i in range(dim))\n            unit = tuple((x_goal[i] - x_start[i])/ c_min for i in range(dim))\n            R = build_rotation_matrix(unit)\n            if R is None:\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if is_free_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            r1 = c_best/2.0\n            rad_sq = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(rad_sq)/2.0 if rad_sq > 1e-12 else max(self.min_neighbor_radius*0.1, 0.001)\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x/norm_rnd for x in rnd]\n            scale = random.random() ** (1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            if is_free_node(clipped):\n                return clipped\n            # fallback uniform + collision free\n            for _ in range(20):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            return clipped\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n) / n) ** (1.0/dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial Hash Grid for neighbor queries\n        class SpatialHashGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.cells = {}\n                self.dim = len(domain)\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d]//self.cell_size) for d in range(self.dim))\n\n            def add(self, node):\n                cc = self._cell_coords(node.position)\n                self.cells.setdefault(cc, []).append(node)\n\n            def remove(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells:\n                    try:\n                        self.cells[cc].remove(node)\n                        if not self.cells[cc]:\n                            del self.cells[cc]\n                    except ValueError:\n                        pass\n\n            def neighbors(self, p, radius):\n                center_cc = self._cell_coords(p)\n                r_cells = int(math.ceil(radius/self.cell_size))\n                nbrs = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            cc = (center_cc[0]+dx, center_cc[1]+dy)\n                            if cc in self.cells:\n                                nbrs.extend(self.cells[cc])\n                elif self.dim == 3:\n                    for dx in range(-r_cells, r_cells+1):\n                        for dy in range(-r_cells, r_cells+1):\n                            for dz in range(-r_cells, r_cells+1):\n                                cc = (center_cc[0]+dx, center_cc[1]+dy, center_cc[2]+dz)\n                                if cc in self.cells:\n                                    nbrs.extend(self.cells[cc])\n                else:\n                    # Fallback linear search if dim unsupported\n                    return []\n                # Filter Euclidean distance\n                r_sq = radius*radius\n                filtered = []\n                for node in nbrs:\n                    sum_sq=0.0\n                    for i_d in range(self.dim):\n                        diff = node.position[i_d] - p[i_d]\n                        sum_sq += diff*diff\n                        if sum_sq > r_sq:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n\n        # Trees initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        grid_cell_size = self.max_neighbor_radius\n        grid_start = SpatialHashGrid(bounds, grid_cell_size)\n        grid_goal = SpatialHashGrid(bounds, grid_cell_size)\n        grid_start.add(tree_start[0])\n        grid_goal.add(tree_goal[0])\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        # To propagate downstream cost updates after rewiring\n        def propagate_cost(n):\n            stack = n.children[:]\n            while stack:\n                c = stack.pop()\n                new_cost = c.parent.cost + dist(c.parent.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        # Extract full path by concatenating forward and backward trees\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate pivot node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        # Multi-pass shortcutting to smooth path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(self.shortcut_passes):\n                improved = False\n                for __ in range(self.shortcut_attempts):\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path)-3)\n                    j = random.randint(i+2, len(new_path)-1)\n                    p1, p2 = new_path[i], new_path[j]\n                    if not is_edge_in_obstacle(p1,p2):\n                        # shortcut\n                        del new_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        # Alternate tree expansion sets\n        trees = [(tree_start, grid_start, tree_goal, grid_goal),\n                 (tree_goal, grid_goal, tree_start, grid_start)]\n        expand_forward = True\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            current_tree, current_grid, other_tree, other_grid = trees[0 if expand_forward else 1]\n\n            # Informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if expand_forward else start_pos\n            else:\n                sample = informed_sample(best_cost, start_pos, goal_pos)\n\n            nearest = None\n            min_d = float('inf')\n            # Use spatial grid neighbors with large radius to approximate nearest quickly\n            approx_radius = self.step_size*4.0\n            approx_neighbors = current_grid.neighbors(sample, approx_radius)\n            for node in approx_neighbors:\n                d_ = dist(node.position, sample)\n                if d_ < min_d:\n                    nearest = node\n                    min_d = d_\n            if nearest is None:\n                # fallback linear search\n                for node in current_tree:\n                    d_ = dist(node.position, sample)\n                    if d_ < min_d:\n                        nearest = node\n                        min_d = d_\n            if nearest is None:\n                # isolated, skip iteration\n                expand_forward = not expand_forward\n                continue\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                expand_forward = not expand_forward\n                continue\n\n            radius = neighbor_radius(len(current_tree))\n            nbrs = current_grid.neighbors(new_pos, radius)\n\n            # Find best parent among neighbors minimizing cost if edge collision free\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in nbrs:\n                c_cand = nb.cost + dist(nb.position, new_pos)\n                if c_cand + 1e-12 < min_cost:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        min_cost = c_cand\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            current_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            current_grid.add(new_node)\n\n            # Rewire neighbors through new_node if cheaper with downstream propagation\n            for nb in nbrs:\n                if nb is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if not is_edge_in_obstacle(new_node.position, nb.position):\n                        # Remove old edge\n                        if nb.parent is not None:\n                            p_old = nb.parent\n                            nb.parent.remove_child(nb)\n                            try:\n                                edges.remove((p_old, nb))\n                            except ValueError:\n                                pass\n                        # Update parent and cost\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n                        propagate_cost(nb)\n\n            # Attempt connections to opposite tree nodes within radius via spatial grid neighbor query\n            candidates_other = other_grid.neighbors(new_pos, radius)\n            radius_sq = radius*radius\n            for onode in candidates_other:\n                # Skip if path cost already no better\n                path_cost = new_node.cost + dist(new_node.position, onode.position) + onode.cost\n                if path_cost + 1e-12 >= best_cost:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, onode.position):\n                    # Connected, update best solution\n                    best_cost = path_cost\n                    if expand_forward:\n                        best_start_node = new_node\n                        best_goal_node = onode\n                    else:\n                        best_start_node = onode\n                        best_goal_node = new_node\n                    success = True\n                    # Early stop on first feasible path found\n                    expand_forward = None\n                    break\n            if expand_forward is None:\n                break\n            expand_forward = not expand_forward\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            extracted_path = extract_path(best_start_node, best_goal_node)\n        else:\n            # fallback: closest node in start tree to goal\n            min_dist = float('inf')\n            closest = None\n            for n in tree_start:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_dist:\n                    min_dist = d_\n                    closest = n\n            if closest is not None:\n                # extract path from start to closest\n                extracted_path = []\n                cur = closest\n                while cur is not None:\n                    extracted_path.append(cur.position)\n                    cur = cur.parent\n                extracted_path.reverse()\n            else:\n                extracted_path = [start_pos]\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -30.37323,
          "time_improvement": 45.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1451.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025295782089233398,
                    "num_nodes_avg": 118.0,
                    "path_length_avg": 163.64877987889284,
                    "smoothness_avg": 0.04555539867781646,
                    "success_improvement": 0.0,
                    "time_improvement": -0.6693056831206631,
                    "length_improvement": 10.30151056751639,
                    "smoothness_improvement": 613.040914439408,
                    "objective_score": 9.045319207770675
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03927867412567139,
                    "num_nodes_avg": 339.3,
                    "path_length_avg": 234.67176147723148,
                    "smoothness_avg": 0.08988377060089861,
                    "success_improvement": 0.0,
                    "time_improvement": 75.562130467165,
                    "length_improvement": 21.659811366767865,
                    "smoothness_improvement": 2212.774158224248,
                    "objective_score": 46.72839675133146
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01972932815551758,
                    "num_nodes_avg": 217.3,
                    "path_length_avg": 125.75597997811558,
                    "smoothness_avg": 0.1279922908485313,
                    "success_improvement": 0.0,
                    "time_improvement": 59.39467989577659,
                    "length_improvement": 16.478865954797055,
                    "smoothness_improvement": 1528.0524921851381,
                    "objective_score": 35.3459860025369
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "\"A bidirectional RRT* planner enhanced with goal bias sampling, adaptive neighbor radius rewiring, early termination on first solution, and path shortcut smoothing. The planner grows start and goal trees alternately, rewires nodes within a dynamically shrinking radius to optimize cost and smoothness, attempts to connect trees at each iteration, and applies shortcut smoothing after path extraction to improve length and smoothness while respecting a 30-second time limit.\"",
          "planning_mechanism": "The planner samples mostly uniformly but with a small bias toward the goal to speed convergence, grows and rewires two trees alternately using an adaptive neighbor radius based on tree size and dimension, attempts connections after each new node addition, and upon finding a valid path or time expiry, extracts and shortcut-smooths the combined path before returning it. Collision checks ensure validity of new nodes and edges throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        time_start = time.monotonic()\n        time_limit = 30.0\n\n        def in_time():\n            return time.monotonic() - time_start < time_limit\n\n        def sample_free():\n            p_goal_bias = 0.05\n            if random.random() < p_goal_bias:\n                return goal_position\n            while True:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if self._sqdist(n.position, point) <= r2]\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            # Choose minimum cost parent\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(near_node.position, new_node.position, obstacles, is_3d)\n                cost_through = near_node.cost + math.dist(near_node.position, new_node.position)\n                if edge_clear and cost_through < min_cost:\n                    min_cost = cost_through\n                    min_parent = near_node\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                        edges.remove((new_node.parent, new_node))\n                    except Exception:\n                        pass\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                edges.append((min_parent, new_node))\n            # Now rewire near nodes to new_node if beneficial\n            for near_node in near_nodes:\n                if near_node == new_node or near_node == min_parent:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                cost_through = new_node.cost + math.dist(new_node.position, near_node.position)\n                if edge_clear and cost_through < near_node.cost:\n                    if near_node.parent:\n                        try:\n                            near_node.parent.children.remove(near_node)\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = cost_through\n                    new_node.children.append(near_node)\n                    edges.append((new_node, near_node))\n\n        def try_connect(tree_a, tree_b):\n            # Attempt to connect a new node in tree_a to nearest in tree_b within step_size, extend incrementally\n            last_node = None\n            for node_a in tree_a[-1:]:  # only last added node\n                nearest_b = nearest(tree_b, node_a.position)\n                dist = math.dist(node_a.position, nearest_b.position)\n                if dist <= self.step_size and not self._is_edge_in_obstacle(node_a.position, nearest_b.position, obstacles, is_3d):\n                    return node_a, nearest_b\n                # Try to incrementally extend tree_b toward node_a\n                from_pos = nearest_b.position\n                to_pos = node_a.position\n                direction_dist = dist\n                steps = int(direction_dist / self.step_size)\n                current_node = nearest_b\n                for step_i in range(steps):\n                    next_pos = steer(from_pos, to_pos)\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, next_pos, obstacles, is_3d):\n                        break\n                    new_node = Node(next_pos, parent=current_node,\n                                    cost=current_node.cost + math.dist(current_node.position, next_pos))\n                    current_node.add_child(new_node)\n                    tree_b.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((current_node, new_node))\n                    from_pos = next_pos\n                    current_node = new_node\n                    if math.dist(next_pos, node_a.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(next_pos, node_a.position, obstacles, is_3d):\n                            return node_a, current_node\n                # else no connection\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Adaptive rewiring radius based on problem dimension and number of nodes\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 2.0\n            from math import log, pi, pow\n            gamma_rrt_star = 2 * (1 + 1/dim)**(1/dim) * pow((pi / 2), 1/dim)\n            r = min(self.step_size * 15.0, gamma_rrt_star * pow(log(n)/n, 1/dim))\n            return max(r, self.step_size)\n\n        for iteration in range(self.max_iter):\n            if not in_time():\n                break\n            sample = sample_free()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos)\n                dist_to_parent = math.dist(nearest_node.position, new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist_to_parent\n                nearest_node.children.append(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                radius = adaptive_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                connected = try_connect(tree_a, tree_b)\n                if connected:\n                    node_a, node_b = connected\n                    success_state = True\n                    extracted_path = extract_path(node_a, node_b)\n                    extracted_path = shortcut_path(extracted_path)\n                    return PlannerResult(\n                        success=success_state,\n                        path=extracted_path,\n                        nodes=nodes,\n                        edges=edges\n                    )\n\n        # If timeout or max iterations reached return best path if any\n        if success_state:\n            extracted_path = shortcut_path(extracted_path)\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _sqdist(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))",
          "objective": -29.96541,
          "time_improvement": 36.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1980.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012406229972839355,
                    "num_nodes_avg": 103.5,
                    "path_length_avg": 160.7183397829509,
                    "smoothness_avg": 0.05658427722082725,
                    "success_improvement": 0.0,
                    "time_improvement": 50.627082684965195,
                    "length_improvement": 11.907731219897055,
                    "smoothness_improvement": 785.6668132306096,
                    "objective_score": 26.26109760358084
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04006195068359375,
                    "num_nodes_avg": 314.0,
                    "path_length_avg": 238.79163146455207,
                    "smoothness_avg": 0.13025351165853924,
                    "success_improvement": 0.0,
                    "time_improvement": 75.07480214571018,
                    "length_improvement": 20.284480181117733,
                    "smoothness_improvement": 3251.516672786518,
                    "objective_score": 50.95071211631628
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05753490924835205,
                    "num_nodes_avg": 302.3,
                    "path_length_avg": 128.73178230846412,
                    "smoothness_avg": 0.15734441021955675,
                    "success_improvement": 0.0,
                    "time_improvement": -18.413733543350357,
                    "length_improvement": 14.502479739459062,
                    "smoothness_improvement": 1901.4092840364967,
                    "objective_score": 12.684414200852814
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT*-inspired planner using a fixed rewiring radius, uniform and goal-biased sampling combined with ellipsoidal informed sampling after first solution, efficient neighbor rewiring with downstream cost propagation for global path improvements, and immediate termination on first path found to reduce planning time and improve path smoothness and length. The planner alternates tree growth from start and goal, rewires neighbors within a fixed radius to enhance path quality, attempts direct tree connections for fast convergence, and applies advanced path shortcutting after completion for smooth optimized paths.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points with an initial goal bias. After the first solution is found, sampling switches to ellipsoidal informed sampling within the current best path cost to focus search efficiently. New nodes connect to the best parent found in a neighborhood defined by a fixed radius and rewiring is performed to lower path costs. Downstream cost propagation ensures consistent cost update in subtrees. The trees attempt direct connection when nodes are close, and the algorithm stops immediately after a path is found, returning a shortened and smoothed final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n        if parent is not None:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent != new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 40.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n        self.goal_sample_rate = 0.05  # initial goal bias\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            distance = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size*0.5)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            # Limited tries to prevent infinite loops\n            for _ in range(100):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            # fallback to start to avoid endless loop\n            return start_pos\n\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0.0)) / 2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1], v[2]*e1[0]-v[0]*e1[2], v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1], k[2]*v_vec[0]-k[0]*v_vec[2], k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i] + rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree_nodes, pt):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def propagate_costs_downstream(node):\n            # BFS to update costs of descendants with improved cost via node\n            from collections import deque\n            queue = deque([node])\n            while queue:\n                curr = queue.popleft()\n                for c in curr.children:\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + self.improve_tol < c.cost:\n                        c.cost = new_cost\n                        c.parent = curr\n                        queue.append(c)\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n                        propagate_costs_downstream(nbr)\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, new_pos)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                est_cost = nbr.cost + dist(nbr.position, new_pos)\n                if est_cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = est_cost\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def merge_trees(node_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_a.position)\n            d = dist(node_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return None\n            total_cost = node_a.cost + d + nearest_b.cost\n            path_a = node_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            # avoid duplicate node at merge\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization of trees and data containers\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling: use goal bias at start, switch to informed sampling after solution\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n\n            if is_in_obstacle(sample):\n                continue  # sample rejected\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                candidate_path, candidate_cost = merged\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    break  # early stopping on first path found\n\n        # If no solution found, attempt heuristic fallback\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n                found_solution = True\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = found_solution\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -28.94013,
          "time_improvement": 45.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1369.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023919391632080077,
                    "num_nodes_avg": 136.4,
                    "path_length_avg": 178.50161436538082,
                    "smoothness_avg": 0.04000668691404389,
                    "success_improvement": 0.0,
                    "time_improvement": 4.808298100059972,
                    "length_improvement": 2.1604366272486275,
                    "smoothness_improvement": 526.1915261159178,
                    "objective_score": 5.369709036946757
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028526616096496583,
                    "num_nodes_avg": 278.8,
                    "path_length_avg": 232.46150100985702,
                    "smoothness_avg": 0.09469756943367832,
                    "success_improvement": 0.0,
                    "time_improvement": 82.25169922617549,
                    "length_improvement": 22.397659929597573,
                    "smoothness_improvement": 2336.636669430822,
                    "objective_score": 49.7972890727653
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025488901138305663,
                    "num_nodes_avg": 262.7,
                    "path_length_avg": 122.55435246365639,
                    "smoothness_avg": 0.10578699719970948,
                    "success_improvement": 0.0,
                    "time_improvement": 47.54078893779472,
                    "length_improvement": 18.605234504781638,
                    "smoothness_improvement": 1245.6027959964083,
                    "objective_score": 31.653391364189442
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner utilizing informed ellipsoidal sampling after first solution, adaptive neighbor radius rewiring, and incremental tree connection with early stopping. It grows trees from both start and goal, rewires nodes for optimal costs within a shrinking radius, and focuses sampling within an ellipsoid around the current best path to improve efficiency. Finally, a sophisticated shortcutting smoothing post-process removes unnecessary waypoints to yield shorter, smoother paths within a 30-second limit.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, sampling points with goal biasing and switching to ellipsoidal informed samples once a path is found. Each new node connects via minimum-cost parent among neighbors within an adaptive radius, followed by rewiring neighbors for cost improvement. Tree merging attempts are made after each extension. Early stopping occurs immediately when a feasible connection forms. The final path is extracted by concatenating tree paths and shortcutting to produce smooth trajectories with improved length and reduced computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            dist_ab = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.5)\n            steps = max(1,int(dist_ab/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        # Ellipsoidal informed sampling around foci start and goal with cost c_best\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best/2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    # rotate coords to align with e1\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    # Rodrigues rotation from x-axis to e1\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i]+rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near_nodes(tree_nodes, pt):\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * ((math.log(n)/n) ** (1.0/dim))\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            near_n = near_nodes(tree_nodes, new_pos)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            # Check neighbors for better parent\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                if nbr.cost + dist(nbr.position, new_pos) + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = nbr.cost + dist(nbr.position, new_pos)\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n\n        def merge_trees(node_in_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_in_a.position)\n            d = dist(node_in_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_in_a.position, nearest_b.position):\n                return None\n            total_cost = node_in_a.cost + d + nearest_b.cost\n            path_a = node_in_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1\n            return path\n\n        # Initialization\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Sampling: goal bias and informed sampling after first solution\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = uniform_sample()\n            if is_in_obstacle(sample):\n                continue\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a = tree_start\n                tree_b = tree_goal\n            else:\n                tree_a = tree_goal\n                tree_b = tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            # Attempt merging trees\n            merge_res = merge_trees(new_node, tree_b)\n            if merge_res is not None:\n                path_candidate, cost_candidate = merge_res\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stopping immediately on connection\n                    break\n\n        # If no solution, try heuristic fallback: connect closest start tree node to goal if possible\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = found_solution\n        else:\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -28.30351,
          "time_improvement": 33.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1540.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020982789993286132,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 162.3763992712687,
                    "smoothness_avg": 0.04901655517737587,
                    "success_improvement": 0.0,
                    "time_improvement": 16.49505469064301,
                    "length_improvement": 10.998922540716148,
                    "smoothness_improvement": 667.2155296791497,
                    "objective_score": 14.88394758001834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034110093116760255,
                    "num_nodes_avg": 312.1,
                    "path_length_avg": 232.1285408403566,
                    "smoothness_avg": 0.101967152153144,
                    "success_improvement": 0.0,
                    "time_improvement": 78.77784767700604,
                    "length_improvement": 22.508811617903905,
                    "smoothness_improvement": 2523.688268871463,
                    "objective_score": 49.75708261820147
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04627988338470459,
                    "num_nodes_avg": 338.4,
                    "path_length_avg": 121.2062870795032,
                    "smoothness_avg": 0.12018983540199198,
                    "success_improvement": 0.0,
                    "time_improvement": 4.7504575721442865,
                    "length_improvement": 19.50055534496077,
                    "smoothness_improvement": 1428.805834822511,
                    "objective_score": 20.2694996527323
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An incremental single-tree Informed RRT* planner with adaptive, shrinking neighbor radius, accelerated nearest neighbor search using spatial hashing, combined with multi-pass iterative path shortcutting. The algorithm employs goal bias and ellipsoidal informed sampling post first solution to focus search, carefully balances exploration and exploitation, and enforces strict 30-second runtime constraint with immediate best-path return on timeout. It dynamically rewires locally to optimize path cost continuously while efficiently pruning unnecessary computations to minimize planning time.",
          "planning_mechanism": "The planner grows a tree from the start node, uses uniform random sampling initially and switches to ellipsoidal informed sampling after the first solution. Nearest neighbors and rewiring candidates are found efficiently via a spatial grid indexed structure with adaptive cell size. The neighbor search radius shrinks adaptively with the number of nodes to reduce computational overhead. Each new node chooses the parent minimizing cost with feasibility checks, then rewires nearby nodes to reduce their costs. The search terminates early if the goal is reached or time runs out, returning the best path found. A multi-pass shortcutting procedure iteratively improves path smoothness and length by attempting to bypass intermediate points where collision-free edges exist.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=6000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 max_neighbor_radius: float=20.0, min_neighbor_radius: float=2.0,\n                 shortcut_iters: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            # Node collision & boundary check\n            return in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Collision check with adaptive resolution (0.5 * step_size)\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Ellipsoidal informed sampling function\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                # No current solution: sample uniform random in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min < 1e-12:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n            # Build rotation matrix aligning x-axis to a1\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta = a[0]\n                    sin_theta = a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]]\n                elif dim ==3:\n                    x_axis = a\n                    # Orthonormal basis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    v = tuple(temp[i] - x_axis[i] * sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                    norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                    if norm_v < 1e-12:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = tuple(v[i]/norm_v for i in range(3))\n                    w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                    R = [list(x_axis), list(v_unit), list(w)]\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            r1 = c_best * 0.5\n            val = abs(c_best * c_best - c_min * c_min)\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0001\n            r2 = max(r2, 0.001)\n            radii = [r1] + [r2]*(dim -1)\n\n            while True:\n                # Sample unit ball point\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-12:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1.0/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            clipped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        # Spatial grid for neighbor search acceleration\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = dict()  # key: cell tuple to list of nodes\n\n            def _cell_coords(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n            def insert(self, node):\n                c = self._cell_coords(node.position)\n                if c not in self.grid:\n                    self.grid[c] = []\n                self.grid[c].append(node)\n\n            def remove(self, node):\n                c = self._cell_coords(node.position)\n                if c in self.grid and node in self.grid[c]:\n                    self.grid[c].remove(node)\n                    if not self.grid[c]:\n                        del self.grid[c]\n\n            def nearby_nodes(self, pos, radius):\n                cell_r = int(math.ceil(radius / self.cell_size))\n                center_cell = self._cell_coords(pos)\n                candidates = []\n                def rec(dim_idx, prefix):\n                    if dim_idx == self.dim:\n                        c = tuple(prefix)\n                        if c in self.grid:\n                            candidates.extend(self.grid[c])\n                        return\n                    for offset in range(-cell_r, cell_r+1):\n                        recursive_prefix = prefix + [center_cell[dim_idx]+offset]\n                        rec(dim_idx+1, recursive_prefix)\n                rec(0, [])\n                return candidates\n\n        def nearest_node(p):\n            # Use spatial grid for candidates\n            candidate_radius = search_radius * 1.2\n            candidates = grid.nearby_nodes(p, candidate_radius)\n            best = None\n            best_dist = float(\"inf\")\n            for node in candidates:\n                dcur = dist(node.position, p)\n                if dcur < best_dist:\n                    best_dist = dcur\n                    best = node\n            if best is None and nodes:\n                # fallback linear search\n                best = nodes[0]\n                best_dist = dist(best.position, p)\n                for n in nodes[1:]:\n                    dcur = dist(n.position, p)\n                    if dcur < best_dist:\n                        best_dist = dcur\n                        best = n\n            return best, best_dist\n\n        def neighbor_radius(n_count):\n            if n_count <= 1:\n                return self.max_neighbor_radius\n            g_rrt_star = self.max_neighbor_radius\n            r = g_rrt_star * ((math.log(n_count)/n_count) ** (1.0/dim))\n            return max(self.min_neighbor_radius, min(r, self.max_neighbor_radius))\n\n        # Initialize tree\n        root = Node(start_pos)\n        nodes.append(root)\n        grid_cell = max(self.step_size * 1.5, 1.0)\n        grid = SpatialGrid(bounds, cell_size=grid_cell)\n        grid.insert(root)\n        best_goal_node = None\n        best_goal_cost = float(\"inf\")\n        success = False\n        search_radius = self.max_neighbor_radius\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            if success:\n                sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest, _ = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            n_nodes = len(nodes)\n            search_radius = neighbor_radius(n_nodes)\n            nbr_candidates = grid.nearby_nodes(new_pos, search_radius)\n            neighbors = [node for node in nbr_candidates if dist(node.position, new_pos) <= search_radius]\n\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                tentative_cost = nb.cost + dist(nb.position, new_pos)\n                if tentative_cost < min_cost and is_free_edge(nb.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid.insert(new_node)\n\n            # Rewire neighbors via new node if cheaper and feasible\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nb))\n\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    grid.insert(goal_node)\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        best_goal_node = goal_node\n                        success = True\n                    break  # Early termination on goal reached\n\n        # Extract path from best goal node if any\n        path: List[Tuple[float, ...]] = []\n        if success and best_goal_node is not None:\n            current = best_goal_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            path.reverse()\n        else:\n            # No goal reached: choose closest node to goal\n            min_dist = float(\"inf\")\n            best_node = None\n            for n in nodes:\n                dcur = dist(n.position, goal_pos)\n                if dcur < min_dist:\n                    min_dist = dcur\n                    best_node = n\n            if best_node:\n                current = best_node\n                while current is not None:\n                    path.append(current.position)\n                    current = current.parent\n                path.reverse()\n\n        # Multi-pass iterative shortcutting for path smoothing\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points[:]\n            shortened = path_points[:]\n            for _ in range(self.shortcut_iters):\n                if len(shortened) < 3:\n                    break\n                made_change = False\n                i = 0\n                while i < len(shortened) - 2:\n                    j = len(shortened) -1\n                    shortcut_done = False\n                    while j > i + 1:\n                        if is_free_edge(shortened[i], shortened[j]):\n                            # remove intermediate points between i and j\n                            shortened = shortened[:i+1] + shortened[j:]\n                            made_change = True\n                            shortcut_done = True\n                            break\n                        j -= 1\n                    if not shortcut_done:\n                        i += 1\n                    # else do not increment i to check again after change\n                if not made_change:\n                    break\n            return shortened\n\n        path = shortcut_path(path)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -28.07313,
          "time_improvement": 32.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 2053.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02738652229309082,
                    "num_nodes_avg": 227.4,
                    "path_length_avg": 170.97848126600815,
                    "smoothness_avg": 0.05401776278360369,
                    "success_improvement": 0.0,
                    "time_improvement": -8.989798164580494,
                    "length_improvement": 6.2839850906874535,
                    "smoothness_improvement": 745.4952890127571,
                    "objective_score": 4.80092805010211
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07412786483764648,
                    "num_nodes_avg": 974.3,
                    "path_length_avg": 250.76320477184095,
                    "smoothness_avg": 0.15370043973610845,
                    "success_improvement": 0.0,
                    "time_improvement": 53.88013648693731,
                    "length_improvement": 16.288024428512955,
                    "smoothness_improvement": 3854.823020362044,
                    "objective_score": 45.210970704999184
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02376887798309326,
                    "num_nodes_avg": 441.3,
                    "path_length_avg": 122.74150903327116,
                    "smoothness_avg": 0.13042050290840068,
                    "success_improvement": 0.0,
                    "time_improvement": 51.0808025790876,
                    "length_improvement": 18.48093402268165,
                    "smoothness_improvement": 1558.9391703547062,
                    "objective_score": 34.2074970391088
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner that integrates adaptive informed sampling after the first path discovery, dynamic neighbor radius rewiring using a spatial hashing grid for efficient neighbor searches, goal biasing in sampling, and early termination upon first path connection. It interleaves tree expansions with rewiring and attempts to incrementally improve the path while respecting a strict 30-second time limit. Post-processing applies a multi-pass shortcutting smoothing to refine the final path's smoothness and length.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased toward the goal and later informed by current best path cost within an ellipsoidal region, uses a dynamic neighbor radius scaled with node count for rewiring, efficiently queries neighbors via a spatial grid, rewires connections for cost improvements, and stops early when a valid connection between the trees is found or time expires. The best path is extracted by concatenating the two trees\u2019 paths at their connection node and refined via iterative shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start in start tree, from goal in goal tree\n        self.children = []              # List[Node]\n        self.valid = True               # Mark if still valid (not pruned)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=15000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.10    # Probability of sampling goal\n        self.max_neighbor_radius = 20.0\n        self.min_neighbor_radius = 4.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Distance function\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Check if position is inside map bounds\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        # Check node collision\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Check edge collision (line segment)\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # Steer from 'from_pos' toward 'to_pos' by max length step_size\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        # Heuristic cost (Euclidean)\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoidal region\n        def informed_sample(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta, sin_theta = a[0], a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = [temp[i] - sum(x_axis[j] * temp[j] for j in range(3)) * x_axis[i]\n                         for i in range(3)]\n                    norm_v = math.sqrt(sum(vi * vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    v_unit = [vi / norm_v for vi in v]\n                    w = [x_axis[1] * v_unit[2] - x_axis[2] * v_unit[1],\n                         x_axis[2] * v_unit[0] - x_axis[0] * v_unit[2],\n                         x_axis[0] * v_unit[1] - x_axis[1] * v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    # In higher dimension fallback to uniform sample\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best * c_best - c_min * c_min\n            r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.001\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            while True:\n                rnd = [random.gauss(0, 1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x * x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u ** (1 / dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0] * dim\n            for i in range(dim):\n                for j in range(dim):\n                    sample[i] += R[i][j] * sample_ball[j]\n                sample[i] += center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius function based on node count\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial hash grid for efficient neighborhood queries\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def remove_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells:\n                    try:\n                        self.cells[cc].remove(node)\n                        if not self.cells[cc]:\n                            del self.cells[cc]\n                    except ValueError:\n                        pass\n\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            c = (ci[0] + dx, ci[1] + dy)\n                            if c in self.cells:\n                                neighbors.extend(self.cells[c])\n                elif self.dim == 3:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            for dz in range(-r_cells, r_cells + 1):\n                                c = (ci[0] + dx, ci[1] + dy, ci[2] + dz)\n                                if c in self.cells:\n                                    neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialize trees: start_tree grows from start, goal_tree from goal\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Setup spatial grids for start and goal trees\n        grid_cell_size = self.max_neighbor_radius\n        start_grid = SpatialGrid(bounds, grid_cell_size)\n        goal_grid = SpatialGrid(bounds, grid_cell_size)\n        start_grid.add_node(start_root)\n        goal_grid.add_node(goal_root)\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        success = False\n\n        # Alternate growth\n        expand_start_tree = True\n\n        # Track current best cost for informed sampling\n        c_best = float('inf')\n\n        # Early stopping counters\n        min_improve = 1e-4\n        no_improve_count = 0\n        max_no_improve = 2000\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > time_limit:\n                break\n\n            # Select which tree to expand and corresponding grid\n            tree_a = start_tree if expand_start_tree else goal_tree\n            tree_b = goal_tree if expand_start_tree else start_tree\n            grid_a = start_grid if expand_start_tree else goal_grid\n\n            # Sample point biased to goal and informed sampling after solution found\n            if not math.isinf(c_best):\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    # Informed sampling from start to goal for start tree, reverse for goal tree\n                    sample = informed_sample(c_best, start_pos if expand_start_tree else goal_pos,\n                                             goal_pos if expand_start_tree else start_pos)\n            else:\n                # No solution found yet: goal bias then uniform sampling in bounds\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start_tree else start_pos\n                else:\n                    for _ in range(100):\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if is_free_node(p):\n                            sample = p\n                            break\n                    else:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Get nearest node to sample in tree A (linear search)\n            nearest = tree_a[0]\n            min_dist = dist(nearest.position, sample)\n            for node in tree_a[1:]:\n                d_ = dist(node.position, sample)\n                if d_ < min_dist:\n                    nearest = node\n                    min_dist = d_\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos) or not is_free_edge(nearest.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Determine adaptive radius for neighbor search\n            radius = radius_adaptive(len(tree_a))\n            candidates = grid_a.neighbor_candidates(new_pos, radius)\n            radius_sq = radius * radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff * diff\n                    if sum_sq > radius_sq:\n                        break\n                else:\n                    neighbors.append(c)\n\n            # Find best parent for new node among neighbors to minimize cost\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.add_node(new_node)\n\n            # Rewire neighbors to potentially improve their cost and parents\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-10 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Attempt to connect new node to closest nodes in opposite tree within same radius\n            candidates_b = (goal_grid if expand_start_tree else start_grid).neighbor_candidates(new_pos, radius)\n            neighbors_b = []\n            for c in candidates_b:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff * diff\n                    if sum_sq > radius_sq:\n                        break\n                else:\n                    neighbors_b.append(c)\n\n            # Try connections to opposite tree nodes\n            improved = False\n            for other_node in neighbors_b:\n                if is_free_edge(new_node.position, other_node.position):\n                    total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                    if total_cost + 1e-10 < best_cost:\n                        best_cost = total_cost\n                        best_start_node = new_node if expand_start_tree else other_node\n                        best_goal_node = other_node if expand_start_tree else new_node\n                        success = True\n                        improved = True\n\n            # If success, we can stop early\n            if success:\n                break\n\n            # Update no improvement count for early stopping if desired\n            if improved:\n                no_improve_count = 0\n                c_best = best_cost\n            else:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n            expand_start_tree = not expand_start_tree\n\n        # Extract the best path by concatenating paths from start and goal trees\n        def extract_full_path(s_node, g_node):\n            path_start = s_node.path_from_root()\n            path_goal = g_node.path_from_root()\n            # Avoid duplicate node at connection\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            full_path = path_start + path_goal[::-1]\n            return full_path\n\n        if success and best_start_node is not None and best_goal_node is not None:\n            extracted_path = extract_full_path(best_start_node, best_goal_node)\n            success_state = True\n        else:\n            # Fallback: choose closest node in start tree to goal and extract path\n            min_d = float('inf')\n            closest_node = None\n            for n in start_tree:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d and n.valid:\n                    min_d = d_\n                    closest_node = n\n            if closest_node is not None:\n                extracted_path = closest_node.path_from_root()\n            else:\n                extracted_path = [start_pos]\n            success_state = False\n\n        # Multi-pass shortcutting smoothing for final path\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            new_path = path[:]\n            max_passes = 4\n            max_iterations = 250\n            for _ in range(max_passes):\n                improved = False\n                iteration = 0\n                while iteration < max_iterations and len(new_path) > 2:\n                    iteration += 1\n                    i = random.randint(0, len(new_path) - 3)\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    p1 = new_path[i]\n                    p2 = new_path[j]\n                    if is_free_edge(p1, p2):\n                        del new_path[i + 1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -26.30007,
          "time_improvement": 34.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1732.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03009607791900635,
                    "num_nodes_avg": 129.0,
                    "path_length_avg": 176.7052192288026,
                    "smoothness_avg": 0.048465116378158854,
                    "success_improvement": 0.0,
                    "time_improvement": -19.77298259463645,
                    "length_improvement": 3.1450692673096885,
                    "smoothness_improvement": 658.5843150028848,
                    "objective_score": -0.7519316429906975
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03749244213104248,
                    "num_nodes_avg": 312.1,
                    "path_length_avg": 241.13114353775876,
                    "smoothness_avg": 0.12187742761150899,
                    "success_improvement": 0.0,
                    "time_improvement": 76.673463917486,
                    "length_improvement": 19.50348371196003,
                    "smoothness_improvement": 3035.993997206948,
                    "objective_score": 49.88409938845656
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02688581943511963,
                    "num_nodes_avg": 307.2,
                    "path_length_avg": 128.33191962449385,
                    "smoothness_avg": 0.12590437429446827,
                    "success_improvement": 0.0,
                    "time_improvement": 44.665763789727805,
                    "length_improvement": 14.76804949473724,
                    "smoothness_improvement": 1501.494347731425,
                    "objective_score": 29.768030572417807
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.893579481866173,
          "time_improvement": 56.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 178.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0102372407913208,
                    "num_nodes_avg": 117.5,
                    "path_length_avg": 167.09773058241916,
                    "smoothness_avg": 0.01743061917619911,
                    "success_improvement": 0.0,
                    "time_improvement": 59.25898163821438,
                    "length_improvement": 8.411086034792367,
                    "smoothness_improvement": 172.82704130288656,
                    "objective_score": 23.688481318854166
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02068014144897461,
                    "num_nodes_avg": 270.5,
                    "path_length_avg": 254.91986206815108,
                    "smoothness_avg": 0.010869990893363076,
                    "success_improvement": 0.0,
                    "time_improvement": 87.1335117617854,
                    "length_improvement": 14.900412580258132,
                    "smoothness_improvement": 179.6926950242082,
                    "objective_score": 35.978764551811544
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03835470676422119,
                    "num_nodes_avg": 352.3,
                    "path_length_avg": 131.0348919324295,
                    "smoothness_avg": 0.02219113712511561,
                    "success_improvement": 0.0,
                    "time_improvement": 21.061420166541545,
                    "length_improvement": 12.97286398951632,
                    "smoothness_improvement": 182.26962625211246,
                    "objective_score": 15.013492574932817
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius, goal bias sampling, informed ellipsoidal sampling after first solution, and incremental cost propagation. It attempts early direct connections between trees to quickly find better paths and applies efficient downstream cost updating, combined with an incremental path shortcutting smoothing step after planning. The planner respects a strict 30-second time limit and stops early when no significant improvement is seen.",
          "planning_mechanism": "The algorithm grows two trees from start and goal alternately, samples either uniformly or inside an informed ellipsoid after a solution is found, steering towards samples by a fixed step size, and rewires within an adaptively shrinking neighborhood radius. It connects the two trees greedily when close, propagates cost improvements downstream, and uses path shortcutting as postprocessing to improve smoothness and length under time constraints.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 80,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(max(0.0, min(mapped[i], bounds[i])) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            r = max(min_r, min(max_r, val))\n            return r\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            radius_sq = radius * radius\n            for n in nodes_list:\n                d_sq = sum((n.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = None\n                min_d = float('inf')\n                for n_ in tree:\n                    d_ = dist(n_.position, pos)\n                    if d_ < min_d and not is_edge_in_obstacle(n_.position, pos):\n                        min_d = d_\n                        p = n_\n                if p is None:\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-12 < old_cost:\n                    child.cost = new_cost\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return n1.valid and n2.valid and not is_edge_in_obstacle(n1.position, n2.position)\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Attempt to jump as far as possible with collision-free segment\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            # Optionally do a second pass for minor local smoothing\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            a_side = (it % 2 == 0)\n            curr_tree = tree_start if a_side else tree_goal\n            other_tree = tree_goal if a_side else tree_start\n\n            # Sample with goal bias and informed sampling after first solution\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = None\n            min_dist = float('inf')\n            for node in curr_tree:\n                d_ = dist(node.position, sample)\n                if d_ < min_dist:\n                    min_dist = d_\n                    nearest_node = node\n\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_count = found_first and no_improve_count + 1 or 0\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count = found_first and no_improve_count + 1 or 0\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            # Attempt early direct connection between trees\n            nearest_other = None\n            min_other_dist = float('inf')\n            for n in other_tree:\n                d_ = dist(n.position, new_node.position)\n                if d_ < min_other_dist:\n                    min_other_dist = d_\n                    nearest_other = n\n\n            connected_other = None\n            if min_other_dist <= self.step_size and nearest_other and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None,\n                                  cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # Incremental connection attempts with limited steps\n                if nearest_other is not None:\n                    current = nearest_other\n                    tries = 0\n                    max_connect_attempts = 15\n                    while tries < max_connect_attempts:\n                        tries += 1\n                        step_pos = steer(current.position, new_node.position)\n                        if (not within_bounds(step_pos) or is_in_obstacle(step_pos) or\n                                is_edge_in_obstacle(current.position, step_pos)):\n                            break\n                        other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                        if other_new is None:\n                            break\n                        rewire(other_tree, other_new, other_neighbors, edges)\n                        current = other_new\n                        if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None,\n                                              cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                            break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if found_first and no_improve_count >= self.max_no_improve:\n                    break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -24.52039,
          "time_improvement": 12.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1827.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03809058666229248,
                    "num_nodes_avg": 196.0,
                    "path_length_avg": 152.22916850039863,
                    "smoothness_avg": 0.052752916060461584,
                    "success_improvement": 0.0,
                    "time_improvement": -51.58862844520687,
                    "length_improvement": 16.560780519391223,
                    "smoothness_improvement": 725.697691136962,
                    "objective_score": -1.9116317662425177
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.047767043113708496,
                    "num_nodes_avg": 335.8,
                    "path_length_avg": 234.22725078535373,
                    "smoothness_avg": 0.12015780909025935,
                    "success_improvement": 0.0,
                    "time_improvement": 70.28095286904852,
                    "length_improvement": 21.808201830247512,
                    "smoothness_improvement": 2991.746974064038,
                    "objective_score": 49.12794182918326
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03955357074737549,
                    "num_nodes_avg": 267.3,
                    "path_length_avg": 120.58963562966282,
                    "smoothness_avg": 0.1465508180874831,
                    "success_improvement": 0.0,
                    "time_improvement": 18.594014514728173,
                    "length_improvement": 19.910105876158166,
                    "smoothness_improvement": 1764.1155888166172,
                    "objective_score": 26.344845824196433
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -24.394856704415727,
          "time_improvement": 84.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037204265594482423,
                    "num_nodes_avg": 58.5,
                    "path_length_avg": 184.8763674372614,
                    "smoothness_avg": 0.010656061011327317,
                    "success_improvement": 0.0,
                    "time_improvement": 85.19386523557586,
                    "length_improvement": -1.3336665458757502,
                    "smoothness_improvement": 66.79049483412726,
                    "objective_score": 25.091912117317943
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007217264175415039,
                    "num_nodes_avg": 195.5,
                    "path_length_avg": 293.476072886139,
                    "smoothness_avg": 0.006583639266204931,
                    "success_improvement": 0.0,
                    "time_improvement": 95.50966105071444,
                    "length_improvement": 2.0292396302187403,
                    "smoothness_improvement": 69.4017803231431,
                    "objective_score": 30.217450994961293
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014179682731628418,
                    "num_nodes_avg": 216.3,
                    "path_length_avg": 159.7621915423607,
                    "smoothness_avg": 0.012486187243912596,
                    "success_improvement": 0.0,
                    "time_improvement": 70.81651479687723,
                    "length_improvement": -6.106440564392849,
                    "smoothness_improvement": 58.82338010809535,
                    "objective_score": 17.875207000967936
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -23.298298969701534,
          "time_improvement": 51.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 174.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016666102409362792,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 171.93676993008617,
                    "smoothness_avg": 0.017258852621246313,
                    "success_improvement": 0.0,
                    "time_improvement": 33.67412195140466,
                    "length_improvement": 5.758731888850669,
                    "smoothness_improvement": 170.1385217208312,
                    "objective_score": 14.408168327335954
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026815319061279298,
                    "num_nodes_avg": 207.7,
                    "path_length_avg": 254.55172472875432,
                    "smoothness_avg": 0.010846570009997185,
                    "success_improvement": 0.0,
                    "time_improvement": 83.31641066589374,
                    "length_improvement": 15.023307420394557,
                    "smoothness_improvement": 179.09005882582343,
                    "objective_score": 34.90435794613397
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0310056209564209,
                    "num_nodes_avg": 214.5,
                    "path_length_avg": 128.32906870441866,
                    "smoothness_avg": 0.02145278500029813,
                    "success_improvement": 0.0,
                    "time_improvement": 36.186718876507044,
                    "length_improvement": 14.769942940104954,
                    "smoothness_improvement": 172.8778417239189,
                    "objective_score": 20.58237063563468
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.256651771997145,
          "time_improvement": 85.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005163788795471191,
                    "num_nodes_avg": 88.6,
                    "path_length_avg": 194.6296584579342,
                    "smoothness_avg": 0.01167543363104651,
                    "success_improvement": 0.0,
                    "time_improvement": 79.44973470673519,
                    "length_improvement": -6.679599905092896,
                    "smoothness_improvement": 82.74588993580629,
                    "objective_score": 20.24088991864385
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014127516746520996,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 298.3796473209629,
                    "smoothness_avg": 0.007304556076322401,
                    "success_improvement": 0.0,
                    "time_improvement": 91.21033439240306,
                    "length_improvement": 0.3922853423102244,
                    "smoothness_improvement": 87.95148910285546,
                    "objective_score": 28.03822896862133
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007713985443115234,
                    "num_nodes_avg": 141.8,
                    "path_length_avg": 161.00482297708567,
                    "smoothness_avg": 0.014351820764112542,
                    "success_improvement": 0.0,
                    "time_improvement": 84.12369414062309,
                    "length_improvement": -6.931737195586904,
                    "smoothness_improvement": 82.55410077829661,
                    "objective_score": 21.490836428726265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "\\frac{\\log n",
          "planning_mechanism": "= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, time_limit: float = 30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n        self.shortcut_attempts = 40  # Reduced shortcut attempts for quick smoothing\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []  # nodes excluding roots\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near(tree, point, radius):\n            r2 = radius ** 2\n            results = []\n            for node in tree:\n                # squared distance for efficiency\n                if is_3d:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    dz = node.position[2] - point[2]\n                    d2 = dx*dx + dy*dy + dz*dz\n                else:\n                    dx = node.position[0] - point[0]\n                    dy = node.position[1] - point[1]\n                    d2 = dx*dx + dy*dy\n                if d2 <= r2:\n                    results.append(node)\n            return results\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            cur = node_s\n            while cur is not None:\n                path_s.append(cur.position)\n                cur = cur.parent\n            path_s.reverse()\n\n            path_g = []\n            cur = node_g\n            while cur is not None:\n                path_g.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate joining node\n            if path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n\n            # Choose best parent from neighbors\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in near_nodes:\n                if node == new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost_candidate = node.cost + dist(node.position, new_node.position)\n                    if cost_candidate < min_cost:\n                        min_parent = node\n                        min_cost = cost_candidate\n\n            # Update parent if better path found\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n            # Rewire neighbors through new_node if beneficial\n            for node in near_nodes:\n                if node == new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def attempt_connect(n1, n2):\n            if dist(n1.position, n2.position) <= self.step_size:\n                if not is_edge_in_obstacle(n1.position, n2.position):\n                    return True\n            return False\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if attempt_connect(new_node, nearest_node):\n                return nearest_node\n            return None\n\n        # Neighborhood radius adapts as in BiRRT* paper\n        def neighbor_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma = 20.0  # can be tuned\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(r, self.step_size * 0.5)\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Bi-directional growth alternating loops\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal biased sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                # Uniform random free sample\n                while True:\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n\n            for tree_a, tree_b in trees:\n                # Extend tree_a toward sample\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                # Skip invalid positions or edges\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire neighbors within adaptive radius\n                radius = neighbor_radius(len(tree_a))\n                rewire(tree_a, new_node, radius)\n\n                # Try connecting to the opposite tree to shortcut search\n                connect_node = try_connect_trees(new_node, tree_b)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        success = True\n\n                        # Early stopping immediately when connection found\n                        # Proceed to final path shortcutting before returning\n                        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n                        return PlannerResult(success=True, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n        # If no solution, try to return partial best path from closest node in start tree to start pos\n        if not success:\n            closest_node = min(all_nodes + start_tree, key=lambda n: dist(n.position, goal_pos))\n            best_path = []\n            cur = closest_node\n            while cur:\n                best_path.append(cur.position)\n                cur = cur.parent\n            best_path.reverse()\n\n        final_path = self._shortcut_path(best_path, obstacles, is_3d, dim)\n\n        return PlannerResult(success=success, path=final_path, nodes=start_tree + goal_tree + all_nodes, edges=edges)\n\n    def _shortcut_path(self, path: List[Tuple[float, ...]], obstacles, is_3d: bool, dim: int, attempts: int = 40) -> List[Tuple[float, ...]]:\n        \"\"\"Path shortcutting by attempting to replace 2+ node segments with a single edge.\"\"\"\n        if len(path) < 3:\n            return path\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(f_pos, t_pos, resolution=1.0):\n            distance = math.dist(f_pos, t_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[d] + (t_pos[d] - f_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        new_path = list(path)\n        for _ in range(attempts):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                # Shortcut by removing intermediate nodes\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path",
          "objective": -21.73093,
          "time_improvement": 32.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 949.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018609023094177245,
                    "num_nodes_avg": 265.4,
                    "path_length_avg": 174.46813050769455,
                    "smoothness_avg": 0.02052379402865142,
                    "success_improvement": 0.0,
                    "time_improvement": 25.941904949863755,
                    "length_improvement": 4.371253044288279,
                    "smoothness_improvement": 221.24194468046562,
                    "objective_score": 11.511533034934422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030954933166503905,
                    "num_nodes_avg": 599.4,
                    "path_length_avg": 246.56024222272634,
                    "smoothness_avg": 0.07105362816383905,
                    "success_improvement": 0.0,
                    "time_improvement": 80.74088204453314,
                    "length_improvement": 17.691094302976712,
                    "smoothness_improvement": 1728.2610305153203,
                    "objective_score": 43.47822634772257
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.053578948974609374,
                    "num_nodes_avg": 618.0,
                    "path_length_avg": 128.47415638420375,
                    "smoothness_avg": 0.07830938655910784,
                    "success_improvement": 0.0,
                    "time_improvement": -10.27189353903225,
                    "length_improvement": 14.67358261152458,
                    "smoothness_improvement": 896.0896168341985,
                    "objective_score": 10.203029589376065
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bi-directional RRT* planner combining adaptive dynamic-radius rewiring, informed ellipsoidal sampling after first solution, and periodic pruning for improved efficiency and path quality. It alternates growing trees from start and goal, uses tree balancing with rewiring within adaptively shrinking radii guided by node density, employs ellipsoidal informed sampling conditioned on best path cost, and prunes disconnected or suboptimal nodes regularly to maintain a compact and efficient search structure. Early stopping occurs upon connecting trees or time limit, followed by robust shortcutting smoothing to deliver a smooth, short path within a 30-second limit.",
          "planning_mechanism": "The planner incrementally extends two trees from start and goal, alternating expansions while biasing sampling with goal probability initially and switching to ellipsoidal informed sampling after a first feasible path is found. Each new node connects via minimal-cost parent among neighbors within an adaptive radius proportional to tree size and dimension, followed by rewiring neighbors locally to reduce cost. Periodic pruning removes invalid or isolated nodes to limit tree complexity. When the two trees connect within step size and obstacle-free, the algorithm stops early. A shortcutting post-process prunes unnecessary waypoints to improve path smoothness and length. Timing is strictly enforced with immediate return if the 30-second time limit is exceeded.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        \n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n            \n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0, goal_sample_rate=0.1, gamma_rrt_star=30.0, max_neighbor_radius=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit = 30.0\n        self.improve_tol = 1e-6\n        self.prune_interval = 500  # prune every 500 iterations\n\n    def plan(self, map):\n        import time\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n        found_solution = False\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist_ = math.dist(p1, p2)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_dist):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= max_dist:\n                return to_pos\n            ratio = max_dist / dist_\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def uniform_sample():\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x * x for x in a1))\n            if length_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / length_a1 for x in a1)\n            r1 = c_best * 0.5\n            if dim == 2:\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                x_raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                x_unit = [x / norm for x in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                x_scaled = [radius * axes[i] * x_unit[i] for i in range(dim)]\n\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n\n                if abs(dot - 1.0) < 1e-10:\n                    x_rot = x_scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    x_rot = [-x_scaled[0]] + x_scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = x_scaled[0], x_scaled[1]\n                        x_rot = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(c * c for c in k))\n                        if k_norm < 1e-10:\n                            x_rot = x_scaled\n                        else:\n                            k = [c / k_norm for c in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = x_scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            x_rot = [0] * 3\n                            for i in range(3):\n                                x_rot[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        x_rot = x_scaled\n\n                sample = tuple(center[i] + x_rot[i] for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest(nodes_list, pt):\n            return min(nodes_list, key=lambda n: math.dist(n.position, pt))\n\n        def near_nodes(nodes_list, pt, radius):\n            return [n for n in nodes_list if math.dist(n.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos):\n            nearest_node = nearest(tree_nodes, new_pos)\n            base_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            gamma = self.gamma_rrt_star\n            n = len(tree_nodes)\n            radius = min(self.max_neighbor_radius,\n                         max(self.step_size * 2.0, gamma * ((math.log(n) / n) ** (1 / dim))))\n            nearlist = near_nodes(tree_nodes, new_pos, radius)\n            best_parent = nearest_node\n            best_cost = base_cost\n            for nb in nearlist:\n                if nb is nearest_node:\n                    continue\n                if not is_edge_in_obstacle(nb.position, new_pos):\n                    cost_candidate = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_candidate + self.improve_tol < best_cost:\n                        best_parent = nb\n                        best_cost = cost_candidate\n            if is_edge_in_obstacle(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            new_node.cost = best_cost\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, nearlist, tree_nodes)\n            return new_node\n\n        def rewire(new_node, neighbors, tree_nodes):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, nb.position):\n                    alt_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if alt_cost + self.improve_tol < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n                        edges.append((new_node, nb))\n\n        def merge_trees(node, tree_other):\n            nearest_node_other = nearest(tree_other, node.position)\n            dist_ = math.dist(node.position, nearest_node_other.position)\n            if dist_ > self.step_size:\n                return None\n            if is_edge_in_obstacle(node.position, nearest_node_other.position):\n                return None\n            path_start = node.path_from_root()\n            path_goal = nearest_node_other.path_from_root()\n            # Remove duplicated meeting point\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            total_cost = node.cost + dist_ + nearest_node_other.cost\n            return full_path, total_cost\n\n        def shortcut_path(path_points):\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        def prune_invalid_nodes(tree_nodes):\n            valid_nodes = []\n            for node in tree_nodes:\n                if not node.valid or node.parent is None and node is not start_root and node is not goal_root:\n                    # Disconnect node children recursively\n                    def invalidate_subtree(nd):\n                        nd.valid = False\n                        for c in nd.children[:]:\n                            invalidate_subtree(c)\n                        nd.children = []\n                    invalidate_subtree(node)\n                else:\n                    valid_nodes.append(node)\n            return valid_nodes\n\n        for it in range(self.max_iter):\n            curr_time = time.monotonic()\n            if curr_time - start_time > self.time_limit:\n                break\n\n            # Sampling\n            c_best = best_cost if found_solution else float('inf')\n            c_min = math.dist(start_pos, goal_pos)\n            sample = uniform_sample() if not found_solution else informed_sample(c_best, c_min)\n            \n            # Goal bias for faster convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n\n            # Alternate tree expansion\n            tree_from, tree_to = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n\n            # Extend tree_from toward sample\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_from, new_pos)\n            if new_node is None:\n                continue\n\n            merge_result = merge_trees(new_node, tree_to)\n            if merge_result is not None:\n                path_candidate, cost_candidate = merge_result\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    found_solution = True\n                    # Early stop upon first connection\n                    break\n\n            # Periodic pruning every prune_interval iterations\n            if it > 0 and it % self.prune_interval == 0:\n                tree_start = prune_invalid_nodes(tree_start)\n                tree_goal = prune_invalid_nodes(tree_goal)\n                # Also prune from nodes list:\n                nodes = [n for n in nodes if n.valid]\n\n        if not success and tree_start:\n            # Try direct connection from closest start tree node to goal if feasible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                candidate_path = nearest_goal_node.path_from_root() + [goal_pos]\n                candidate_cost = nearest_goal_node.cost + math.dist(nearest_goal_node.position, goal_pos)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_path = candidate_path\n                    best_cost = candidate_cost\n                    success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -20.67738,
          "time_improvement": 9.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1444.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03827791213989258,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 160.6466233769438,
                    "smoothness_avg": 0.04725787452949247,
                    "success_improvement": 0.0,
                    "time_improvement": -52.33412529129126,
                    "length_improvement": 11.947040118448713,
                    "smoothness_improvement": 639.6883585036219,
                    "objective_score": -5.333571723800039
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05289309024810791,
                    "num_nodes_avg": 298.2,
                    "path_length_avg": 232.68903229137203,
                    "smoothness_avg": 0.09180706801300251,
                    "success_improvement": 0.0,
                    "time_improvement": 67.0916988049012,
                    "length_improvement": 22.32170343870305,
                    "smoothness_improvement": 2262.261985932813,
                    "objective_score": 44.83184163435625
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042598557472229,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 121.23262798955986,
                    "smoothness_avg": 0.12021932172282064,
                    "success_improvement": 0.0,
                    "time_improvement": 12.327067171100092,
                    "length_improvement": 19.48306096672048,
                    "smoothness_improvement": 1429.180898646998,
                    "objective_score": 22.533861224597302
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner enhanced with spatial hashing for neighbor lookups, adaptive neighbor radius, ellipsoidal informed sampling after the first solution, immediate early stopping on path connection, and iterative post-processing shortcutting smoothing to deliver faster planning, shorter paths, and smoother results within a strict 30-second limit. The planner alternates tree expansions, performs rewiring with cost propagation using spatial hashing to efficiently identify neighbors, attempts greedy incremental connections between trees, and refines the best path with multiple shortcut passes before returning.",
          "planning_mechanism": "A dual-tree RRT* approach growing two trees from start and goal, sampling with goal bias and informed ellipsoidal distribution once a path is found, efficiently rewiring neighbors located via spatial hashing within a dynamically adapting radius, connecting trees greedily with incremental steps, and shortcutting the best stitched path iteratively. The planner monitors time strictly for early termination and returns the best found path with updated costs and smoothness improvements.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position    # tuple (x,y) or (x,y,z)\n        self.parent = parent        # Node or None\n        self.cost = cost            # path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 goal_sample_rate=0.1,\n                 max_no_improve=150,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0,\n                 gamma_rrt_star=50.0,\n                 hash_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n        self.hash_cell_size = hash_cell_size  # cell size for spatial hash\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            tries = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                tries += 1\n                if tries > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r2)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x / n for x in v)\n\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x*x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        # Spatial hashing for neighbor queries\n        def hash_coords(pos):\n            return tuple(int(p // self.hash_cell_size) for p in pos)\n\n        def cells_around(pos, radius):\n            center_cell = hash_coords(pos)\n            cell_range = int(math.ceil(radius / self.hash_cell_size))\n            ranges = [range(c - cell_range, c + cell_range + 1) for c in center_cell]\n            # Cartesian product of ranges\n            if dim == 2:\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        yield (x, y)\n            else:\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            yield (x, y, z)\n\n        def insert_node_hash(node, hash_map):\n            c = hash_coords(node.position)\n            if c not in hash_map:\n                hash_map[c] = []\n            hash_map[c].append(node)\n\n        def get_neighbors_hash(pos, radius, hash_map):\n            neighbors = []\n            r_sq = radius * radius\n            for c in cells_around(pos, radius):\n                if c in hash_map:\n                    for n in hash_map[c]:\n                        if dist(n.position, pos) <= radius:\n                            neighbors.append(n)\n            return neighbors\n\n        def nearest_node_hash(nodes_list, pos):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, pos)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def add_node_rrt_star(tree, pos, all_nodes, edges_list, hash_map):\n            r = neighbor_radius(len(tree))\n            neighbors = get_neighbors_hash(pos, r, hash_map)\n            candidate_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not candidate_parents:\n                # fallback nearest\n                fallback = nearest_node_hash(tree, pos)\n                if fallback is None or is_edge_in_obstacle(fallback.position, pos):\n                    return None, []\n                candidate_parents = [fallback]\n            best_parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges_list.append((best_parent, new_node))\n            insert_node_hash(new_node, hash_map)\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list, hash_map):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            if not n1.valid or not n2.valid:\n                return False\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def stitch_path(n_start, n_goal, forward_start=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if not path_start or not path_goal:\n                return []\n            # Remove duplicate connection node if identical\n            if path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if forward_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            # Iterative shortcutting, 30 passes max\n            for _ in range(30):\n                shortened = [path[0]]\n                i = 0\n                changed = False\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    if j != i + 1:\n                        changed = True\n                    shortened.append(path[j])\n                    i = j\n                path = shortened\n                if not changed:\n                    break\n            return path\n\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        # Initialize spatial hash maps for fast neighbor lookup\n        hash_map_start = {}\n        hash_map_goal = {}\n        insert_node_hash(tree_start[0], hash_map_start)\n        insert_node_hash(tree_goal[0], hash_map_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        first_solution_found = False\n        iter_since_improve = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            forward_expand = (it % 2 == 0)\n            curr_tree = tree_start if forward_expand else tree_goal\n            other_tree = tree_goal if forward_expand else tree_start\n            curr_hash = hash_map_start if forward_expand else hash_map_goal\n            other_hash = hash_map_goal if forward_expand else hash_map_start\n\n            # Sample with goal bias and informed sampling after first solution\n            if first_solution_found:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if forward_expand else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = None\n            # Nearest in current tree using hash: fallback loop as no direct nearest indexing\n            # Optimized by checking nodes in neighbor cells within radius step_size*2\n            candidates = get_neighbors_hash(sample, self.step_size * 2.0, curr_hash)\n            if candidates:\n                nearest_node = min(candidates, key=lambda n: dist(n.position, sample))\n            else:\n                # fallback to full tree linear search\n                nearest_node = min(curr_tree, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample)\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges, curr_hash)\n            if new_node is None:\n                iter_since_improve += 1\n                if first_solution_found and iter_since_improve >= self.max_no_improve:\n                    break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges, curr_hash)\n\n            # Attempt to connect trees greedily with incremental steps\n            nearest_other = None\n            # Nearest node in the other tree within radius\n            candidates_oth = get_neighbors_hash(new_node.position, self.step_size * 2.0, other_hash)\n            if candidates_oth:\n                nearest_other = min(candidates_oth, key=lambda n: dist(n.position, new_node.position))\n            else:\n                nearest_other = min(other_tree, key=lambda n: dist(n.position, new_node.position))\n\n            connected_other = None\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Direct connection possible\n                final_node = Node(new_node.position, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                insert_node_hash(final_node, other_hash)\n                connected_other = final_node\n            else:\n                current = nearest_other\n                tries = 0\n                max_steps = 20\n                while tries < max_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if (not within_bounds(step_pos)) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(other_tree, step_pos, nodes, edges, other_hash)\n                    if new_other_node is None:\n                        break\n                    rewire(other_tree, new_other_node, neighbors_other, edges, other_hash)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            insert_node_hash(final_node, other_hash)\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, forward_expand)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    first_solution_found = True\n                    iter_since_improve = 0\n                    # Early stop on first better path (speed optimization)\n                    break\n                else:\n                    iter_since_improve += 1\n            else:\n                iter_since_improve += 1\n\n            if first_solution_found and iter_since_improve >= self.max_no_improve:\n                break\n\n        # Perform iterative shortcutting to smooth and shorten path\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -17.14453,
          "time_improvement": -4.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1529.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03778905868530273,
                    "num_nodes_avg": 82.8,
                    "path_length_avg": 157.33581428310708,
                    "smoothness_avg": 0.04771463785088872,
                    "success_improvement": 0.0,
                    "time_improvement": -50.38864134931417,
                    "length_improvement": 13.761747045907985,
                    "smoothness_improvement": 646.8376963609011,
                    "objective_score": -3.625355695444954
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05281453132629395,
                    "num_nodes_avg": 237.2,
                    "path_length_avg": 232.7402224388376,
                    "smoothness_avg": 0.09580556044485192,
                    "success_improvement": 0.0,
                    "time_improvement": 67.14057552298459,
                    "length_improvement": 22.30461469405234,
                    "smoothness_improvement": 2365.1460762019865,
                    "objective_score": 45.35067185433671
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.062174749374389646,
                    "num_nodes_avg": 321.4,
                    "path_length_avg": 124.90974088086932,
                    "smoothness_avg": 0.13164626176870137,
                    "success_improvement": 0.0,
                    "time_improvement": -27.963080184304655,
                    "length_improvement": 17.04089766961249,
                    "smoothness_improvement": 1574.5307325816234,
                    "objective_score": 9.708268209384215
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A refined bidirectional RRT* planner employing adaptive shrinking rewiring radius, goal bias with ellipsoidal informed sampling after the first solution, incremental rewiring with subtree cost updates, and enhanced multi-pass randomized shortcut smoothing to improve planning speed, path quality, and smoothness within a strict 30-second time limit. The planner grows two trees that alternate expansion, connects and rewires efficiently using an adaptive neighborhood radius computed from problem dimension and node count, and leverages spatial locality to reduce computational overhead. The final path is extracted by merging the trees and applying extensive smoothing before returning.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling points biased toward the goal and later focused via ellipsoidal informed sampling once a solution exists. Each iteration expands one tree by steering towards a sampled position, selects the minimal cost parent from neighbors within an adaptively computed rewiring radius, then rewires neighbors to improve their costs and propagate cost updates down subtrees. When a connection between the two trees is found, the combined path is updated if it improves on the best cost found so far. Planning terminates early if time limit reached or upon first optimal connection. The final path is shortcut-smoothed through multiple randomized passes to reduce length and sharp turns before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def propagate_cost_to_children(self):\n        for c in self.children:\n            new_cost = self.cost + math.dist(self.position, c.position)\n            if new_cost + 1e-10 < c.cost:\n                c.cost = new_cost\n                c.propagate_cost_to_children()\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 35.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n        self.shortcut_passes = 5\n        self.max_shortcut_attempts_per_pass = 200\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b, resolution=None):\n            dist_ab = dist(a,b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.5)\n            steps = max(1,int(dist_ab/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def uniform_sample():\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            # Fallback uniform without checking\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_a1 = math.sqrt(sum(x*x for x in a1))\n            if length_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_a1 for x in a1)\n            r1 = c_best/2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n\n            attempts = 0\n            while attempts < 100:\n                # Sample unit ball\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    attempts += 1\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i]+rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def adaptive_neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            return min(\n                self.max_neighbor_radius,\n                max(self.step_size * 2.0,\n                    self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0/dim)))\n            )\n\n        def near_nodes(tree_nodes, pt, radius):\n            return [node for node in tree_nodes if dist(node.position, pt) <= radius]\n\n        def choose_parent_and_add(tree_nodes, new_pos, nodes_list, edges_list):\n            n_nodes = len(tree_nodes)\n            radius = adaptive_neighbor_radius(n_nodes)\n            near_n = near_nodes(tree_nodes, new_pos, radius)\n            nearest_n = nearest_node(tree_nodes, new_pos)\n            min_cost = nearest_n.cost + dist(nearest_n.position, new_pos)\n            best_parent = nearest_n\n            for nbr in near_n:\n                if nbr == nearest_n:\n                    continue\n                if nbr.cost + dist(nbr.position, new_pos) + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = nbr.cost + dist(nbr.position, new_pos)\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                new_node = Node(new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                nodes_list.append(new_node)\n                tree_nodes.append(new_node)\n                edges_list.append((best_parent, new_node))\n                rewire(new_node, near_n, nodes_list, edges_list)\n                return new_node\n            return None\n\n        def rewire(pivot, neighbors, nodes_list, edges_list):\n            for nbr in neighbors:\n                if nbr is pivot:\n                    continue\n                candidate_cost = pivot.cost + dist(pivot.position, nbr.position)\n                if candidate_cost + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(pivot.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges_list.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(pivot, candidate_cost)\n                        edges_list.append((pivot, nbr))\n                        nbr.propagate_cost_to_children()\n\n        def merge_trees(node_in_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_in_a.position)\n            d = dist(node_in_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_in_a.position, nearest_b.position):\n                return None\n            total_cost = node_in_a.cost + d + nearest_b.cost\n            path_a = node_in_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            return path_a + path_b[::-1], total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_passes):\n                attempts = 0\n                while attempts < self.max_shortcut_attempts_per_pass:\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p_i = path[i]\n                    p_j = path[j]\n                    if not is_edge_in_obstacle(p_i, p_j):\n                        # shortcut by removing intermediate nodes in [i+1:j]\n                        path = path[:i+1] + path[j:]\n                        # Restart attempts count after successful shortcut\n                        attempts = 0\n                    else:\n                        attempts += 1\n            return path\n\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if not is_in_obstacle(goal_pos) else uniform_sample()\n                else:\n                    sample = uniform_sample()\n\n            if is_in_obstacle(sample):\n                continue\n            if not in_bounds(sample):\n                continue\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a = tree_start\n                tree_b = tree_goal\n            else:\n                tree_a = tree_goal\n                tree_b = tree_start\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample, self.step_size)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_n.position, new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos, nodes, edges)\n            if new_node is None:\n                continue\n\n            merge_res = merge_trees(new_node, tree_b)\n            if merge_res is not None:\n                path_candidate, cost_candidate = merge_res\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stop immediately after improvement\n                    break\n\n        # If no solution found, fallback: connect closest start node to goal if possible\n        if not found_solution:\n            nearest_goal_node = nearest_node(tree_start, goal_pos)\n            if nearest_goal_node and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_goal_node.position, goal_pos):\n                best_path = nearest_goal_node.path_from_root() + [goal_pos]\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = found_solution\n        else:\n            success = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -14.78723,
          "time_improvement": -12.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1466.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05620861053466797,
                    "num_nodes_avg": 104.1,
                    "path_length_avg": 156.81522087637052,
                    "smoothness_avg": 0.04641097727750338,
                    "success_improvement": 0.0,
                    "time_improvement": -123.69270007059305,
                    "length_improvement": 14.047092541470724,
                    "smoothness_improvement": 626.4325774431745,
                    "objective_score": -25.547391609079604
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05493648052215576,
                    "num_nodes_avg": 274.5,
                    "path_length_avg": 235.07958894654598,
                    "smoothness_avg": 0.09746590415171812,
                    "success_improvement": 0.0,
                    "time_improvement": 65.82037012506655,
                    "length_improvement": 21.523666818847847,
                    "smoothness_improvement": 2407.8679156768876,
                    "objective_score": 44.69965070721311
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03858215808868408,
                    "num_nodes_avg": 230.3,
                    "path_length_avg": 119.91877884663268,
                    "smoothness_avg": 0.11506439039040965,
                    "success_improvement": 0.0,
                    "time_improvement": 20.593298101504963,
                    "length_improvement": 20.35565700867962,
                    "smoothness_improvement": 1363.6105525961814,
                    "objective_score": 25.209436398640165
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, efficient local rewiring using an adaptive neighbor radius, goal biasing in sampling, and a straightforward early stopping criterion. It alternates tree growth between start and goal trees, performs rewiring to improve path costs locally, attempts connections between trees incrementally but avoids overly fine granularity, and applies path shortcutting postprocessing to smooth the final solution efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased toward goal and informed by best path cost when available. It extends the trees toward these samples with collision checking, rewires neighbors to improve path costs, tries to connect the trees when possible, and extracts the best path found. Sampling, rewiring radius, and search terminate early on stable convergence or timeout, ensuring efficient planning and quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 100\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fi, to):\n            d = dist(fi, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fi[i] + ratio * (to[i] - fi[i]) for i in range(dim))\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos  # fallback in crowded maps\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(u):\n                    return math.sqrt(sum(x*x for x in u))\n                def normalize(u):\n                    n=norm(u)\n                    return tuple(x/n if n>1e-12 else x for x in u)\n                b2 = normalize(cross(a1, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0,0,1)\n                    b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0))/2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    n = math.sqrt(sum(x*x for x in v))\n                    if n > 1e-12:\n                        unit = [x/n for x in v]\n                        r = random.random() ** (1.0/d)\n                        return [x*r for x in unit]\n\n            u = sample_unit_ball(dim)\n            mapped = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n                mapped[i] += center[i]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size*2)\n            val = 30.0 * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            max_r = max(bounds)*0.25\n            return max(self.step_size, min(max_r, val))\n\n        def nearest(tree, p):\n            best, best_dist = None, float('inf')\n            for n in tree:\n                d_ = dist(n.position, p)\n                if d_ < best_dist:\n                    best, best_dist = n, d_\n            return best\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            return [n for n in tree if sum((n.position[i]-p[i])**2 for i in range(dim)) <= r2]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def rewire(tree, new_node, neighbors, edges):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n        def can_connect(n1, n2):\n            return not edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, start_side=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged if start_side else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smooth = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smooth.append(path[j])\n                i = j\n            return smooth\n\n        start_time = time.monotonic()\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            expand_start = (iter % 2 == 0)\n            curr_tree = tree_start if expand_start else tree_goal\n            other_tree = tree_goal if expand_start else tree_start\n            start_side = expand_start\n\n            c_min = dist(start_pos, goal_pos)\n            if found_solution:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start else start_pos\n                else:\n                    sample = informed_sample(best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if expand_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                no_improve_count += 1\n                if found_solution and no_improve_count > self.max_no_improve:\n                    break\n                continue\n            if is_in_obstacle(new_pos):\n                no_improve_count += 1\n                if found_solution and no_improve_count > self.max_no_improve:\n                    break\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_count += 1\n                if found_solution and no_improve_count > self.max_no_improve:\n                    break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                no_improve_count += 1\n                if found_solution and no_improve_count > self.max_no_improve:\n                    break\n                continue\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            max_connect_dist = self.step_size * 1.5\n            if dist(nearest_other.position, new_node.position) <= max_connect_dist and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n\n            if connected_other:\n                candidate_path = stitch_path(new_node, connected_other, start_side)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count > self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count > self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success = True\n        else:\n            success = False\n            # fallback path: start only\n            best_path = [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -14.70312,
          "time_improvement": -14.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1592.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04139509201049805,
                    "num_nodes_avg": 207.0,
                    "path_length_avg": 152.38453869111407,
                    "smoothness_avg": 0.04394790340632159,
                    "success_improvement": 0.0,
                    "time_improvement": -64.73952679879461,
                    "length_improvement": 16.475619655861866,
                    "smoothness_improvement": 587.8801227086602,
                    "objective_score": -6.597085632577963
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05509812831878662,
                    "num_nodes_avg": 361.6,
                    "path_length_avg": 234.54106535101695,
                    "smoothness_avg": 0.10144633169793549,
                    "success_improvement": 0.0,
                    "time_improvement": 65.71979830454899,
                    "length_improvement": 21.703441495577685,
                    "smoothness_improvement": 2510.2871834271373,
                    "objective_score": 45.289440305846995
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06902077198028564,
                    "num_nodes_avg": 352.9,
                    "path_length_avg": 126.36880801773285,
                    "smoothness_avg": 0.13977742342545846,
                    "success_improvement": 0.0,
                    "time_improvement": -42.053014578518386,
                    "length_improvement": 16.071854750618613,
                    "smoothness_improvement": 1677.9585086756513,
                    "objective_score": 5.417001020193908
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius rewiring, ellipsoidal informed sampling after the first solution, goal biasing, and incremental cost propagation. It alternates growing start and goal trees, attempts greedy connections between them, and employs aggressive post-processing shortcutting to minimize path length. The planner enforces a hard 30-second time limit and terminates early on convergence or timeout, returning the best path found.",
          "planning_mechanism": "The planner grows two trees alternately with adaptive rewiring radius based on tree size and problem dimension, sampling uniformly initially and switching to focused ellipsoidal informed sampling after a feasible path is found. It continuously attempts to connect the trees greedily, rewires nodes to improve cost paths, and applies shortcut path smoothing post-planning, aiming to reduce path length and improve convergence speed within a fixed time budget.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-7,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos  # fallback\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            # Build orthonormal basis matrix\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            for n in nodes_list:\n                if dist(n.position, p) <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            if a_is_start:\n                return merged\n            else:\n                return merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        no_improve_count = 0\n\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if (not within_bounds(new_pos)\n                or is_in_obstacle(new_pos)\n                or is_edge_in_obstacle(nearest_node_curr.position, new_pos)):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            # Greedy direct connection if close enough\n            if dist(new_node.position, nearest_other.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # Incremental connection attempts with max greedy steps\n                current = nearest_other\n                max_greedy_steps = 20\n                greed_steps = 0\n                while greed_steps < max_greedy_steps:\n                    greed_steps += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if (not within_bounds(step_pos)\n                        or is_in_obstacle(step_pos)\n                        or is_edge_in_obstacle(current.position, step_pos)):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -14.5691,
          "time_improvement": -15.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1488.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.057781648635864255,
                    "num_nodes_avg": 248.1,
                    "path_length_avg": 153.14796594089302,
                    "smoothness_avg": 0.0412528584076199,
                    "success_improvement": 0.0,
                    "time_improvement": -129.9529000083497,
                    "length_improvement": 16.057173082979112,
                    "smoothness_improvement": 545.6968160950934,
                    "objective_score": -26.623082072241978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04786028861999512,
                    "num_nodes_avg": 351.4,
                    "path_length_avg": 232.60316340669706,
                    "smoothness_avg": 0.10295221046662639,
                    "success_improvement": 0.0,
                    "time_improvement": 70.22293865222784,
                    "length_improvement": 22.35036894400636,
                    "smoothness_improvement": 2549.03452878619,
                    "objective_score": 47.222275606003116
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041600918769836424,
                    "num_nodes_avg": 331.1,
                    "path_length_avg": 120.57958196696151,
                    "smoothness_avg": 0.11547155330320089,
                    "success_improvement": 0.0,
                    "time_improvement": 14.38032709661274,
                    "length_improvement": 19.916783040220405,
                    "smoothness_improvement": 1368.789634793246,
                    "objective_score": 23.108116127082294
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bi-directional RRT* planner with adaptive neighbor radius, goal bias sampling, early stopping, and integrated path shortcutting for improved planning speed, path length, and smoothness. The planner alternates tree expansions between start and goal, rewires neighbors dynamically using a radius shrinking with the number of nodes, and stops immediately upon connecting both trees. Post-processing shortcutting removes unnecessary waypoints to smooth and shorten the final path. Efficient collision checking and incremental best path updates ensure robustness and quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling points biased towards the goal and within map boundaries. Each new node connects to its best parent among neighbors inside an adaptive radius, rewiring neighbors that can be improved by the new node. After adding a node, an attempt is made to connect the other tree within step size increments. When a connection is found, planning stops early, and a combined path is extracted and shortcut. This method uses dynamic radii to limit neighbor searching overhead and improves path quality with minimal wasted exploration.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1,\n                 gamma_rrt_star: float=30.0, max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for node in tree_nodes[1:]:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1/dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size*2.0, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = nearest(tree_nodes, new_pos)\n            neighbors = near_nodes(tree_nodes, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost_cand = nb.cost + math.dist(nb.position, new_pos)\n                    if cost_cand < min_cost:\n                        min_cost = cost_cand\n                        best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            nodes.append(new_node)\n            tree_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges)\n            return new_node\n\n        def rewire(pivot: Node, neighbors: List[Node], edges: List[Tuple[Node,Node]]) -> None:\n            for nb in neighbors:\n                if nb is pivot:\n                    continue\n                if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                    if new_cost + 1e-15 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = pivot\n                        nb.cost = new_cost\n                        pivot.children.append(nb)\n                        edges.append((pivot, nb))\n\n        def merge_trees(node_start: Node, tree_goal: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            nearest_goal_node = nearest(tree_goal, node_start.position)\n            dist_goal = math.dist(node_start.position, nearest_goal_node.position)\n            if dist_goal > self.step_size or not is_free_edge(node_start.position, nearest_goal_node.position):\n                return None\n            # connect goal node parent chain if needed\n            # Create a connecting node at goal node's position attached to start tree node\n            connecting_cost = node_start.cost + dist_goal + nearest_goal_node.cost\n            path_start = node_start.path_from_root()\n            path_goal = nearest_goal_node.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            full_path = path_start + path_goal[::-1]\n            return full_path, connecting_cost\n\n        def shortcut_path(path_points: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_points) < 3:\n                return path_points\n            shortened = [path_points[0]]\n            i = 0\n            while i < len(path_points) - 1:\n                j = len(path_points) - 1\n                while j > i + 1:\n                    if is_free_edge(path_points[i], path_points[j]):\n                        shortened.append(path_points[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    i += 1\n                    if i < len(path_points):\n                        shortened.append(path_points[i])\n            return shortened\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        success = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            sample = sample_free()\n            # Alternate tree expansions\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            merged = merge_trees(new_node, tree_b)\n            if merged is not None:\n                path_candidate, cost_candidate = merged\n                if cost_candidate < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    success = True\n                    break  # Early stopping\n\n        if not success:\n            # Try connecting start tree node nearest goal to form path if possible\n            nearest_goal_node = nearest(tree_start, goal_pos)\n            if nearest_goal_node and is_free_edge(nearest_goal_node.position, goal_pos):\n                path_candidate = nearest_goal_node.path_from_root() + [goal_pos]\n                best_path = path_candidate\n                success = False\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.2797,
          "time_improvement": -14.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1551.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.037523436546325686,
                    "num_nodes_avg": 119.5,
                    "path_length_avg": 159.4209224416483,
                    "smoothness_avg": 0.0499161308278024,
                    "success_improvement": 0.0,
                    "time_improvement": -49.33154826515664,
                    "length_improvement": 12.618866223558411,
                    "smoothness_improvement": 681.295842068116,
                    "objective_score": -3.821665535071364
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06830766201019287,
                    "num_nodes_avg": 321.3,
                    "path_length_avg": 231.84012711924962,
                    "smoothness_avg": 0.09872843875579924,
                    "success_improvement": 0.0,
                    "time_improvement": 57.50127086883818,
                    "length_improvement": 22.60509241953809,
                    "smoothness_improvement": 2440.353840406813,
                    "objective_score": 43.01520591440838
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07245962619781494,
                    "num_nodes_avg": 278.3,
                    "path_length_avg": 123.63111074361593,
                    "smoothness_avg": 0.12815608053053237,
                    "success_improvement": 0.0,
                    "time_improvement": -49.13058839116163,
                    "length_improvement": 17.890102924951922,
                    "smoothness_improvement": 1530.135884850495,
                    "objective_score": 3.645564661875139
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive fixed-radius rewiring, informed elliptical sampling after initial solution, goal bias sampling, and incremental cost propagation. It leverages efficient local neighbor searches, consistent cost updates with downstream propagation, and path shortcutting smoothing to deliver improved path length, smoothness, and reduced planning time under strict time limits.",
          "planning_mechanism": "Grows two RRT* trees from start and goal alternately, initially sampling uniformly and switching to informed elliptical sampling after the first found path. Nodes connect via collision-free edges with best-parent selection from neighbors within a fixed rewiring radius. The algorithm rewires neighbors to optimize path cost and propagates cost changes downstream. Frequent attempts connect the two trees to update the best path. With goal bias and early termination on post-optimization convergence or time expiration, the method balances exploration and exploitation to efficiently find short, smooth paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 10000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05,\n                 post_opt_iters: int = 300,\n                 max_no_improve: int = 100,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    # fallback: return start to avoid infinite loop in crowded maps\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                # 3D case\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / dim_)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            result = []\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            # Remove duplicated connection point if any\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start else merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    # Check if direct path is free\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                a_is_start_side = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                a_is_start_side = False\n\n            sample = None\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n            if is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            # Try to connect greedy in one step if possible\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                # Connect directly\n                final_node = Node(new_node.position, parent=None, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # incremental connection attempts\n                current = nearest_other\n                tries = 0\n                max_greedy_steps = 20\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos):\n                        break\n                    if is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if other_new is None:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, parent=None, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i + 1])\n\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -13.97956,
          "time_improvement": -17.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1470.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.052588915824890135,
                    "num_nodes_avg": 232.6,
                    "path_length_avg": 153.88454915168901,
                    "smoothness_avg": 0.04347023177026047,
                    "success_improvement": 0.0,
                    "time_improvement": -109.28744658079108,
                    "length_improvement": 15.653440153233934,
                    "smoothness_improvement": 580.4035243237437,
                    "objective_score": -20.492152260678246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048712754249572755,
                    "num_nodes_avg": 358.8,
                    "path_length_avg": 233.0599917365158,
                    "smoothness_avg": 0.10226409696877743,
                    "success_improvement": 0.0,
                    "time_improvement": 69.69256321821518,
                    "length_improvement": 22.197866498438458,
                    "smoothness_improvement": 2531.328872858417,
                    "objective_score": 46.883133228819716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.054259729385375974,
                    "num_nodes_avg": 387.5,
                    "path_length_avg": 119.05752821578226,
                    "smoothness_avg": 0.10995381497824393,
                    "success_improvement": 0.0,
                    "time_improvement": -11.673021153817839,
                    "length_improvement": 20.927658669342527,
                    "smoothness_improvement": 1298.6044105768708,
                    "objective_score": 15.547710908344518
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An advanced unidirectional RRT* variant with integrated informed sampling after initial solution, adaptive neighbor radius neighborhood search, and efficient incremental rewiring supported by a basic spatial grid for fast neighbor queries. The planner employs dynamic goal biasing, early stopping upon acceptable solution discovery or time limit, and post-processing path shortcutting to significantly improve planning time, path length, and smoothness.",
          "planning_mechanism": "The planner grows a tree from the start position by sampling either uniformly or within an ellipsoidal informed subset after first solution found, extending the nearest node by a limited step. It then efficiently finds neighbors within an adaptive radius using a grid-based spatial hashing structure for faster rewiring. Nodes are connected to the best parent minimizing cost and neighbors are rewired to improve paths. Early termination is triggered when a sufficiently good path is found or the time limit expires. Finally, shortcutting post-processing removes unnecessary waypoints for smoother paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 15000, step_size: float = 5.0, goal_sample_rate: float = 0.15, max_neighbor_radius: float = 20.0, min_neighbor_radius: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Distance metric\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        # Clamp point inside bounds\n        def clamp_point(p):\n            return tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoid region after first solution found\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            # Build rotation matrix using Gram-Schmidt for 2D or 3D\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    # 2D rotate so that x-axis aligns with a\n                    cos_theta, sin_theta = a\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    # find orthogonal vector\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1, 0, 0)\n                    else:\n                        temp = (0, 1, 0)\n                    v = [temp[i] - sum(x_axis[j]*temp[j] for j in range(3))*x_axis[i] for i in range(3)]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = [vi/norm_v for vi in v]\n                    w = [x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j] * sample_ball[j]\n                sample[i] = s + center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius for rewiring based on theory\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            r = gamma * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # --- Basic spatial grid for neighbor search ---\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                # Iterate over neighboring cells in grid\n                def expand_coords(ci, r_cells):\n                    if self.dim == 2:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                yield (ci[0]+dx, ci[1]+dy)\n                    elif self.dim == 3:\n                        for dx in range(-r_cells,r_cells+1):\n                            for dy in range(-r_cells,r_cells+1):\n                                for dz in range(-r_cells,r_cells+1):\n                                    yield (ci[0]+dx, ci[1]+dy, ci[2]+dz)\n                    else:\n                        return [] # Not supported\n                for c in expand_coords(ci, r_cells):\n                    if c in self.cells:\n                        neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialization\n        root = Node(start_pos)\n        nodes.append(root)\n        edges = []\n        grid_cell_size = self.max_neighbor_radius  # Reasonable cell size for approximate neighbors\n        spatial_grid = SpatialGrid(bounds, grid_cell_size)\n        spatial_grid.add_node(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Early stopping parameters\n        min_improvement_cost = 1e-4\n        no_improve_count = 0\n        max_no_improve = 1500\n\n        for it in range(self.max_iter):\n            cur_time = time.monotonic()\n            if cur_time - start_time > time_limit:\n                break\n\n            # Sample point\n            if best_goal_node is not None:\n                # After first solution, sample informed\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                # Before first solution sample uniformly with some goal bias\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search by linear - fallback for safety if spatial grid empty\n            def nearest_node(p):\n                best = nodes[0]\n                best_d = dist(p, best.position)\n                for n in nodes[1:]:\n                    d_ = dist(p, n.position)\n                    if d_ < best_d:\n                        best = n\n                        best_d = d_\n                return best, best_d\n\n            nearest, _ = nearest_node(sample)\n\n            # Steer new node position\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Adaptive radius neighborhood\n            radius = radius_adaptive(len(nodes))\n\n            # Retrieve candidate neighbors from spatial grid\n            candidates = spatial_grid.neighbor_candidates(new_pos, radius)\n            # Filter candidates strictly within radius (squared distances)\n            radius_sq = radius * radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                pos_c = c.position\n                for i in range(dim):\n                    diff = pos_c[i] - new_pos[i]\n                    sum_sq += diff*diff\n                    if sum_sq > radius_sq:\n                        break\n                if sum_sq <= radius_sq:\n                    neighbors.append(c)\n\n            # Select the best parent (lowest cost) among neighbors + nearest\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.add_node(new_node)\n\n            # Rewire neighbors with better cost through new_node\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Goal check and connect\n            dist_to_goal = dist(new_pos, goal_pos)\n            if dist_to_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_to_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-8 < best_goal_cost:\n                    improved = best_goal_cost - goal_cost\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                else:\n                    improved = 0.0\n\n                # Early stopping: break if cost improvement small or solution sufficient\n                if improved < min_improvement_cost:\n                    break\n\n            # Track no improvement streak and possibly early terminate\n            if best_goal_node is not None:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        # Extract path from best goal node or closest node\n        extracted_path: List[Tuple[float, ...]] = []\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            current = best_goal_node\n        else:\n            # Find node closest to goal to extract partial path\n            min_d = float('inf')\n            current = None\n            for n in nodes:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d:\n                    min_d = d_\n                    current = n\n            if current is None:\n                current = root\n\n        while current is not None:\n            extracted_path.append(current.position)\n            current = current.parent\n        extracted_path.reverse()\n\n        # Post-process shortcutting to smooth and shorten path\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            improved = True\n            new_path = path[:]\n            max_iter = 200\n            iteration = 0\n            while improved and iteration < max_iter and len(new_path) > 2:\n                improved = False\n                iteration += 1\n                i = 0\n                while i < len(new_path) - 2:\n                    p1 = new_path[i]\n                    p3 = new_path[i+2]\n                    if is_free_edge(p1, p3):\n                        del new_path[i+1]\n                        improved = True\n                    else:\n                        i += 1\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -13.86985,
          "time_improvement": -13.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1697.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023928070068359376,
                    "num_nodes_avg": 242.3,
                    "path_length_avg": 170.20756672600876,
                    "smoothness_avg": 0.05125578115753204,
                    "success_improvement": 0.0,
                    "time_improvement": 4.7737606364002065,
                    "length_improvement": 6.706535565983733,
                    "smoothness_improvement": 702.2642788256377,
                    "objective_score": 8.967370924638491
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1532435417175293,
                    "num_nodes_avg": 964.5,
                    "path_length_avg": 231.25080942683635,
                    "smoothness_avg": 0.10406023561585567,
                    "success_improvement": 0.0,
                    "time_improvement": 4.6570241332318485,
                    "length_improvement": 22.801823627834896,
                    "smoothness_improvement": 2577.544813954116,
                    "objective_score": 27.965925486441073
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0716317892074585,
                    "num_nodes_avg": 607.7,
                    "path_length_avg": 125.84121677266735,
                    "smoothness_avg": 0.15017270596541038,
                    "success_improvement": 0.0,
                    "time_improvement": -47.426800724264325,
                    "length_improvement": 16.422255734395755,
                    "smoothness_improvement": 1810.185735283898,
                    "objective_score": 4.676241899777645
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A dual-tree bidirectional RRT* planner with adaptive neighbor radius and ellipsoidal informed sampling after first solution. It employs goal biasing, dynamic rewiring with downstream cost propagation, greedy incremental tree connections, and post-planning path shortcutting to efficiently find shorter, smoother paths within a 30-second limit. The planner alternates expansions from start and goal trees, focuses sampling inside an informed ellipsoid after the first path, and stops early on stagnation to reduce planning time.",
          "planning_mechanism": "The planner initializes two trees at start and goal and alternately expands them by sampling (uniformly before first solution and ellipsoidally after), steering toward samples with a fixed step size. Each new node is connected to the best parent within an adaptive radius, followed by rewiring nearby nodes with proper cost and parent updates propagated downstream. The two trees attempt to connect greedily via incremental steps. The best path merges the two trees\u2019 paths and is smoothed by shortcutting before returning. Early termination occurs on timeout or no improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=10000,\n                 step_size=5.0,\n                 goal_sample_rate=0.05,\n                 max_no_improve=100,\n                 post_opt_iters=300,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0,\n                 gamma_rrt_star=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def near_nodes(nodes_list, p, radius):\n            r_sq = radius * radius\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            possible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not possible_parents:\n                p = nearest(tree, pos)\n                if not p or is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                possible_parents = [p]\n            best_parent = min(possible_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n1, n2, n1_is_start):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            # Remove duplicate connection node if any\n            if path1 and path2 and path1[-1] == path2[-1]:\n                combined = path1 + path2[-2::-1]\n            else:\n                combined = path1 + path2[::-1]\n            return combined if n1_is_start else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal[:]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                curr_is_start = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                curr_is_start = False\n\n            # Sampling\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbor_nodes = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbor_nodes, edges)\n\n            # Attempt greedy connection\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                current = nearest_other\n                tries = 0\n                max_steps = 20\n                while tries < max_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if (not within_bounds(step_pos)) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(other_tree, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, curr_is_start)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    post_no_improve = 0\n                    post_iter = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -13.77791,
          "time_improvement": -18.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1598.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06372268199920654,
                    "num_nodes_avg": 287.6,
                    "path_length_avg": 152.576090368934,
                    "smoothness_avg": 0.046970337316992926,
                    "success_improvement": 0.0,
                    "time_improvement": -153.59635572828506,
                    "length_improvement": 16.370627145918192,
                    "smoothness_improvement": 635.1877767309533,
                    "objective_score": -33.08059154727984
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04632420539855957,
                    "num_nodes_avg": 360.9,
                    "path_length_avg": 238.06797499023278,
                    "smoothness_avg": 0.10759340578586915,
                    "success_improvement": 0.0,
                    "time_improvement": 71.17863795197799,
                    "length_improvement": 20.526057541542208,
                    "smoothness_improvement": 2668.4558272681725,
                    "objective_score": 47.01150504685958
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035000181198120116,
                    "num_nodes_avg": 282.6,
                    "path_length_avg": 121.55600159653787,
                    "smoothness_avg": 0.1250353575595627,
                    "success_improvement": 0.0,
                    "time_improvement": 27.965435515449506,
                    "length_improvement": 19.268291614362116,
                    "smoothness_improvement": 1490.440519007569,
                    "objective_score": 27.40280821828997
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighbor radius, goal bias sampling, and early stopping upon first successful connection. The planner alternates growth from start and goal trees, rewires local neighborhoods to optimize path cost continuously, and applies incremental shortcutting during runtime to enhance smoothness. It enforces strict collision checks on nodes and edges, respects map bounds, and returns the best path found within a 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternatively from start and goal positions using steered sampling biased towards the goal. It uses an adaptive neighbor radius based on the tree size for efficient rewiring and path cost minimization. Once the trees connect, it immediately stops searching and extracts the path by concatenating the two trees. Incremental shortcutting refines the path progressively during planning and before returning, maintaining smoothness and reduced path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, goal_sample_rate=0.1, time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time, random, math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=0.5):\n            distance = dist(from_p, to_p)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def neighbor_radius(n_count):\n            if n_count <= 1:\n                return self.step_size * 2.5\n            gamma = 15.0\n            return max(gamma * ((math.log(n_count) / n_count) ** (1.0 / dim)), self.step_size * 0.5)\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            close_nodes = []\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                if is_3d:\n                    dz = node.position[2] - point[2]\n                    d2 = dx * dx + dy * dy + dz * dz\n                else:\n                    d2 = dx * dx + dy * dy\n                if d2 <= r2:\n                    close_nodes.append(node)\n            return close_nodes\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            min_parent = new_node.parent\n            min_cost = new_node.cost\n            for node in neighbors:\n                if node is new_node.parent:\n                    continue\n                if not is_edge_in_obstacle(node.position, new_node.position):\n                    cost = node.cost + dist(node.position, new_node.position)\n                    if cost < min_cost:\n                        min_parent = node\n                        min_cost = cost\n            if min_parent != new_node.parent:\n                if new_node.parent:\n                    new_node.parent.remove_child(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n            for node in neighbors:\n                if node is new_node:\n                    continue\n                if not is_edge_in_obstacle(new_node.position, node.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new < node.cost:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n\n        def try_connect(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            if dist(new_node.position, nearest_node.position) <= self.step_size:\n                if not is_edge_in_obstacle(new_node.position, nearest_node.position):\n                    return nearest_node\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def incremental_shortcut(path, attempts=20):\n            if len(path) < 3:\n                return path\n            new_path = list(path)\n            for _ in range(attempts):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        start_time = time.monotonic()\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = []\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        # Alternate growing from start and goal\n        trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n        for itr in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = goal_pos if random.random() < self.goal_sample_rate else None\n            if sample is None:\n                for _ in range(10):\n                    q = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(q):\n                        sample = q\n                        break\n                if sample is None:\n                    continue\n\n            for treeA, treeB in trees:\n                nearest_node = nearest(treeA, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                radius = neighbor_radius(len(treeA))\n                rewire(treeA, new_node, radius)\n\n                connect_node = try_connect(new_node, treeB)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        best_path = incremental_shortcut(best_path, attempts=25)\n                        success = True\n                    # Early stopping once connected\n                    break\n            if success:\n                break\n\n        if not success and all_nodes:\n            # Fallback path to node in start tree closest to goal\n            candidate = min(start_tree + all_nodes, key=lambda n: dist(n.position, goal_pos))\n            path_fallback = []\n            cur = candidate\n            while cur:\n                path_fallback.append(cur.position)\n                cur = cur.parent\n            path_fallback.reverse()\n            best_path = incremental_shortcut(path_fallback, attempts=15)\n\n        nodes = start_tree + goal_tree + all_nodes\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)",
          "objective": -12.85838,
          "time_improvement": 23.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 468.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025329160690307616,
                    "num_nodes_avg": 341.2,
                    "path_length_avg": 199.28970104769465,
                    "smoothness_avg": 0.01530141369385365,
                    "success_improvement": 0.0,
                    "time_improvement": -0.8021420818120347,
                    "length_improvement": -9.233843091640871,
                    "smoothness_improvement": 139.5003518604712,
                    "objective_score": -5.083446720225777
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027920055389404296,
                    "num_nodes_avg": 629.4,
                    "path_length_avg": 253.0655624653485,
                    "smoothness_avg": 0.03292110168198772,
                    "success_improvement": 0.0,
                    "time_improvement": 82.62908089074593,
                    "length_improvement": 15.519431160728347,
                    "smoothness_improvement": 747.0836583886348,
                    "objective_score": 37.83580125560396
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05471627712249756,
                    "num_nodes_avg": 813.0,
                    "path_length_avg": 132.95956512894526,
                    "smoothness_avg": 0.048582676599616334,
                    "success_improvement": 0.0,
                    "time_improvement": -12.612651072411719,
                    "length_improvement": 11.69458769547944,
                    "smoothness_improvement": 517.9680603469529,
                    "objective_score": 5.822797597298914
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A refined bidirectional informed RRT* planner implementing adaptive and gradually shrinking rewiring radius, dynamic goal bias increment with early stopping on solution stability, ellipsoidal informed sampling post first solution, continuous incremental pruning integrated with expansions for maintaining tree quality, and progressive multi-pass shortcutting for enhanced path smoothness and minimal length. The planner alternates tree expansions, uses cost-aware parent selection and rewiring for improved path cost and smoothness, and respects strict collision checks with time-capped iterative search.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding with gradually shrinking neighbor search radius based on node count and problem dimension for adaptive rewiring. It begins with low goal sampling that progressively increases to bias sampling toward the goal, switching to ellipsoidal informed sampling after first feasible path discovery to focus exploration near the optimal corridor. Incremental pruning is applied frequently to remove invalid or disconnected nodes, preserving efficient neighbor queries and tree quality. Rewiring and parent selection are cost-aware with collision validation to maintain consistent and optimal paths. Upon path improvements, multiple shortcutting passes iteratively smooth and shorten the path. Early termination occurs when path cost stabilizes or time limit approaches, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float,...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost-to-come\n        self.children = []\n        self.valid = True         # For pruning invalid nodes\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n        # Goal bias parameters\n        self.goal_sample_rate_start = 0.03\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 2.5e-4\n\n        self.improve_tol = 1e-6\n        self.max_no_improve = 120\n\n        self.prune_frequency = 50  # prune frequently for tree quality\n\n        # Shortcutting passes per improvement\n        self.shortcut_passes = 3\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Trees initialization\n        tree_start = []\n        tree_goal = []\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n        tree_start.append(start_node)\n        tree_goal.append(goal_node)\n        nodes.extend([start_node, goal_node])\n\n        found_solution = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1,p2,resolution=1.0):\n            d = dist(p1,p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n\n            center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x*x for x in a1))\n            if len_a1 < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/len_a1 for x in a1)\n\n            if dim == 2:\n                r1 = c_best*0.5\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))*0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r1 = c_best*0.5\n                r_side = math.sqrt(max(c_best*c_best - c_min*c_min,0))*0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 250:\n                raw = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in raw))\n                if norm < 1e-12:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0/dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotation to align e1 axis (only for 2D or 3D)\n                v = [1.0] + [0.0]*(dim-1)\n                dot = sum(v[i]*e1[i] for i in range(dim))\n\n                if abs(dot - 1.0) < 1e-12:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-12:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0*cos_a - x1*sin_a, x0*sin_a + x1*cos_a)\n                    elif dim == 3:\n                        k = [v[1]*e1[2] - v[2]*e1[1],\n                             v[2]*e1[0] - v[0]*e1[2],\n                             v[0]*e1[1] - v[1]*e1[0]]\n                        k_norm = math.sqrt(sum(kk*kk for kk in k))\n                        if k_norm < 1e-12:\n                            rotated = scaled\n                        else:\n                            k = [kk/k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i]*v_vec[i] for i in range(dim))\n                            cross = [k[1]*v_vec[2] - k[2]*v_vec[1],\n                                     k[2]*v_vec[0] - k[0]*v_vec[2],\n                                     k[0]*v_vec[1] - k[1]*v_vec[0]]\n                            rotated = [0.0]*3\n                            for i in range(3):\n                                rotated[i] = v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a)\n                    else:\n                        rotated = scaled\n\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not is_in_obstacle(sample):\n                    return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            best = None\n            min_dist = float('inf')\n            for n in tree:\n                if not n.valid:\n                    continue\n                d = dist(n.position, point)\n                if d < min_dist:\n                    best = n\n                    min_dist = d\n            return best\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if n.valid and dist(n.position, point) <= radius]\n\n        def prune_invalid_nodes():\n            to_remove = []\n            for node in nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                if node.parent is None and node not in (start_node, goal_node):\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                if n in tree_start:\n                    tree_start.remove(n)\n                if n in tree_goal:\n                    tree_goal.remove(n)\n                remove_edges = []\n                for e in edges:\n                    if e[0] == n or e[1] == n:\n                        remove_edges.append(e)\n                for e in remove_edges:\n                    edges.remove(e)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def multi_pass_shortcut(path, passes):\n            pth = path[:]\n            for _ in range(passes):\n                pth = shortcut_path(pth)\n            return pth\n\n        expand_start_tree = True\n\n        for iter in range(1, self.max_iter+1):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Goal bias sampling or informed after first solution\n            if random.random() < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            nearest = nearest_node(tree_a, sample)\n            if nearest is None:\n                expand_start_tree = not expand_start_tree\n                continue\n\n            new_pos = steer(nearest.position, sample)\n            if not within_bounds(new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Adaptive radius shrinking with tree size and iteration\n            n_nodes = len(tree_a) + 1\n            gamma_rrtstar = 25.0  # tuning constant\n            radius = gamma_rrtstar * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(radius, self.step_size*0.8)\n            radius = min(radius, self.step_size*15)\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            # Select best parent among neighbors (including nearest)\n            best_parent = nearest\n            best_cost_through = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest:\n                    continue\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + self.improve_tol < best_cost_through:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = cost_cand\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision free\n            for nb in neighbors:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    # Remove old edge\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    # Re-assign parent to new_node\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connect to other tree within radius for solution\n            near_other = near_nodes(tree_b, new_pos, radius)\n            improved = False\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_pos, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_pos, other_node.position) + other_node.cost\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n                    if not found_solution:\n                        found_solution = True\n                    no_improve_count = 0\n                    improved = True\n\n            if found_solution and not improved:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break  # Early stop on stable solution\n\n            if iter % self.prune_frequency == 0 and found_solution:\n                prune_invalid_nodes()\n\n            expand_start_tree = not expand_start_tree\n\n        success_state = found_solution and best_start_node is not None and best_goal_node is not None\n\n        if success_state:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            raw_path = path_start + path_goal[::-1]\n            # Progressive multi-pass shortcutting for smoothness\n            extracted_path = multi_pass_shortcut(raw_path, self.shortcut_passes)\n        else:\n            # Fallback to nearest start tree node to goal if no full path\n            closest = None\n            min_d = float('inf')\n            for n in tree_start:\n                if not n.valid:\n                    continue\n                d = dist(n.position, goal_pos)\n                if d < min_d:\n                    min_d = d\n                    closest = n\n            extracted_path = closest.path_from_root() if closest else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -11.75546,
          "time_improvement": -25.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1668.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.060872888565063475,
                    "num_nodes_avg": 408.7,
                    "path_length_avg": 155.17539674283108,
                    "smoothness_avg": 0.04636208027443427,
                    "success_improvement": 0.0,
                    "time_improvement": -142.25506865744146,
                    "length_improvement": 14.94590613373992,
                    "smoothness_improvement": 625.6672331636013,
                    "objective_score": -30.580640751170478
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0633683443069458,
                    "num_nodes_avg": 555.4,
                    "path_length_avg": 231.9435950637363,
                    "smoothness_avg": 0.10771692821225023,
                    "success_improvement": 0.0,
                    "time_improvement": 60.57434816332567,
                    "length_improvement": 22.57055184150878,
                    "smoothness_improvement": 2671.6341482685657,
                    "objective_score": 45.0728062952458
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04550633430480957,
                    "num_nodes_avg": 474.5,
                    "path_length_avg": 124.63068443824068,
                    "smoothness_avg": 0.1420720345680538,
                    "success_improvement": 0.0,
                    "time_improvement": 6.342514217858319,
                    "length_improvement": 17.226233671566593,
                    "smoothness_improvement": 1707.1457930388879,
                    "objective_score": 20.77422343349189
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved informed RRT* planner with goal bias and adaptive rewiring radius using a KD-tree-like grid spatial index for fast nearest neighbor queries. The planner employs ellipsoidal informed sampling focused around the current best path cost to direct exploration, and performs dynamic neighbor selection with rewiring to continuously optimize path cost and smoothness. Early termination occurs if a path reaching the goal is found or after 30 seconds to reduce planning time while returning the best solution so far. This planner balances efficient spatial queries, collision-aware edge checking, and heuristic-driven sampling to improve planning time, path quality, and smoothness.",
          "planning_mechanism": "The planner builds a single tree from the start node, using informed sampling within the ellipsoidal subset defined by the best path cost to the goal. It uses a spatial hashing grid acceleration structure for rapid nearest neighbor and radius searches. In each iteration, it samples points with goal bias, steers towards them, checks node and edge collisions, rewires neighbors within a dynamic radius for cost optimization, and updates the best path if connected to the goal. Planning terminates early if a feasible path is found or at the 30-second timeout limit, returning the best path identified so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 10000, step_size: float = 5.0, goal_sample_rate: float=0.15, base_neighbor_radius: float=20.0, grid_cell_size: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                # Tuple[int, ...]\n        start_pos = map.start            # Tuple[float, ...]\n        goal_pos = map.goal              # Tuple[float, ...]\n        obstacles = map.obstacles        # List of tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        # Utility definitions\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            # Adaptive edge collision check resolution proportional to step size\n            distance = dist(p1,p2)\n            resolution = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        # --- Spatial hashing grid for fast neighbor search ---\n        # Positions bucketed into grid cells for O(1) neighbor lookup approx\n        # grid_cell_size chosen as ~step_size or configurable\n        grid_cell_size = self.grid_cell_size\n\n        def grid_key(pos):\n            return tuple(int(pos[i] // grid_cell_size) for i in range(dim))\n\n        # Map from grid_key -> list of node indices\n        grid = dict()\n\n        def grid_insert(node_idx, pos):\n            key = grid_key(pos)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node_idx)\n\n        def grid_nearby_nodes(pos, radius):\n            # Iterate over keys in radius neighborhood\n            base_key = grid_key(pos)\n            range_cells = int(math.ceil(radius/grid_cell_size))\n            candidates = set()\n            # Generate neighbor indices in each dimension\n            def neighbors_1d(c):\n                return [c+i for i in range(-range_cells, range_cells+1)]\n            if dim==2:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        k = (dx,dy)\n                        if k in grid:\n                            candidates.update(grid[k])\n            elif dim==3:\n                for dx in neighbors_1d(base_key[0]):\n                    for dy in neighbors_1d(base_key[1]):\n                        for dz in neighbors_1d(base_key[2]):\n                            k = (dx,dy,dz)\n                            if k in grid:\n                                candidates.update(grid[k])\n            else:\n                # fallback all nodes if dim unexpected\n                candidates.update(range(len(nodes)))\n            # Filter by actual distance\n            result = []\n            for idx in candidates:\n                if dist(positions[idx], pos) <= radius:\n                    result.append(nodes[idx])\n            return result\n\n        def nearest_node(pos):\n            # Brute force with spatial grid neighbors fallback:\n            # Search within larger radius around pos to find nearest neighbor\n            radius = self.step_size * 2.0\n            search_radius = radius\n            # progressively expand radius until found neighbors or max radius\n            max_radius = max(bounds)*math.sqrt(dim)\n            while True:\n                neighbors = grid_nearby_nodes(pos, search_radius)\n                if neighbors or search_radius >= max_radius:\n                    break\n                search_radius *= 2.0\n                if search_radius > max_radius:\n                    search_radius = max_radius\n            if not neighbors:\n                # fallback to linear search all nodes (very rare)\n                best_node = None\n                best_distance = float('inf')\n                for n in nodes:\n                    d = dist(n.position, pos)\n                    if d < best_distance:\n                        best_distance = d\n                        best_node = n\n                return best_node, best_distance\n            best_node = None\n            best_distance = float('inf')\n            for n in neighbors:\n                d = dist(n.position, pos)\n                if d < best_distance:\n                    best_distance = d\n                    best_node = n\n            return best_node, best_distance\n\n        # Heuristic cost for informed sampling (Euclidean)\n        def heuristic_cost(a,b):\n            return dist(a,b)\n\n        def build_rotation_matrix(a):\n            # a: unit vector of dim dims, build rotation matrix aligning x-axis unit vector to a\n            # support only dim=2 or dim=3\n            if dim == 2:\n                cos_theta = a[0]\n                sin_theta = a[1]\n                return [[cos_theta, -sin_theta],\n                        [sin_theta,  cos_theta]]\n            elif dim == 3:\n                x_axis = a\n                # Choose arbitary vector to orthogonalize against x_axis\n                if abs(x_axis[0]) < 0.9:\n                    temp = (1,0,0)\n                else:\n                    temp = (0,1,0)\n                v = tuple(temp[i] - x_axis[i]*sum(x_axis[j]*temp[j] for j in range(3)) for i in range(3))\n                norm_v = math.sqrt(sum(v[i]*v[i] for i in range(3)))\n                if norm_v < 1e-10:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                v_unit = tuple(v[i]/norm_v for i in range(3))\n                w = (x_axis[1]*v_unit[2] - x_axis[2]*v_unit[1],\n                     x_axis[2]*v_unit[0] - x_axis[0]*v_unit[2],\n                     x_axis[0]*v_unit[1] - x_axis[1]*v_unit[0])\n                R = [list(x_axis), list(v_unit), list(w)]\n                return [[R[0][0],R[1][0],R[2][0]],\n                        [R[0][1],R[1][1],R[2][1]],\n                        [R[0][2],R[1][2],R[2][2]]]\n            else:\n                return None\n\n        def sample_informed(c_best, x_start, x_goal):\n            # If no path yet, uniform random in bounds\n            if math.isinf(c_best):\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                # start==goal, trivial\n                return x_start\n\n            center = tuple((x_start[i]+x_goal[i])/2.0 for i in range(dim))\n            a1 = tuple((x_goal[i]-x_start[i])/c_min for i in range(dim))\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                # fallback uniform sampling\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            if c_best < c_min:\n                r2 = 0.0001\n            else:\n                val = c_best**2 - c_min**2\n                if val < 0:\n                    val = 0\n                r2 = math.sqrt(val)/2.0\n                if r2 < 0.001:\n                    r2 = 0.001\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                gauss = [random.gauss(0,1) for _ in range(dim)]\n                norm_gauss = math.sqrt(sum(x*x for x in gauss))\n                if norm_gauss > 1e-10:\n                    break\n            unit_ball = [x/norm_gauss for x in gauss]\n            u = random.random()\n            scale = u**(1.0/dim)\n            sample_ball = [scale*unit_ball[i]*radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += R[i][j]*sample_ball[j]\n                sample[i] = s + center[i]\n            # Clamp inside bounds\n            clipped = tuple(max(0.0,min(sample[i], bounds[i])) for i in range(dim))\n            return clipped\n\n        nodes: List[Node] = []\n        positions: List[Tuple[float,...]] = []\n        edges: List[Tuple[Node,Node]] = []\n\n        root = Node(start_pos)\n        nodes.append(root)\n        positions.append(start_pos)\n        grid_insert(0, start_pos)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Precompute max radius for neighbor search scaling with log(n)/n in high density scenario\n        # We'll use self.base_neighbor_radius but decrease it as tree grows (adaptive radius)\n        def neighbor_radius(n_nodes):\n            gamma_rrt = self.base_neighbor_radius\n            val = gamma_rrt * (math.log(n_nodes+1) / (n_nodes+1))**(1.0/dim)\n            return max(val, self.step_size*1.5)\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample goal point with probability goal_sample_rate, else informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal_pos\n            else:\n                sample_pt = sample_informed(best_goal_cost, start_pos, goal_pos)\n\n            # Nearest node search via spatial hashing\n            nearest, _ = nearest_node(sample_pt)\n\n            # Steer towards sampled point\n            new_pos = steer(nearest.position, sample_pt, self.step_size)\n\n            # Node collision check + bounds\n            if not is_free_node(new_pos):\n                continue\n\n            # Edge collision nearest->new_pos\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            # Add new node after rewiring neighbors within radius\n            nradius = neighbor_radius(len(nodes))\n            neighbors = grid_nearby_nodes(new_pos, nradius)\n\n            # Determine best parent with minimal cost + collision-free edge\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nbr in neighbors:\n                tentative_cost = nbr.cost + dist(nbr.position, new_pos)\n                if tentative_cost < min_cost:\n                    if is_free_edge(nbr.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n\n            nodes.append(new_node)\n            positions.append(new_pos)\n            grid_insert(len(nodes)-1, new_pos)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for nbr in neighbors:\n                if nbr is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if alt_cost < nbr.cost:\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                        nbr.update_parent(new_node, alt_cost)\n                        edges.append((new_node, nbr))\n\n            # Check if new_node can connect directly to goal for improved path\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if is_free_node(goal_pos) and is_free_edge(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    positions.append(goal_pos)\n                    grid_insert(len(nodes)-1, goal_pos)\n                    edges.append((new_node, goal_node))\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        best_goal_node = goal_node\n                        # Early termination on first found path\n                        break\n\n        # Extract path from best_goal_node if exists\n        extracted_path = []\n        success = False\n        if best_goal_node is not None:\n            success = True\n            current = best_goal_node\n            while current is not None:\n                extracted_path.append(current.position)\n                current = current.parent\n            extracted_path.reverse()\n        else:\n            # No goal reached, extract from closest node to goal\n            min_dist = float('inf')\n            closest = None\n            for n in nodes:\n                d = dist(n.position, goal_pos)\n                if d < min_dist:\n                    min_dist = d\n                    closest = n\n            if closest is not None:\n                current = closest\n                while current is not None:\n                    extracted_path.append(current.position)\n                    current = current.parent\n                extracted_path.reverse()\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -11.67906,
          "time_improvement": 17.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 97.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030892300605773925,
                    "num_nodes_avg": 250.8,
                    "path_length_avg": 172.8223959302965,
                    "smoothness_avg": 0.011826902640376145,
                    "success_improvement": 0.0,
                    "time_improvement": -22.94170000227719,
                    "length_improvement": 5.273306244493363,
                    "smoothness_improvement": 85.11670885203338,
                    "objective_score": -3.292942709726973
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09835076332092285,
                    "num_nodes_avg": 982.7,
                    "path_length_avg": 247.72707600463454,
                    "smoothness_avg": 0.00824493977827406,
                    "success_improvement": 0.0,
                    "time_improvement": 38.80946401598113,
                    "length_improvement": 17.30157160112754,
                    "smoothness_improvement": 112.14823908507424,
                    "objective_score": 22.584523360896235
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03158433437347412,
                    "num_nodes_avg": 420.6,
                    "path_length_avg": 138.564029335853,
                    "smoothness_avg": 0.015149031435232588,
                    "success_improvement": 0.0,
                    "time_improvement": 34.99565735820171,
                    "length_improvement": 7.972369425158277,
                    "smoothness_improvement": 92.69456167097287,
                    "objective_score": 15.745591670910343
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighbor radius, goal bias, and informed sampling. It alternates expanding trees from start and goal, rewires neighbors for cost improvements, attempts fast incremental connections, and applies path shortcutting for smoothness and length improvement. Early stopping occurs on timeout, stagnation, or successful connection, balancing exploration and exploitation for efficient, high-quality paths.",
          "planning_mechanism": "A bidirectional search grows two trees from start and goal by sampling with goal bias and informed distribution after first path found. Each extension chooses the best parent within adaptive radius and rewires neighbors to reduce costs with cost propagation. Trees attempt greedy incremental connections at each iteration. When a connection is made, the combined path is shortcut for improved smoothness and length. The search respects collision constraints, map bounds, and halts after time limit or stagnation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 goal_sample_rate=0.05,\n                 max_no_improve=100,\n                 post_opt_iters=300,\n                 improve_tol=1e-6,\n                 time_limit_sec=30.0,\n                 gamma_rrt_star=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(d)]\n                    norm_ = math.sqrt(sum(x * x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x / norm_ for x in v]\n                        r = random.random() ** (1.0 / d)\n                        return [x * r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = [center[i] for i in range(dim)]\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i], 0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.0, self.step_size * 2.0)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(2.0, self.step_size)\n            return max(min_r, min(max_r, val))\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def near_nodes(nodes_list, p, radius):\n            return [n for n in nodes_list if dist(n.position, p) <= radius]\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            possible_parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not possible_parents:\n                p = nearest(tree, pos)\n                if not p or is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                possible_parents = [p]\n            best_parent = min(possible_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n1, n2, n1_is_start):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            if path1 and path2 and path1[-1] == path2[-1]:\n                combined = path1 + path2[-2::-1]\n            else:\n                combined = path1 + path2[::-1]\n            return combined if n1_is_start else combined[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal[:]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            if it % 2 == 0:\n                curr_tree = tree_start\n                other_tree = tree_goal\n                curr_is_start = True\n            else:\n                curr_tree = tree_goal\n                other_tree = tree_start\n                curr_is_start = False\n\n            # Sampling\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if curr_is_start else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos)) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbor_nodes = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if new_node is None:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbor_nodes, edges)\n\n            # Try fast direct connection\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                current = nearest_other\n                tries = 0\n                max_steps = 20\n                while tries < max_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if (not within_bounds(step_pos)) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    new_other_node, neighbors_other = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if new_other_node is None:\n                        break\n                    rewire(other_tree, new_other_node, neighbors_other, edges)\n                    current = new_other_node\n                    if dist(current.position, new_node.position) <= self.step_size:\n                        if can_connect(current, new_node):\n                            final_node = Node(new_node.position, cost=current.cost + dist(current.position, new_node.position))\n                            current.add_child(final_node)\n                            other_tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((current, final_node))\n                            connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, curr_is_start)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first = True\n                    post_no_improve = 0\n                    post_iter = 0\n                else:\n                    if found_first:\n                        post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(success=True, path=best_path, nodes=nodes, edges=edges)\n        else:\n            # Return best approximate path\n            if nodes:\n                # fallback to nearest node to goal from the tree with minimal cost + distance to goal\n                end_node = min(nodes, key=lambda n: n.cost + dist(n.position, goal_pos))\n                path = end_node.path_from_root()\n                return PlannerResult(success=False, path=path, nodes=nodes, edges=edges)\n            else:\n                return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return sum(x * x for x in v) ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -11.53763,
          "time_improvement": -24.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1527.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05551867485046387,
                    "num_nodes_avg": 226.4,
                    "path_length_avg": 156.1114011195167,
                    "smoothness_avg": 0.04464349950228266,
                    "success_improvement": 0.0,
                    "time_improvement": -120.94697170964241,
                    "length_improvement": 14.432867302940048,
                    "smoothness_improvement": 598.76771212155,
                    "objective_score": -24.630532570520945
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045183229446411136,
                    "num_nodes_avg": 343.7,
                    "path_length_avg": 231.48365383955797,
                    "smoothness_avg": 0.09519222146902785,
                    "success_improvement": 0.0,
                    "time_improvement": 71.8885148019321,
                    "length_improvement": 22.724093460813606,
                    "smoothness_improvement": 2349.3644225838257,
                    "objective_score": 46.94783262998692
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059907841682434085,
                    "num_nodes_avg": 411.1,
                    "path_length_avg": 122.65550871222877,
                    "smoothness_avg": 0.13619592683423404,
                    "success_improvement": 0.0,
                    "time_improvement": -23.29751267217226,
                    "length_improvement": 18.538051341022793,
                    "smoothness_improvement": 1632.4021363938564,
                    "objective_score": 12.295587684931279
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An adaptive informed bi-directional RRT* planner with dynamic neighbor radius, goal bias, and ellipsoidal informed sampling after first solution. It alternates tree expansions, incrementally rewires nodes within shrinking neighborhood for optimized paths, and applies iterative shortcutting post-processing. Planning halts early either on time limit or upon satisfying a quality threshold, ensuring efficient search with shorter, smoother paths.",
          "planning_mechanism": "The planner maintains two trees grown from start and goal, sampling points with goal bias initially, then informed ellipsoidal sampling post first solution to focus near best path. Each new node connects to best parent found in a radius adaptively decreasing with node count, followed by rewiring neighbors to minimize path cost. Trees attempt connection after each extension, and upon success, iterative path shortcutting improves smoothness and length. Planning respects a hard 30-second limit and returns the best path found so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"] = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent: Optional[\"Node\"], new_cost: float):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.05, gamma_rrt_star: float = 25.0, max_neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        TIME_LIMIT = 30.0\n        t_start = time.monotonic()\n\n        nodes_all: List[Node] = []\n        edges_all: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(p):\n            if not in_bounds(p):\n                return False\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            dist = math.dist(p1, p2)\n            resolution = min(1.0, self.step_size*0.5)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_free_node(p):\n                    return p\n\n        def sample_goal():\n            if is_free_node(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        def sample_ellipsoid(c_best, c_min, x_center, C):\n            # Sample uniformly inside unit ball and transform via C*ball + x_center\n            # Returns point in informed subset ellipsoid focusing near optimal path.\n            while True:\n                ball = self._sample_unit_ball(dim)\n                if ball is None:\n                    return sample_uniform()  # fallback\n                point_local = tuple(ball[i] * c_best / 2 if i == 0 else ball[i] * math.sqrt(c_best**2 - c_min**2) / 2 for i in range(dim))\n                p = tuple(sum(C[i][j] * point_local[j] for j in range(dim)) + x_center[i] for i in range(dim))\n                if in_bounds(p) and is_free_node(p):\n                    return p\n\n        def nearest(tree_nodes: List[Node], point: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            best_node = tree_nodes[0]\n            best_dist = math.dist(best_node.position, point)\n            for n in tree_nodes[1:]:\n                d = math.dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree_nodes: List[Node], point: Tuple[float, ...]) -> List[Node]:\n            n = len(tree_nodes)\n            if n < 2:\n                return []\n            rad = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            radius = min(self.max_neighbor_radius, max(self.step_size * 2, rad))\n            return [node for node in tree_nodes if math.dist(node.position, point) <= radius]\n\n        def rewire(new_node: Node, neighbors: List[Node], edges: List[Tuple[Node, Node]]):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        # Update parent and edges\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.update_parent(new_node, new_cost)\n                        edges.append((new_node, nb))\n\n        def choose_parent_and_add(tree_nodes: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            if not tree_nodes:\n                return None\n            nearest_node = nearest(tree_nodes, new_pos)\n            if nearest_node is None:\n                return None\n            neighbors = near_nodes(tree_nodes, new_pos)\n            # Candidate parent nodes include nearest\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cand_cost = nb.cost + math.dist(nb.position, new_pos)\n                if cand_cost < min_cost:\n                    min_cost = cand_cost\n                    best_parent = nb\n            if not is_free_edge(best_parent.position, new_pos):\n                return None\n            new_node = Node(new_pos, None, min_cost)\n            best_parent.add_child(new_node)\n            nodes_all.append(new_node)\n            tree_nodes.append(new_node)\n            edges_all.append((best_parent, new_node))\n            rewire(new_node, neighbors, edges_all)\n            return new_node\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Optional[Tuple[List[Tuple[float, ...]], float]]:\n            if not other_tree:\n                return None\n            nearest_other = nearest(other_tree, new_node.position)\n            if nearest_other is None:\n                return None\n            dist_between = math.dist(new_node.position, nearest_other.position)\n            if dist_between > self.step_size:\n                return None\n            if not is_free_edge(new_node.position, nearest_other.position):\n                return None\n            path1 = new_node.path_from_root()\n            path2 = nearest_other.path_from_root()\n            # Avoid duplication of meeting node\n            if path1[-1] == path2[-1]:\n                path2 = path2[:-1]\n            full_path = path1 + path2[::-1]\n            total_cost = new_node.cost + nearest_other.cost + dist_between\n            return full_path, total_cost\n\n        def shortcut_path(path: List[Tuple[float, ...]], timeout_sec=5.0) -> List[Tuple[float, ...]]:\n            n = len(path)\n            if n < 3:\n                return path\n            t0 = time.monotonic()\n            shortened = [path[0]]\n            i = 0\n            while i < n - 1:\n                end = n - 1\n                while end > i + 1:\n                    if time.monotonic() - t0 > timeout_sec:\n                        break\n                    if is_free_edge(path[i], path[end]):\n                        shortened.append(path[end])\n                        i = end\n                        break\n                    end -= 1\n                else:\n                    i += 1\n                    if i < n:\n                        shortened.append(path[i])\n                    continue\n            return shortened\n\n        def compute_rotation_matrix(unit_x: Tuple[float, ...]) -> List[List[float]]:\n            # Returns rotation matrix C such that C * (c_min/2,0,..0) aligns with unit_x\n            if dim == 2:\n                x, y = unit_x\n                norm = math.hypot(x, y)\n                if norm < 1e-14:\n                    return [[1, 0], [0, 1]]\n                x /= norm\n                y /= norm\n                return [[x, -y],[y, x]]\n            elif dim == 3:\n                # Use SVD on unit_x to generate rotation matrix\n                import math\n                ux, uy, uz = unit_x\n                norm = math.sqrt(ux*ux+uy*uy+uz*uz)\n                if norm < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ux /= norm\n                uy /= norm\n                uz /= norm\n                # Pick arbitrary vector not colinear to unit_x\n                v = (0,0,1) if abs(uz) < 0.9 else (0,1,0)\n                # Compute axis = unit_x cross v\n                ax = uy*v[2] - uz*v[1]\n                ay = uz*v[0] - ux*v[2]\n                az = ux*v[1] - uy*v[0]\n                axis_length = math.sqrt(ax*ax + ay*ay + az*az)\n                if axis_length < 1e-14:\n                    return [[1,0,0],[0,1,0],[0,0,1]]\n                ax /= axis_length\n                ay /= axis_length\n                az /= axis_length\n                angle = math.acos(ux*0 + uy*0 + uz*1)\n                c = math.cos(angle)\n                s = math.sin(angle)\n                t = 1 - c\n                C = [[0.0]*3 for _ in range(3)]\n                C[0][0] = t*ax*ax + c\n                C[0][1] = t*ax*ay - s*az\n                C[0][2] = t*ax*az + s*ay\n                C[1][0] = t*ax*ay + s*az\n                C[1][1] = t*ay*ay + c\n                C[1][2] = t*ay*az - s*ax\n                C[2][0] = t*ax*az - s*ay\n                C[2][1] = t*ay*az + s*ax\n                C[2][2] = t*az*az + c\n                return C\n            else:\n                # For higher dims, just identity\n                return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf'):\n                return sample_uniform()\n            # Define ellipse parameters\n            midpoint = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            norm_diff = math.dist(start, goal)\n            if norm_diff < 1e-14:\n                return sample_uniform()\n            unit_x = tuple(d / norm_diff for d in diff)\n            C = compute_rotation_matrix(unit_x)\n            # Ellipsoid radii\n            r1 = c_best / 2.0\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            # Create diagonal scaling matrix but use in sample_ellipsoid logic\n            while True:\n                # Sample in unit n-ball\n                u = self._sample_unit_ball(dim)\n                if u is None:\n                    return sample_uniform()\n                # Scale sample: first dimension scaled by r1, others by r2\n                local = [0.0]*dim\n                local[0] = u[0]*r1\n                for i in range(1, dim):\n                    local[i] = u[i]*r2\n                # Rotate and translate\n                point = []\n                for i in range(dim):\n                    s = 0.0\n                    for j in range(dim):\n                        s += C[i][j]*local[j]\n                    point.append(s + midpoint[i])\n                if in_bounds(point) and is_free_node(tuple(point)):\n                    return tuple(point)\n\n        def _sample_unit_ball(d: int) -> Optional[Tuple[float, ...]]:\n            # Rejection sample from unit ball\n            for _ in range(100):\n                coord = tuple(random.uniform(-1,1) for _ in range(d))\n                norm = math.sqrt(sum(x*x for x in coord))\n                if norm <= 1 and norm > 1e-14:\n                    return tuple(x / norm for x in coord)\n            return None\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        nodes_all.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_path: List[Tuple[float, ...]] = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - t_start > TIME_LIMIT:\n                break\n\n            if found_solution:\n                sample = informed_sample(best_cost, math.dist(start_pos, goal_pos), start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = sample_goal()\n                else:\n                    sample = sample_uniform()\n\n            # Alternate tree expansion\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            new_node = choose_parent_and_add(tree_a, new_pos)\n            if new_node is None:\n                continue\n\n            connect_result = try_connect(new_node, tree_b)\n            if connect_result is not None:\n                path_candidate, cost_candidate = connect_result\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_path = path_candidate\n                    found_solution = True\n                    # Early stop on good solution or keep searching until time runs out\n                    # Here we break immediately to reduce planning time\n                    break\n\n        # If no path found, try direct connection if feasible\n        if not found_solution:\n            nearest_goal = nearest(tree_start, goal_pos)\n            if nearest_goal and is_free_edge(nearest_goal.position, goal_pos):\n                p = nearest_goal.path_from_root() + [goal_pos]\n                best_path = p\n                found_solution = False\n\n        if best_path:\n            # Iterative shortcutting to further improve smoothness & length within small time to not exceed time limit\n            t_sc_start = time.monotonic()\n            time_for_shortcut = max(1.0, TIME_LIMIT - (time.monotonic() - t_start) - 0.5)\n            # Multiple iterations of shortcutting limited by remaining time\n            for _ in range(8):\n                best_path = shortcut_path(best_path, timeout_sec=time_for_shortcut)\n                if time.monotonic() - t_sc_start > time_for_shortcut:\n                    break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges_all\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.16731,
          "time_improvement": -25.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1490.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05280606746673584,
                    "num_nodes_avg": 104.3,
                    "path_length_avg": 159.03977593430037,
                    "smoothness_avg": 0.045831156313335134,
                    "success_improvement": 0.0,
                    "time_improvement": -110.1516422374204,
                    "length_improvement": 12.827778663888708,
                    "smoothness_improvement": 617.3571202525652,
                    "objective_score": -22.262039871630073
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06106133460998535,
                    "num_nodes_avg": 251.7,
                    "path_length_avg": 229.1376515349893,
                    "smoothness_avg": 0.0943546418960893,
                    "success_improvement": 0.0,
                    "time_improvement": 62.009691978774306,
                    "length_improvement": 23.507256556010894,
                    "smoothness_improvement": 2327.812896887935,
                    "objective_score": 44.3463260116785
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06167628765106201,
                    "num_nodes_avg": 241.0,
                    "path_length_avg": 120.7672251338709,
                    "smoothness_avg": 0.12772867393374066,
                    "success_improvement": 0.0,
                    "time_improvement": -26.9371862625311,
                    "length_improvement": 19.792159383366613,
                    "smoothness_improvement": 1524.6993044871776,
                    "objective_score": 11.417636273696527
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A hybrid bidirectional informed RRT* planner introducing adaptive rewiring radius scaling with node count, progressive goal bias increment, ellipsoidal informed sampling after first solution, periodic incremental pruning of invalid nodes, and incremental path shortcutting for enhanced smoothness and path length, while enforcing strict collision checking and stopping early on time or quality stabilization.",
          "planning_mechanism": "A planner growing two trees simultaneously from start and goal, alternating expansions with an adaptive radius for rewiring and neighbor search that scales with tree size, using informed ellipsoidal sampling localized near the current best path after a first solution is found, progressively increasing goal bias to accelerate convergence, pruning disconnected nodes periodically, and incrementally shortcutting the extracted path to reduce jaggedness and shorten path length. It stops early on time limit or after stable path quality, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-5\n        self.max_no_improve = 150\n        self.prune_every = 300\n        self.goal_sample_rate_start = 0.05\n        self.goal_sample_rate_max = 0.25\n        self.goal_sample_rate_inc = 1e-4\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Trees\n        tree_start = []\n        tree_goal = []\n\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n        tree_start.append(start_node)\n        tree_goal.append(goal_node)\n        nodes.append(start_node)\n        nodes.append(goal_node)\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        found_solution = False\n        no_improve_count = 0\n        goal_sample_rate = self.goal_sample_rate_start\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            step = self.step_size\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return start_pos\n\n        def informed_sample(c_best, c_min):\n            if not found_solution or c_best == float('inf'):\n                return uniform_sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            len_a1 = math.sqrt(sum(x * x for x in a1))\n            if len_a1 < 1e-10:\n                return uniform_sample()\n            e1 = tuple(x / len_a1 for x in a1)\n\n            if dim == 2:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r2)\n            elif dim == 3:\n                r1 = c_best * 0.5\n                r_side = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) * 0.5\n                axes = (r1, r_side, r_side)\n            else:\n                return uniform_sample()\n\n            attempts = 0\n            while attempts < 200:\n                raw = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in raw))\n                if norm < 1e-10:\n                    attempts += 1\n                    continue\n                unit = [x / norm for x in raw]\n                radius = random.random() ** (1.0 / dim)\n                scaled = [radius * axes[i] * unit[i] for i in range(dim)]\n\n                # Rotate to align first axis e1 (only 2D/3D cases)\n                v = [1.0] + [0.0] * (dim - 1)\n                dot = sum(v[i] * e1[i] for i in range(dim))\n                if abs(dot - 1.0) < 1e-10:\n                    rotated = scaled\n                elif abs(dot + 1.0) < 1e-10:\n                    rotated = [-scaled[0]] + scaled[1:]\n                else:\n                    if dim == 2:\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x0, x1 = scaled[0], scaled[1]\n                        rotated = (x0 * cos_a - x1 * sin_a, x0 * sin_a + x1 * cos_a)\n                    elif dim == 3:\n                        k = [v[1] * e1[2] - v[2] * e1[1],\n                             v[2] * e1[0] - v[0] * e1[2],\n                             v[0] * e1[1] - v[1] * e1[0]]\n                        k_norm = math.sqrt(sum(kk * kk for kk in k))\n                        if k_norm < 1e-10:\n                            rotated = scaled\n                        else:\n                            k = [kk / k_norm for kk in k]\n                            angle = math.acos(dot)\n                            cos_a = math.cos(angle)\n                            sin_a = math.sin(angle)\n                            v_vec = scaled\n                            k_dot_v = sum(k[i] * v_vec[i] for i in range(dim))\n                            cross = [k[1] * v_vec[2] - k[2] * v_vec[1],\n                                     k[2] * v_vec[0] - k[0] * v_vec[2],\n                                     k[0] * v_vec[1] - k[1] * v_vec[0]]\n                            rotated = [0.0] * 3\n                            for i in range(3):\n                                rotated[i] = v_vec[i] * cos_a + cross[i] * sin_a + k[i] * k_dot_v * (1 - cos_a)\n                    else:\n                        rotated = scaled\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not is_in_obstacle(sample):\n                        return sample\n                attempts += 1\n            return uniform_sample()\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def prune_disconnected_nodes():\n            to_remove = []\n            for node in nodes:\n                if not node.valid:\n                    to_remove.append(node)\n                    continue\n                if node.parent is None and node not in (start_node, goal_node):\n                    to_remove.append(node)\n            for n in to_remove:\n                if n.parent is not None:\n                    n.parent.remove_child(n)\n                for c in list(n.children):\n                    c.parent = None\n                if n in nodes:\n                    nodes.remove(n)\n                # remove edges involving n if present\n                for e in list(edges):\n                    if e[0] == n or e[1] == n:\n                        edges.remove(e)\n                if n in tree_start:\n                    tree_start.remove(n)\n                if n in tree_goal:\n                    tree_goal.remove(n)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Alternate tree expansion flag (True = start tree, False = goal tree)\n        expand_start_tree = True\n\n        for iteration in range(1, self.max_iter + 1):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Increase goal bias progressively capped by max rate\n            if goal_sample_rate < self.goal_sample_rate_max:\n                goal_sample_rate = min(self.goal_sample_rate_max, goal_sample_rate + self.goal_sample_rate_inc)\n\n            tree_a = tree_start if expand_start_tree else tree_goal\n            tree_b = tree_goal if expand_start_tree else tree_start\n\n            # Sample with goal bias and informed sampling if solution found\n            p_rand = random.random()\n            if p_rand < goal_sample_rate and not is_in_obstacle(goal_pos):\n                sample = goal_pos\n            else:\n                c_best = best_cost if found_solution else float('inf')\n                sample = informed_sample(c_best, c_min)\n\n            if not within_bounds(sample):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            nearest_n = nearest_node(tree_a, sample)\n            new_pos = steer(nearest_n.position, sample)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_n.position, new_pos):\n                expand_start_tree = not expand_start_tree\n                continue\n\n            # Adaptive radius, scaled with tree size\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0  # Practical tuning constant\n            radius = min(gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim), self.step_size * 20.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            best_parent = nearest_n\n            best_cost_through = nearest_n.cost + dist(nearest_n.position, new_pos)\n            for nb in neighbors:\n                if nb == nearest_n:\n                    continue\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost_through:\n                    if not is_edge_in_obstacle(nb.position, new_pos):\n                        best_parent = nb\n                        best_cost_through = cost_candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_through)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new_node if improves cost\n            for nb in neighbors:\n                if nb == new_node or nb == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost and not is_edge_in_obstacle(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connecting new_node to tree_b nodes (within radius) for path connection\n            near_other = near_nodes(tree_b, new_pos, radius)\n            for other_node in near_other:\n                if is_edge_in_obstacle(new_pos, other_node.position):\n                    continue\n                total_cost = new_node.cost + dist(new_pos, other_node.position) + other_node.cost\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_start_node = new_node if expand_start_tree else other_node\n                    best_goal_node = other_node if expand_start_tree else new_node\n                    found_solution = True\n                    no_improve_count = 0\n\n            if found_solution:\n                no_improve_count += 1\n                if no_improve_count >= self.max_no_improve:\n                    break\n\n            # Periodic pruning of invalid/disconnected nodes\n            if iteration % self.prune_every == 0 and found_solution:\n                prune_disconnected_nodes()\n\n            expand_start_tree = not expand_start_tree\n\n        success_state = found_solution and best_start_node is not None and best_goal_node is not None\n        if success_state:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            raw_path = path_start + path_goal[::-1]\n            extracted_path = shortcut_path(raw_path)\n        else:\n            # Fallback: closest node in start tree to goal\n            closest = None\n            min_d = float('inf')\n            for node in tree_start:\n                d = dist(node.position, goal_pos)\n                if d < min_d and node.valid:\n                    min_d = d\n                    closest = node\n            if closest is not None:\n                extracted_path = closest.path_from_root()\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -9.49294,
          "time_improvement": -34.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1672.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.061150741577148435,
                    "num_nodes_avg": 436.7,
                    "path_length_avg": 156.22154427651856,
                    "smoothness_avg": 0.04528416025938395,
                    "success_improvement": 0.0,
                    "time_improvement": -143.36083679340524,
                    "length_improvement": 14.372496093257316,
                    "smoothness_improvement": 608.7954441872863,
                    "objective_score": -31.340776161130748
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06872091293334961,
                    "num_nodes_avg": 579.9,
                    "path_length_avg": 230.40586524632596,
                    "smoothness_avg": 0.11283454594413964,
                    "success_improvement": 0.0,
                    "time_improvement": 57.24416004803713,
                    "length_improvement": 23.083890315659026,
                    "smoothness_improvement": 2803.31413858114,
                    "objective_score": 45.04015289671226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05595877170562744,
                    "num_nodes_avg": 500.8,
                    "path_length_avg": 122.18235555906139,
                    "smoothness_avg": 0.13394741797193868,
                    "success_improvement": 0.0,
                    "time_improvement": -15.169853724122028,
                    "length_improvement": 18.85229713622458,
                    "smoothness_improvement": 1603.8012696331193,
                    "objective_score": 14.779428512663735
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A dual-tree bidirectional RRT* planner employing adaptive fixed-radius rewiring, dynamic informed elliptical sampling after initial solution, increased goal bias, and early stopping with robust collision checking and incremental cost propagation to enhance planning efficiency, path quality, and smoothness within a strict 30-second limit.",
          "planning_mechanism": "The planner grows two RRT* trees alternately from start and goal, uses informed elliptical sampling focused on the current best path after the first solution, employs goal bias sampling to expedite goal connection, rewires new nodes with neighbors in a fixed radius ensuring collision-free connections, propagates cost efficiently downstream upon rewiring, tries incremental greedy connections between trees, and applies a post-planning shortcut smoothing while stopping early if no improvement is observed, all respecting map bounds and obstacles to return the best feasible path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 12000,\n                 step_size: float = 4.0,\n                 goal_sample_rate: float = 0.10,\n                 post_opt_iters: int = 250,\n                 max_no_improve: int = 60,\n                 improve_tol: float = 1e-6,\n                 time_limit_sec: float = 30.0,\n                 gamma_rrt_star: float = 35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * r for i in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def uniform_sample():\n            trials = 0\n            while True:\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n                trials += 1\n                if trials > 1000:\n                    return start_pos\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min <= 1e-12:\n                return uniform_sample()\n            center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n            a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                r1 = c_best / 2.0\n                r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r2]\n            else:\n                ref = (1., 0., 0.) if abs(a1[0]) < 0.9 else (0.,1.,0.)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0., 0., 1.)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = [a1, b2, b3]\n                r1 = c_best / 2.0\n                r_other = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                radii = [r1, r_other, r_other]\n\n            def sample_unit_ball(dim_):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dim_)]\n                    norm_ = math.sqrt(sum(x*x for x in v))\n                    if norm_ > 1e-12:\n                        v = [x/norm_ for x in v]\n                        r = random.random()**(1.0/dim_)\n                        return [x*r for x in v]\n\n            u = sample_unit_ball(dim)\n            mapped = list(center)\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i] * radii[j] * u[j]\n            mapped = tuple(min(max(mapped[i],0.0), bounds[i]) for i in range(dim))\n            if is_in_obstacle(mapped):\n                return uniform_sample()\n            return mapped\n\n        def nearest(nodes_list, p):\n            min_node = None\n            min_d = float('inf')\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ < min_d:\n                    min_d = d_\n                    min_node = n\n            return min_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(2.5, self.step_size * 1.5)\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            max_r = max(bounds) * 0.22\n            min_r = max(2.5, self.step_size * 1.2)\n            return max(min_r, min(max_r, val))\n\n        def near_nodes(nodes_list, p, radius):\n            result = []\n            r_sq = radius*radius\n            for n in nodes_list:\n                d_ = dist(n.position, p)\n                if d_ <= radius:\n                    result.append(n)\n            return result\n\n        def add_node_rrt_star(tree, pos, nodes_all, edges_list):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            parents = [n for n in neighbors if not is_edge_in_obstacle(n.position, pos)]\n            if not parents:\n                p = nearest(tree, pos)\n                if is_edge_in_obstacle(p.position, pos):\n                    return None, []\n                parents = [p]\n            best_parent = min(parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_list.append((best_parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_to_children(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost + 1e-12 < old_cost:\n                    propagate_cost_to_children(child)\n\n        def rewire(tree, new_node, neighbors, edges_list):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges_list.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges_list.append((new_node, nb))\n                    propagate_cost_to_children(nb)\n\n        def can_connect(n1, n2):\n            return not is_edge_in_obstacle(n1.position, n2.position) and n1.valid and n2.valid\n\n        def stitch_path(n_start, n_goal, a_is_start):\n            path_a = n_start.path_from_root()\n            path_b = n_goal.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            if a_is_start:\n                return merged\n            else:\n                return merged[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        start_time = time.monotonic()\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_first = False\n        post_no_improve = 0\n        post_iter = 0\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            curr_tree = tree_start if it % 2 == 0 else tree_goal\n            other_tree = tree_goal if it % 2 == 0 else tree_start\n            a_is_start_side = (it % 2 == 0)\n\n            if found_first:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if a_is_start_side else start_pos\n                else:\n                    sample = uniform_sample()\n\n            nearest_node_curr = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node_curr.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node_curr.position, new_pos):\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_rrt_star(curr_tree, new_pos, nodes, edges)\n            if not new_node:\n                if found_first:\n                    post_no_improve += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(curr_tree, new_node, neighbors, edges)\n\n            nearest_other = nearest(other_tree, new_node.position)\n            connected_other = None\n\n            # Try a direct connection if within step_size and collision free\n            if dist(nearest_other.position, new_node.position) <= self.step_size and can_connect(nearest_other, new_node):\n                final_node = Node(new_node.position, parent=None,\n                                  cost=nearest_other.cost + dist(nearest_other.position, new_node.position))\n                nearest_other.add_child(final_node)\n                other_tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((nearest_other, final_node))\n                connected_other = final_node\n            else:\n                # Incremental greedy connection attempts (limit reduced to improve speed)\n                current = nearest_other\n                max_greedy_steps = 15\n                tries = 0\n                while tries < max_greedy_steps:\n                    tries += 1\n                    step_pos = steer(current.position, new_node.position)\n                    if not within_bounds(step_pos) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                        break\n                    other_new, other_neighbors = add_node_rrt_star(other_tree, step_pos, nodes, edges)\n                    if not other_new:\n                        break\n                    rewire(other_tree, other_new, other_neighbors, edges)\n                    current = other_new\n                    if dist(current.position, new_node.position) <= self.step_size and can_connect(current, new_node):\n                        final_node = Node(new_node.position, parent=None,\n                                          cost=current.cost + dist(current.position, new_node.position))\n                        current.add_child(final_node)\n                        other_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                        break\n\n            if connected_other is not None:\n                candidate_path = stitch_path(new_node, connected_other, a_is_start_side)\n                cost_candidate = 0.0\n                for i in range(len(candidate_path) - 1):\n                    cost_candidate += dist(candidate_path[i], candidate_path[i+1])\n\n                improved = False\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_first = True\n                    post_iter = 0\n                    post_no_improve = 0\n                    improved = True\n                if not improved:\n                    if found_first:\n                        post_no_improve += 1\n                if found_first:\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n            else:\n                if found_first:\n                    post_iter += 1\n                    post_no_improve += 1\n                    if post_iter >= self.post_opt_iters or post_no_improve >= self.max_no_improve:\n                        break\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": -9.38351,
          "time_improvement": -34.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1650.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044814467430114746,
                    "num_nodes_avg": 189.9,
                    "path_length_avg": 154.9920457324414,
                    "smoothness_avg": 0.04197078937010046,
                    "success_improvement": 0.0,
                    "time_improvement": -78.3475721301645,
                    "length_improvement": 15.046403727917191,
                    "smoothness_improvement": 556.933994669952,
                    "objective_score": -11.691759428949272
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05145115852355957,
                    "num_nodes_avg": 393.5,
                    "path_length_avg": 237.20947427610412,
                    "smoothness_avg": 0.11364820992333273,
                    "success_improvement": 0.0,
                    "time_improvement": 67.98882021096053,
                    "length_improvement": 20.8126497904913,
                    "smoothness_improvement": 2824.250298824254,
                    "objective_score": 47.00548743170421
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09248323440551758,
                    "num_nodes_avg": 473.4,
                    "path_length_avg": 120.21573335505566,
                    "smoothness_avg": 0.1311992453792897,
                    "success_improvement": 0.0,
                    "time_improvement": -90.34157208540037,
                    "length_improvement": 20.15843396363922,
                    "smoothness_improvement": 1568.8447171036246,
                    "objective_score": -7.163187661918458
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A unidirectional RRT* planning algorithm enhanced with adaptive neighbor radius based on the log-scale of explored nodes, dynamic goal-biased informed sampling within an ellipsoidal region after the first path is found, and efficient rewiring leveraging a spatial hashing grid for scalability. The planner incrementally extends the tree towards sampled points, rewires nearby nodes for improved paths, performs collision checking for nodes and edges, and applies a potent multi-pass shortcutting postprocessing that locally shortcuts and smooths the final path for improved smoothness and length while respecting a 30-second hard time limit. Early stopping occurs upon stable convergence or time expiration.",
          "planning_mechanism": "The planner grows a single tree from start, sampling preferentially near the goal and inside an ellipsoidal region after finding a path, uses a spatial grid to efficiently find neighbors for adaptive-radius rewiring minimizing path costs. Tree extension occurs by steering towards sampled points with collision checks. After planning, a multi-pass shortcutting process attempts to shortcut non-adjacent node pairs and smooth the path, improving smoothness and shortening length. The best path found is returned on time limit or on early convergence.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position       # Tuple of coordinates\n        self.parent = parent           # Parent Node or None\n        self.cost = cost               # Cost from start to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Mark node as valid or pruned\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=15000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, max_neighbor_radius: float=20.0,\n                 min_neighbor_radius: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a,b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            d = dist(p1, p2)\n            resolution = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i/steps) for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, max_len):\n            d = dist(from_pos, to_pos)\n            if d <= max_len:\n                return to_pos\n            ratio = max_len / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def heuristic_cost(a, b):\n            return dist(a, b)\n\n        # Informed sampling inside ellipsoid after first solution\n        def sample_informed(c_best, x_start, x_goal):\n            if math.isinf(c_best):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            c_min = heuristic_cost(x_start, x_goal)\n            if c_min == 0.0:\n                return x_start\n\n            center = tuple((x_start[i] + x_goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((x_goal[i] - x_start[i]) / c_min for i in range(dim))\n\n            def build_rotation_matrix(a):\n                if dim == 2:\n                    cos_theta, sin_theta = a[0], a[1]\n                    return [[cos_theta, -sin_theta],\n                            [sin_theta,  cos_theta]]\n                elif dim == 3:\n                    x_axis = a\n                    # Arbitrary vector not colinear with x_axis\n                    if abs(x_axis[0]) < 0.9:\n                        temp = (1,0,0)\n                    else:\n                        temp = (0,1,0)\n                    v = [temp[i] - sum(x_axis[j]*temp[j] for j in range(3))*x_axis[i] for i in range(3)]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    v_unit = [vi/norm_v for vi in v]\n                    w = [x_axis[1]*v_unit[2]-x_axis[2]*v_unit[1],\n                         x_axis[2]*v_unit[0]-x_axis[0]*v_unit[2],\n                         x_axis[0]*v_unit[1]-x_axis[1]*v_unit[0]]\n                    R = [list(x_axis), v_unit, w]\n                    # transpose\n                    return [[R[0][0], R[1][0], R[2][0]],\n                            [R[0][1], R[1][1], R[2][1]],\n                            [R[0][2], R[1][2], R[2][2]]]\n                else:\n                    return None\n\n            R = build_rotation_matrix(a1)\n            if R is None:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            r1 = c_best / 2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)/2.0 if val > 0 else 0.001\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                rnd = [random.gauss(0,1) for _ in range(dim)]\n                norm_rnd = math.sqrt(sum(x*x for x in rnd))\n                if norm_rnd > 1e-10:\n                    break\n            unit_ball = [x / norm_rnd for x in rnd]\n            u = random.random()\n            scale = u**(1/dim)\n            sample_ball = [scale * unit_ball[i] * radii[i] for i in range(dim)]\n\n            sample = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    sample[i] += R[i][j] * sample_ball[j]\n                sample[i] += center[i]\n\n            clipped = tuple(min(max(0.0, sample[i]), bounds[i]) for i in range(dim))\n            return clipped\n\n        # Adaptive neighbor radius function\n        def radius_adaptive(n_nodes):\n            if n_nodes < 2:\n                return self.max_neighbor_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            r = self.max_neighbor_radius * val\n            return max(min(r, self.max_neighbor_radius), self.min_neighbor_radius)\n\n        # Spatial grid for neighbor lookup\n        class SpatialGrid:\n            def __init__(self, domain, cell_size):\n                self.domain = domain\n                self.cell_size = cell_size\n                self.dim = len(domain)\n                self.cells = {}\n\n            def _cell_coords(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def add_node(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n\n            def neighbor_candidates(self, p, radius):\n                ci = self._cell_coords(p)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                def expand_coords(ci, r_cells):\n                    if self.dim == 2:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                yield (ci[0]+dx, ci[1]+dy)\n                    elif self.dim == 3:\n                        for dx in range(-r_cells, r_cells+1):\n                            for dy in range(-r_cells, r_cells+1):\n                                for dz in range(-r_cells, r_cells+1):\n                                    yield (ci[0]+dx, ci[1]+dy, ci[2]+dz)\n                    else:\n                        return []\n                for c in expand_coords(ci, r_cells):\n                    if c in self.cells:\n                        neighbors.extend(self.cells[c])\n                return neighbors\n\n        # Initialize start node and spatial grid\n        root = Node(start_pos)\n        nodes.append(root)\n        edges = []\n        grid_cell_size = self.max_neighbor_radius\n        spatial_grid = SpatialGrid(bounds, grid_cell_size)\n        spatial_grid.add_node(root)\n\n        best_goal_cost = float('inf')\n        best_goal_node = None\n\n        # Early stopping criteria\n        min_improve = 1e-4\n        no_improve_count = 0\n        max_no_improve = 1500\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point: goal bias + informed sampling after first success\n            if best_goal_node is not None:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_informed(best_goal_cost, start_pos, goal_pos)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node linear search\n            nearest = nodes[0]\n            min_dist = dist(nearest.position, sample)\n            for n in nodes[1:]:\n                d_ = dist(n.position, sample)\n                if d_ < min_dist:\n                    nearest = n\n                    min_dist = d_\n\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest.position, new_pos):\n                continue\n\n            radius = radius_adaptive(len(nodes))\n\n            # Candidate neighbors from spatial grid\n            candidates = spatial_grid.neighbor_candidates(new_pos, radius)\n            radius_sq = radius*radius\n            neighbors = []\n            for c in candidates:\n                sum_sq = 0.0\n                p_c = c.position\n                for i_d in range(dim):\n                    diff = p_c[i_d] - new_pos[i_d]\n                    sum_sq += diff*diff\n                    if sum_sq > radius_sq:\n                        break\n                if sum_sq <= radius_sq:\n                    neighbors.append(c)\n\n            # Choose best parent among neighbors\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nb in neighbors:\n                tentative = nb.cost + dist(nb.position, new_pos)\n                if tentative < min_cost and is_free_edge(nb.position, new_pos):\n                    best_parent = nb\n                    min_cost = tentative\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_grid.add_node(new_node)\n\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + 1e-8 < nb.cost and is_free_edge(new_node.position, nb.position):\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                    nb.update_parent(new_node, alt_cost)\n                    edges.append((new_node, nb))\n\n            # Check connection to goal\n            dist_goal = dist(new_pos, goal_pos)\n            if dist_goal <= self.step_size and is_free_node(goal_pos) and is_free_edge(new_pos, goal_pos):\n                goal_node = Node(goal_pos)\n                goal_cost = new_node.cost + dist_goal\n                goal_node.update_parent(new_node, goal_cost)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n\n                if goal_cost + 1e-8 < best_goal_cost:\n                    improvement = best_goal_cost - goal_cost\n                    best_goal_cost = goal_cost\n                    best_goal_node = goal_node\n                    no_improve_count = 0\n                else:\n                    improvement = 0.0\n\n                if improvement < min_improve:\n                    break\n\n            if best_goal_node is not None:\n                no_improve_count += 1\n                if no_improve_count > max_no_improve:\n                    break\n\n        # Extract path from best goal node or closest node if none\n        def extract_path(end_node):\n            path = []\n            curr = end_node\n            while curr is not None:\n                path.append(curr.position)\n                curr = curr.parent\n            path.reverse()\n            return path\n\n        success_state = False\n        if best_goal_node is not None:\n            success_state = True\n            extracted_path = extract_path(best_goal_node)\n        else:\n            # Closest node to goal fallback\n            min_d_goal = float('inf')\n            closest = None\n            for n in nodes:\n                d_ = dist(n.position, goal_pos)\n                if d_ < min_d_goal:\n                    min_d_goal = d_\n                    closest = n\n            if closest is not None:\n                extracted_path = extract_path(closest)\n            else:\n                extracted_path = [start_pos]\n\n        # Multi-pass shortcutting procedure to improve smoothness and length\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path[:]\n            new_path = path[:]\n            max_passes = 4\n            max_iter = 250\n            for _ in range(max_passes):\n                improved = False\n                iteration = 0\n                while iteration < max_iter and len(new_path) > 2:\n                    iteration += 1\n                    # Attempt random shortcuts\n                    i = random.randint(0, len(new_path) - 3)\n                    j = random.randint(i+2, len(new_path) -1)\n                    p1 = new_path[i]\n                    p2 = new_path[j]\n                    if is_free_edge(p1, p2):\n                        # Remove intermediate nodes i+1,...,j-1\n                        del new_path[i+1:j]\n                        improved = True\n                if not improved:\n                    break\n            return new_path\n\n        extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False",
          "objective": -9.18874,
          "time_improvement": -26.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1660.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04491877555847168,
                    "num_nodes_avg": 257.5,
                    "path_length_avg": 170.83109971963432,
                    "smoothness_avg": 0.05137458565640392,
                    "success_improvement": 0.0,
                    "time_improvement": -78.76268587607503,
                    "length_improvement": 6.364767251664998,
                    "smoothness_improvement": 704.123827221081,
                    "objective_score": -16.2893262757181
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15320281982421874,
                    "num_nodes_avg": 923.8,
                    "path_length_avg": 233.87027954362262,
                    "smoothness_avg": 0.10372010455317819,
                    "success_improvement": 0.0,
                    "time_improvement": 4.682359925185249,
                    "length_improvement": 21.927369105584845,
                    "smoothness_improvement": 2568.792996724922,
                    "objective_score": 27.405094424531093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05047609806060791,
                    "num_nodes_avg": 455.9,
                    "path_length_avg": 127.79099531260484,
                    "smoothness_avg": 0.14213662533607357,
                    "success_improvement": 0.0,
                    "time_improvement": -3.8858547643932844,
                    "length_improvement": 15.127305666646151,
                    "smoothness_improvement": 1707.9673828405046,
                    "objective_score": 16.450463884872228
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with goal bias and ellipsoidal informed sampling after the first solution, an adaptive neighbor radius for rewiring, direct rewiring without recursion to reduce overhead, greedy connection attempts between trees, and iterative shortcut smoothing to improve planning speed and path quality within a strict 30-second limit. The planner alternates tree expansions, chooses parents with minimal cost in an adaptively sized neighborhood, connects trees greedily upon proximity, and post-processes the found path for smoothness and length reduction.",
          "planning_mechanism": "The planner grows two trees from start and goal by alternating expansions; samples points with goal bias and informed distribution post first solution; chooses parents and rewires neighbors within an adaptive radius without deep cost propagation; connects trees directly when near; iteratively shortcutting the resulting path to refine smoothness and length; enforcing a strict 30-second time limit to return the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1\n        self.time_limit_sec = 30.0\n        self.gamma_rrt_star = 50.0\n        self.max_neighbor_radius = 30.0\n        self.improve_tol = 1e-10\n        self.shortcut_passes = 10\n        self.max_shortcut_attempts_per_pass = 100\n\n    def plan(self, map):\n        import time, math, random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a,b):\n            dist_ab = dist(a,b)\n            res = min(1.0, self.step_size * 0.5)\n            steps = max(1, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr,to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + ratio*(to[i]-fr[i]) for i in range(dim))\n\n        def uniform_sample():\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(s):\n                    return s\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def informed_sample(c_best):\n            c_min = dist(start_pos, goal_pos)\n            if c_best == float('inf') or c_best < c_min + 1e-12:\n                return uniform_sample()\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            direction = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            length_dir = math.sqrt(sum(x*x for x in direction))\n            if length_dir < 1e-12:\n                return uniform_sample()\n            e1 = tuple(x/length_dir for x in direction)\n            r1 = c_best/2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0))/2.0\n\n            for _ in range(100):\n                x_raw = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_raw))\n                if norm_x < 1e-12:\n                    continue\n                x_unit = [xi / norm_x for xi in x_raw]\n                radius = random.random() ** (1.0 / dim)\n                if dim == 2:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1]]\n                    cos_t, sin_t = e1[0], e1[1]\n                    rot_x = cos_t*coords[0] - sin_t*coords[1]\n                    rot_y = sin_t*coords[0] + cos_t*coords[1]\n                    sample = (center[0] + rot_x, center[1] + rot_y)\n                elif dim == 3:\n                    coords = [radius*r1*x_unit[0], radius*r2*x_unit[1], radius*r2*x_unit[2]]\n                    v = (1.0, 0.0, 0.0)\n                    dot = sum(v[i]*e1[i] for i in range(3))\n                    if abs(dot-1.0) < 1e-9:\n                        rot = coords\n                    elif abs(dot+1.0) < 1e-9:\n                        rot = (-coords[0], coords[1], coords[2])\n                    else:\n                        k = (v[1]*e1[2]-v[2]*e1[1],\n                             v[2]*e1[0]-v[0]*e1[2],\n                             v[0]*e1[1]-v[1]*e1[0])\n                        k_norm = math.sqrt(sum(x*x for x in k))\n                        k = tuple(x/k_norm for x in k)\n                        angle = math.acos(dot)\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        v_vec = coords\n                        k_dot_v = sum(k[i]*v_vec[i] for i in range(3))\n                        cross = (k[1]*v_vec[2]-k[2]*v_vec[1],\n                                 k[2]*v_vec[0]-k[0]*v_vec[2],\n                                 k[0]*v_vec[1]-k[1]*v_vec[0])\n                        rot = tuple(v_vec[i]*cos_a + cross[i]*sin_a + k[i]*k_dot_v*(1-cos_a) for i in range(3))\n                    sample = tuple(center[i]+rot[i] for i in range(3))\n                else:\n                    sample = uniform_sample()\n                if in_bounds(sample) and not is_in_obstacle(sample):\n                    return sample\n            return uniform_sample()\n\n        def nearest_node(tree_nodes, pt):\n            best = tree_nodes[0]\n            best_dist = dist(best.position, pt)\n            for node in tree_nodes[1:]:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.max_neighbor_radius\n            return min(self.max_neighbor_radius, max(self.step_size*2, self.gamma_rrt_star * ((math.log(n)/n)**(1/dim))))\n\n        def near_nodes(tree_nodes, pt, radius):\n            return [n for n in tree_nodes if dist(n.position, pt) <= radius]\n\n        def choose_parent(tree_nodes, new_pos):\n            n_nodes = len(tree_nodes)\n            radius = adaptive_radius(n_nodes)\n            near = near_nodes(tree_nodes, new_pos, radius)\n            nearest = nearest_node(tree_nodes, new_pos)\n            best_parent = nearest\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            for nbr in near:\n                if nbr is nearest:\n                    continue\n                cost = nbr.cost + dist(nbr.position, new_pos)\n                if cost + self.improve_tol < min_cost:\n                    if not is_edge_in_obstacle(nbr.position, new_pos):\n                        min_cost = cost\n                        best_parent = nbr\n            if not is_edge_in_obstacle(best_parent.position, new_pos):\n                return best_parent, min_cost, near\n            else:\n                return None, None, near\n\n        def rewire(new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(new_node, cost_through_new)\n\n        def merge_trees(node_a, tree_b):\n            nearest_b = nearest_node(tree_b, node_a.position)\n            d = dist(node_a.position, nearest_b.position)\n            if d > self.step_size:\n                return None\n            if is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return None\n            path_a = node_a.path_from_root()\n            path_b = nearest_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                path_b = path_b[:-1]\n            combined_path = path_a + path_b[::-1]\n            total_cost = node_a.cost + d + nearest_b.cost\n            return combined_path, total_cost\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_passes):\n                attempts = 0\n                while attempts < self.max_shortcut_attempts_per_pass:\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        attempts = 0\n                    else:\n                        attempts += 1\n            return path\n\n        nodes = []\n        edges = []\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_pos, None, 0.0)\n        root_goal = Node(goal_pos, None, 0.0)\n        nodes.extend([root_start, root_goal])\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit_sec:\n                break\n\n            if found_solution:\n                sample = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if not is_in_obstacle(goal_pos) else uniform_sample()\n                else:\n                    sample = uniform_sample()\n\n            if is_in_obstacle(sample):\n                continue\n            if not in_bounds(sample):\n                continue\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                curr_tree, other_tree = tree_start, tree_goal\n            else:\n                curr_tree, other_tree = tree_goal, tree_start\n\n            nearest = nearest_node(curr_tree, sample)\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            parent, cost_new_node, near = choose_parent(curr_tree, new_pos)\n            if parent is None:\n                continue\n            new_node = Node(new_pos, parent, cost_new_node)\n            parent.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n\n            rewire(new_node, near)\n\n            merged = merge_trees(new_node, other_tree)\n            if merged is not None:\n                path_candidate, cost_candidate = merged\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_path = path_candidate\n                    best_cost = cost_candidate\n                    found_solution = True\n                    # Early stop immediately after improvement\n                    break\n\n        if not found_solution:\n            # Try direct connection fallback\n            nearest_start = nearest_node(tree_start, goal_pos)\n            if nearest_start and not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nearest_start.position, goal_pos):\n                best_path = nearest_start.path_from_root() + [goal_pos]\n                found_solution = True\n\n        if best_path:\n            best_path = shortcut_path(best_path)\n            success_state = True\n        else:\n            success_state = False\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -8.40271,
          "time_improvement": -28.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1498.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0637139081954956,
                    "num_nodes_avg": 147.5,
                    "path_length_avg": 169.44407412039683,
                    "smoothness_avg": 0.044426999551566815,
                    "success_improvement": 0.0,
                    "time_improvement": -153.5614387320576,
                    "length_improvement": 7.1250179614341755,
                    "smoothness_improvement": 595.3790177556791,
                    "objective_score": -38.816525753978375
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06506216526031494,
                    "num_nodes_avg": 343.4,
                    "path_length_avg": 237.27939895162234,
                    "smoothness_avg": 0.10493766217498746,
                    "success_improvement": 0.0,
                    "time_improvement": 59.52050975376072,
                    "length_improvement": 20.78930692113313,
                    "smoothness_improvement": 2600.121631305382,
                    "objective_score": 43.330345235335
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04352459907531738,
                    "num_nodes_avg": 269.4,
                    "path_length_avg": 122.76500515688167,
                    "smoothness_avg": 0.10988670179234934,
                    "success_improvement": 0.0,
                    "time_improvement": 10.421162650336374,
                    "length_improvement": 18.465329016144725,
                    "smoothness_improvement": 1297.750735806072,
                    "objective_score": 20.694299883818104
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified unidirectional RRT* variant with goal bias and fixed-radius rewiring that prioritizes early successful path discovery and incremental local path cost improvements while maintaining bounded computational effort. It samples mostly uniformly but occasionally samples the goal to speed convergence, extends towards samples by fixed step size clipped to map bounds, connects new nodes to lowest-cost neighbor within radius after collision checks, rewires neighbors to new node if beneficial, and terminates immediately upon first reaching goal vicinity collision-free. Path extraction traces back through parents from goal to start.",
          "planning_mechanism": "A single tree is grown from start by sampling mostly uniform points with some probability sampling the goal directly. Each iteration extends towards the sample obeying a maximum step size and checks node and edge collisions. The planner selects a minimum cost parent node within a fixed radius and adds the new node, then rewires neighbor nodes to improve costs. If a new node can connect to the goal collision-free within step distance, the path is extracted and returned immediately. This approach reduces runtime via goal bias, efficient rewiring, and early stopping while preserving path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.05, rewiring_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewiring_radius = rewiring_radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        nodes = []\n        edges = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        success = False\n        goal_node = None\n\n        for _ in range(self.max_iter):\n            if time.monotonic() - start_time > 30:\n                break\n\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest.position, sample)\n            if dist_to_sample == 0:\n                continue\n            scale = min(self.step_size, dist_to_sample) / dist_to_sample\n            new_pos = tuple(nearest.position[d] + direction[d]*scale for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Find neighbors to consider for rewiring within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.rewiring_radius]\n\n            # Select parent minimizing cost + dist with collision-free edge\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + math.dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if passing through new_node improves cost collision-free\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nb))\n\n            # If new node is close enough to goal and path is collision-free, finish early\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success = True\n                        break\n\n        path = []\n        if success and goal_node:\n            node = goal_node\n            while node is not None:\n                path.append(node.position)\n                node = node.parent\n            path.reverse()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.90364,
          "time_improvement": -8.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025247907638549803,
                    "num_nodes_avg": 233.8,
                    "path_length_avg": 170.12946546952813,
                    "smoothness_avg": 0.014816791053862539,
                    "success_improvement": 0.0,
                    "time_improvement": -0.4787803341404643,
                    "length_improvement": 6.749344102254376,
                    "smoothness_improvement": 131.91495516970375,
                    "objective_score": 4.565547136959005
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12624733448028563,
                    "num_nodes_avg": 859.5,
                    "path_length_avg": 236.88602288914717,
                    "smoothness_avg": 0.011656507882273733,
                    "success_improvement": 0.0,
                    "time_improvement": 21.453156004545612,
                    "length_improvement": 20.920627173489493,
                    "smoothness_improvement": 199.93034365416824,
                    "objective_score": 19.98797482372822
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07023768424987793,
                    "num_nodes_avg": 492.5,
                    "path_length_avg": 121.35915641758058,
                    "smoothness_avg": 0.02178086692654423,
                    "success_improvement": 0.0,
                    "time_improvement": -44.55756576526181,
                    "length_improvement": 19.399026809465404,
                    "smoothness_improvement": 177.0510196092805,
                    "objective_score": -0.842598545852899
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A unidirectional Adaptive Radius RRT* planner enhanced with dynamic step sizing and batch rewiring, combined with an incremental path shortcutting smoothing that adapts shortcut frequency depending on improvements and remaining time, improving efficiency, path length, and smoothness within a 30-second limit.",
          "planning_mechanism": "The planner grows a tree from start toward goal by sampling mostly uniform points with goal bias and a dynamic step size inversely proportional to local density. It connects each new node by selecting minimum cost parents within an adaptive radius that shrinks as the tree grows to reduce computational overhead. Batch rewiring is performed every fixed number of iterations to re-optimize local neighborhoods efficiently. An incremental path shortcutting smoothing runs repeatedly after path updates but adapts shortcut attempts to the time left and current improvement, terminating early if no meaningful shortcutting progress occurs. This combined strategy yields efficient path finding with shorter, smoother paths and faster convergence under the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For future collision state if needed\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not new_parent:\n            if self.parent is not None:\n                self.parent.remove_child(self)\n            self.parent = new_parent\n            self.cost = new_cost\n            if new_parent is not None and self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.1, rewire_batch_size: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_batch_size = rewire_batch_size\n        self.time_limit = 30.0\n        self.improve_tol = 1e-10\n        self.max_neighbor_radius = 25.0  # Max cap on neighbor radius\n\n    def plan(self, map) -> PlannerResult:\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=None):\n            dist_ab = math.dist(a, b)\n            res = resolution\n            if res is None:\n                res = min(1.0, self.step_size * 0.4)\n            steps = max(1, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = math.dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n\n        def nearest_node(pt):\n            best = nodes[0]\n            best_dist = math.dist(best.position, pt)\n            for node in nodes[1:]:\n                d = math.dist(node.position, pt)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def compute_neighbor_radius(num_nodes):\n            # Adaptive radius shrinking as n grows: r = min(maxr, gamma*(log(n)/n)^(1/dim))\n            if num_nodes < 2:\n                return self.max_neighbor_radius\n            gamma = 50.0  # Tunable constant\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            r = min(r, self.max_neighbor_radius)\n            r = max(r, self.step_size * 1.5)  # Ensure not too small\n            return r\n\n        def near_nodes(pt, radius):\n            return [node for node in nodes if math.dist(node.position, pt) <= radius]\n\n        def choose_parent(new_pos, near_n):\n            min_cost = float('inf')\n            best_parent = None\n            for nbr in near_n:\n                cost_cand = nbr.cost + math.dist(nbr.position, new_pos)\n                if cost_cand < min_cost and not is_edge_in_obstacle(nbr.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = nbr\n            return best_parent, min_cost if best_parent is not None else (None, None)\n\n        def add_node(new_pos):\n            radius = compute_neighbor_radius(len(nodes) + 1)\n            near_n = near_nodes(new_pos, radius)\n            parent, cost = choose_parent(new_pos, near_n)\n            if parent is None:\n                # fallback to nearest if no collision free parents in radius\n                nearest = nearest_node(new_pos)\n                if not is_edge_in_obstacle(nearest.position, new_pos):\n                    parent = nearest\n                    cost = nearest.cost + math.dist(nearest.position, new_pos)\n                else:\n                    return None\n            new_node = Node(new_pos, parent, cost)\n            parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, near_n\n\n        def batch_rewire(new_node, near_n):\n            for nbr in near_n:\n                if nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new + self.improve_tol < nbr.cost:\n                    if not is_edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, nbr))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            i = 0\n            changed = False\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_found = False\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        shortcut_found = True\n                        j = len(path) - 1\n                    else:\n                        j -= 1\n                i += 1 if not shortcut_found else 0\n            return path, changed\n\n        # Initialize with start node\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n        edges = []\n        best_goal_node = None\n        best_cost = float('inf')\n\n        # Minimum step size and max step size for dynamic adjustment\n        min_step = self.step_size * 0.5\n        max_step = self.step_size * 1.2\n\n        # Helper to estimate local node density for adaptive step sizing\n        def local_density(pos):\n            radius = compute_neighbor_radius(len(nodes))\n            neighbors = near_nodes(pos, radius)\n            return len(neighbors) / (radius ** dim)\n\n        def dynamic_step(nearest):\n            # Smaller step in dense areas to enable finer expansions, larger step in sparse area\n            density = local_density(nearest.position)\n            # Inverse relation: higher density smaller steps but clipped\n            step = max(min_step, min(max_step, max_step / (1 + density)))\n            return step\n\n        iteration_since_last_rewire = 0\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            sample = sample_point()\n            nearest = nearest_node(sample)\n            step = dynamic_step(nearest)\n            new_pos = steer(nearest.position, sample, step)\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            result = add_node(new_pos)\n            if result is None:\n                continue\n            new_node, near_n = result\n\n            if math.dist(new_node.position, goal_pos) <= step and not is_edge_in_obstacle(new_node.position, goal_pos):\n                if not is_in_obstacle(goal_pos):\n                    goal_node = Node(goal_pos, new_node, new_node.cost + math.dist(new_node.position, goal_pos))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_goal_node = goal_node\n                        best_cost = goal_node.cost\n\n            iteration_since_last_rewire += 1\n            if iteration_since_last_rewire >= self.rewire_batch_size:\n                batch_rewire(new_node, near_n)\n                iteration_since_last_rewire = 0\n\n            # Early stop if goal reached\n            if best_goal_node is not None:\n                # Optional: break here for early solution; or continue to improve until time runs out\n                break\n\n        success = best_goal_node is not None\n        extracted_path = []\n        if success:\n            # Extract path\n            node = best_goal_node\n            while node is not None:\n                extracted_path.append(node.position)\n                node = node.parent\n            extracted_path.reverse()\n\n            # Incremental shortcutting smoothing: adapt attempts and early terminate if no improvement or time near\n            shortcut_iterations = 0\n            max_shortcut_iterations = 30\n            last_changed = True\n            while shortcut_iterations < max_shortcut_iterations and last_changed and (time.monotonic() - start_time) < self.time_limit - 0.1:\n                extracted_path, last_changed = shortcut_path(extracted_path)\n                shortcut_iterations += 1\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -7.75918,
          "time_improvement": -34.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1743.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03669331073760986,
                    "num_nodes_avg": 241.1,
                    "path_length_avg": 167.53823491682016,
                    "smoothness_avg": 0.05736578232374133,
                    "success_improvement": 0.0,
                    "time_improvement": -46.027907029702206,
                    "length_improvement": 8.169638628869315,
                    "smoothness_improvement": 797.8990651567084,
                    "objective_score": -4.9170936058055315
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11225483417510987,
                    "num_nodes_avg": 743.0,
                    "path_length_avg": 239.05308733539022,
                    "smoothness_avg": 0.12199082539274042,
                    "success_improvement": 0.0,
                    "time_improvement": 30.158818924887232,
                    "length_improvement": 20.197198685841983,
                    "smoothness_improvement": 3038.9118037951534,
                    "objective_score": 36.360523907947126
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09030163288116455,
                    "num_nodes_avg": 535.4,
                    "path_length_avg": 123.90221873096671,
                    "smoothness_avg": 0.11735227711298638,
                    "success_improvement": 0.0,
                    "time_improvement": -85.85157488235612,
                    "length_improvement": 17.710045908528613,
                    "smoothness_improvement": 1392.7123028331262,
                    "objective_score": -8.165883405424035
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An improved RRT* variant with adaptive rewiring radius scaled to node density and informed sampling within an ellipsoidal heuristic to focus exploration near start-goal regions, combined with pruning of suboptimal branches and incremental best-path tracking. Early termination occurs upon reaching goal, ensuring faster convergence. This approach reduces redundant collision checks and limits neighbor searches by adaptive radius heuristic, improving planning speed while enhancing path length and smoothness through informed rewiring and bounded sampling.",
          "planning_mechanism": "A single-tree planner grows incrementally from the start node toward the goal using informed sampling constrained in an ellipse covering feasible nodes, adaptively adjusting rewiring neighbor radius based on the current node density to reduce computational overhead. Each new node is connected through optimal parent selection minimizing cost subject to collision constraints. Local rewiring improves path quality incrementally. The algorithm prunes nodes that are too costly or isolated periodically to streamline the search and uses early termination once the goal is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent is not None:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.1, min_radius=8.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.min_radius = min_radius   # Minimum rewiring radius\n        self.max_radius = max_radius   # Maximum rewiring radius\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            d = dist(from_pos, to_pos)\n            if d <= max_dist:\n                return to_pos\n            ratio = max_dist / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_point_in_ellipse(p, f1, f2, max_dist):\n            # Check if p is inside ellipse defined by foci f1, f2 and major axis max_dist\n            # sum of distances from p to foci <= max_dist\n            return dist(p, f1) + dist(p, f2) <= max_dist + 1e-8\n\n        def heuristic_radius(n_nodes):\n            # Adaptive rewiring radius based on number of nodes and dimension,\n            # from RRT* theory: r = min(max_radius, gamma * (log(n)/n)^(1/d))\n            # gamma chosen to ensure connectivity, here gamma tuned empirically\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma_rrt = 35.0\n            radius = gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def extract_path(end_node):\n            path = []\n            current = end_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_goal_cost = float('inf')\n        success = False\n\n        max_dist_start_goal = dist(start_pos, goal_pos)\n        # initialize informed sampling ellipse parameters:\n        c_min = max_dist_start_goal\n        # heuristic cost to beat is infinite initially; update upon feasible path\n\n        def sample_informed():\n            # If no solution found, sample uniformly in map\n            if best_goal_node is None:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Sample uniformly in an ellipsoid (informed sampling)\n                # Ellipse defined with foci = start and goal, and major axis = cost of best solution\n                c_best = best_goal_cost\n                if c_best < float('inf'):\n                    # Generate random point in unit ball\n                    while True:\n                        sample_ball = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in sample_ball))\n                        if norm > 1e-8:\n                            sample_ball = [x / norm for x in sample_ball]\n                            break\n                    radius = random.uniform(0, 1) ** (1.0 / dim)\n                    sample_ball = [x * radius for x in sample_ball]\n\n                    # Compute ellipse transform parameters\n                    # Rotation or aligning ellipse along start-goal vector\n                    # Construct transform matrix that scales unit ball to ellipse\n                    # Length of major axis a = c_best / 2\n                    # Minor axes radii b = sqrt(c_best^2 - c_min^2) / 2\n\n                    a = c_best / 2.0\n                    if c_best**2 - c_min**2 > 0:\n                        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                    else:\n                        b = 0.0  # Degenerate ellipse: almost line\n\n                    # Rotate sample_ball aligned with start->goal vector\n                    # Create unit vector for start->goal\n                    unit_vec = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n                    # Orthogonal basis: for dim>1, just 1D alignment, rest arbitrary axes (identity)\n                    # For simplicity, align first dimension to start->goal, scale others by b/a\n\n                    if dim == 1:\n                        # 1D case, scale by a along line (unit_vec=1 or -1)\n                        new_sample = [start_pos[0] + sample_ball[0] * a * unit_vec[0]]\n                    else:\n                        # Build sample point in aligned coords\n                        new_sample = [0.0] * dim\n                        new_sample[0] = sample_ball[0] * a\n                        for i in range(1, dim):\n                            new_sample[i] = sample_ball[i] * b\n                        # Rotate back to world frame: since only aligned with unit_vec on axis0,\n                        # approximate by placing first dim component along unit_vec, others arbitrary orthogonal\n                        # Find perpendicular basis by Gram-Schmidt (approx)\n                        # We only do a simple linear transform ignoring rotation for complexity,\n                        # Instead, we map sample: sample_world = start + unit_vec * new_sample[0] + perpendicular components\n                        base_point = list(start_pos)\n                        # Decompose new_sample into unit_vec axis and orthogonal components\n                        # For simplicity, distribute orthogonal components equally among remaining dims\n\n                        sample_world = [base_point[i] + unit_vec[i] * new_sample[0] for i in range(dim)]\n                        # Orthogonal part: we add equally distributed parts scaled by new_sample[i]\n                        # Construct orthogonal vectors to unit_vec by simple Gram-Schmidt approach\n                        # For dims>1, find orthogonal vectors:\n                        ortho_vectors = []\n                        def normalize(vec):\n                            nrm = math.sqrt(sum(x*x for x in vec))\n                            if nrm < 1e-10:\n                                return [0.0]*len(vec)\n                            return [x/nrm for x in vec]\n                        # Start with identity basis\n                        identity = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            identity[i][i] = 1\n                        for i in range(dim):\n                            proj = sum(identity[i][j]*unit_vec[j] for j in range(dim))\n                            ortho = [identity[i][j]-proj*unit_vec[j] for j in range(dim)]\n                            ortho = normalize(ortho)\n                            ortho_vectors.append(ortho)\n                        # Add scaled orthogonal components\n                        for i in range(1, dim):\n                            for j in range(dim):\n                                sample_world[j] += ortho_vectors[i][j]*new_sample[i]\n                        return tuple(max(0.0, min(sample_world[i], bounds[i])) for i in range(dim))\n                    return tuple(new_sample)\n                else:\n                    # fallback: uniform sampling\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def node_density():\n            # Approximate node density as number of nodes / total volume\n            # Volume = product of bounds dimensions\n            volume = 1.0\n            for v in bounds:\n                volume *= v\n            return len(nodes) / max(1e-10, volume)\n\n        def prune_nodes():\n            # Periodically prune nodes that have cost worse than best_goal_cost + margin or disconnected\n            # Also prune isolated nodes without children nor parent (except root)\n            margin = 15.0\n            to_remove = []\n            for node in nodes:\n                if node is root:\n                    continue\n                if best_goal_cost < float('inf'):\n                    if node.cost > best_goal_cost + margin:\n                        to_remove.append(node)\n                        continue\n                if (node.parent is None) and (len(node.children) == 0):\n                    # isolated\n                    to_remove.append(node)\n            for node in to_remove:\n                # remove from nodes list and edges\n                nodes.remove(node)\n                if node.parent is not None:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                # Remove edges referencing this node\n                edges[:] = [(p, c) for p, c in edges if p != node and c != node]\n\n        iter_chunk = 100  # prune and update radius every chunk\n\n        for iter_idx in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_informed()\n\n            # Nearest node to sample\n            if not nodes:\n                break\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if any(new_pos[i] < 0.0 or new_pos[i] > bounds[i] for i in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighbor radius for rewiring\n            r = heuristic_radius(len(nodes))\n\n            # Find neighbors within radius r\n            near_nodes = [n for n in nodes if dist(n.position, new_pos) <= r]\n\n            # Choose best parent minimizing cost + dist and collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in near_nodes:\n                tentative_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if improves cost and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, alt_cost)\n                        edges.append((new_node, neighbor))\n\n            # Check if new node can connect to goal directly\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_pos, obstacles, is_3d)):\n                    goal_node = Node(goal_pos)\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        best_goal_node = goal_node\n                        best_goal_cost = goal_cost\n                        success = True\n\n                        # Early break on finding better path\n                        break\n\n            # Periodic pruning and radius update\n            if (iter_idx > 0) and (iter_idx % iter_chunk == 0) and (success):\n                prune_nodes()\n\n        # Extract path if success\n        if best_goal_node is not None and success:\n            extracted_path = extract_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.73775,
          "time_improvement": -3.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 143.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031192827224731445,
                    "num_nodes_avg": 228.2,
                    "path_length_avg": 173.47041072322037,
                    "smoothness_avg": 0.016212433782287948,
                    "success_improvement": 0.0,
                    "time_improvement": -24.137702006209146,
                    "length_improvement": 4.918119068040286,
                    "smoothness_improvement": 153.759794556254,
                    "objective_score": -3.521640188257302
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.1286400556564331,
                    "num_nodes_avg": 775.0,
                    "path_length_avg": 247.3898406969005,
                    "smoothness_avg": 0.00894525060365523,
                    "success_improvement": 0.0,
                    "time_improvement": 19.964485390459707,
                    "length_improvement": 17.414150453629286,
                    "smoothness_improvement": 130.16774103563074,
                    "objective_score": 17.088674594493636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050321340560913086,
                    "num_nodes_avg": 417.3,
                    "path_length_avg": 125.51343547763591,
                    "smoothness_avg": 0.01937830391026074,
                    "success_improvement": 0.0,
                    "time_improvement": -3.567345296452773,
                    "length_improvement": 16.639952463287656,
                    "smoothness_improvement": 146.4905953809094,
                    "objective_score": 9.64622086594131
               }
          ],
          "success_rate": 1.0
     }
]