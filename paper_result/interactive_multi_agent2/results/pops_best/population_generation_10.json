{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* planner with fixed step extension, goal bias sampling, adaptive neighbor radius rewiring, and shortcut path smoothing within a 30-second time limit to efficiently find collision-free paths with reduced length and improved smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal points alternately. Each iteration samples a state biased toward the goal, extends the nearest tree toward the sample by a fixed step if collision-free, and rewires nearby nodes using an adaptive radius to optimize cost. The planner attempts to greedily connect the two trees each iteration and finishes early on success or time expiration. After planning, a shortcutting post-processing step removes unnecessary waypoints to smooth and shorten the path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        start_time = time.monotonic()\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                s = self.step_size / d\n                new_p = tuple(from_p[i] + s * (to_p[i] - from_p[i]) for i in range(dim))\n            return tuple(max(0, min(new_p[i], bounds[i])) for i in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n):\n            if n < 2:\n                return self.step_size * 5.0\n            gamma = 50.0\n            return min(gamma * (math.log(n) / n) ** (1/dim), self.step_size * 10)\n\n        def near(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (nodes_start, nodes_goal) if i % 2 == 0 else (nodes_goal, nodes_start)\n            q_rand = sample()\n            nearest = min(tree_a, key=lambda n: dist(n.position, q_rand))\n            new_pos = steer(nearest.position, q_rand)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = adaptive_radius(len(all_nodes))\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            parent = nearest\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_nb\n                        parent = nb\n            new_node = Node(new_pos)\n            new_node.update_parent(parent, min_cost)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((parent, new_node))\n\n            for nb in neighbors:\n                if nb is parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node, c_new)\n                        edges.append((new_node, nb))\n\n            nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            curr = nearest_other\n            connected = False\n            while True:\n                new_to_pos = steer(curr.position, new_node.position)\n                if self._is_in_obstacle(new_to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr.position, new_to_pos, obstacles, is_3d):\n                    break\n                new_to_node = Node(new_to_pos)\n                new_to_node.update_parent(curr, curr.cost + dist(curr.position, new_to_pos))\n                tree_b.append(new_to_node)\n                all_nodes.append(new_to_node)\n                edges.append((curr, new_to_node))\n                if dist(new_to_pos, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_to_pos, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position)\n                        final_node.update_parent(new_to_node, new_to_node.cost + dist(new_to_node.position, new_node.position))\n                        tree_b.append(final_node)\n                        all_nodes.append(final_node)\n                        edges.append((new_to_node, final_node))\n                        total_cost = final_node.cost + new_node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            if tree_a is nodes_start:\n                                best_start_node = new_node\n                                best_goal_node = final_node\n                            else:\n                                best_start_node = final_node\n                                best_goal_node = new_node\n                            success = True\n                        connected = True\n                    break\n                curr = new_to_node\n            if connected:\n                break\n\n        if success and best_start_node and best_goal_node:\n            path_start = best_start_node.path_from_root()\n            path_goal = best_goal_node.path_from_root()\n            path = path_start + path_goal[-2::-1]\n            extracted_path = self._shortcut_path(path, obstacles, is_3d, bounds)\n        else:\n            closest = min(nodes_start, key=lambda n: dist(n.position, goal_pos), default=None)\n            extracted_path = closest.path_from_root() if closest else [start_pos]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortcut = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut.append(path[j])\n            i = j\n        return shortcut\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_ab = math.dist(a, b)\n        steps = max(1, int(dist_ab / resolution))\n        for i in range(steps + 1):\n            interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(len(a)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -39.02046,
     "time_improvement": 67.0,
     "length_improvement": 18.0,
     "smoothness_improvement": 1673.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.011158227920532227,
               "num_nodes_avg": 90.1,
               "path_length_avg": 163.77008971239428,
               "smoothness_avg": 0.05022285267966682,
               "success_improvement": 0.0,
               "time_improvement": 55.59374074889366,
               "length_improvement": 10.235018725496927,
               "smoothness_improvement": 686.0967051069562,
               "objective_score": 26.249616985501035
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.019709515571594238,
               "num_nodes_avg": 259.0,
               "path_length_avg": 231.03195017180343,
               "smoothness_avg": 0.1046731272784061,
               "success_improvement": 0.0,
               "time_improvement": 87.73740252654807,
               "length_improvement": 22.874885146679258,
               "smoothness_improvement": 2593.314957879559,
               "objective_score": 53.01272663536977
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.02050490379333496,
               "num_nodes_avg": 244.2,
               "path_length_avg": 121.04037650344381,
               "smoothness_avg": 0.14454576908273487,
               "success_improvement": 0.0,
               "time_improvement": 57.79845235116024,
               "length_improvement": 19.61074524976676,
               "smoothness_improvement": 1738.6115134735423,
               "objective_score": 37.79904042257584
          }
     ],
     "success_rate": 1.0
}