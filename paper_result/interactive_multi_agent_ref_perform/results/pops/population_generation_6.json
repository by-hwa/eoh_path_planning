[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.95507,
          "time_improvement": 61.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1487.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010840678215026855,
                    "num_nodes_avg": 108.5,
                    "path_length_avg": 171.66948645779462,
                    "smoothness_avg": 0.03037023005591788,
                    "success_improvement": 0.0,
                    "time_improvement": 57.96689607994491,
                    "node_improvement": 72.67690757995467,
                    "length_improvement": 5.905234195391321,
                    "smoothness_improvement": 375.36005038524775,
                    "objective_score": 22.810009593144503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03051626682281494,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 234.6106758602652,
                    "smoothness_avg": 0.10438344350479727,
                    "success_improvement": 0.0,
                    "time_improvement": 81.56959762974842,
                    "node_improvement": 77.84048914869314,
                    "length_improvement": 21.68020350396321,
                    "smoothness_improvement": 2585.8611857338155,
                    "objective_score": 50.40830731997153
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029309940338134766,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 129.2870965574641,
                    "smoothness_avg": 0.12568844803562226,
                    "success_improvement": 0.0,
                    "time_improvement": 42.24321361941394,
                    "node_improvement": 60.47043865225684,
                    "length_improvement": 14.133666456496211,
                    "smoothness_improvement": 1498.7477816569226,
                    "objective_score": 28.64690286800652
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood scaling, combined probabilistic goal and ellipsoidal informed sampling, enhanced rewiring, and aggressive progressive shortcutting to improve planning efficiency, path smoothness, and length. The planner alternates expansions from start and goal trees, dynamically adapts rewiring radius based on node density, and balances exploration with exploitation by mixing goal bias with ellipsoidal sampling. It uses efficient nearest neighbor queries, performs rewiring immediately after node addition, and aggressively shortcuts paths every iteration after improvements, yielding faster convergence to high-quality, smooth paths.",
          "planning_mechanism": "The planner maintains two trees from start and goal, alternately extending them toward samples drawn probabilistically either from the goal (goal bias) or ellipsoidal informed region based on current best path cost. For each new node, it selects the best parent and rewires neighbors within an adaptive radius to minimize cost. Upon path improvements, it aggressively applies progressive shortcutting with more attempts to significantly smooth and shorten the path. The adaptive rewiring radius shrinks as the tree grows, balancing local optimization and global exploration for efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.10,\n                 shortcut_attempts=80):\n        # max_iter: max iterations for planning\n        # step_size: maximum extension length per step\n        # gamma: rewiring radius scaling factor\n        # goal_sample_rate: probability of sampling directly at goal to bias search\n        # shortcut_attempts: max shortcut tries per path smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            rad = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(rad, self.step_size * 40.0)\n\n        def sample():\n            # Combined goal bias and ellipsoidal informed sampling\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No solution yet, uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return self._sample_free(bounds, obstacles, is_3d)\n            # After first solution, use mixture of goal bias and ellipsoidal informed sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return self._sample_ellipsoidal_informed(bounds, obstacles, is_3d,\n                                                         best_cost, c_min,\n                                                         start_pos, goal_pos, dim)\n\n        def extend_and_rewire(tree_from, tree_to, sample):\n            nearest = self._nearest(tree_from, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            r = adaptive_radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, r)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-free edges\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if it's cost efficient and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to the other tree\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n\n            return None\n\n        def aggressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    # Reset attempts on success to allow more smoothing\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            smp = sample()\n\n            # Alternate tree expansions to balance growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = extend_and_rewire(tree_a, tree_b, smp)\n                if res is not None:\n                    new_node, connect_node, total_cost = res\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start = new_node\n                            solution_goal = connect_node\n                        else:\n                            solution_start = connect_node\n                            solution_goal = new_node\n\n                        raw_path = self._extract_path(solution_start, solution_goal)\n                        smoothed_path = aggressive_shortcut(raw_path)\n                        if smoothed_path and len(smoothed_path) >= 2:\n                            # Return improved solution immediately on improvement for speed\n                            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_ellipsoidal_informed(self, bounds, obstacles, is_3d, best_cost, c_min,\n                                    start_pos, goal_pos, dim):\n        import random\n        import math\n\n        center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n        direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n        length = math.dist(start_pos, goal_pos)\n\n        if dim == 2:\n            if length < 1e-12:\n                R = [[1, 0],\n                     [0, 1]]\n            else:\n                a1 = [1, 0]\n                a2 = [direction[0] / length, direction[1] / length]\n                cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_t, -sin_t],\n                     [sin_t, cos_t]]\n        else:\n            from math import sqrt\n            if length < 1e-12:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                a1 = [1,0,0]\n                a2 = [d/length for d in direction]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        a1_val = best_cost * 0.5\n        a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0)) * 0.5\n\n        while True:\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0],\n                     [0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (\n                    center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                    center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1]\n                )\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val, 0, 0],\n                     [0, a_other, 0],\n                     [0, 0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0/3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim/2)) / gamma(dim/2 + 1)",
          "objective": -32.52068,
          "time_improvement": 47.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1734.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020076465606689454,
                    "num_nodes_avg": 116.8,
                    "path_length_avg": 162.49456117438694,
                    "smoothness_avg": 0.04179993549748345,
                    "success_improvement": 0.0,
                    "time_improvement": 22.15651562983882,
                    "node_improvement": 70.58675396625536,
                    "length_improvement": 10.93415612922186,
                    "smoothness_improvement": 554.2597605483732,
                    "objective_score": 15.978747169226628
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034181642532348636,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 238.180902638735,
                    "smoothness_avg": 0.12075947586833821,
                    "success_improvement": 0.0,
                    "time_improvement": 79.35588159570369,
                    "node_improvement": 81.99287778001747,
                    "length_improvement": 20.48835904203003,
                    "smoothness_improvement": 3007.2282936270713,
                    "objective_score": 51.13592137206448
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03004302978515625,
                    "num_nodes_avg": 247.2,
                    "path_length_avg": 125.47417143071527,
                    "smoothness_avg": 0.1369214674928818,
                    "success_improvement": 0.0,
                    "time_improvement": 40.798622122433216,
                    "node_improvement": 68.56961220597584,
                    "length_improvement": 16.666029773699346,
                    "smoothness_improvement": 1641.6309600180152,
                    "objective_score": 30.447359301039647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive radius rewiring, informed sampling after first solution, frequent incremental shortcutting to improve path smoothness and length, early termination on solution stagnation, and efficient collision checks. It alternates growing start and goal trees, connects and rewires nodes within adaptive radius based on node count, and progressively shortcuts the best path during planning for better convergence in less time.",
          "planning_mechanism": "The Planner grows two trees from start and goal, samples points uniformly or within an ellipsoidal informed subset after a solution is found, extends and rewires nodes within an adaptive radius logarithmically decreasing with node count, attempts connections between trees to form a solution, and applies incremental shortcutting after solution improvements and periodically to smooth and shorten paths, terminating early if no improvements occur for a defined interval.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=20, max_shortcut_attempts=40, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            if dim == 2:\n                cos_theta = dir_vec[0]/length\n                sin_theta = dir_vec[1]/length\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1*x_ball[0], a2*x_ball[1]]\n                    pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                          center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                # 3D sampling inside prolate hyperspheroid\n                from math import sqrt\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq==0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    # Rotation matrix mapping x-axis to dir_vec unit vector\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i]-from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size*8.0\n            return min(self.step_size*30, self.gamma_rrt_star*(math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        last_improve_iter = 0\n        no_improve_limit = 100\n\n        for iter in range(self.max_iter):\n            if best_cost < float('inf') and random.random() < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = iter\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        path = extract_path(solution_start, solution_goal)\n                        for _ in range(2):\n                            path = shortcut_path(path)\n                        # Replace last path with shortcut improved\n                        if len(path) < len(extract_path(solution_start, solution_goal)):\n                            # best path shortened\n                            continue\n\n            if best_cost < float('inf') and (iter - last_improve_iter) > no_improve_limit:\n                break\n\n            if best_cost < float('inf') and iter % self.shortcut_interval == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -32.21382,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1551.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02305736541748047,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 168.73944907303084,
                    "smoothness_avg": 0.04309848636832513,
                    "success_improvement": 0.0,
                    "time_improvement": 10.598523681644005,
                    "node_improvement": 71.74515235457064,
                    "length_improvement": 7.511234115393865,
                    "smoothness_improvement": 574.5849015253947,
                    "objective_score": 10.559222081356495
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02576143741607666,
                    "num_nodes_avg": 208.1,
                    "path_length_avg": 237.2903072590682,
                    "smoothness_avg": 0.1076212802971938,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44129290220465,
                    "node_improvement": 86.01760397769269,
                    "length_improvement": 20.785665414129483,
                    "smoothness_improvement": 2669.1730585217547,
                    "objective_score": 51.149652411747866
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018548035621643068,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 128.3642742559325,
                    "smoothness_avg": 0.11870521723960548,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45011559832764,
                    "node_improvement": 76.78321678321677,
                    "length_improvement": 14.746561089097684,
                    "smoothness_improvement": 1409.9216013800688,
                    "objective_score": 34.93257933985725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional Anytime Informed RRT* planner integrating adaptive density-based rewiring radius, ellipsoidal informed sampling, incremental path shortcutting, and optimized data structures for enhanced planning efficiency, robustness, and path quality. It grows trees from start and goal, alternates expansions, samples within shrinking ellipsoidal informed sets, dynamically adapts rewiring radius based on node density, rewires neighbors to improve cost locally, attempts early tree connection to reduce search time, and frequently applies a focused incremental shortcutting method to continuously smooth and shorten the path while maintaining collision safety.",
          "planning_mechanism": "The algorithm alternates expansions between two bidirectional trees and samples points concentrated in an ellipsoidal informed region defined by the current best solution cost. It incorporates a density-adaptive rewiring radius for efficient pruning and rewiring, performs collision-checked parent selection and neighbor rewiring, connects trees when nodes are reachable, and incrementally shortcuts the current best path at frequent intervals to improve smoothness and length without excessive computation. This continuous interplay of sampling, rewiring, connection, and shortcutting rapidly converges towards an optimal, smooth path with reduced runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0, shortcut_freq=25, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def unit_ball_vol(d):\n            if d == 2:\n                return math.pi\n            if d == 3:\n                return 4.0/3.0*math.pi\n            from math import gamma, pi\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [direction[0]/length, direction[1]/length]\n                    cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [direction[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball)<=1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            dist_sq = 0.0\n            diff_vec = []\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                diff_vec.append(diff)\n                dist_sq += diff*diff\n            dist = dist_sq**0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            new_pos = tuple(from_pos[i] + diff_vec[i]*ratio for i in range(dim))\n            return new_pos\n\n        def is_edge_collision_free(p1, p2):\n            # Collision check in intervals of max 1.0 units for efficiency\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / 1.0))\n            for step_i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(step_i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not is_edge_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                tentative = n.cost + math.dist(n.position, new_pos)\n                if tentative < min_cost:\n                    if is_edge_collision_free(n.position, new_pos):\n                        min_cost = tentative\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent if beneficial\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if is_edge_collision_free(new_node.position, n.position):\n                        if n.parent is not None:\n                            try: edges.remove((n.parent, n))\n                            except ValueError: pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect to nearest node in other tree within step_size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_edge_collision_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            shortcut_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) <3:\n                    break\n                i = random.randint(0,len(shortcut_path)-3)\n                j = random.randint(i+2,len(shortcut_path)-1)\n                if is_edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False",
          "objective": -32.21323,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01826310157775879,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 166.80041346603122,
                    "smoothness_avg": 0.03850615988076263,
                    "success_improvement": 0.0,
                    "time_improvement": 29.187562688064194,
                    "node_improvement": 67.01082850667338,
                    "length_improvement": 8.574050257575799,
                    "smoothness_improvement": 502.7050195984601,
                    "objective_score": 16.414224058957036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02589578628540039,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 234.42132183759287,
                    "smoothness_avg": 0.0955636258647175,
                    "success_improvement": 0.0,
                    "time_improvement": 84.36015244901614,
                    "node_improvement": 83.86749983202311,
                    "length_improvement": 21.743415326984575,
                    "smoothness_improvement": 2358.9209251966936,
                    "objective_score": 50.14869955687905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028525924682617186,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 126.10181619096082,
                    "smoothness_avg": 0.1209255471006773,
                    "success_improvement": 0.0,
                    "time_improvement": 43.78815790153682,
                    "node_improvement": 70.10807374443738,
                    "length_improvement": 16.24917800917602,
                    "smoothness_improvement": 1438.1640333251999,
                    "objective_score": 30.07677434259266
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* variant with adaptive rewiring, efficient ellipsoidal sampling focused on the current best path cost, continuous rewiring with cost propagation, and frequent incremental shortcutting to ensure efficient convergence to high-quality, smooth, and short paths. Sampling is restricted within an ellipsoid based on the best solution cost, rewiring radius adapts to node density, and shortcutting continuously improves smoothness and path length during planning.",
          "planning_mechanism": "The planner grows bidirectional trees from start and goal, alternately sampling points focused on an informed ellipsoid region to guide exploration toward promising areas. On each extension, it rewires neighbors dynamically adapting the radius based on sampling density, propagates cost improvements efficiently, and frequently performs incremental shortcutting to refine the best path, thereby ensuring fast convergence, robustness, and high-quality smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=30.0, shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_nodes = [Node(start_pos, None, 0.0)]\n        goal_nodes = [Node(goal_pos, None, 0.0)]\n        nodes = start_nodes + goal_nodes\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[: i + 1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = math.sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [\n                            [0, -v[2], v[1]],\n                            [v[2], 0, -v[0]],\n                            [-v[1], v[0], 0],\n                        ]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [\n                            [\n                                sum(vx[i][k] * vx[k][j] for k in range(3))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n                        R = [\n                            [\n                                I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                        L[1][0] * x_ball[0] + L[1][1] * x_ball[1],\n                    ]\n                    pt = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0],\n                        L[1][1] * x_ball[1],\n                        L[2][2] * x_ball[2],\n                    ]\n                    pt = tuple(\n                        center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim))\n                        for i in range(dim)\n                    )\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-10 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-10 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if (\n                dist_connect <= self.step_size\n                and not is_edge_in_obstacle(new_node.position, nearest_other.position)\n            ):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            # Alternate tree roles to maintain bidirectionality\n            for (tree_a, tree_b) in [(start_nodes, goal_nodes), (goal_nodes, start_nodes)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (\n                            (new_node, connect_node)\n                            if tree_a is start_nodes\n                            else (connect_node, new_node)\n                        )\n\n            if best_cost < float(\"inf\") and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.90769,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1713.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018351244926452636,
                    "num_nodes_avg": 106.7,
                    "path_length_avg": 166.32115349423978,
                    "smoothness_avg": 0.045429712971989604,
                    "success_improvement": 0.0,
                    "time_improvement": 28.845800073030155,
                    "node_improvement": 73.13019390581718,
                    "length_improvement": 8.836740242474923,
                    "smoothness_improvement": 611.0736602123392,
                    "objective_score": 17.0111524684557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053799915313720706,
                    "num_nodes_avg": 275.9,
                    "path_length_avg": 244.29920467196445,
                    "smoothness_avg": 0.11771383242798397,
                    "success_improvement": 0.0,
                    "time_improvement": 67.50735951830073,
                    "node_improvement": 81.46207081905531,
                    "length_improvement": 18.445893717778457,
                    "smoothness_improvement": 2928.861694218456,
                    "objective_score": 45.96405255724957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02596104145050049,
                    "num_nodes_avg": 190.7,
                    "path_length_avg": 125.21405267786288,
                    "smoothness_avg": 0.1335209899284163,
                    "success_improvement": 0.0,
                    "time_improvement": 48.842395856970974,
                    "node_improvement": 75.75333757151938,
                    "length_improvement": 16.83878826381995,
                    "smoothness_improvement": 1598.3771363951587,
                    "objective_score": 32.747877397359055
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
          "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.45446,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1289.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103193283081056,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 173.3649996406287,
                    "smoothness_avg": 0.03905650881261121,
                    "success_improvement": 0.0,
                    "time_improvement": 25.93023309560016,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 4.975896552754276,
                    "smoothness_improvement": 511.3191754837242,
                    "objective_score": 13.321203737751233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022163128852844237,
                    "num_nodes_avg": 240.8,
                    "path_length_avg": 245.67296527562377,
                    "smoothness_avg": 0.08351123895740013,
                    "success_improvement": 0.0,
                    "time_improvement": 86.6145035068227,
                    "node_improvement": 83.8204663038366,
                    "length_improvement": 17.987292886770433,
                    "smoothness_improvement": 2048.8043290880164,
                    "objective_score": 47.020748429549144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017162418365478514,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 131.41011815324833,
                    "smoothness_avg": 0.11058336040285022,
                    "success_improvement": 0.0,
                    "time_improvement": 66.18054762740364,
                    "node_improvement": 71.51938970120788,
                    "length_improvement": 12.723656600001021,
                    "smoothness_improvement": 1306.6121819096536,
                    "objective_score": 34.02141915776997
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.35436,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020946669578552245,
                    "num_nodes_avg": 169.2,
                    "path_length_avg": 156.9968252907203,
                    "smoothness_avg": 0.020851635172459877,
                    "success_improvement": 0.0,
                    "time_improvement": 18.782430240028845,
                    "node_improvement": 57.39108536892471,
                    "length_improvement": 13.947552284259512,
                    "smoothness_improvement": 226.3733704995064,
                    "objective_score": 15.135127295061892
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029881834983825684,
                    "num_nodes_avg": 307.0,
                    "path_length_avg": 231.7579073494588,
                    "smoothness_avg": 0.09111135278880159,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95276488074154,
                    "node_improvement": 79.3724383524827,
                    "length_improvement": 22.63253974525912,
                    "smoothness_improvement": 2244.360732110702,
                    "objective_score": 49.38715697193144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02644164562225342,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 123.73707639297194,
                    "smoothness_avg": 0.07830820806750623,
                    "success_improvement": 0.0,
                    "time_improvement": 47.89533993801242,
                    "node_improvement": 63.4837889383344,
                    "length_improvement": 17.819725586191648,
                    "smoothness_improvement": 896.0746265080132,
                    "objective_score": 29.54081046565878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* planner leveraging grid-based spatial hashing for efficient nearest and near-node queries, incremental node rewiring with limited local radius to reduce computational overhead, and incremental lightweight shortcutting applied periodically during planning to progressively smooth and shorten paths. The planner alternates expansion between start and goal trees, uses goal bias sampling, and performs adaptive radius-based rewiring with spatial acceleration to enhance planning speed, path quality, and smoothness while maintaining robustness and path feasibility.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling strategically biases towards the goal to accelerate convergence. To accelerate nearest and neighborhood queries, spatial hashing discretizes the map space into grid cells allowing fast candidate pruning. Nodes connect via steering within a step size, and rewiring attempts are limited locally and applied incrementally every few iterations to limit overhead. Lightweight incremental shortcutting applies every set of iterations to progressively refine paths. The search stops upon connection or max iterations, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.15,\n                 rewire_interval=10, shortcut_interval=50, grid_resolution=5.0, local_rewire_radius_factor=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_interval = rewire_interval\n        self.shortcut_interval = shortcut_interval\n        self.grid_resolution = grid_resolution\n        self.local_rewire_radius_factor = local_rewire_radius_factor\n\n    def plan(self, map):\n        import random\n        import math\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Spatial hash grid for fast neighbor queries\n        class SpatialHash:\n            def __init__(self, resolution, bounds, dim):\n                self.res = resolution\n                self.bounds = bounds\n                self.dim = dim\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.res) for i in range(self.dim))\n\n            def add(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.cells and node in self.cells[h]:\n                    self.cells[h].remove(node)\n                    if not self.cells[h]:\n                        del self.cells[h]\n\n            def near(self, pos, radius):\n                hr = int(math.ceil(radius / self.res))\n                base = self._hash(pos)\n                candidates = []\n                def neighbors_1d(b):\n                    return [b + i for i in range(-hr, hr + 1)]\n                if self.dim == 2:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            cell = (xi, yi)\n                            if cell in self.cells:\n                                candidates.extend(self.cells[cell])\n                else:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    z_idx = neighbors_1d(base[2])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            for zi in z_idx:\n                                cell = (xi, yi, zi)\n                                if cell in self.cells:\n                                    candidates.extend(self.cells[cell])\n                return candidates\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        hash_start = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_goal = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_start.add(start_tree[0])\n        hash_goal.add(goal_tree[0])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            dist_ = dist(fr, to)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree_hash, pos):\n            candidates = tree_hash.near(pos, self.step_size*5)\n            best = None\n            best_d = float('inf')\n            for node in candidates:\n                d_ = dist(node.position, pos)\n                if d_ < best_d:\n                    best_d = d_\n                    best = node\n            # If no candidates in nearby cells, fallback to linear search\n            if best is None:\n                # linear fallback rare and expensive, only approx fallback\n                best = None\n                best_d = float('inf')\n                for node_list in tree_hash.cells.values():\n                    for node in node_list:\n                        d_ = dist(node.position, pos)\n                        if d_ < best_d:\n                            best_d = d_\n                            best = node\n            return best\n\n        def near_nodes(tree_hash, pos, radius):\n            candidates = tree_hash.near(pos, radius)\n            r_sq = radius*radius\n            return [node for node in candidates if dist(node.position, pos) <= radius]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()  # avoid duplication\n            return path_start[::-1] + path_goal\n\n        def rewire(tree_hash, new_node, near_nodes_):\n            nonlocal edges\n            radius = self.local_rewire_radius_factor * self.step_size\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                dist_to_near = dist(new_node.position, near.position)\n                if dist_to_near > radius:\n                    continue\n                new_cost = new_node.cost + dist_to_near\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def shortcut_path(path, max_attempts=15):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        connection_start = None\n        connection_goal = None\n        best_cost = float('inf')\n        best_path = []\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, hash_start, hash_goal),\n                                                   (goal_tree, start_tree, hash_goal, hash_start)]:\n                q_rand = sample()\n                nearest_node = nearest(hash_a, q_rand)\n                if nearest_node is None:\n                    continue\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n                # Determine parent among near nodes with minimal cost\n                near_nodes_a = near_nodes(hash_a, q_new_pos, self.local_rewire_radius_factor * self.step_size)\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    tentative_cost = near.cost + dist(near.position, q_new_pos)\n                    if tentative_cost + 1e-12 < min_cost:\n                        if not is_edge_in_obstacle(near.position, q_new_pos):\n                            min_cost = tentative_cost\n                            min_parent = near\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n                hash_a.add(q_new)\n\n                # Periodic rewiring for efficiency\n                if it % self.rewire_interval == 0:\n                    rewire(hash_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(hash_b, q_new.position)\n                if nearest_other is None:\n                    continue\n                dist_connect = dist(q_new.position, nearest_other.position)\n                if dist_connect <= self.step_size * self.local_rewire_radius_factor:\n                    if not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                        total_cost = q_new.cost + dist_connect + nearest_other.cost\n                        if total_cost + 1e-12 < best_cost:\n                            best_cost = total_cost\n                            connection_start, connection_goal = (q_new, nearest_other) if tree_a is start_tree else (nearest_other, q_new)\n                            best_path = extract_path(connection_start, connection_goal)\n\n            # Periodic lightweight shortcutting on best path\n            if best_path and it % self.shortcut_interval == 0:\n                best_path = shortcut_path(best_path)\n\n            # Early termination if connected and smoothed path found\n            if best_path and it % self.shortcut_interval == 0:\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Return best path found if any\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -29.85719,
          "time_improvement": 50.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1124.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0184661865234375,
                    "num_nodes_avg": 150.7,
                    "path_length_avg": 170.55441969465716,
                    "smoothness_avg": 0.026642453962263436,
                    "success_improvement": 0.0,
                    "time_improvement": 28.40013126938419,
                    "node_improvement": 62.04986149584488,
                    "length_improvement": 6.516419957630541,
                    "smoothness_improvement": 317.01225952420344,
                    "objective_score": 14.0149526530146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0354881763458252,
                    "num_nodes_avg": 344.6,
                    "path_length_avg": 235.67995906786047,
                    "smoothness_avg": 0.0792326175097546,
                    "success_improvement": 0.0,
                    "time_improvement": 78.5667960882094,
                    "node_improvement": 76.84606598132096,
                    "length_improvement": 21.323245991657284,
                    "smoothness_improvement": 1938.712317473634,
                    "objective_score": 46.057548008825364
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028713369369506837,
                    "num_nodes_avg": 310.3,
                    "path_length_avg": 123.23507190643708,
                    "smoothness_avg": 0.09562231356413795,
                    "success_improvement": 0.0,
                    "time_improvement": 43.418788240119405,
                    "node_improvement": 60.54672600127146,
                    "length_improvement": 18.153133063263258,
                    "smoothness_improvement": 1116.3087704308396,
                    "objective_score": 29.499060162147973
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
          "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -29.43149,
          "time_improvement": 46.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1325.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025296664237976073,
                    "num_nodes_avg": 157.7,
                    "path_length_avg": 169.82640352208247,
                    "smoothness_avg": 0.034435143239248046,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9159783497959368,
                    "node_improvement": 60.28708133971292,
                    "length_improvement": 6.915457157973212,
                    "smoothness_improvement": 438.98476880462505,
                    "objective_score": 6.918991643745834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026137399673461913,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 237.06092208208943,
                    "smoothness_avg": 0.09896313272769311,
                    "success_improvement": 0.0,
                    "time_improvement": 84.21422922761201,
                    "node_improvement": 84.65363166028354,
                    "length_improvement": 20.862240788691224,
                    "smoothness_improvement": 2446.3926853468774,
                    "objective_score": 50.01357666823272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02440671920776367,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 124.62874035050683,
                    "smoothness_avg": 0.09361395032374312,
                    "success_improvement": 0.0,
                    "time_improvement": 51.90526997765084,
                    "node_improvement": 72.01525746980292,
                    "length_improvement": 17.227524842071908,
                    "smoothness_improvement": 1090.7625382549713,
                    "objective_score": 31.361908589813254
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with dynamic goal-biased informed sampling, adaptive rewiring radius tuned by node density, efficient incremental rewiring with robust edge and child updates, and a geometry-driven post-processing smoothing combining heuristic shortcutting and path simplification for enhanced smoothness and path length within reduced planning time. This algorithm integrates focused sampling around the current best path, frequent rewiring to optimize locally, and geometry-aware shortcutting with checks for collision-free paths. It balances exploration and exploitation by adapting sampling and rewiring adaptively and uses early termination based on no improvement stagnation to improve efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending them toward samples generated either uniformly, toward the goal directly with goal bias, or within an ellipsoidal informed subset defined by the best solution cost. New nodes choose parents from neighbors within an adaptive radius decreasing with node number and dimension, ensuring efficient rewiring and local cost optimization. Upon connecting the two trees, the best path is extracted and a geometry-driven post-processing smoothing method attempts shortcutting only between points with larger Euclidean distance and removes unnecessary waypoints to reduce jagged turns. The algorithm applies early stopping if no improvement is made for a defined iteration window, yielding faster convergence and better path length and smoothness without compromising robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, gamma=35.0,\n                 goal_sample_rate=0.15, shortcut_interval=15, max_shortcut_attempts=50,\n                 no_improve_limit=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.no_improve_limit = no_improve_limit\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                diff = p2[i] - p1[i]\n                dist += diff*diff\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            # Build rotation matrix to align x-axis with dir_vec\n            if dim == 2:\n                cos_theta = dir_vec[0] / length\n                sin_theta = dir_vec[1] / length\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [a1 * x_ball[0], a2 * x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                from math import sqrt\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq == 0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            return min(self.step_size * 28.0, self.gamma * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        last_improve_iter = 0\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try + 1e-10 < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost and edge is collision free\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost + 1e-10 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent is not None:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + dist_to_other\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += math.dist(path[i], path[i+1])\n            return length\n\n        def geometric_shortcut(path):\n            # Heuristic geometry-aware shortcut: only try pairs with distance > 3*step_size to reduce attempts\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if math.dist(new_path[i], new_path[j]) > 3*self.step_size:\n                    if not edge_in_obstacle(new_path[i], new_path[j]):\n                        # Shortcut feasible, replace intermediate nodes\n                        new_path = new_path[:i+1] + new_path[j:]\n                        attempts = 0  # reset attempts on success\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            # Post-process: Remove collinear or near-collinear nodes to smooth path further\n            def is_collinear(p1,p2,p3, tol=1e-3):\n                # Check area of triangle formed by these 3 points\n                if dim == 2:\n                    area = abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n                else:\n                    # For 3D use vector triple product for area of parallelogram\n                    import numpy as np\n                    a = np.array(p2)-np.array(p1)\n                    b = np.array(p3)-np.array(p1)\n                    cross = (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n                    area = (cross[0]**2 + cross[1]**2 + cross[2]**2)**0.5 / 2.0\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n            # Remove near-collinear middle points\n            i = 1\n            while i < len(new_path)-1:\n                if is_collinear(new_path[i-1], new_path[i], new_path[i+1]):\n                    new_path.pop(i)\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            r = random.random()\n            if best_cost < float('inf') and r < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-10 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = it\n                        if tree_from is start_tree:\n                            sol_start, sol_goal = n_start, n_goal\n                        else:\n                            sol_start, sol_goal = n_goal, n_start\n\n            if best_cost < float('inf'):\n                if (it - last_improve_iter) > self.no_improve_limit:\n                    break\n                if it % self.shortcut_interval == 0 and sol_start is not None and sol_goal is not None:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = geometric_shortcut(raw_path)\n                    if len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and sol_start and sol_goal:\n            raw_path = extract_path(sol_start, sol_goal)\n            final_path = geometric_shortcut(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -28.78012,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1275.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020882630348205568,
                    "num_nodes_avg": 147.3,
                    "path_length_avg": 170.37169066289314,
                    "smoothness_avg": 0.02821399372542354,
                    "success_improvement": 0.0,
                    "time_improvement": 19.030732751249133,
                    "node_improvement": 62.90606900025183,
                    "length_improvement": 6.616576635467197,
                    "smoothness_improvement": 341.61026947087623,
                    "objective_score": 11.387217154009438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030633068084716795,
                    "num_nodes_avg": 267.9,
                    "path_length_avg": 242.56536860233672,
                    "smoothness_avg": 0.10851433639409444,
                    "success_improvement": 0.0,
                    "time_improvement": 81.49905511330289,
                    "node_improvement": 81.9995968554727,
                    "length_improvement": 19.024698103524358,
                    "smoothness_improvement": 2692.152035137315,
                    "objective_score": 49.325295571792054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03129546642303467,
                    "num_nodes_avg": 269.8,
                    "path_length_avg": 125.02772119995618,
                    "smoothness_avg": 0.06998655864811568,
                    "success_improvement": 0.0,
                    "time_improvement": 38.33062953989469,
                    "node_improvement": 65.69612205975844,
                    "length_improvement": 16.96254075929408,
                    "smoothness_improvement": 790.2238601336318,
                    "objective_score": 25.627832618213013
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing dynamic adaptive rewiring radius, ellipsoidal informed sampling post initial solution, efficient k-nearest rewiring leveraging approximate nearest neighbor heuristic, and a refined incremental shortcutting mechanism combining curvature preservation with iterative path smoothing. This planner aggressively prunes and updates trees for faster convergence, improves path length by adaptive rewiring and ellipsoidal sampling, while enhancing path smoothness by integrating curvature-aware incremental shortcutting and smoothing every fixed iteration interval. Early exits during collision checks and consistent graph maintenance reduce planning time and increase robustness.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions from start and goal states. It performs ellipsoidal informed sampling inside an adaptive prolate hyperspheroid once a valid path is found, focusing search near the best solution. Adaptive near radius for rewiring scales logarithmically with node count and dimension. The planner uses approximate nearest neighbors by early exiting distance checks to improve rewiring efficiency. Rewiring considers curvature preservation to avoid sharp turns. The incremental shortcutting aggressively shortcuts edges without increasing curvature beyond a small angle threshold, followed by midpoint smoothing. Path extraction reconciles the two trees once a connection occurs, and path smoothing is applied periodically to maintain smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.5, gamma_rrt_star=45.0,\n                 shortcut_interval=30, max_shortcut_attempts=45, curvature_threshold=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.curvature_threshold = curvature_threshold  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 45)\n\n        def angle_between(a, b, c):\n            # Returns angle at b formed by points a-b-c in radians\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_preserving_rewire(new_node, near_nodes_list):\n            import math\n            for near in near_nodes_list:\n                if near is new_node.parent or near is new_node:\n                    continue\n                dist_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_cost\n                if potential_cost + 1e-15 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Check curvature increase if rewired\n                        prev_parent = near.parent\n                        if prev_parent is None:\n                            continue\n                        ang_before = angle_between(prev_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position,\n                                                  near.children[0].position) if near.children else 0.0\n                        # Accept if curvature doesn't increase noticeably or children absent\n                        if len(near.children) == 0 or ang_after < ang_before + self.curvature_threshold:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = potential_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_subtree_costs(near, edges)\n\n        def incremental_curvature_shortcut(path):\n            # Iteratively tries shortcuts preserving curvature within threshold\n            if len(path) < 3:\n                return path[:]\n            import random\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                L = len(new_path)\n                for i in range(L - 2):\n                    for j in range(L - 1, i + 1, -1):\n                        if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                            # Check curvature preservation between three-waypoints if applicable\n                            if i > 0 and j < L - 1:\n                                ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1])\n                                ang_after = angle_between(new_path[i-1], new_path[j], new_path[j+1])\n                                if ang_after < ang_before + self.curvature_threshold:\n                                    new_path = new_path[:i+1] + new_path[j:]\n                                    changed = True\n                                    break\n                            else:\n                                new_path = new_path[:i+1] + new_path[j:]\n                                changed = True\n                                break\n                    if changed:\n                        break\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(a, midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(midpoint, c, obstacles, is_3d)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-6:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_connection(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Efficient approximate k-nearest rewiring (early exit heuristic)\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    # Early exit collision check\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes trying to preserve curvature and improve cost\n            curvature_preserving_rewire(new_node, near_nodes)\n\n            # Try connect to tree_b within step_size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost + 1e-15 < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_connection(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, conn_node, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, conn_node\n                        else:\n                            solution_start, solution_goal = conn_node, new_node\n\n            # Apply incremental path smoothing and curvature-aware shortcutting every shortcut_interval iterations once solution found\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    shortcut_path = incremental_curvature_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(shortcut_path)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extract_path(self, node_start, node_goal):\n        s_path = []\n        n = node_start\n        while n is not None:\n            s_path.append(n.position)\n            n = n.parent\n        g_path = []\n        n = node_goal\n        while n is not None:\n            g_path.append(n.position)\n            n = n.parent\n        return s_path[::-1] + g_path\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq >= best_dist_sq:  # early exit\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist += d * d\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * diff_vec[i] for i in range(len(from_pos)))\n        return new_pos\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
          "objective": -28.74503,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1723.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0299816370010376,
                    "num_nodes_avg": 148.2,
                    "path_length_avg": 167.3939001155781,
                    "smoothness_avg": 0.050243287597786124,
                    "success_improvement": 0.0,
                    "time_improvement": -16.24930089808597,
                    "node_improvement": 62.67942583732058,
                    "length_improvement": 8.248750820561371,
                    "smoothness_improvement": 686.4165559506581,
                    "objective_score": 3.506543002664322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024869823455810548,
                    "num_nodes_avg": 213.3,
                    "path_length_avg": 234.52362942815247,
                    "smoothness_avg": 0.11434926003010829,
                    "success_improvement": 0.0,
                    "time_improvement": 84.97978616358722,
                    "node_improvement": 85.66821205402137,
                    "length_improvement": 21.70926210849506,
                    "smoothness_improvement": 2842.288823017571,
                    "objective_score": 52.73093722926106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03181536197662353,
                    "num_nodes_avg": 263.6,
                    "path_length_avg": 123.95805243875779,
                    "smoothness_avg": 0.13682429202352978,
                    "success_improvement": 0.0,
                    "time_improvement": 37.30614787659427,
                    "node_improvement": 66.48442466624284,
                    "length_improvement": 17.672963818329237,
                    "smoothness_improvement": 1640.3948952206044,
                    "objective_score": 29.99759713007884
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
          "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -28.03557,
          "time_improvement": 38.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1533.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A bidirectional RRT* variant with adaptive neighborhood radius, continuous incremental shortcutting, and efficient heuristic-guided rewiring combined with hybrid sampling. The planner integrates adaptive ellipsoidal informed sampling and early collision rejection to minimize path length and runtime. Continuous path smoothing after each successful connection refines solution quality and improves smoothness. Parent-child pruning during rewiring maintains tree consistency, and heuristic-prioritized rewiring focuses optimization on promising regions for faster convergence.",
          "planning_mechanism": "The planner grows two bidirectional trees from start and goal by sampling new points with hybrid uniform and ellipsoidal informed sampling guided by current best cost. New nodes are connected using an adaptive neighborhood radius that shrinks as node density and best cost improve, promoting better rewiring opportunities. Rewiring incorporates heuristic distance to goal and incremental cost propagation ensuring improved path quality. After every successful connection, an incremental shortcutting procedure continuously refines the path by removing unnecessary waypoints using collision and curvature checks, enhancing smoothness and shortening path length. Efficient collision checks with early exit reduce planning time, and adaptive smoothing balances exploration and optimization for rapid convergence and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=25.0,\n                 blend_sample_rate=0.65, max_local_shortcuts=80,\n                 shortcut_interval=10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.max_local_shortcuts = max_local_shortcuts\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def heuristic_goal(p):  # Euclidean dist to goal\n            return math.dist(p, goal_pos)\n\n        def heuristic_start(p):  # Euclidean dist to start\n            return math.dist(p, start_pos)\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        # Adaptive neighborhood radius based on node count and best cost (shrinks as tree fills and solution improves)\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 6.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            r = self.base_radius * val\n            if best_cost < float('inf'):\n                r = min(r, best_cost*0.35)\n            return max(r, self.step_size * 1.1)\n\n        # Hybrid sampling combines uniform random and ellipsoidal informed sampling around start and goal\n        def sample_point(best_cost):\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                # Uniform random with rejection sampling for obstacle\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                # fallback uniform no check\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            center = tuple(0.5*(start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost/2.0\n            rad2 = best_cost*best_cost - c_min*c_min\n            try:\n                a_rest = math.sqrt(rad2)/2.0 if rad2 > 0 else 0.0\n            except Exception:\n                a_rest = a1_val\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            rsq = radius*radius\n            return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= rsq]\n\n        def cost_with_curvature(parent, child_pos):\n            # Base cost plus curvature penalty for smoothness\n            base_cost = parent.cost + math.dist(parent.position, child_pos)\n            # Curvature penalty via angle between grandparent-parent-child\n            if parent is None or parent.parent is None:\n                return base_cost\n            a = parent.parent.position\n            b = parent.position\n            c = child_pos\n            v1 = [b[i]-a[i] for i in range(dim)]\n            v2 = [c[i]-b[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return base_cost\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_theta = max(min(dot/(len1*len2),1.0), -1.0)\n            ang = math.acos(cos_theta)\n            # Penalty scaled to angle, tighter penalty here strengthens smoothness\n            penalty = ang*2.0\n            return base_cost + penalty\n\n        def rewire(tree, new_node, near_nodes, best_cost):\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent or neighbor is new_node:\n                    continue\n                new_cost = cost_with_curvature(new_node, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost:\n                    # Early collision check for edge\n                    if collision_edge(new_node.position, neighbor.position):\n                        continue\n                    # Heuristic-driven rewiring: only if helps towards goal shorter path\n                    if heuristic_goal(neighbor.position) + new_cost >= heuristic_goal(neighbor.position) + neighbor.cost:\n                        continue\n                    # Prune old parent-child link\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    self._propagate_cost_changes(neighbor)\n\n        def propagate_costs(node):\n            # propagate cost changes downstream nodes\n            import math\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    potential_cost = cost_with_curvature(curr, c.position)\n                    if potential_cost + 1e-12 < c.cost:\n                        c.cost = potential_cost\n                        stack.append(c)\n\n        self._propagate_cost_changes = propagate_costs\n\n        def extract_path(n_from, n_to):\n            # retrieve path from start-tree node to root (start)\n            path_start = []\n            n = n_from\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            # retrieve path from goal-tree node to root (goal)\n            path_goal = []\n            n = n_to\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # concatenate carefully, avoid duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def incremental_shortcut(path):\n            # Incremental shortcut removes unnecessary nodes continuously with collision and angle checks\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    # Check curvature-compatible angle reduction\n                    if i>0 and j<len(new_path)-1:\n                        a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                        d, e, f = new_path[j-1], new_path[j], new_path[j+1]\n                        def angle(pt1, pt2, pt3):\n                            v1 = [pt1[k]-pt2[k] for k in range(dim)]\n                            v2 = [pt3[k]-pt2[k] for k in range(dim)]\n                            len1 = math.sqrt(sum(x*x for x in v1))\n                            len2 = math.sqrt(sum(x*x for x in v2))\n                            if len1 < 1e-12 or len2 < 1e-12:\n                                return 0.0\n                            dot = sum(v1[k]*v2[k] for k in range(dim))\n                            cos_a = max(min(dot/(len1*len2),1.0),-1.0)\n                            return math.acos(cos_a)\n                        old_angle = angle(a,b,c)\n                        new_angle = angle(a, new_path[j], c)\n                        # Reject sharp angle increase to maintain smoothness\n                        if new_angle > old_angle+0.4:\n                            attempts += 1\n                            continue\n                    del new_path[i+1:j]\n                attempts += 1\n            return new_path\n\n        # Trees and data structures\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        for it in range(1, self.max_iter+1):\n            sample = sample_point(best_cost)\n            # Alternate tree roles for bidirectional growth\n            if it % 2 == 1:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_goal, heuristic_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_start, heuristic_goal\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                collision_node(new_pos) or\n                collision_edge(nearest_node.position, new_pos)):\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = near(tree_a, new_pos, radius)\n            # Prioritize nodes nearer goal for rewiring\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n\n            min_cost = cost_with_curvature(nearest_node, new_pos)\n            min_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                cur_cost = cost_with_curvature(candidate, new_pos)\n                # Prune by cost+heuristic\n                if cur_cost + heuristic_a(new_pos) + 1e-12 >= min_cost + heuristic_a(new_pos):\n                    continue\n                if collision_edge(candidate.position, new_pos):\n                    continue\n                min_cost = cur_cost\n                min_parent = candidate\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent,new_node))\n\n            rewire(tree_a, new_node, near_nodes, best_cost)\n\n            # Connect to other tree within step size and free path\n            nearest_other = nearest(tree_b, new_pos)\n            dist_conn = math.dist(new_pos, nearest_other.position)\n            if dist_conn <= self.step_size:\n                if not collision_edge(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other) if tree_a is start_tree else (nearest_other, new_node)\n\n            # Continuous incremental shortcutting every shortcut_interval iterations when solution exists\n            if best_cost < float('inf') and it % self.shortcut_interval == 0 and best_pair[0] and best_pair[1]:\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                improved_path = incremental_shortcut(raw_path)\n                if improved_path:\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        # Final check after max iterations\n        if best_cost < float('inf') and best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            improved_path = incremental_shortcut(raw_path)\n            return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -27.69077,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1341.0,
          "node_improvement": 71.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020848727226257323,
                    "num_nodes_avg": 123.4,
                    "path_length_avg": 168.3536368145685,
                    "smoothness_avg": 0.032372817225057804,
                    "success_improvement": 0.0,
                    "time_improvement": 19.162187021895182,
                    "node_improvement": 68.92470410475951,
                    "length_improvement": 7.722703927843541,
                    "smoothness_improvement": 406.7048882699285,
                    "objective_score": 12.415802904624321
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03440771102905273,
                    "num_nodes_avg": 275.6,
                    "path_length_avg": 236.32201036605926,
                    "smoothness_avg": 0.09884469617616079,
                    "success_improvement": 0.0,
                    "time_improvement": 79.21934676391426,
                    "node_improvement": 81.48222804542094,
                    "length_improvement": 21.108910787896583,
                    "smoothness_improvement": 2443.345227569551,
                    "objective_score": 48.647876639759986
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04077534675598145,
                    "num_nodes_avg": 286.3,
                    "path_length_avg": 124.84117708294514,
                    "smoothness_avg": 0.10002833338269039,
                    "success_improvement": 0.0,
                    "time_improvement": 19.650024359980847,
                    "node_improvement": 63.59821996185633,
                    "length_improvement": 17.08643447953652,
                    "smoothness_improvement": 1172.353017304273,
                    "objective_score": 22.00863308223753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive sampling radius, momentum-based tree extension, and batch rewiring to efficiently converge to high-quality solutions. The algorithm uses ellipsoidal informed sampling shrinking with the best path cost and adapts the rewiring radius scaling with tree density to balance exploration and local optimization. Momentum steering moves nodes further along promising directions to accelerate convergence. Batch rewiring is performed less frequently but covers a broader neighborhood for better path refinement. Incremental shortcutting runs immediately after improvements to incrementally shorten and smooth the path, enhancing path length and smoothness while reducing search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling within a shrinking ellipsoidal informed subset after the first found path. Each iteration attempts to extend in momentum-driven directions to improve progress speed. It adaptively chooses parent nodes and rewires a dynamically scaled neighborhood to optimize cost. Batch rewiring periodically repairs the trees globally. Paths are incrementally shortcut as soon as better solutions are found for continuous quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, gamma_adapt=45.0, batch_rewire_freq=50, max_shortcut_attempts=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_adapt = gamma_adapt\n        self.batch_rewire_freq = batch_rewire_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.2\n            val = self.gamma_adapt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 45.0)\n\n        def sample_ellipsoidal():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in direction]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0], [0,a_other,0], [0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer_momentum(from_pos, to_pos, momentum):\n            dist = math.dist(from_pos, to_pos)\n            if dist < 1e-12:\n                return from_pos\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            step = min(self.step_size, dist)\n            base_new = tuple(from_pos[i]+direction[i]*step for i in range(dim))\n            # Apply momentum to push further if within map bounds and free\n            momentum_step = 0.6 * self.step_size\n            candidate = tuple(base_new[i] + direction[i]*momentum_step for i in range(dim))\n            if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)):\n                return candidate\n            return base_new\n\n        def rewire_batch(tree):\n            n_nodes = len(tree)\n            if n_nodes <= 1:\n                return\n            r = radius(n_nodes) * 1.15  # slightly larger radius for batch rewiring\n            for n in tree:\n                near_nodes = self._near(tree, n.position, r)\n                for near in near_nodes:\n                    if near is n or n.parent is None:\n                        continue\n                    tentative_cost = n.cost + math.dist(n.position, near.position)\n                    if tentative_cost + 1e-9 < near.cost:\n                        if not self._is_edge_in_obstacle(n.position, near.position, obstacles, is_3d):\n                            # Rewire near node to n\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = n\n                            near.cost = tentative_cost\n                            n.add_child(near)\n                            edges.append((n, near))\n\n        def attempt_extend(tree_from, tree_to, sample, prev_dir):\n            nearest = self._nearest(tree_from, sample)\n            if prev_dir is None:\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n            else:\n                new_pos = steer_momentum(nearest.position, sample, prev_dir)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None, None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None, None\n\n            new_node = Node(new_pos)\n            rn = radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, rn)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            d_connect = math.dist(new_node.position, nearest_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_connect + nearest_other.cost\n                    return (new_node, nearest_other, total_cost, \n                            tuple((new_node.position[i] - nearest_other.position[i]) for i in range(dim)))\n            return None, None, None, None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            pth = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not self._is_edge_in_obstacle(pth[i], pth[j], obstacles, is_3d):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        prev_direction = None\n        for it in range(self.max_iter):\n            sample = sample_ellipsoidal()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(treeA, treeB, sample, prev_direction)\n                if res[0] is not None:\n                    new_node, connect_node, c_cost, direction_vec = res\n                    if c_cost + 1e-9 < best_cost:\n                        best_cost = c_cost\n                        prev_direction = direction_vec\n                        if treeA is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n                        # Incremental shortcut immediately on improvement\n                        raw_path = self._extract_path(sol_start, sol_goal)\n                        improved_path = incremental_shortcut(raw_path)\n                        if improved_path and len(improved_path) >= 2:\n                            # Batch rewiring occasionally for global improvement\n                            if it % self.batch_rewire_freq == 0:\n                                rewire_batch(start_tree)\n                                rewire_batch(goal_tree)\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n            # Occasionally batch rewire for global tree quality\n            if it > 0 and it % self.batch_rewire_freq == 0:\n                rewire_batch(start_tree)\n                rewire_batch(goal_tree)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur is not None:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_goal = []\n        cur = node_goal\n        while cur is not None:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -27.13468,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1399.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016662406921386718,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 161.76013706572985,
                    "smoothness_avg": 0.04759929459666155,
                    "success_improvement": 0.0,
                    "time_improvement": 35.394016149831984,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 11.336705620871545,
                    "smoothness_improvement": 645.0323239603604,
                    "objective_score": 20.645389837274323
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0229341983795166,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 235.63681484522058,
                    "smoothness_avg": 0.09687544838552706,
                    "success_improvement": 0.0,
                    "time_improvement": 86.14881346306589,
                    "node_improvement": 88.49694282066787,
                    "length_improvement": 21.33764877501207,
                    "smoothness_improvement": 2392.675063524693,
                    "objective_score": 50.610608621550476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06088290214538574,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 124.62617397516483,
                    "smoothness_avg": 0.09909509135315861,
                    "success_improvement": 0.0,
                    "time_improvement": -19.972976160105908,
                    "node_improvement": 70.59122695486333,
                    "length_improvement": 17.2292293063764,
                    "smoothness_improvement": 1160.4822475733902,
                    "objective_score": 10.14805597366102
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.77328,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1515.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An improved bidirectional RRT* planner integrating adaptive rewiring radius scaling and a probabilistic goal-biased informed sampling scheme, combined with frequent, iterative, and cautious shortcutting that preserves smoothness. This planner enhances path quality and smoothness by incorporating an adaptive neighbor radius based on the number of nodes and dimension, dynamically balancing exploration with goal bias, and applying incremental smoothing phases that limit abrupt path modifications. Tree connection attempts occur often to accelerate solution discovery. Meanwhile, rewiring drops parents only when a truly better cost is achievable, and cost updates propagate efficiently to maintain subtree consistency for smooth path refinement.",
          "planning_mechanism": "The planner grows two trees from start and goal, exploring with goal-biased, adaptive informed elliptical sampling that shrinks as better solutions are found. It steers with fixed steps and rewires within a dynamically scaled neighborhood radius calculated to maintain local path quality in accordance with dimensionality and tree size. The planner frequently attempts to connect the trees and propagates cost updates recursively on rewiring to ensure subtree cost consistency. After each successful connection, a multi-pass shortcutting method iteratively attempts valid shortcuts with limited aggressive node removal to enhance smoothness without causing sharp deviations. This approach optimizes both runtime and path quality robustly in complex environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b): return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            # Dimension-specific adaptive radius: r = min(r_max, max(r_min, gamma * (log n / n)^{1/d}))\n            # gamma empirically taken as 40\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            # goal biased informed sampling if solution found; else uniform with goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                # informed sampling inside ellipsoid aligned with start-goal\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    # degenerate\n                    return goal_pos\n\n                # Rotate samples to align ellipsoid with line between start and goal\n                # Build orthonormal basis\n                e1 = [x/length for x in a1]\n                # Generate orthogonal vectors with Gram-Schmidt\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    # Simple for 2D and 3D:\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        import math\n                        # Choose arbitrary\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            # fallback\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                # Compute ellipsoid axes\n                c_min = length\n                # safety margin to allow slightly larger sampling region for exploration\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                # Axes lengths (a): a1 = c_max/2, others scale by sqrt(c_max^2 - c_min^2)/2 or fallback\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    # sample in unit ball first\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1]]\n                        # rotate back to map coords\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        # 3D\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            # Euclidean distance nearest node\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            return [n for n in tree if ( (n.position[0]-p[0])**2 + (n.position[1]-p[1])**2 + ((n.position[2]-p[2])**2 if is_3d else 0.0)) <= r2]\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # start path reversed + goal path trimmed of start overlap\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=5, max_attempts_per_pass=200):\n            # cautious multi-pass shortcutting; avoid removing nodes that create sharp turns\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts +=1\n                        continue\n                    if is_free_edge(new_path[i], new_path[j]):\n                        # Check local smoothness before shortcut removal\n                        # compute turning angles if removing intermediate nodes between i and j\n                        prev_pt = new_path[i]\n                        next_pt = new_path[j]\n                        remove_indices = range(i+1, j)\n                        # crude smoothness check: angle at prev_pt and next_pt\n                        def angle(a,b,c):\n                            import math\n                            ab = [b[k]-a[k] for k in range(dim)]\n                            cb = [b[k]-c[k] for k in range(dim)]\n                            lab = math.sqrt(sum(x*x for x in ab))\n                            lcb = math.sqrt(sum(x*x for x in cb))\n                            if lab < 1e-8 or lcb < 1e-8:\n                                return 0\n                            dot = sum(ab[k]*cb[k] for k in range(dim))\n                            val = max(min(dot/(lab*lcb),1),-1)\n                            return math.acos(val)\n                        # For safety, check angle formed by prev_pt -> next_pt (expected to be ~0)\n                        # and angles before and after removing nodes\n                        if i>0:\n                            a = new_path[i-1]\n                            b = prev_pt\n                            c = next_pt\n                            a1 = angle(a,b,c)\n                            if a1 > math.pi*135/180: # >135 degrees sharp\n                                i+=1\n                                attempts+=1\n                                continue\n                        if j<len(new_path)-1:\n                            a = prev_pt\n                            b = next_pt\n                            c = new_path[j+1]\n                            a2 = angle(a,b,c)\n                            if a2 > math.pi*135/180:\n                                i+=1\n                                attempts+=1\n                                continue\n                        # Accept shortcut if angles okay:\n                        # Remove intermediate nodes:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        improved = True\n                        # Restart checking from start after change to propagate smoothing\n                        i = 0\n                        attempts +=1\n                        continue\n                    else:\n                        i+=1\n                        attempts+=1\n                if not improved:\n                    break\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate tree expansions for balance and exploration\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            # Compute adaptive neighbor radius for rewiring based on number of nodes in prop_tree\n            r = rewiring_radius(len(prop_tree))\n\n            near_nodes = near(prop_tree, new_pos, r)\n            # Choose parent minimizing cost + heuristic with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                # Use strict improvement only\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cost improves with new_node as parent\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old parent edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            # Attempt connection from new_node to other_tree for path joining\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            # After finding a solution, apply shortcutting iteratively every 80 iterations or at last iteration\n            if solution_nodes[0] and solution_nodes[1] and ( (it > 0 and it % 80 == 0) or it == self.max_iter-1 ):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n                if smoothed:\n                    return PlannerResult(True, smoothed, nodes, edges)\n\n        # Final return after max_iter or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n            return PlannerResult(True, smoothed, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.71512,
          "time_improvement": 54.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 465.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017966294288635255,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 163.95951929194274,
                    "smoothness_avg": 0.024923003054025138,
                    "success_improvement": 0.0,
                    "time_improvement": 30.338388437200997,
                    "node_improvement": 56.3082347015865,
                    "length_improvement": 10.131189371242641,
                    "smoothness_improvement": 290.09911896286457,
                    "objective_score": 16.630725748720206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03304464817047119,
                    "num_nodes_avg": 340.6,
                    "path_length_avg": 250.18134841864676,
                    "smoothness_avg": 0.025115402013338145,
                    "success_improvement": 0.0,
                    "time_improvement": 80.04257317904118,
                    "node_improvement": 77.11482899952965,
                    "length_improvement": 16.48226482701569,
                    "smoothness_improvement": 546.2373836960618,
                    "objective_score": 36.63331776840208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024051189422607422,
                    "num_nodes_avg": 287.7,
                    "path_length_avg": 129.7207213209384,
                    "smoothness_avg": 0.05176360916448404,
                    "success_improvement": 0.0,
                    "time_improvement": 52.60586020800652,
                    "node_improvement": 63.42021614748887,
                    "length_improvement": 13.84567353558893,
                    "smoothness_improvement": 558.4292877800516,
                    "objective_score": 26.88130862265557
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
          "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -26.27848,
          "time_improvement": 35.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.16492572596105,
          "time_improvement": 92.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003008270263671875,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 184.17006126805845,
                    "smoothness_avg": 0.01054995558932253,
                    "success_improvement": 0.0,
                    "time_improvement": 88.33588322571401,
                    "node_improvement": 82.85066733820196,
                    "length_improvement": -0.9465289423981464,
                    "smoothness_improvement": 65.12971456814059,
                    "objective_score": 26.25849617511602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008660387992858887,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 300.8164456420612,
                    "smoothness_avg": 0.0064472474436514295,
                    "success_improvement": 0.0,
                    "time_improvement": 94.76952943432936,
                    "node_improvement": 85.05005711214136,
                    "length_improvement": -0.4211880766230819,
                    "smoothness_improvement": 65.89232048978258,
                    "objective_score": 28.50760758677387
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0042524576187133786,
                    "num_nodes_avg": 126.3,
                    "path_length_avg": 160.72624335922288,
                    "smoothness_avg": 0.012431076585876402,
                    "success_improvement": 0.0,
                    "time_improvement": 91.62030753242554,
                    "node_improvement": 83.94151303242214,
                    "length_improvement": -6.746717877938324,
                    "smoothness_improvement": 58.122376605720596,
                    "objective_score": 23.72867341599327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -26.062040773062417,
          "time_improvement": 66.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 167.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012016057968139648,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 175.84673815929608,
                    "smoothness_avg": 0.016310939143948412,
                    "success_improvement": 0.0,
                    "time_improvement": 53.409537367863955,
                    "node_improvement": 66.1294384286074,
                    "length_improvement": 3.6156163450092893,
                    "smoothness_improvement": 155.30161737405683,
                    "objective_score": 18.96873910423504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018314409255981445,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 257.3377355314211,
                    "smoothness_avg": 0.010767991223558952,
                    "success_improvement": 0.0,
                    "time_improvement": 88.93895070058699,
                    "node_improvement": 83.00073909830007,
                    "length_improvement": 14.093256823589732,
                    "smoothness_improvement": 177.06817005275553,
                    "objective_score": 36.02298015459372
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022396659851074217,
                    "num_nodes_avg": 265.9,
                    "path_length_avg": 136.5245362961063,
                    "smoothness_avg": 0.0210441701583257,
                    "success_improvement": 0.0,
                    "time_improvement": 55.86619816574277,
                    "node_improvement": 66.19198982835347,
                    "length_improvement": 9.326903591935762,
                    "smoothness_improvement": 167.68029109483984,
                    "objective_score": 23.19440306035849
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A novel bidirectional anytime RRT* variant employing an adaptive lazy collision checking strategy combined with an incremental cover tree for efficient nearest-neighbor queries. The algorithm uses goal-biased and informed sampling with rejection sampling limited by collision checks. Rewiring leverages a dynamically scaled neighborhood radius without strict curvature penalties to allow aggressive cost reduction. Edge and node collision checks are delayed until necessary to minimize expensive tests. The planner maintains anytime path improvement using incremental shortcutting during runtime and final iterative midpoint smoothing to enhance smoothness and shorten path length. It implements early stopping based on solution stability to reduce planning time.",
          "planning_mechanism": "The planner expands two trees simultaneously from start and goal nodes using samples drawn from a hybrid of uniform and informed distributions, rapidly connecting through incremental connections facilitated by a cover tree data structure that supports fast approximate nearest neighbor queries and dynamic radius updates. Lazy collision checking postpones collision tests until a promising edge or rewire candidate is identified, substantially reducing computational overhead. The method performs rewiring with an adaptive radius depending on node density and best path cost to accelerate convergence and improve solution quality. The found path undergoes incremental shortcut passes interleaved with the planning, followed by a final smoothing stage shifting vertices toward midpoints if collision-free. The algorithm terminates early if the solution cost remains stable for a predefined patience period.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, r_min=6.0, r_max=28.0,\n                 goal_sample_rate=0.12, uniform_sample_rate=0.1,\n                 shortcut_interval=30, shortcut_passes=5, shortcut_attempts=120,\n                 smooth_iters=8, early_stop_patience=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.uniform_sample_rate = uniform_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_iters = smooth_iters\n        self.early_stop_patience = early_stop_patience\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0.0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def node_collision(p):\n            px, py = p[0], p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, res=1.0):\n            d = math.dist(a,b)\n            if d < 1e-12:\n                return False\n            steps = max(1, int(d / res))\n            for i in range(steps+1):\n                t = i / float(steps)\n                pt = tuple(a[j] + (b[j]-a[j])*t for j in range(dim))\n                if node_collision(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = math.dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # Adaptive radius scales with node count & best cost to allow flexible rewiring\n        def adaptive_radius(n, best_cost):\n            if n < 2:\n                return self.r_max\n            val = 28.0 * (math.log(n)/n) ** (1.0/dim)\n            if best_cost < float('inf'):\n                val = min(val, best_cost*0.13)\n            return max(self.r_min, min(self.r_max, val))\n\n        # Lazy Collision cache: stores tested edges and node collisions\n        collision_cache_nodes = {}\n        collision_cache_edges = {}\n\n        def cache_node_free(p):\n            if p in collision_cache_nodes:\n                return collision_cache_nodes[p]\n            free = not node_collision(p)\n            collision_cache_nodes[p] = free\n            return free\n\n        def cache_edge_free(a,b):\n            key = (a,b) if a < b else (b,a)\n            if key in collision_cache_edges:\n                return collision_cache_edges[key]\n            free = not edge_collision(a,b)\n            collision_cache_edges[key] = free\n            return free\n\n        # Incremental cover tree structure for efficient neighbor queries\n        class CoverNode:\n            __slots__ = ('point','node_ref','children','level')\n            def __init__(self, point, node_ref, level):\n                self.point = point\n                self.node_ref = node_ref\n                self.children = []\n                self.level = level\n\n        class CoverTree:\n            def __init__(self, points_nodes=[]):\n                self.max_level = 0\n                self.min_level = 0\n                self.root = None\n                for p,n in points_nodes:\n                    self.insert(p,n)\n\n            def distance(self,a,b):\n                return math.dist(a,b)\n\n            def insert(self, point, node_ref):\n                if self.root is None:\n                    self.root = CoverNode(point,node_ref,0)\n                    self.max_level = 0\n                    self.min_level = 0\n                    return\n                curr = self.root\n                level = self.max_level\n                while True:\n                    d = self.distance(point,curr.point)\n                    cover_radius = 2 ** level\n                    if d > cover_radius:\n                        level += 1\n                        if level > self.max_level:\n                            self.max_level = level\n                        # New root\n                        new_root = CoverNode(point,node_ref,level)\n                        new_root.children.append(self.root)\n                        self.root = new_root\n                        return\n                    found_child = False\n                    for c in curr.children:\n                        if self.distance(point, c.point) <= 2 ** (level-1):\n                            curr = c\n                            level -= 1\n                            found_child = True\n                            break\n                    if not found_child:\n                        new_node = CoverNode(point,node_ref,level-1)\n                        curr.children.append(new_node)\n                        if level-1 < self.min_level:\n                            self.min_level = level-1\n                        return\n\n            # Approximate nearest neighbor search (descend cover tree)\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                def search(curnode):\n                    nonlocal best,best_dist\n                    d = self.distance(point, curnode.point)\n                    if d < best_dist:\n                        best_dist = d\n                        best = curnode\n                    cover_r = 2**curnode.level\n                    for c in curnode.children:\n                        dc = self.distance(point, c.point)\n                        if dc - cover_r <= best_dist:\n                            search(c)\n                if self.root is not None:\n                    search(self.root)\n                return best.node_ref if best else None\n\n            # Radius search returning all nodes within radius,\n            # pruning by cover tree properties\n            def radius_search(self, point, radius):\n                res = []\n                radius_sq = radius*radius\n                def search(curnode):\n                    d = self.distance(point, curnode.point)\n                    if d <= radius:\n                        res.append(curnode.node_ref)\n                    cover_r = 2**curnode.level\n                    for c in curnode.children:\n                        dc = self.distance(point, c.point)\n                        if dc - cover_r <= radius:\n                            search(c)\n                if self.root is not None:\n                    search(self.root)\n                return res\n\n            # Rebuild cover tree with new points\n            def rebuild(self, points_nodes):\n                self.root = None\n                self.max_level = 0\n                self.min_level = 0\n                for p,n in points_nodes:\n                    self.insert(p,n)\n\n        # Hybrid sampling: goal bias, uniform, then informed elliptical sampling if solution exists\n        def dist(p1,p2):\n            return math.dist(p1,p2)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                c_best = c_min\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = tuple((goal[i]-start[i])/c_min for i in range(dim))\n\n            # Orthonormal basis Gram-Schmidt\n            basis = [a1]\n            for i_dim in range(dim):\n                vec = [0.0]*dim\n                vec[i_dim] = 1.0\n                for b in basis:\n                    proj = sum(vec[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        vec[j] -= proj*b[j]\n                norm = math.sqrt(sum(x*x for x in vec))\n                if norm > 1e-10:\n                    basis.append([x/norm for x in vec])\n                if len(basis) == dim:\n                    break\n            basis = basis[:dim]\n\n            r1 = c_best/2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)*0.5 if val > 0 else 0.0\n\n            # sample in unit ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xx*xx for xx in x))\n                if norm_x > 1e-10:\n                    break\n            x_unit = [xx / norm_x for xx in x]\n            scale = random.uniform(0,1) ** (1.0/dim)\n            x_ball = [scale * v for v in x_unit]\n\n            mapped = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i]*([r1] + [r_rest]*(dim-1))[j] * x_ball[j]\n\n            pt = tuple(center[i] + mapped[i] for i in range(dim))\n            clamped = tuple(max(0.0,min(pt[i], bounds[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            prob = random.random()\n            if prob < self.goal_sample_rate:\n                if cache_node_free(goal):\n                    return goal\n            if prob < self.goal_sample_rate + self.uniform_sample_rate or c_best == float('inf'):\n                for _ in range(15):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if cache_node_free(p):\n                        return p\n                # fallback if no free found\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if cache_node_free(p):\n                        return p\n            for _ in range(20):\n                p = informed_sample(c_best)\n                if cache_node_free(p):\n                    return p\n            # fallback uniform\n            while True:\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if cache_node_free(p):\n                    return p\n\n        # Extract path by concatenating two nodes' root paths with deduplication\n        def extract_path(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                path_g = path_g[:-1]\n            return path_s + path_g[::-1]\n\n        # Incremental shortcutting interleaved during planning\n        def shortcut_path(path, passes, attempts):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            for _ in range(passes):\n                changed = False\n                a_i = 0\n                att = 0\n                while att < attempts and a_i < len(pth)-2:\n                    b_i = random.randint(a_i+2,len(pth)-1)\n                    if cache_edge_free(pth[a_i], pth[b_i]):\n                        # shortcut possible\n                        pth = pth[:a_i+1] + pth[b_i:]\n                        changed = True\n                        a_i = 0\n                        att += 1\n                    else:\n                        a_i += 1\n                        att += 1\n                if not changed:\n                    break\n            return pth\n\n        # Final smoothing by midpoint moves if collision-free and improvement found\n        def smooth_path(path, iterations):\n            if len(path) < 4:\n                return path[:]\n            pts = list(path)\n            for _ in range(iterations):\n                improved = False\n                for i in range(1,len(pts)-1):\n                    a = pts[i-1]\n                    b = pts[i]\n                    c = pts[i+1]\n                    mid = tuple(0.5*(a[j]+c[j]) for j in range(dim))\n                    if not cache_node_free(mid):\n                        continue\n                    if cache_edge_free(a, mid) and cache_edge_free(mid, c):\n                        # Check if smoothing decreases length locally\n                        old_len = math.dist(a,b) + math.dist(b,c)\n                        new_len = math.dist(a,mid) + math.dist(mid,c)\n                        if new_len + 1e-9 < old_len:\n                            pts[i] = mid\n                            improved = True\n                if not improved:\n                    break\n            return pts\n\n        # Update node costs by BFS once parent changes\n        def update_costs(node):\n            from collections import deque\n            queue = deque([node])\n            while queue:\n                curr = queue.popleft()\n                for c in curr.children:\n                    c_new_cost = curr.cost + math.dist(curr.position, c.position)\n                    if c_new_cost + 1e-14 < c.cost:\n                        c.cost = c_new_cost\n                        queue.append(c)\n\n        # Lazy attempt to connect new nodes and rewire neighbors\n        def rewire(tree_nodes, cover_tree, newnode, radius):\n            neighbors = cover_tree.radius_search(newnode.position, radius)\n            for nbr in neighbors:\n                if nbr is newnode.parent:\n                    continue\n                new_cost = newnode.cost + math.dist(newnode.position, nbr.position)\n                if new_cost + 1e-14 < nbr.cost and cache_edge_free(newnode.position, nbr.position):\n                    # Reassign parent with no strict curvature check for agile improvements\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = newnode\n                    nbr.cost = new_cost\n                    newnode.add_child(nbr)\n                    update_costs(nbr)\n            return neighbors\n\n        # Build initial nodes and trees\n        start_node = Node(start,None,0.0)\n        goal_node = Node(goal,None,0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n\n        # Cover trees for start and goal branches\n        cover_start = CoverTree([(start_node.position, start_node)])\n        cover_goal = CoverTree([(goal_node.position, goal_node)])\n\n        best_cost = float('inf')\n        best_pair = (None,None)\n        best_path = []\n        no_improve_cnt = 0\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n\n        # Main planning loop\n        for iter_i in range(self.max_iter):\n            # Alternate expansion between start and goal trees\n            if iter_i % 2 == 0:\n                tree_a, tree_cover_a = tree_start, cover_start\n                tree_b, tree_cover_b = tree_goal, cover_goal\n            else:\n                tree_a, tree_cover_a = tree_goal, cover_goal\n                tree_b, tree_cover_b = tree_start, cover_start\n\n            q_rand = sample_point(best_cost)\n            nearest_node = tree_cover_a.nearest(q_rand)\n            if nearest_node is None:\n                continue\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if not in_bounds(q_new_pos):\n                continue\n            if not cache_node_free(q_new_pos):\n                continue\n            # Lazy edge check postponed, do only if candidate parent\n            # But check edge to nearest_node eagerly here (since immediate)\n            if not cache_edge_free(nearest_node.position, q_new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, q_new_pos)\n            q_new = Node(q_new_pos, nearest_node, new_cost)\n            nearest_node.add_child(q_new)\n            tree_a.append(q_new)\n            nodes_all.append(q_new)\n            edges_all.append((nearest_node, q_new))\n            tree_cover_a.insert(q_new_pos, q_new)\n\n            # Adaptive rewiring radius depends on current size and best cost\n            radius = adaptive_radius(len(tree_a), best_cost)\n            rewire(tree_a, tree_cover_a, q_new, radius)\n\n            # Attempt connect to opposite tree near q_new\n            near_other = tree_cover_b.nearest(q_new.position)\n            if near_other is not None:\n                dist_conn = math.dist(q_new.position, near_other.position)\n                # Connect threshold relaxed with radius for anytime improvements\n                threshold = max(self.step_size * 1.6, radius)\n                if dist_conn <= threshold and cache_edge_free(q_new.position, near_other.position):\n                    candidate_cost = q_new.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-14 < best_cost:\n                        best_cost = candidate_cost\n                        best_pair = (q_new, near_other)\n                        raw_path = extract_path(best_pair[0], best_pair[1])\n                        # Anytime shortcutting incremental step\n                        shortened = shortcut_path(raw_path, self.shortcut_passes, self.shortcut_attempts)\n                        if (not best_path) or (len(shortened) < len(best_path)):\n                            best_path = shortened\n                            no_improve_cnt = 0\n                        else:\n                            no_improve_cnt +=1\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n            else:\n                no_improve_cnt += 1\n\n            # Periodic rebuilding cover trees for performance stability\n            if iter_i > 0 and iter_i % 50 == 0:\n                cover_start.rebuild([(n.position,n) for n in tree_start])\n                cover_goal.rebuild([(n.position,n) for n in tree_goal])\n\n            # Early stop if no improvement over patience\n            if best_path and no_improve_cnt >= self.early_stop_patience:\n                break\n\n        if best_path:\n            smoothed = smooth_path(best_path, self.smooth_iters)\n            return PlannerResult(True, smoothed, nodes_all, edges_all)\n        else:\n            return PlannerResult(False, [], nodes_all, edges_all)",
          "objective": -25.2934,
          "time_improvement": 35.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030253791809082033,
                    "num_nodes_avg": 199.6,
                    "path_length_avg": 183.53499532831353,
                    "smoothness_avg": 0.05372424486945132,
                    "success_improvement": 0.0,
                    "time_improvement": -17.304540349158078,
                    "node_improvement": 49.73558297658021,
                    "length_improvement": -0.5984392375601633,
                    "smoothness_improvement": 740.9010962719202,
                    "objective_score": -1.8459201659239195
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03470773696899414,
                    "num_nodes_avg": 289.3,
                    "path_length_avg": 237.79078662307307,
                    "smoothness_avg": 0.09570785169256846,
                    "success_improvement": 0.0,
                    "time_improvement": 79.03814508460205,
                    "node_improvement": 80.56171470805617,
                    "length_improvement": 20.618590996924894,
                    "smoothness_improvement": 2362.631959628963,
                    "objective_score": 47.895757921680364
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029233217239379883,
                    "num_nodes_avg": 256.7,
                    "path_length_avg": 125.30394103003316,
                    "smoothness_avg": 0.11862623908375855,
                    "success_improvement": 0.0,
                    "time_improvement": 42.394400540100946,
                    "node_improvement": 67.361729179911,
                    "length_improvement": 16.779088700331812,
                    "smoothness_improvement": 1408.917005067257,
                    "objective_score": 29.830358407565654
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an improved bidirectional Informed RRT* algorithm. It integrates elliptical informed sampling after an initial feasible path is found to concentrate search towards lower-cost solutions, adaptive rewiring radius based on tree cardinality and space dimension, and a gradient-based local smoothing post-processing to enhance path smoothness and length. The algorithm alternates tree expansions, rewires locally for cost improvements, attempts early tree connections, and continuously refines the path by restricting samples within the informed subset of the configuration space, improving planning efficiency, path quality, and convergence speed.",
          "planning_mechanism": "The algorithm starts growing two trees from start and goal positions using RRT* extensions. Initially, samples are uniform random with goal bias. Upon finding a first feasible path, the planner calculates an ellipsoidal informed sampling region tightly enclosing start and goal based on current best path cost, biasing new samples there. Nearby nodes are rewired using adaptive radius to improve costs. Early connection attempts between trees prune unnecessary expansions. After planning, a gradient-based smoothing is applied to the combined path to reduce sharp turns and shorten path length further, ensuring all nodes and edges respect collision constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.1, shortcut_iterations=120, smoothing_iters=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.0\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size * 1.5)\n\n        # Ellipse informed sampling helper\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoid centered between start and goal\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_best for i in range(dim))  # unit vector along start->goal\n\n            # Build orthonormal basis:\n            # Gram-Schmidt for higher dim (supporting 2D and 3D)\n            # We'll build transformation matrix with a1 as first column\n            import math as _math\n            # Create basis matrix Q = [a1, a2, a3,...]\n            orthonormal = [a1]\n            for i_dim in range(dim):\n                e = [0.0]*dim\n                e[i_dim] = 1.0\n                # Orthogonalize e wrt previous basis\n                for b in orthonormal:\n                    proj = sum(e[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        e[j] -= proj * b[j]\n                norm_e = math.sqrt(sum(v*v for v in e))\n                if norm_e > 1e-8:\n                    e = [v/norm_e for v in e]\n                    orthonormal.append(e)\n                if len(orthonormal) >= dim:\n                    break\n            Q = orthonormal[:dim]\n\n            # Radii of ellipse axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others]\n            elif dim == 3:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others, r_others]\n            else:\n                # For higher dim, fallback to bounding box sampling (should not occur here)\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Sample uniformly inside unit n-ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(px*px for px in x))\n                if norm_x > 1e-8:\n                    break\n            x_unit = [px/norm_x for px in x]\n            scale = random.uniform(0,1)**(1.0/dim)\n            x_scaled = [scale*v for v in x_unit]\n\n            # Map unit ball sample to ellipse point: center + Q * (radii * x_scaled)\n            sample = [center[i] + sum(Q[j][i]*radii[j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            # Clamp sample to map bounds\n            clamped = tuple(max(0.0, min(bounds[i], sample[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                return informed_sample(c_best)\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce length and sharp turns\n            # Random pairwise shortcutting with collision check\n            def check_shortcut(i,j):\n                return not is_edge_in_obstacle(path[i], path[j])\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if check_shortcut(i,j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def gradient_smooth_path(path, alpha=0.2, beta=0.4, iterations=40):\n            # Smooth path using gradient descent approach similar to path smoothing in PRM/RRT*\n            if len(path) < 3:\n                return path[:]\n            smoothed = [list(p) for p in path]\n            for _ in range(iterations):\n                for i in range(1,len(smoothed)-1):\n                    p = smoothed[i]\n                    p_old = p[:]\n                    # Smoothness term: pull point towards neighbors\n                    for d in range(dim):\n                        p[d] += alpha * (smoothed[i-1][d] + smoothed[i+1][d] - 2*p[d])\n                    # Data term: keeps it close to original vertex position\n                    for d in range(dim):\n                        p[d] += beta * (path[i][d] - p[d])\n\n                    # Clamp to bounds\n                    for d in range(dim):\n                        p[d] = max(0.0, min(bounds[d], p[d]))\n\n                    # Collision check for edges (i-1)-(i) and (i)-(i+1)\n                    prev_p = tuple(smoothed[i-1])\n                    nxt_p = tuple(smoothed[i+1])\n                    curr_p = tuple(p)\n                    if (is_in_obstacle(curr_p) or \n                        is_edge_in_obstacle(prev_p, curr_p) or \n                        is_edge_in_obstacle(curr_p, nxt_p)):\n                        # revert if invalid\n                        smoothed[i] = p_old\n                    else:\n                        smoothed[i] = p\n            return [tuple(p) for p in smoothed]\n\n        success = False\n        connection_pair = (None, None)\n        c_best = float('inf')\n        best_path_nodes = None\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point(c_best)\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connection with other tree within adaptive radius\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Build candidate path and update c_best if better\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    candidate_path_nodes = extract_path(node_start, node_goal)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path_nodes)-1):\n                        candidate_cost += dist(candidate_path_nodes[i], candidate_path_nodes[i+1])\n                    if candidate_cost < c_best:\n                        c_best = candidate_cost\n                        connection_pair = (node_start, node_goal)\n                        best_path_nodes = candidate_path_nodes\n                        success = True\n            if success and (it > 100 and it % 30 == 0):\n                # Early termination could be allowed if path cost is stable\n                break\n\n        path = []\n        if success and best_path_nodes:\n            # Post-processing: shortcut + gradient smoothing\n            path = shortcut_path(best_path_nodes)\n            path = gradient_smooth_path(path, iterations=self.smoothing_iters)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -24.91343,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04222602844238281,
                    "num_nodes_avg": 145.6,
                    "path_length_avg": 165.7015735704016,
                    "smoothness_avg": 0.03195078114288795,
                    "success_improvement": 0.0,
                    "time_improvement": -63.72509232767426,
                    "node_improvement": 63.33417275245531,
                    "length_improvement": 9.1763418166028,
                    "smoothness_improvement": 400.09910711794936,
                    "objective_score": -11.611227072750854
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934156894683838,
                    "num_nodes_avg": 346.2,
                    "path_length_avg": 234.8985415700393,
                    "smoothness_avg": 0.10549100772507927,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23952661781249,
                    "node_improvement": 76.7385607740375,
                    "length_improvement": 21.58410564428557,
                    "smoothness_improvement": 2614.3596108679344,
                    "objective_score": 48.89411942625476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02059016227722168,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 120.75685810991956,
                    "smoothness_avg": 0.12972022960082913,
                    "success_improvement": 0.0,
                    "time_improvement": 59.42599710311202,
                    "node_improvement": 67.60330578512396,
                    "length_improvement": 19.799044667050456,
                    "smoothness_improvement": 1550.031745571195,
                    "objective_score": 37.45738465901985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is an Informed Bidirectional RRT* (Informed Bi-RRT*) that grows two trees from start and goal positions. It integrates focused ellipsoidal sampling around the current best path for efficient exploration, combines asymptotically optimal rewiring for path improvement, and applies post-planning path shortcutting for smoothness enhancement. The approach balances fast convergence, robust path quality improvement, and smooth, shorter final paths by combining informed sampling, smart rewiring, and path shortcutting techniques.",
          "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal, using ellipsoidal informed sampling restricted to promising regions around the current shortest path cost. Each extension step rewires nearby nodes to improve path cost locally. Upon connecting trees, it extracts the path and applies iterative shortcutting to remove unnecessary waypoints and smooth rough turns. Early pruning of nodes and careful collision checks maintain robustness and computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=7000, step_size=7.0, radius_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor  # factor multiplied by step_size for rewiring radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        nodes = []\n\n        best_cost = float('inf')\n        best_path = []\n        connected = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def node_path_cost(node):\n            return node.cost\n\n        def is_collision_point(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_collision_edge(f, t):\n            d = dist(f, t)\n            steps = max(1, int(d / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(len(f)))\n                if is_collision_point(interp):\n                    return True\n            return False\n\n        def extract_path(node_start, node_goal):\n            path_from_start = []\n            n = node_start\n            while n:\n                path_from_start.append(n.position)\n                n = n.parent\n            path_from_goal = []\n            n = node_goal\n            while n:\n                path_from_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_from_start)) + path_from_goal\n\n        def radius():\n            # radius depends on dimension and step size, uses standard RRT* ball radius scaling with factor\n            dim = 3 if is_3d else 2\n            return max(self.step_size * self.radius_factor, self.step_size * (math.log(len(start_tree) + len(goal_tree) + 1) / (len(start_tree) + len(goal_tree) + 1)) ** (1/dim))\n\n        def near_nodes(tree, point, rad):\n            return [n for n in tree if dist(n.position, point) <= rad]\n\n        def informed_sample():\n            # If we have a path, sample inside ellipsoid defined by start, goal, and best_cost\n            if best_cost == float('inf'):\n                # no solution yet, sample uniformly in bounds\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_collision_point(p):\n                        return p\n            else:\n                # ellipsoidal sampling focused on the best path cost\n                c_min = dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    # Numerical safety: best_cost cannot be less than min dist (due to floating point)\n                    c_best = c_min\n                else:\n                    c_best = best_cost\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n\n                # Compute rotation matrix from standard basis to unit vector from start->goal\n                direction = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 0 else 0.0 for i in range(len(bounds)))\n                # For 2D or 3D, build a rotation matrix U aligning x axis to direction vector\n                # We'll do 2D and 3D separately to reduce complexity\n\n                def sample_unit_ball():\n                    # Uniformly sample a point in the unit ball in n-dim\n                    while True:\n                        sample = tuple(random.uniform(-1,1) for _ in range(len(bounds)))\n                        if sum(x*x for x in sample) <= 1:\n                            return sample\n\n                # Radii of ellipsoid axes (r1,...,rn)\n                r1 = c_best / 2.0\n                if is_3d:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    r3 = r2\n                    radii = (r1, r2, r3)\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    radii = (r1, r2)\n\n                # Sample point in unit ball\n                while True:\n                    unit_sample = sample_unit_ball()\n                    scaled = tuple(unit_sample[i]*radii[i] for i in range(len(bounds)))\n\n                    # Rotation matrix U aligns x-axis to direction vector\n                    # For 2D: construct 2D rotation matrix\n                    if not is_3d:\n                        ux, uy = direction[0], direction[1]\n                        rot_sample = (scaled[0]*ux - scaled[1]*uy, scaled[0]*uy + scaled[1]*ux)\n                    else:\n                        # For 3D, use Householder reflection or simple rotation by aligning vector\n                        # We'll approximate: let u = direction vector\n                        # Find orthonormal basis [u, v, w]\n                        # We'll do a simple alignment: assume u is normalized\n                        u = direction\n                        # arbitrary orthogonal vector to u\n                        if abs(u[0]) < 0.9:\n                            v = (1,0,0)\n                        else:\n                            v = (0,1,0)\n                        # make v orthonormal to u\n                        dot_uv = sum(u[i]*v[i] for i in range(3))\n                        v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                        v_len = math.sqrt(sum(x*x for x in v))\n                        if v_len > 0:\n                            v = tuple(x/v_len for x in v)\n                        else:\n                            # fallback orthogonal vector\n                            if abs(u[2]) < 0.9:\n                                v = (0,0,1)\n                            else:\n                                v = (1,0,0)\n                            dot_uv = sum(u[i]*v[i] for i in range(3))\n                            v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                            v_len = math.sqrt(sum(x*x for x in v))\n                            if v_len > 0:\n                                v = tuple(x/v_len for x in v)\n\n                        # w = u cross v\n                        w = (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n\n                        # scaled sample coords: [x,y,z]\n                        x, y, z = scaled\n                        rot_sample = (u[0]*x + v[0]*y + w[0]*z,\n                                      u[1]*x + v[1]*y + w[1]*z,\n                                      u[2]*x + v[2]*y + w[2]*z)\n\n                    point = tuple(center[i] + rot_sample[i] for i in range(len(bounds)))\n\n                    # Reject if out of bounds or in collision\n                    in_bounds = all(0 <= point[i] <= bounds[i] for i in range(len(bounds)))\n                    if in_bounds and not is_collision_point(point):\n                        return point\n\n        def try_extend(tree_from, tree_to):\n            nonlocal best_cost, best_path, connected\n            sample = informed_sample()\n            nearest = min(tree_from, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_collision_point(new_pos) or is_collision_edge(nearest.position, new_pos):\n                return False\n\n            # Create new node, find near nodes for rewiring\n            new_node = Node(new_pos)\n            near_rad = radius()\n            near = [n for n in tree_from if dist(n.position, new_pos) <= near_rad]\n\n            # Choose best parent minimizing cost\n            cost_min = nearest.cost + dist(nearest.position, new_pos)\n            parent_min = nearest\n            for p in near:\n                if not is_collision_edge(p.position, new_pos) and p.cost + dist(p.position, new_pos) < cost_min:\n                    cost_min = p.cost + dist(p.position, new_pos)\n                    parent_min = p\n            new_node.parent = parent_min\n            new_node.cost = cost_min\n            parent_min.add_child(new_node)\n            tree_from.append(new_node)\n\n            # Rewire near nodes if cheaper through new_node\n            for n in near:\n                if n is parent_min:\n                    continue\n                edge_cost = dist(new_node.position, n.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < n.cost and not is_collision_edge(new_node.position, n.position):\n                    # Change parent\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n\n            # Try to connect to other tree\n            nearest_other = min(tree_to, key=lambda node: dist(node.position, new_pos))\n            if dist(new_pos, nearest_other.position) <= self.step_size and not is_collision_edge(new_node.position, nearest_other.position):\n                # connection found, build path\n                connected = True\n                path = extract_path(new_node, nearest_other)\n                cost_path = 0.0\n                for i in range(len(path) - 1):\n                    cost_path += dist(path[i], path[i+1])\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    best_path = path\n                return True\n            return False\n\n        for i in range(self.max_iter):\n            if connected:\n                # Continue improving trees for better paths until iterations end\n                progressed = (try_extend(start_tree, goal_tree) or try_extend(goal_tree, start_tree))\n                if not progressed:\n                    break\n            else:\n                # Regular bidirectional grow\n                if try_extend(start_tree, goal_tree):\n                    connected = True\n                if not connected:\n                    try_extend(goal_tree, start_tree)\n\n        if not best_path:\n            # No path found\n            return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n        # Path shortcutting to smooth and shorten path\n        shortcut_path = self._shortcut_path(best_path, is_collision_point, is_collision_edge)\n\n        return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n    def _shortcut_path(self, path, is_collision_point, is_collision_edge, max_iter=150):\n        if len(path) <= 2:\n            return path[:]\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            # Try to shortcut between path[i] and path[j]\n            if not is_collision_edge(path[i], path[j]):\n                # Shortcut: remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
          "objective": -24.81658,
          "time_improvement": 30.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1375.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02101633548736572,
                    "num_nodes_avg": 109.5,
                    "path_length_avg": 172.32714291787394,
                    "smoothness_avg": 0.049746205597541,
                    "success_improvement": 0.0,
                    "time_improvement": 18.51231112692918,
                    "node_improvement": 72.4250818433644,
                    "length_improvement": 5.544762268388349,
                    "smoothness_improvement": 678.6361432159815,
                    "objective_score": 12.273731415191671
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017328310012817382,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 235.9789361832376,
                    "smoothness_avg": 0.0925726072219917,
                    "success_improvement": 0.0,
                    "time_improvement": 89.53450866755713,
                    "node_improvement": 88.21474165154875,
                    "length_improvement": 21.223438824965278,
                    "smoothness_improvement": 2281.9598611757096,
                    "objective_score": 51.00421520112486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05953328609466553,
                    "num_nodes_avg": 301.0,
                    "path_length_avg": 124.124788332228,
                    "smoothness_avg": 0.09950538690435078,
                    "success_improvement": 0.0,
                    "time_improvement": -17.313486408915992,
                    "node_improvement": 61.72917991099809,
                    "length_improvement": 17.562225776996367,
                    "smoothness_improvement": 1165.701176699687,
                    "objective_score": 11.171795427021458
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An Adaptive Bidirectional RRT* Planner with Relaxed Curvature Constraints, Progressive Sampling, and Enhanced Multi-Stage Smoothing to Accelerate Planning and Improve Path Smoothness and Length. This planner grows two trees simultaneously with adaptive rewiring radius that decays moderately without aggressive shrinking, enabling better connectivity early on. Sampling progressively shifts from uniform to ellipsoidal informed sampling with adjustable bias to improve exploration-exploitation balance over iterations. Curvature penalties and rewiring angle thresholds are relaxed moderately to allow more beneficial rewiring and parent changes, facilitating shorter and smoother paths. The planner invokes local shortcutting frequently with improved curvature-aware checks, followed by extended iterative smoothing with momentum-based acceptance to reduce curvature spikes robustly while avoiding excessive runtime. Efficient grid-based nearest neighbor searches and early pruning accelerate collision checks, and incremental cost propagation ensures consistent updates. Planning halts early once improvement stalls, balancing quality and time.",
          "planning_mechanism": "The planner alternates between expanding start and goal trees, sampling adaptively between uniform and ellipsoidal informed distributions that gradually bias search toward the corridor between start and goal. Upon node addition, a moderate adaptive radius determines nearby candidates for rewiring with relaxed curvature constraints allowing smoother, shorter paths. Frequent local shortcutting aggressively prunes suboptimal segments respecting curvature improvement, followed by momentum-enhanced iterative smoothing that progressively refines path smoothness. Early pruning of nodes outside bounds or in obstacles, combined with efficient spatial hashing for neighborhood queries, reduces planning iterations and collision checks. Incremental cost updates propagate improvements rapidly, and the algorithm terminates early when no significant cost improvement is observed over fixed iteration windows, ensuring high-quality paths in reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 initial_step=7.0,\n                 initial_radius=22.0,\n                 min_radius_factor=1.2,\n                 uniform_sample_decay_iter=800,\n                 local_shortcut_interval=8,\n                 max_local_shortcuts=100,\n                 curvature_alpha=1.6,\n                 max_rewire_angle_diff=2.2,  # relaxed ~126 deg\n                 smoothing_iters=25,\n                 smoothing_momentum=0.85,\n                 no_improve_stop=200):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.initial_radius = initial_radius\n        self.min_radius_factor = min_radius_factor\n        self.uniform_sample_decay_iter = uniform_sample_decay_iter\n        self.local_shortcut_interval = local_shortcut_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_alpha = curvature_alpha\n        self.max_rewire_angle_diff = max_rewire_angle_diff\n        self.smoothing_iters = smoothing_iters\n        self.smoothing_momentum = smoothing_momentum\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, step=0.3):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(1, int(dist / step))\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            ratio = step / dist\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        GRID_SIZE = self.initial_step * 2.8\n\n        def grid_hash(p):\n            return tuple(int(p[i] / GRID_SIZE) for i in range(dim))\n\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius * radius\n            gh = grid_hash(p)\n            shifts = [-1, 0, 1]\n            neighbors = []\n            if dim == 2:\n                cells = [(gh[0] + dx, gh[1] + dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 3\n            while expansions <= max_expansions:\n                if dim == 2:\n                    cells = [(gh[0] + dx, gh[1] + dy) for dx in range(-expansions, expansions + 1) for dy in\n                             range(-expansions, expansions + 1)]\n                else:\n                    cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in range(-expansions, expansions + 1) for dy in\n                             range(-expansions, expansions + 1) for dz in range(-expansions, expansions + 1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff * diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions += 1\n            if min_node is None:\n                all_nodes = []\n                for cellnodes in ht.values():\n                    all_nodes.extend(cellnodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position, p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        c_min = math.dist(start_pos, goal_pos)\n        vol_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost, iter_ratio):\n            if n_nodes <= 1:\n                return self.initial_step * 3.5\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            base_r = self.initial_radius * val\n            if best_cost < float('inf'):\n                base_r = min(base_r, best_cost * 0.33)\n            base_r = max(base_r, self.initial_step * self.min_radius_factor)\n            decay = max(0.5, 1.0 - iter_ratio * 0.5)  # slower decay for better connectivity\n            return base_r * decay\n\n        def angle_between(a, b, c):\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dot / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i] - parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i] - parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x * x for x in v1))\n            len2 = math.sqrt(sum(x * x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            cos_ang = max(min(dot / (len1 * len2), 1.0), -1.0)\n            angle = math.acos(cos_ang)\n            return angle * self.curvature_alpha\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            penalty = curvature_penalty(parent, child_pos)\n            return linear_cost + penalty\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-14 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def rewire(tree_hash, new_node, near_nodes):\n            # Allow relaxed curvature with max angle diff threshold and only rewire if cost gains sufficiently\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-14 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        angle_diff_ok = True\n                        if n.parent and n.parent.parent:\n                            angle_before = angle_between(n.parent.parent.position, n.parent.position, n.position)\n                            angle_after = angle_between(n.parent.position, new_node.position, n.position)\n                            angle_if = abs(angle_after - angle_before)\n                            if angle_if > self.max_rewire_angle_diff:\n                                angle_diff_ok = False\n                        if angle_diff_ok:\n                            if n.parent:\n                                n.parent.remove_child(n)\n                            n.parent = new_node\n                            n.cost = c_cost\n                            new_node.add_child(n)\n                            self._propagate_costs(n)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def ellipsoidal_informed_sample(best_cost, iteration):\n            # Progressive blend: Early iterations sample uniform; gradually bias toward ellipsoidal informed\n            blend_threshold = min(1.0, iteration / self.uniform_sample_decay_iter)\n            sample_use_informed = (random.random() < blend_threshold)\n            if best_cost == float('inf'):\n                sample_use_informed = False  # no path found yet, uniform sampling only\n\n            if not sample_use_informed:\n                attempts = 0\n                while attempts < 15:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            half_best = best_cost * 0.5\n            delta = best_cost * best_cost - c_min * c_min\n            a_rest = math.sqrt(max(delta, 0.0)) * 0.5 if delta > 0 else 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    norm_d = (d_vec[0] / length, d_vec[1] / length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s], [s, c]]\n                attempts = 0\n                while attempts < 50:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [half_best * ball[0], a_rest * ball[1]]\n                    candidate = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                    if in_bounds(candidate) and not collision_node(candidate):\n                        return candidate\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [d_vec[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = sqrt(sum(x * x for x in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [\n                            [I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)]\n                            for i in range(3)\n                        ]\n                attempts = 0\n                while attempts < 50:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x * x for x in ball) <= 1:\n                            break\n                    x_scaled = [half_best * ball[0], a_rest * ball[1], a_rest * ball[2]]\n                    candidate = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(candidate) and not collision_node(candidate):\n                        return candidate\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def attempt_expand(tree, tree_hash, other_tree_hash, sample, best_cost, iter_ratio):\n            nearest_node = nearest(tree_hash, sample)\n            if nearest_node is None:\n                return None\n            step = max(self.initial_step * (0.65 + 0.35 * (1 - iter_ratio)), 1.0)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not in_bounds(new_pos):\n                return None\n            if collision_node(new_pos):\n                return None\n            if collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree), best_cost, iter_ratio)\n            near_nodes = nearby_nodes(tree_hash, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost and not collision_edge(near.position, new_pos):\n                    min_cost = c\n                    min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            add_to_hash(tree_hash, new_node)\n\n            rewire(tree_hash, new_node, near_nodes)\n\n            other_near = nearest(other_tree_hash, new_node.position)\n            if other_near is None:\n                return None\n            dist_other = math.dist(other_near.position, new_node.position)\n            threshold = step * 1.22\n            if dist_other <= threshold and not collision_edge(other_near.position, new_node.position):\n                total_cost = new_node.cost + dist_other + other_near.cost\n                return (new_node, other_near, total_cost)\n            return None\n\n        def extract_nodes_edges(path):\n            nodes = []\n            edges = []\n            prev = None\n            for pos in path:\n                n = Node(pos)\n                nodes.append(n)\n                if prev is not None:\n                    edges.append((prev, n))\n                prev = n\n            return nodes, edges\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_local_shortcuts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    valid = True\n                    if i > 0 and j < len(new_path) - 1:\n                        ang_before = angle_between(new_path[i - 1], new_path[i], new_path[i + 1])\n                        ang_after = angle_between(new_path[i - 1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j + 1])\n                        if ang_after > ang_before * 1.38 or ang_after2 > math.pi * 0.93:\n                            valid = False\n                    if valid:\n                        del new_path[i + 1:j]\n                        attempts += 1\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            return new_path\n\n        def gaussian_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            pts = [list(p) for p in path]\n            momentum = self.smoothing_momentum\n            prev_cost = None\n            for _ in range(self.smoothing_iters):\n                changed = False\n                new_pts = [pts[0][:]]\n                for i in range(1, len(pts) - 1):\n                    prev_pt = pts[i - 1]\n                    curr_pt = pts[i]\n                    next_pt = pts[i + 1]\n                    avg_pt = [(prev_pt[d] + curr_pt[d] * 4 + next_pt[d]) / 6.0 for d in range(dim)]\n                    if not collision_node(tuple(avg_pt)) and not collision_edge(tuple(prev_pt), tuple(avg_pt)) \\\n                            and not collision_edge(tuple(avg_pt), tuple(next_pt)):\n                        ang_before = angle_between(tuple(prev_pt), tuple(curr_pt), tuple(next_pt))\n                        ang_after = angle_between(tuple(prev_pt), tuple(avg_pt), tuple(next_pt))\n                        accept = False\n                        if ang_after <= ang_before:\n                            accept = True\n                        else:\n                            if ang_after <= ang_before * 1.1:\n                                accept = True\n                        if accept:\n                            # Momentum-based interpolation between avg_pt and curr_pt\n                            interp_pt = [curr_pt[d] * momentum + avg_pt[d] * (1 - momentum) for d in range(dim)]\n                            new_pts.append(interp_pt)\n                            changed = True\n                        else:\n                            new_pts.append(curr_pt)\n                    else:\n                        new_pts.append(curr_pt)\n                new_pts.append(pts[-1][:])\n                pts = new_pts\n                # Optional early stop if no change or smoothness cost doesn't improve significantly\n                # Compute rough smoothness cost: sum of curvature angles\n                def smoothness_cost(pnts):\n                    cost = 0.0\n                    for k in range(1, len(pnts) - 1):\n                        cost += angle_between(pnts[k - 1], pnts[k], pnts[k + 1])\n                    return cost\n\n                current_cost = smoothness_cost(pts)\n                if prev_cost is not None and (prev_cost - current_cost) < 1e-4:\n                    break\n                prev_cost = current_cost\n                if not changed:\n                    break\n            return [tuple(p) for p in pts]\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        start_hash = {}\n        goal_hash = {}\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        last_improvement_iter = 0\n\n        for it in range(1, self.max_iter + 1):\n            iter_ratio = it / self.max_iter\n            sample = ellipsoidal_informed_sample(best_cost, it)\n\n            # Expand alternately start and goal trees with reversed seq every iteration\n            if it % 2 == 1:\n                seq = [(start_tree, start_hash, goal_hash), (goal_tree, goal_hash, start_hash)]\n            else:\n                seq = [(goal_tree, goal_hash, start_hash), (start_tree, start_hash, goal_hash)]\n\n            improved_this_iter = False\n            for tree, tree_hash, other_hash in seq:\n                res = attempt_expand(tree, tree_hash, other_hash, sample, best_cost, iter_ratio)\n                if res:\n                    new_node, conn_node, candidate_cost = res\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        last_improvement_iter = it\n                        improved_this_iter = True\n                        if tree is start_tree:\n                            best_start_node, best_goal_node = new_node, conn_node\n                        else:\n                            best_start_node, best_goal_node = conn_node, new_node\n\n            # Early stop if no improvement for no_improve_stop iterations\n            if it - last_improvement_iter > self.no_improve_stop and best_cost < float('inf'):\n                break\n\n            # Frequent local shortcut and smoothing to prune\n            if best_cost < float('inf') and best_start_node and best_goal_node:\n                if it % self.local_shortcut_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_start_node, best_goal_node)\n                    shortcutted = local_shortcut(raw_path)\n                    smoothed = gaussian_smooth(shortcutted)\n                    nodes_out, edges_out = extract_nodes_edges(smoothed)\n                    return PlannerResult(True, smoothed, nodes_out, edges_out)\n\n        # If no path found, return failure with all nodes and no edges\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -24.74655,
          "time_improvement": 38.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1317.0,
          "node_improvement": 98.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030016565322875978,
                    "num_nodes_avg": 14.1,
                    "path_length_avg": 179.9872449276465,
                    "smoothness_avg": 0.03556942969605148,
                    "success_improvement": 0.0,
                    "time_improvement": -16.384730227549014,
                    "node_improvement": 96.44925711407706,
                    "length_improvement": 1.3461389747480768,
                    "smoothness_improvement": 456.7388149960638,
                    "objective_score": -1.824041608435539
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027966880798339845,
                    "num_nodes_avg": 7.1,
                    "path_length_avg": 239.23197112424504,
                    "smoothness_avg": 0.0946968940862508,
                    "success_improvement": 0.0,
                    "time_improvement": 83.10930792593194,
                    "node_improvement": 99.52294564267957,
                    "length_improvement": 20.137482128237867,
                    "smoothness_improvement": 2336.6192922550786,
                    "objective_score": 48.6983781159977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02747805118560791,
                    "num_nodes_avg": 6.6,
                    "path_length_avg": 130.92330873802592,
                    "smoothness_avg": 0.09876166849570775,
                    "success_improvement": 0.0,
                    "time_improvement": 45.85304800443131,
                    "node_improvement": 99.16083916083916,
                    "length_improvement": 13.04697223421844,
                    "smoothness_improvement": 1156.2411334373305,
                    "objective_score": 27.365303409047108
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner employing simplified adaptive radius rewiring and refined elliptical informed sampling, combined with efficient collision checking and iterative cautious shortcutting to improve path length and smoothness while maintaining fast convergence and robustness. The planner symmetrically grows trees from start and goal, samples within an informed ellipsoid adapting to the best found path, selects parents minimizing cost with collision-free edges, and performs local rewiring. Periodic cautious shortcutting is applied to enhance smoothness without sharp deviations, balancing exploration and exploitation efficiently.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal alternately, samples points using goal-biased uniform sampling or elliptical informed sampling based on current best cost. It extends trees toward samples with fixed step size, selects optimal parents within an adaptive neighborhood radius, and rewires nearby nodes if cost improves without collision. Trees attempt connection each iteration within step size. Upon connection, the path is extracted and improved via cautious multi-pass shortcutting that avoids sharp turns, outputting a collision-free, smoother, shorter path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, r_min=5.0, r_max=25.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def node_collision(p):\n            px, py = p[0], p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            dist_val = dist(a, b)\n            steps = max(1, int(dist_val / resolution))\n            for s in range(steps + 1):\n                t = s / steps\n                interp = tuple(a[i] + t * (b[i] - a[i]) for i in range(dim))\n                if node_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 35.0\n            val = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample(best_cost):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n            # informed ellipse sampling\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                foci_dist = c_min\n                val = c_best * c_best - foci_dist * foci_dist\n                r1 = c_best / 2.0\n                r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-8:\n                            u = [x / norm for x in vec]\n                            r = random.random() ** (1.0 / dim)\n                            return [u[i] * r for i in range(dim)]\n\n                while True:\n                    u_sample = unit_ball_sample()\n                    sample_pt = [0.0] * dim\n                    sample_pt[0] = u_sample[0] * r1\n                    for i in range(1, dim):\n                        sample_pt[i] = u_sample[i] * r_rest\n                    pt = tuple(center[i] + sample_pt[i] for i in range(dim))\n                    if in_bounds(pt) and not node_collision(pt):\n                        return pt\n            else:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_node = n\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def update_costs(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-14 < child.cost:\n                    child.cost = new_cost\n                    update_costs(child)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=4, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path) - 2 and attempts < max_attempts:\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    if edge_collision(new_path[i], new_path[j]):\n                        i += 1\n                        attempts += 1\n                        continue\n                    # Check turning angles to avoid sharp bends\n                    def angle(a, b, c):\n                        import math\n                        ab = [b[d] - a[d] for d in range(dim)]\n                        cb = [b[d] - c[d] for d in range(dim)]\n                        lab = math.sqrt(sum(x * x for x in ab))\n                        lcb = math.sqrt(sum(x * x for x in cb))\n                        if lab < 1e-8 or lcb < 1e-8:\n                            return 0\n                        dot = sum(ab[d] * cb[d] for d in range(dim))\n                        val = max(min(dot / (lab * lcb), 1.0), -1.0)\n                        return math.acos(val)\n\n                    cond = True\n                    if i > 0:\n                        a, b, c = new_path[i - 1], new_path[i], new_path[j]\n                        if angle(a, b, c) > 3 * math.pi / 4:  # >135 degrees\n                            cond = False\n                    if cond and j < len(new_path) - 1:\n                        a, b, c = new_path[i], new_path[j], new_path[j + 1]\n                        if angle(a, b, c) > 3 * math.pi / 4:\n                            cond = False\n                    if cond:\n                        new_path = new_path[:i + 1] + new_path[j:]\n                        improved = True\n                        i = 0\n                        attempts += 1\n                    else:\n                        i += 1\n                        attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        for it in range(self.max_iter):\n            pt = sample(best_cost)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, pt)\n            new_pos = steer(nearest_node.position, pt)\n\n            if not in_bounds(new_pos):\n                continue\n            if node_collision(new_pos):\n                continue\n            if edge_collision(nearest_node.position, new_pos):\n                continue\n\n            r = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for cand in near_nodes:\n                if cand is nearest_node:\n                    continue\n                cost_cand = cand.cost + dist(cand.position, new_pos)\n                if cost_cand + 1e-14 < min_cost and not edge_collision(cand.position, new_pos):\n                    min_cost = cost_cand\n                    min_parent = cand\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent or near_node is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-14 < near_node.cost and not edge_collision(new_node.position, near_node.position):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    update_costs(near_node)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_con = dist(nearest_other.position, new_node.position)\n            if dist_con <= self.step_size and not edge_collision(nearest_other.position, new_node.position):\n                total_cost = new_node.cost + dist_con + nearest_other.cost\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        solution_nodes = (new_node, nearest_other)\n                    else:\n                        solution_nodes = (nearest_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and (it % 60 == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n                if short_path:\n                    return PlannerResult(True, short_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n            return PlannerResult(True, short_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.49867,
          "time_improvement": 49.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 442.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022717666625976563,
                    "num_nodes_avg": 183.8,
                    "path_length_avg": 169.35702476940347,
                    "smoothness_avg": 0.023703810745518868,
                    "success_improvement": 0.0,
                    "time_improvement": 11.91565479849687,
                    "node_improvement": 53.714429614706624,
                    "length_improvement": 7.172731090098877,
                    "smoothness_improvement": 271.0161118162685,
                    "objective_score": 9.233415652689729
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032560324668884276,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 255.25648444467683,
                    "smoothness_avg": 0.02286526971496877,
                    "success_improvement": 0.0,
                    "time_improvement": 80.33508199289592,
                    "node_improvement": 80.58187193442183,
                    "length_improvement": 14.788038341835955,
                    "smoothness_improvement": 488.33985895423257,
                    "objective_score": 35.41504689774151
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0229816198348999,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 126.47150951572493,
                    "smoothness_avg": 0.05237959417986045,
                    "success_improvement": 0.0,
                    "time_improvement": 54.71350360419659,
                    "node_improvement": 71.13795295613478,
                    "length_improvement": 16.003645305772068,
                    "smoothness_improvement": 566.2645717083553,
                    "objective_score": 28.847561123263993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A refined bidirectional RRT* planner incorporating adaptive informed sampling focused on progressively shrinking ellipsoidal regions, combined rewiring with multi-scale neighborhoods for fine and coarse optimization, and hierarchical smoothing via iterative shortcutting and curvature-based node pruning to yield minimal path length and enhanced smoothness efficiently. The planner adapts radius heuristics by tree density and dimension, performs dynamic rewiring for both local and extended neighborhoods, and aggressively shortcuts with curvature checks to remove zigzags and redundant nodes, reducing planning time and improving path quality.",
          "planning_mechanism": "The planner alternates expanding start and goal trees using goal-biased and informed sampling within ellipsoids defined by the current best solution cost to restrict unnecessary exploration. Upon adding nodes, it chooses optimal parents from a two-tier neighborhood (small and large radius) to balance local and global optimization and rewires neighbors accordingly. After connecting trees, it extracts a path that undergoes iterative shortcutting combined with curvature-driven pruning to remove short sharp turns, improving smoothness and path minimality. This integrated approach accelerates convergence to shorter, smoother paths with reduced total planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.0, radius_const=28.0, goal_bias=0.12, shortcut_interval=30, curvature_tol=0.22):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_const = radius_const\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n        self.curvature_tol = curvature_tol  # radians threshold for pruning\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        dist_start_goal = math.dist(start_pos, goal_pos)\n\n        def radius(n):\n            # Adaptive radius with constants tuned for near-optimal rewiring\n            return min(self.radius_const * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 35)\n\n        def radius_small(n):\n            # Smaller radius for fine rewiring (local neighborhood)\n            return min(0.42 * self.step_size * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 15)\n\n        def near(tree, pos, r):\n            r_sq = r * r\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def informed_sample(c_max):\n            if c_max == float('inf'):\n                return sample_free()\n            if random.random() < self.goal_bias:\n                return goal_pos\n            # Ellipsoidal informed sampling around start to goal line\n            c_min = dist_start_goal\n            if c_max <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if length == 0:\n                return sample_free()\n\n            # Rotation matrix from unit x-axis vector to direction vector\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                a1 = (1, 0)\n                a2 = (dir_vec[0] / length, dir_vec[1] / length)\n                cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                R = [[cos_theta, -sin_theta],\n                     [sin_theta, cos_theta]]\n                r = random.random() ** 0.5\n                theta = random.uniform(0, 2 * math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                a1_val = c_max / 2.0\n                a_other = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                L = [[a1_val, 0], [0, a_other]]\n                x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                            L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                      center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n            else:\n                from math import sqrt\n                # 3D rotation from [1,0,0] to normalized dir_vec\n                a1 = [1, 0, 0]\n                a2 = [dir_vec[i] / length for i in range(3)]\n                v = [a1[1] * a2[2] - a1[2] * a2[1],\n                     a1[2] * a2[0] - a1[0] * a2[2],\n                     a1[0] * a2[1] - a1[1] * a2[0]]\n                s = sqrt(sum(vi * vi for vi in v))\n                c = sum(a1[i] * a2[i] for i in range(3))\n                if s == 0:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    vx = [[0, -v[2], v[1]],\n                          [v[2], 0, -v[0]],\n                          [-v[1], v[0], 0]]\n                    I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2)) for j in range(3)] for i in range(3)]\n\n                while True:\n                    x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                    norm_sq = sum(xi * xi for xi in x_ball)\n                    if norm_sq <= 1:\n                        break\n                a1_val = c_max / 2.0\n                a_other = sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Clamp sample inside bounds and avoid obstacles\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                return sample_free()\n            if in_obstacle(pt):\n                return sample_free()\n            return pt\n\n        def extract_path(nstart, ngoal):\n            # Path from nstart to root\n            ps = []\n            node = nstart\n            while node:\n                ps.append(node.position)\n                node = node.parent\n            ps.reverse()\n            # Path from ngoal to root (skip root because goal repeated)\n            pg = []\n            node = ngoal\n            while node:\n                pg.append(node.position)\n                node = node.parent\n            # join paths\n            return ps + pg\n\n        def curvature(pA, pB, pC):\n            # Calculate the curvature from three points (A,B,C)\n            # Using cosine law formula for angle at B\n            import math\n            def dist(u, v):\n                return math.dist(u, v)\n            a = dist(pB, pC)\n            b = dist(pA, pC)\n            c = dist(pA, pB)\n            if a * c == 0:\n                return 0.0\n            cos_angle = (a * a + c * c - b * b) / (2 * a * c)\n            cos_angle = min(1.0, max(-1.0, cos_angle))\n            return math.acos(cos_angle)\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    # Replace intermediate nodes [i+1...j-1]\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def prune_curvature(path):\n            # Remove nodes creating sharp small bends iteratively\n            if len(path) < 4:\n                return path[:]\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                n = len(new_path)\n                i = 1\n                while i < n - 1:\n                    angle = curvature(new_path[i - 1], new_path[i], new_path[i + 1])\n                    if angle < self.curvature_tol:\n                        # Try removing node i if edge between neighbors collision free\n                        if not edge_in_obstacle(new_path[i - 1], new_path[i + 1]):\n                            new_path.pop(i)\n                            n -= 1\n                            changed = True\n                            # Do not increment i, test new triple from same index\n                            continue\n                    i += 1\n            return new_path\n\n        def attach_new_node(tree, new_pos):\n            n_nodes = len(tree)\n            new_node = Node(new_pos)\n            # Near nodes large radius\n            R_big = radius(n_nodes)\n            near_big = near(tree, new_pos, R_big)\n            # Near nodes smaller radius for fine rewiring\n            R_small = radius_small(n_nodes)\n            near_small = near(tree, new_pos, R_small)\n            if len(near_big) == 0:\n                # Fallback to nearest as parent if no near\n                nearest = min(tree, key=lambda n: math.dist(n.position, new_pos))\n                if edge_in_obstacle(nearest.position, new_pos):\n                    return None\n                new_node.parent = nearest\n                new_node.cost = nearest.cost + math.dist(nearest.position, new_pos)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n\n            # Choose best parent from large radius near neighbors with collision-free edge\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in near_big:\n                if edge_in_obstacle(neighbor.position, new_pos):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n            if best_parent is None:\n                return None\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n\n            # Rewire: first use large radius neighbors to check global improvement\n            for neighbor in near_big:\n                if neighbor is best_parent:\n                    continue\n                if edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    # Update parent of neighbor to new_node\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        old_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n\n            # Further, perform finer rewiring with smaller radius neighbors to polish local connections\n            for neighbor in near_small:\n                if neighbor is best_parent:\n                    continue\n                if edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        old_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n\n            return new_node\n\n        for iteration in range(self.max_iter):\n            c_max_use = best_cost if best_cost < float('inf') else float('inf')\n            x_rand = informed_sample(c_max_use)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, x_rand))\n                new_pos = steer(nearest.position, x_rand, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n                new_node = attach_new_node(tree_a, new_pos)\n                if new_node is None:\n                    continue\n\n                # Try to connect the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not edge_in_obstacle(new_node.position, nearest_other.position):\n                    path_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if path_cost + 1e-7 < best_cost:\n                        best_cost = path_cost\n                        # Mark connection direction for path extraction\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, nearest_other\n                        else:\n                            solution_start, solution_goal = nearest_other, new_node\n\n            # Progressive shortcutting and smoothing after some improvements or interval\n            if best_cost < float('inf') and solution_start and solution_goal and (iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1):\n                raw_path = extract_path(solution_start, solution_goal)\n                # Iteratively shortcut path aggressively with pruning\n                shorted = shortcut_path(raw_path, max_attempts=120)\n                pruned = prune_curvature(shorted)\n                if pruned and len(pruned) >= 2:\n                    return PlannerResult(True, pruned, nodes, edges)\n\n        # Return failure and last best nodes/edges if no path found\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.38604,
          "time_improvement": 26.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1581.0,
          "node_improvement": 100.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02613198757171631,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 166.51088262332885,
                    "smoothness_avg": 0.05025803213293863,
                    "success_improvement": 0.0,
                    "time_improvement": -1.3228625970076129,
                    "node_improvement": 99.49634852681945,
                    "length_improvement": 8.73274670037076,
                    "smoothness_improvement": 686.6473399440655,
                    "objective_score": 8.2760259408405
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03163425922393799,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 241.39906339940762,
                    "smoothness_avg": 0.0971089706431334,
                    "success_improvement": 0.0,
                    "time_improvement": 80.89438234475895,
                    "node_improvement": 99.86561849089566,
                    "length_improvement": 19.414044350496003,
                    "smoothness_improvement": 2398.683759412188,
                    "objective_score": 47.91016011078622
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05096986293792725,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 128.45238253246742,
                    "smoothness_avg": 0.13822002357252447,
                    "success_improvement": 0.0,
                    "time_improvement": -0.43880852679198545,
                    "node_improvement": 99.74570883661794,
                    "length_improvement": 14.688043767088448,
                    "smoothness_improvement": 1658.1484975016301,
                    "objective_score": 16.971926189723625
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner that uses a hybrid sampling strategy blending uniform and ellipsoidal informed samples, employs an adaptive rewiring radius based on both tree size and best path cost, and improves path quality and smoothness through incremental shortcutting combined with periodic global smoothing. The planner performs efficient nearest neighbor searches, dynamic rewiring, and early solution updating to boost planning speed, path length minimization, and path smoothness.",
          "planning_mechanism": "The planner alternately grows two trees from the start and goal points by sampling points within a combination of uniform and shrinking ellipsoidal informed regions. Each newly added node rewires nearby nodes within an adaptive radius that scales with the number of tree nodes and current best solution cost. Incremental local shortcutting is applied frequently, and global smoothing runs periodically to enhance path smoothness. Connections between the two trees happen based on an adaptive connection threshold derived from the rewiring radius. The planner returns the first significantly improved feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n    \n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, gamma=25.0, max_shortcut_attempts=120, goal_bias=0.1, global_smooth_interval=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_bias = goal_bias\n        self.global_smooth_interval = global_smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.35):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            new_point = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            clipped = tuple(max(0, min(bounds[i], new_point[i])) for i in range(dim))\n            return clipped\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d2 += diff * diff\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near_radius(num_nodes, cost_bound):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r1 = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            r2 = self.step_size * max(2.5, min(15.0, cost_bound / (c_min + 1e-8)))\n            return min(r1, r2)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                dist2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    dist2 += diff * diff\n                if dist2 <= r2:\n                    result.append(n)\n            return result\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        update_parent(c, current, new_cost)\n                        stack.append(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            attempts_limit = min(self.max_shortcut_attempts, max(30, int(len(pth)/1.5)))\n            attempts = 0\n            while attempts < attempts_limit:\n                if len(pth) <3:\n                    break\n                i = random.randint(0, len(pth)-3)\n                j = random.randint(i+2, len(pth)-1)\n                if not edge_in_obstacle(pth[i], pth[j]):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        def global_smooth(path):\n            # simple global smoothing by iterating attempts to replace segments with direct edges\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            length = len(pth)\n            for _ in range(min(self.max_shortcut_attempts//2, length*2)):\n                i = random.randint(0, length-3)\n                j = random.randint(i+2, length-1)\n                if not edge_in_obstacle(pth[i], pth[j]):\n                    pth = pth[:i+1] + pth[j:]\n                    length = len(pth)\n            return pth\n\n        def sample_hybrid():\n            # With probability goal_bias, sample goal\n            if random.random() < self.goal_bias and not in_obstacle(goal_pos):\n                return goal_pos\n            # If no solution yet or best_cost close to c_min, uniform sampling\n            if best_cost == float('inf') or best_cost <= c_min * 1.05:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            # Else ellipsoidal informed sampling blended with uniform exploration with probabilistic mixing\n            if random.random() < 0.7:\n                # ellipsoidal informed sampling\n                center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n                direction = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = c_min\n                if dim == 2:\n                    if length < 1e-12:\n                        R = [[1,0],[0,1]]\n                    else:\n                        a1 = [1,0]\n                        a2 = [direction[0]/length, direction[1]/length]\n                        cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                        sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                        R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                else:\n                    if length < 1e-12:\n                        R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                    else:\n                        a1 = [1,0,0]\n                        a2 = [direction[i]/length for i in range(dim)]\n                        v = [a1[1]*a2[2]-a1[2]*a2[1],\n                             a1[2]*a2[0]-a1[0]*a2[2],\n                             a1[0]*a2[1]-a1[1]*a2[0]]\n                        s = math.sqrt(sum(vi*vi for vi in v))\n                        c = sum(a1[i]*a2[i] for i in range(dim))\n                        if s < 1e-12:\n                            R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                        else:\n                            vx = [[0,-v[2],v[1]],\n                                  [v[2],0,-v[0]],\n                                  [-v[1],v[0],0]]\n                            I = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                            vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(dim)) for j in range(dim)] for i in range(dim)]\n                            R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(dim)] for i in range(dim)]\n                a1_val = best_cost*0.5\n                a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))*0.5\n                while True:\n                    if dim ==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        L = [[a1_val,0],[0,a_other]]\n                        x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                    L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                        pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                              center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    else:\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(dim)]\n                            if sum(xi*xi for xi in x_ball) <= 1:\n                                break\n                        L = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            for j in range(dim):\n                                L[i][j] = 0.0\n                        L[0][0] = a1_val\n                        for i in range(1, dim):\n                            L[i][i] = a_other\n                        x_scaled = [sum(L[i][j]*x_ball[j] for j in range(dim)) for i in range(dim)]\n                        pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                        continue\n                    if in_obstacle(pt):\n                        continue\n                    return pt\n            else:\n                # Uniform exploration sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n\n        def attempt_extend(tree_from, tree_to, sample, cost_bound):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = near_radius(len(tree_from), cost_bound)\n            near_nodes = near(tree_from, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-12 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-12 < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            max_connect_dist = r\n            if dist_connect <= max_connect_dist and not edge_in_obstacle(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        path = None\n        for it in range(1, self.max_iter + 1):\n            sample = sample_hybrid()\n            for tree_a, tree_b in ((start_tree, goal_tree), (goal_tree, start_tree)):\n                res = attempt_extend(tree_a, tree_b, sample, best_cost if best_cost != float('inf') else 1e9)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        raw_path = extract_path(sol_start, sol_goal)\n                        path = incremental_shortcut(raw_path)\n                        if it % self.global_smooth_interval == 0:\n                            path = global_smooth(path)\n                        if path and len(path) >= 2:\n                            return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.32893,
          "time_improvement": 30.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1345.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025517725944519044,
                    "num_nodes_avg": 123.1,
                    "path_length_avg": 170.34272343598496,
                    "smoothness_avg": 0.034596724076046935,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0588447369758993,
                    "node_improvement": 69.0002518257366,
                    "length_improvement": 6.6324540315506555,
                    "smoothness_improvement": 441.51385977893085,
                    "objective_score": 6.504695138917817
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04263021945953369,
                    "num_nodes_avg": 287.0,
                    "path_length_avg": 241.88838424645087,
                    "smoothness_avg": 0.09472703358432175,
                    "success_improvement": 0.0,
                    "time_improvement": 74.25333503821882,
                    "node_improvement": 80.71625344352617,
                    "length_improvement": 19.25069496743331,
                    "smoothness_improvement": 2337.3948032490475,
                    "objective_score": 45.51339150817087
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0426234245300293,
                    "num_nodes_avg": 313.8,
                    "path_length_avg": 125.75611555299454,
                    "smoothness_avg": 0.10658790176329103,
                    "success_improvement": 0.0,
                    "time_improvement": 16.008289440735243,
                    "node_improvement": 60.10171646535283,
                    "length_improvement": 16.478775912417827,
                    "smoothness_improvement": 1255.7902429285402,
                    "objective_score": 20.968703594313972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A dual-tree bidirectional planner utilizing adaptive sampling between uniform and informed ellipsoidal distributions with an enhanced smoothing post-processing phase. The planner implements curvature-aware adaptive shortcutting combined with a spline-based global smooth, enabling smooth, low-cost paths with efficient rewiring tuned by node density and path quality. Trees alternate extensions toward strategic samples; rewiring is dynamically bounded by a cost- and density-dependent radius. Connection attempts adapt to local conditions to accelerate convergence. Both incremental and global smoothings employ curvature and length considerations to reduce jaggedness organically, while collision checks prune invalid expansions early, resulting in faster planning times, shorter paths, and improved path smoothness.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, sampling adaptively from uniform or ellipsoidal distributions guided by current best cost. Each iteration selects which tree to extend towards the sample, adding a new node steered stepwise with collision checks. Neighborhood rewiring optimizes path cost with a radius scaled via node count and best known path. When opposite trees connect, the path is extracted and immediately improved by curvature-sensitive incremental shortcuts. Periodically, a global smoothing pass using a cubic spline reduces curvature overall without overshooting or abrupt changes. The process stops early when a sufficiently good path is found, balancing speed and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, goal_sample_rate=0.07,\n                 shortcut_attempts=40, global_smooth_freq=300, uniform_sample_rate=0.25,\n                 r_min=4.0, r_max=30.0, curvature_thresh=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.curvature_thresh = curvature_thresh\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.4):\n            dist_ab = dist(a, b)\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                diff_sq = 0.0\n                for i in range(dim):\n                    d_i = n.position[i] - point[i]\n                    diff_sq += d_i * d_i\n                if diff_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-14) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample_point():\n            if best_cost == float('inf'):\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            if random.random() < self.uniform_sample_rate:\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            params = compute_ellipsoid_params()\n            if params is None:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * ball[0], b * ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(num_nodes):\n            if num_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(num_nodes) / num_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            if best_cost < float('inf') and best_cost > 0:\n                dist_base = dist(start_pos, goal_pos)\n                ratio = max(0.25, min(1.0, best_cost / (dist_base * 2.5)))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a, b, c):\n            # angle at b formed by points a-b-c in radians, dim>=2\n            v1 = [a[i] - b[i] for i in range(dim)]\n            v2 = [c[i] - b[i] for i in range(dim)]\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-14 or norm2 < 1e-14:\n                return 0.0\n            val = max(-1.0, min(1.0, dot / (norm1 * norm2)))\n            return math.acos(val)\n\n        def curvature_sensitive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if is_edge_in_obstacle(new_path[i], new_path[j]):\n                    attempts += 1\n                    continue\n                # Estimate local curvature before and after shortcut\n                def local_curvature(idx):\n                    if idx <= 0 or idx >= len(new_path) - 1:\n                        return 0.0\n                    return angle_between(new_path[idx - 1], new_path[idx], new_path[idx + 1])\n\n                # Current max curvature in segment [i+1..j-1]\n                curr_max_curve = 0.0\n                for k in range(i + 1, j):\n                    c = local_curvature(k)\n                    if c > curr_max_curve:\n                        curr_max_curve = c\n\n                # Curvature after shortcut at i\n                # New connection from i to j replaces intermediate nodes, estimate curvature at i and j edges\n                after_curve_i = 0.0\n                if 0 < i < len(new_path) -1 and j < len(new_path):\n                    after_curve_i = local_curvature(i)\n\n                after_curve_j = 0.0\n                if 0 < j < len(new_path) - 1 and i >= 0:\n                    after_curve_j = local_curvature(j)\n\n                max_after_curve = max(after_curve_i, after_curve_j)\n                if max_after_curve <= max(curr_max_curve, self.curvature_thresh):\n                    # Accept shortcut\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def catmull_rom_spline(points, n_points=100):\n            # 1D Catmull-Rom spline for each dimension to smooth the path globally\n            # Handles 2D and 3D points, linear interpolation on edges for clamping endpoints\n            if len(points) < 4:\n                return points[:]\n            def sample_segment(p0, p1, p2, p3, n):\n                res = []\n                for t_i in range(n):\n                    t = t_i / (n - 1)\n                    t2 = t * t\n                    t3 = t2 * t\n                    def c(t, p0, p1, p2, p3):\n                        return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\n                    pt = tuple(\n                        c(t, p0[d], p1[d], p2[d], p3[d])\n                        for d in range(dim)\n                    )\n                    res.append(pt)\n                return res\n\n            smoothed = []\n            for i in range(len(points) - 3):\n                seg = sample_segment(points[i], points[i + 1], points[i + 2], points[i + 3], n_points // (len(points) - 3))\n                smoothed.extend(seg if i == 0 else seg[1:])\n            return smoothed\n\n        def global_smooth(path):\n            if len(path) < 4:\n                # fallback to shortcutting only if spline not possible\n                return curvature_sensitive_shortcut(path)\n            # Apply curvature-sensitive shortcutting first\n            path = curvature_sensitive_shortcut(path)\n            # Then apply spline smoothing\n            spline_path = catmull_rom_spline(path, n_points=120)\n            # Verify collision free spline segments between sampled spline points (check every 3rd point for speed)\n            verified_path = [spline_path[0]]\n            idx = 0\n            while idx < len(spline_path) - 1:\n                next_idx = min(len(spline_path) - 1, idx + 3)\n                if is_edge_in_obstacle(spline_path[idx], spline_path[next_idx]):\n                    # If collision, fallback to previous point and skip smoothing partial\n                    # Insert intermediate points linearly for fallback\n                    verified_path.append(spline_path[next_idx])\n                    idx = next_idx\n                else:\n                    verified_path.append(spline_path[next_idx])\n                    idx = next_idx\n            return verified_path\n\n        for iteration in range(self.max_iter):\n            sample_pos = sample_point()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if iteration % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            neighbors = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for candidate in neighbors:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential cost improvement\n            for nbr in neighbors:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Try connect two trees if close enough\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            connect_thresh = min(self.step_size * 1.7, rewiring_radius(len(tree_to_extend)))\n\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                path_cost = new_node.cost + dist_connect + nearest_other.cost\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    solution_nodes = (new_node, nearest_other) if iteration % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    # Immediately improve with curvature-aware shortcut\n                    smoothed_path = curvature_sensitive_shortcut(raw_path)\n                    improved_since_last_global_smooth = True\n\n                    # Early return if good quality solution found\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        if iteration % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on best path if available\n            if improved_since_last_global_smooth and iteration % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # Terminate returning best found solution if exists\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = global_smooth(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.04579,
          "time_improvement": 41.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 1408.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02419092655181885,
                    "num_nodes_avg": 141.9,
                    "path_length_avg": 188.3479380599631,
                    "smoothness_avg": 0.033290610348386845,
                    "success_improvement": 0.0,
                    "time_improvement": 6.203310392005505,
                    "node_improvement": 64.26592797783933,
                    "length_improvement": -3.2364894147353587,
                    "smoothness_improvement": 421.0703436696947,
                    "objective_score": 2.0244511871089097
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0251894474029541,
                    "num_nodes_avg": 237.1,
                    "path_length_avg": 250.2720422831174,
                    "smoothness_avg": 0.1005791278020062,
                    "success_improvement": 0.0,
                    "time_improvement": 84.78674820166262,
                    "node_improvement": 84.06907209567964,
                    "length_improvement": 16.45198860457725,
                    "smoothness_improvement": 2487.9734025631583,
                    "objective_score": 47.74708463606093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034386706352233884,
                    "num_nodes_avg": 316.6,
                    "path_length_avg": 135.2191336681014,
                    "smoothness_avg": 0.1112860441211003,
                    "success_improvement": 0.0,
                    "time_improvement": 32.239177896453405,
                    "node_improvement": 59.74570883661793,
                    "length_improvement": 10.193889860863345,
                    "smoothness_improvement": 1315.5502669390778,
                    "objective_score": 22.365838620149418
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An optimized bidirectional RRT* planner employing a balanced KDTree with batched nearest neighbor queries and adaptive rewiring. The algorithm moderates rewiring and shortcutting frequency through dynamic scheduling informed by recent improvement trends, reducing computational overhead. Sampling is a hybrid informed strategy with goal bias and fallback uniform sampling constrained within map bounds. Early stopping is adaptively triggered based on solution improvement stability to curtail excess computation. Incremental shortcutting is applied selectively while global smoothing is invoked conditionally to balance planning speed with path quality enhancement. Overall, the planner balances exploration-exploitation efficiently, improving runtime while maintaining path length and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally, sampling points by biased and ellipsoidal informed sampling. It inserts new nodes via efficient KDTree nearest and radius searches with adaptive rewiring radius, minimizing cost connections. Rewiring and shortcutting run at adaptive intervals aligned with improvement progress. Path extraction merges start and goal trees via closest nodes upon connection. Early stopping detects plateauing improvements to end planning promptly. The output path is incrementally shortcut and optionally globally smoothed before return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=6.0, r_min=5.0, r_max=18.0,\n                 goal_sample_rate=0.15, shortcut_attempts=50, smooth_passes=3,\n                 improvement_thresh=5e-4, early_stop_patience=120,\n                 rewiring_interval=8, shortcut_interval=20, smooth_interval=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_passes = smooth_passes\n        self.improvement_thresh = improvement_thresh\n        self.early_stop_patience = early_stop_patience\n        self.rewiring_interval = rewiring_interval\n        self.shortcut_interval = shortcut_interval\n        self.smooth_interval = smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        node_coll_cache = {}\n        edge_coll_cache = {}\n\n        def key_node_collision(p):\n            return tuple(round(x * 1000) for x in p)\n\n        def key_edge_collision(a, b):\n            ka = key_node_collision(a)\n            kb = key_node_collision(b)\n            return tuple(sorted((ka, kb)))\n\n        def collision_node(p):\n            key = key_node_collision(p)\n            if key in node_coll_cache:\n                return node_coll_cache[key]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        node_coll_cache[key] = True\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        node_coll_cache[key] = True\n                        return True\n            node_coll_cache[key] = False\n            return False\n\n        def collision_edge(a, b):\n            key = key_edge_collision(a, b)\n            if key in edge_coll_cache:\n                return edge_coll_cache[key]\n            dist_ab = math.dist(a, b)\n            steps = max(3, int(dist_ab / 0.4))\n            for step in range(steps + 1):\n                interp = tuple(a[i] + (b[i] - a[i]) * step / steps for i in range(dim))\n                if collision_node(interp):\n                    edge_coll_cache[key] = True\n                    return True\n            edge_coll_cache[key] = False\n            return False\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                clipped = tuple(max(0, min(bounds[i], to_p[i])) for i in range(dim))\n                return clipped\n            ratio = self.step_size / dist\n            new_p = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            clipped = tuple(max(0, min(bounds[i], new_p[i])) for i in range(dim))\n            return clipped\n\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                self.node = None\n                self.left = None\n                self.right = None\n                self.size = 0\n                if points:\n                    points = sorted(points, key=lambda n: n.position[self.axis])\n                    median = len(points) // 2\n                    self.node = points[median]\n                    left_points = points[:median]\n                    right_points = points[median + 1:]\n                    if left_points:\n                        self.left = KDTree(left_points, depth + 1)\n                    if right_points:\n                        self.right = KDTree(right_points, depth + 1)\n                    self.size = len(points)\n\n            def insert(self, node, depth=0):\n                axis = depth % dim\n                if self.node is None:\n                    self.node = node\n                    self.size = 1\n                    return\n                if node.position[axis] < self.node.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree()\n                    self.left.insert(node, depth + 1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree()\n                    self.right.insert(node, depth + 1)\n                self.size += 1\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.node is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = math.dist(point, self.node.position)\n                if here_dist < best_dist:\n                    best = self.node\n                    best_dist = here_dist\n                diff = point[axis] - self.node.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth + 1)\n                if away is not None and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth + 1)\n                return best, best_dist\n\n            def near(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.node is None:\n                    return results\n                axis = depth % dim\n                dist_axis = point[axis] - self.node.position[axis]\n                sq_radius = radius * radius\n                dist_sq = sum((point[i] - self.node.position[i]) ** 2 for i in range(dim))\n                if dist_sq <= sq_radius:\n                    results.append(self.node)\n                if self.left is not None and dist_axis < radius:\n                    self.left.near(point, radius, results, depth + 1)\n                if self.right is not None and dist_axis > -radius:\n                    self.right.near(point, radius, results, depth + 1)\n                return results\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def rewiring_radius(num_nodes, current_cost):\n            # Use a smoothly decaying radius capped by r_min and r_max and cost factor to adapt rewiring scope\n            if num_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(num_nodes) / num_nodes) ** (1 / dim)) * self.step_size\n            cost_scale = self.r_max if current_cost == float('inf') else max(self.r_min, min(self.r_max, current_cost / (dist(start_pos, goal_pos) + 1e-9)))\n            return max(self.r_min, min(base, cost_scale))\n\n        def sample(iter_num):\n            p_goal = self.goal_sample_rate\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost if best_cost < float('inf') else None\n            if random.random() < p_goal and not collision_node(goal_pos):\n                return goal_pos\n            uniform_prob = 0.15 if (c_best is None or c_best > 1.1 * c_min) else 0.08\n            r = random.random()\n            if r < uniform_prob:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n            if c_best is not None and c_best < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                a_len = c_best / 2.0\n                val = max(c_best * c_best - c_min * c_min, 0.0)\n                b_len = math.sqrt(val) / 2.0\n\n                a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                length_a1 = math.sqrt(sum(x * x for x in a1))\n                if length_a1 < 1e-15:\n                    basis = [[1 if i == j else 0 for i in range(dim)] for j in range(dim)]\n                else:\n                    e1 = [x / length_a1 for x in a1]\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append([-e1[1], e1[0]])\n                    else:\n                        v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                        dot = sum(v[i] * e1[i] for i in range(dim))\n                        u = [v[i] - dot * e1[i] for i in range(dim)]\n                        u_norm = math.sqrt(sum(x * x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0] * dim\n                            u[-1] = 1.0\n                            u_norm = 1.0\n                        u = [x / u_norm for x in u]\n                        w = [e1[1] * u[2] - e1[2] * u[1],\n                             e1[2] * u[0] - e1[0] * u[2],\n                             e1[0] * u[1] - e1[1] * u[0]]\n                        basis.extend([u, w])\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-9:\n                            return [x / norm for x in vec]\n\n                for _ in range(12):\n                    u = unit_ball_sample()\n                    pt = [0] * dim\n                    if dim == 2:\n                        pt[0] = u[0] * a_len\n                        pt[1] = u[1] * b_len\n                    else:\n                        pt[0] = u[0] * a_len\n                        pt[1] = u[1] * b_len\n                        pt[2] = u[2] * b_len\n                    sample_p = [center[i] + sum(pt[j] * basis[j][i] for j in range(dim)) for i in range(dim)]\n                    sample_t = tuple(sample_p)\n                    if in_bounds(sample_t) and not collision_node(sample_t):\n                        return sample_t\n                # fallback uniform sample one last attempt\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    c_new_cost = current.cost + dist(current.position, c.position)\n                    if c_new_cost + 1e-12 < c.cost:\n                        update_parent(c, current, c_new_cost)\n                        stack.append(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            attempts_limit = min(self.shortcut_attempts, max(30, int(len(pth) / 1.5)))\n            attempts = 0\n            while attempts < attempts_limit:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not collision_edge(pth[i], pth[j]):\n                    pth = pth[:i + 1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        def global_smooth(path, passes=3):\n            smoothed = path[:]\n            for _ in range(passes):\n                smoothed = incremental_shortcut(smoothed)\n            return smoothed\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        start_tree_nodes = [start_node]\n        goal_tree_nodes = [goal_node]\n\n        start_kd = KDTree(start_tree_nodes)\n        goal_kd = KDTree(goal_tree_nodes)\n\n        all_nodes = start_tree_nodes + goal_tree_nodes\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        iter_since_improve = 0\n        prev_best_cost = best_cost\n        last_improved_path = None\n\n        for it in range(1, self.max_iter + 1):\n            sample_point = sample(it)\n\n            if it % 2 == 1:\n                res = None\n                nearest_node, _ = start_kd.nearest(sample_point)\n                if nearest_node is not None:\n                    new_pos = steer(nearest_node.position, sample_point)\n                    if in_bounds(new_pos) and not collision_node(new_pos) and not collision_edge(nearest_node.position, new_pos):\n                        r = rewiring_radius(len(start_tree_nodes), best_cost)\n                        if it % self.rewiring_interval == 0:\n                            near_nodes = start_kd.near(new_pos, r)\n                        else:\n                            near_nodes = []\n                        min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                        min_parent = nearest_node\n                        for node in near_nodes:\n                            c_new = node.cost + dist(node.position, new_pos)\n                            if c_new + 1e-12 < min_cost and not collision_edge(node.position, new_pos):\n                                min_cost = c_new\n                                min_parent = node\n                        new_node = Node(new_pos, min_parent, min_cost)\n                        min_parent.add_child(new_node)\n                        start_tree_nodes.append(new_node)\n                        all_nodes.append(new_node)\n                        edges.append((min_parent, new_node))\n                        start_kd.insert(new_node)\n                        if it % self.rewiring_interval == 0:\n                            for node in near_nodes:\n                                if node is min_parent or node is new_node:\n                                    continue\n                                c_through = new_node.cost + dist(new_node.position, node.position)\n                                if c_through + 1e-12 < node.cost and not collision_edge(new_node.position, node.position):\n                                    if node.parent is not None:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                        except ValueError:\n                                            pass\n                                        node.parent.remove_child(node)\n                                    update_parent(node, new_node, c_through)\n                                    propagate_costs(node)\n                                    edges.append((new_node, node))\n                        nearest_other, dist_other = goal_kd.nearest(new_node.position)\n                        if nearest_other is not None:\n                            dist_connect = dist(new_node.position, nearest_other.position)\n                            max_connect_dist = max(self.step_size * 1.4, r)\n                            if dist_connect <= max_connect_dist and not collision_edge(new_node.position, nearest_other.position):\n                                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                                res = new_node, nearest_other, total_cost\n                if res is not None:\n                    n1, n2, cost_path = res\n                    if cost_path + 1e-10 < best_cost:\n                        best_cost = cost_path\n                        iter_since_improve = 0\n                        solution_nodes = (n1, n2)\n                        raw_path = extract_path(n1, n2)\n                        if it % self.shortcut_interval == 0:\n                            shortcut_path = incremental_shortcut(raw_path)\n                            if it % self.smooth_interval == 0 or len(shortcut_path) > 30:\n                                shortcut_path = global_smooth(shortcut_path, passes=self.smooth_passes)\n                            last_improved_path = shortcut_path\n                        else:\n                            last_improved_path = raw_path\n                        if prev_best_cost - best_cost < self.improvement_thresh and it > self.smooth_interval:\n                            if last_improved_path and len(last_improved_path) >= 2:\n                                return PlannerResult(True, last_improved_path, all_nodes, edges)\n                        prev_best_cost = best_cost\n                    else:\n                        iter_since_improve += 1\n                else:\n                    iter_since_improve += 1\n\n            else:\n                res = None\n                nearest_node, _ = goal_kd.nearest(sample_point)\n                if nearest_node is not None:\n                    new_pos = steer(nearest_node.position, sample_point)\n                    if in_bounds(new_pos) and not collision_node(new_pos) and not collision_edge(nearest_node.position, new_pos):\n                        r = rewiring_radius(len(goal_tree_nodes), best_cost)\n                        if it % self.rewiring_interval == 0:\n                            near_nodes = goal_kd.near(new_pos, r)\n                        else:\n                            near_nodes = []\n                        min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                        min_parent = nearest_node\n                        for node in near_nodes:\n                            c_new = node.cost + dist(node.position, new_pos)\n                            if c_new + 1e-12 < min_cost and not collision_edge(node.position, new_pos):\n                                min_cost = c_new\n                                min_parent = node\n                        new_node = Node(new_pos, min_parent, min_cost)\n                        min_parent.add_child(new_node)\n                        goal_tree_nodes.append(new_node)\n                        all_nodes.append(new_node)\n                        edges.append((min_parent, new_node))\n                        goal_kd.insert(new_node)\n                        if it % self.rewiring_interval == 0:\n                            for node in near_nodes:\n                                if node is min_parent or node is new_node:\n                                    continue\n                                c_through = new_node.cost + dist(new_node.position, node.position)\n                                if c_through + 1e-12 < node.cost and not collision_edge(new_node.position, node.position):\n                                    if node.parent is not None:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                        except ValueError:\n                                            pass\n                                        node.parent.remove_child(node)\n                                    update_parent(node, new_node, c_through)\n                                    propagate_costs(node)\n                                    edges.append((new_node, node))\n                        nearest_other, dist_other = start_kd.nearest(new_node.position)\n                        if nearest_other is not None:\n                            dist_connect = dist(new_node.position, nearest_other.position)\n                            max_connect_dist = max(self.step_size * 1.4, r)\n                            if dist_connect <= max_connect_dist and not collision_edge(new_node.position, nearest_other.position):\n                                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                                res = new_node, nearest_other, total_cost\n                if res is not None:\n                    n1, n2, cost_path = res\n                    if cost_path + 1e-10 < best_cost:\n                        best_cost = cost_path\n                        iter_since_improve = 0\n                        solution_nodes = (n2, n1)\n                        raw_path = extract_path(n2, n1)\n                        if it % self.shortcut_interval == 0:\n                            shortcut_path = incremental_shortcut(raw_path)\n                            if it % self.smooth_interval == 0 or len(shortcut_path) > 30:\n                                shortcut_path = global_smooth(shortcut_path, passes=self.smooth_passes)\n                            last_improved_path = shortcut_path\n                        else:\n                            last_improved_path = raw_path\n                        if prev_best_cost - best_cost < self.improvement_thresh and it > self.smooth_interval:\n                            if last_improved_path and len(last_improved_path) >= 2:\n                                return PlannerResult(True, last_improved_path, all_nodes, edges)\n                        prev_best_cost = best_cost\n                    else:\n                        iter_since_improve += 1\n                else:\n                    iter_since_improve += 1\n\n            if iter_since_improve > self.early_stop_patience and last_improved_path is not None:\n                final_path = global_smooth(last_improved_path, passes=self.smooth_passes)\n                if len(final_path) >= 2:\n                    return PlannerResult(True, final_path, all_nodes, edges)\n                break\n\n        # Final return fallback\n        if last_improved_path is not None and len(last_improved_path) >= 2:\n            return PlannerResult(True, last_improved_path, all_nodes, edges)\n        elif solution_nodes[0] is not None and solution_nodes[1] is not None:\n            final_path = extract_path(solution_nodes[0], solution_nodes[1])\n            final_path = global_smooth(incremental_shortcut(final_path), passes=self.smooth_passes)\n            if len(final_path) >= 2:\n                return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -23.86634,
          "time_improvement": 24.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03662815093994141,
                    "num_nodes_avg": 201.4,
                    "path_length_avg": 166.29767002889622,
                    "smoothness_avg": 0.047824350412532836,
                    "success_improvement": 0.0,
                    "time_improvement": -42.020161868092764,
                    "node_improvement": 49.282296650717704,
                    "length_improvement": 8.849611901949048,
                    "smoothness_improvement": 648.5549361952724,
                    "objective_score": -4.053506738282037
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.041453075408935544,
                    "num_nodes_avg": 387.0,
                    "path_length_avg": 240.79462057912352,
                    "smoothness_avg": 0.09711053205906416,
                    "success_improvement": 0.0,
                    "time_improvement": 74.96427516160415,
                    "node_improvement": 73.9971779883088,
                    "length_improvement": 19.615824761828765,
                    "smoothness_improvement": 2398.7239357687286,
                    "objective_score": 46.25239708442215
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030809426307678224,
                    "num_nodes_avg": 342.4,
                    "path_length_avg": 125.39917220855682,
                    "smoothness_avg": 0.1271093631225309,
                    "success_improvement": 0.0,
                    "time_improvement": 39.28839727299763,
                    "node_improvement": 56.46535282898919,
                    "length_improvement": 16.715840685977813,
                    "smoothness_improvement": 1516.8217166813586,
                    "objective_score": 29.400132176892768
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A Dual-Tree Probabilistic Roadmap with Incremental Local Optimization (DTPRM-ILO). This algorithm grows two random graphs rooted at start and goal using probabilistic roadmap sampling with connection radius adapting to graph size. Each new node connection and rewiring consider both collision-free edges and cost improvement. Periodically, incremental local path optimization via shortcutting and curvature smoothing refines candidate connection paths proactively. This approach balances exploration and exploitation, enhances robustness and path quality, reduces computation by efficient local updates and dynamic pruning of suboptimal branches. It terminates once a valid connection is found and sufficiently smooth path is obtained or on iteration limit.",
          "planning_mechanism": "The planner creates two expanding probabilistic roadmaps (graphs) grown from start and goal by sampling random collision-free nodes in the map. New nodes attempt connection to nearby nodes within a dynamically computed radius, favoring connections improving path cost while maintaining collision-free edges. Rewiring propagates cost improvements through the graphs. In each iteration, the planner attempts to connect the graphs by checking for collision-free edges between nodes from opposing graphs. Upon successful connection, the combined path is extracted and incrementally optimized using incremental shortcutting and curvature-limited smoothing. The process repeats until a smooth, low-cost path is found or maximum iterations are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, node):\n        self.children.append(node)\n\n    def remove_child(self, node):\n        if node in self.children:\n            self.children.remove(node)\nclass Planner:\n    def __init__(self, max_iter=5000, r_min=3.0, r_max=15.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_graph = [Node(start_pos)]\n        goal_graph = [Node(goal_pos)]\n        nodes_all = start_graph + goal_graph\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_node():\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def near_nodes(graph, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in graph:\n                dx = n.position[0] - point[0]\n                dy = n.position[1] - point[1]\n                dz = n.position[2] - point[2] if is_3d else 0.0\n                if dx * dx + dy * dy + dz * dz <= r2:\n                    result.append(n)\n            return result\n\n        def connection_radius(n_nodes):\n            # Adaptive radius using log-factor and graph size\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 15.0\n            return max(self.r_min, min(self.r_max, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def is_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        def reconstruct_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a, b, c):\n            import math\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-9 or lcb < 1e-9:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if is_free_edge(path[i], path[j]):\n                        # Preserve curvature: only if angle does not increase beyond threshold\n                        if i > 0 and j < len(path) - 1:\n                            ang_before = angle_between(path[i-1], path[i], path[i+1]) if i+1 < len(path) else 0.0\n                            ang_after = angle_between(path[i-1], path[j], path[j+1]) if (j+1) < len(path) else 0.0\n                            if ang_after < ang_before + 0.2:\n                                break\n                            else:\n                                j -= 1\n                        else:\n                            break\n                    else:\n                        j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path)-1):\n                a = new_path[i-1]\n                b = new_path[i]\n                c = new_path[i+1]\n                midpoint = tuple((a[j] + c[j]) * 0.5 for j in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    is_free_edge(a, midpoint) and is_free_edge(midpoint, c)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-3:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def update_subtree_costs(node):\n            for child in node.children:\n                prev_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-15 < prev_cost:\n                    child.cost = new_cost\n                    update_subtree_costs(child)\n\n        def rewire(graph, new_node, radius):\n            near = near_nodes(graph, new_node.position, radius)\n            for neighbor in near:\n                if neighbor is new_node.parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-15 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent is not None:\n                            neighbor.parent.remove_child(neighbor)\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n                        update_subtree_costs(neighbor)\n\n        best_solution = None\n        best_cost = float('inf')\n        best_nodes = None\n\n        for it in range(self.max_iter):\n            sample_pt = sample_node()\n            for graph_roots, other_graph_roots in [(start_graph, goal_graph),(goal_graph, start_graph)]:\n                radius = connection_radius(len(graph_roots))\n                # Find nearest node for attempt connection\n                nearest_node = None\n                min_dist = float('inf')\n                for n in graph_roots:\n                    d = dist(n.position, sample_pt)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n                if nearest_node is None:\n                    continue\n                direction_dist = min_dist\n                # New node position is sample_pt itself, no steering to keep probabilistic roadmap nature\n                new_pos = sample_pt\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if not is_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                graph_roots.append(new_node)\n                nodes_all.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(graph_roots, new_node, radius)\n\n                # Attempt to connect new_node with other_graph nodes\n                radius_other = connection_radius(len(other_graph_roots))\n                near_others = near_nodes(other_graph_roots, new_node.position, radius_other)\n                for other_node in near_others:\n                    if is_free_edge(new_node.position, other_node.position):\n                        total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                        if total_cost + 1e-15 < best_cost:\n                            best_cost = total_cost\n                            best_solution = (new_node, other_node)\n                            best_nodes = (start_graph, goal_graph) if start_graph is graph_roots else (goal_graph, start_graph)\n\n            # If a solution exists, extract and optimize path\n            if best_solution is not None and it % 50 == 0:\n                n1, n2 = best_solution\n                path = reconstruct_path(n1, n2)\n                if len(path) >= 3:\n                    path = incremental_shortcut(path)\n                    path = smooth_path(path)\n                if path:\n                    return PlannerResult(True, path, nodes_all, edges)\n\n        # If ended without intermediate return but solution found, extract and optimize\n        if best_solution is not None:\n            n1, n2 = best_solution\n            path = reconstruct_path(n1, n2)\n            if len(path) >= 3:\n                path = incremental_shortcut(path)\n                path = smooth_path(path)\n            return PlannerResult(True, path, nodes_all, edges)\n\n        # Else planning failed\n        return PlannerResult(False, [], nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.79526,
          "time_improvement": 63.0,
          "length_improvement": -8.0,
          "smoothness_improvement": 1886.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023380041122436523,
                    "num_nodes_avg": 178.6,
                    "path_length_avg": 204.66609096189143,
                    "smoothness_avg": 0.08196450351646048,
                    "success_improvement": 0.0,
                    "time_improvement": 9.347397029799074,
                    "node_improvement": 55.02392344497608,
                    "length_improvement": -12.180727597962154,
                    "smoothness_improvement": 1182.9224688008014,
                    "objective_score": 1.4103948941664388
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007231664657592773,
                    "num_nodes_avg": 114.9,
                    "path_length_avg": 276.5380841464404,
                    "smoothness_avg": 0.11558975370987438,
                    "success_improvement": 0.0,
                    "time_improvement": 95.63241171601906,
                    "node_improvement": 92.27978230195525,
                    "length_improvement": 7.683627804504005,
                    "smoothness_improvement": 2874.207618889435,
                    "objective_score": 47.670938291955295
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0076017618179321286,
                    "num_nodes_avg": 132.6,
                    "path_length_avg": 178.70626179196276,
                    "smoothness_avg": 0.1338258146720928,
                    "success_improvement": 0.0,
                    "time_improvement": 85.02032660697179,
                    "node_improvement": 83.14049586776859,
                    "length_improvement": -18.68819000449183,
                    "smoothness_improvement": 1602.2544846349017,
                    "objective_score": 22.30445640257095
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with relaxed curvature constraints and adaptive rewiring radius enabling more aggressive shortcutting and sharper turns to produce smoother and shorter paths with efficient planning time. It combines hybrid uniform and informed sampling, hash-grid accelerated neighbor queries, incremental rewiring with curvature-aware cost, and periodic multi-level smoothing phases employing increased angle thresholds for enhanced path smoothness and robustness.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using hybrid sampling. It adaptively tunes rewiring radius to the node density and best path cost but relaxes curvature penalties and uses higher angle thresholds in curvature checks to allow more aggressive rewiring and shortcuts. Nearest neighbors are queried through spatial grid hashing. After connection, local multi-attempt curvature-aware shortcuts and global midpoint smoothing with relaxed angle limits progressively refine path smoothness. Early collision checking pruning and incremental cost propagation accelerate search and ensure feasible paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=20.0,\n                 blend_sample_rate=0.7, shortcut_local_interval=15, shortcut_global_interval=60,\n                 max_local_shortcuts=60, curvature_threshold=0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.shortcut_local_interval = shortcut_local_interval\n        self.shortcut_global_interval = shortcut_global_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 3.0\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        start_hash, goal_hash = {}, {}\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            shifts = [-1,0,1]\n            neighbors = []\n            if dim==2:\n                cells = [(gh[0]+dx,gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0]+dx,gh[1]+dy,gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 2\n            while expansions <= max_expansions:\n                if dim == 2:\n                    cells = [(gh[0]+dx, gh[1]+dy) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1)]\n                else:\n                    cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1) for dz in range(-expansions,expansions+1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff*diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions +=1\n            if min_node is None:\n                all_nodes = []\n                for cell_nodes in ht.values():\n                    all_nodes.extend(cell_nodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position,p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 5.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            radius = self.base_radius * val\n            if best_cost < float('inf'):\n                radius = min(radius, best_cost*0.4)  # relaxed multiplier for bigger radius\n            radius = max(radius, self.step_size*1.2)\n            return radius\n\n        def angle_between(a,b,c):\n            ab = [a[i]-b[i] for i in range(dim)]\n            cb = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ab))\n            lcb = math.sqrt(sum(x*x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i]*cb[i] for i in range(dim))\n            val = max(min(dot/(lab*lcb),1.0),-1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            # Reduced penalty scale for more permissive curvature\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i]-parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i]-parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(min(dot/(len1*len2),1.0),-1.0)\n            penalty = (1.0 - cos_ang)*0.5  # half previous penalty weight\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear_cost + pen\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-10 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        # Check curvature increase with relaxed threshold\n                        if n.parent:\n                            ang_before = angle_between(n.parent.parent.position if n.parent.parent else n.parent.position,\n                                                     n.parent.position, n.position)\n                            ang_after = angle_between(n.parent.position, new_node.position, n.position)\n                            if ang_after > ang_before + self.curvature_threshold:\n                                continue\n                        if n.parent:\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = c_cost\n                        new_node.add_child(n)\n                        self._propagate_costs(n)\n\n        def propagate_costs(node):\n            import math\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def hybrid_sample(best_cost):\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost*0.5\n            term = best_cost*best_cost - c_min*c_min\n            a_rest = math.sqrt(term)*0.5 if term > 0 else 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def attempt_connection(tree_a, tree_hash_a, tree_b, tree_hash_b, sample, best_cost):\n            nearest_node = nearest(tree_hash_a, sample)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, sample)\n\n            if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = nearby_nodes(tree_hash_a, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost and not collision_edge(near.position, new_pos):\n                    min_cost = c\n                    min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            add_to_hash(tree_hash_a, new_node)\n\n            rewire(tree_hash_a, new_node, near_nodes)\n\n            other_nearest = nearest(tree_hash_b, new_node.position)\n            if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not collision_edge(other_nearest.position, new_node.position):\n                    total_cost = new_node.cost + math.dist(other_nearest.position, new_node.position) + other_nearest.cost\n                    return (new_node, other_nearest, total_cost)\n            return None\n\n        def quick_local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >=3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    valid = True\n                    # Relax curvature checks: larger angle threshold and apply selectively\n                    if i > 0 and j < len(new_path)-1:\n                        ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1] if i+1<len(new_path) else new_path[i])\n                        ang_after = angle_between(new_path[i-1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j+1])\n                        if ang_after > ang_before + self.curvature_threshold + 0.3 or ang_after2 > self.curvature_threshold + 0.7:\n                            valid = False\n                    if valid:\n                        del new_path[i+1:j]\n                        attempts += 1\n                    else:\n                        attempts +=1\n                else:\n                    attempts +=1\n            return new_path\n\n        def global_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for idx in range(1, len(path)-1):\n                a = new_path[idx-1]\n                b = new_path[idx]\n                c = new_path[idx+1]\n                midpoint = tuple(0.5*(a[i]+c[i]) for i in range(dim))\n                if not collision_node(midpoint) and not collision_edge(a, midpoint) and not collision_edge(midpoint, c):\n                    ang_old = angle_between(a,b,c)\n                    ang_new = angle_between(a, midpoint, c)\n                    # Allow relaxed curvature threshold to smooth sharper turns\n                    if ang_new < ang_old + self.curvature_threshold + 0.2:\n                        new_path[idx] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        add_to_hash(start_hash,start_tree[0])\n        add_to_hash(goal_hash,goal_tree[0])\n\n        best_cost = float('inf')\n        best_sol_start = None\n        best_sol_goal = None\n\n        for it in range(1, self.max_iter+1):\n            sample = hybrid_sample(best_cost)\n\n            for tree_a, hash_a, tree_b, hash_b in [(start_tree, start_hash, goal_tree, goal_hash),\n                                                   (goal_tree, goal_hash, start_tree, start_hash)]:\n                res = attempt_connection(tree_a, hash_a, tree_b, hash_b, sample, best_cost)\n                if res:\n                    new_node, conn_node, cost_candidate = res\n                    if cost_candidate + 1e-15 < best_cost:\n                        best_cost = cost_candidate\n                        best_sol_start, best_sol_goal = (new_node, conn_node) if tree_a is start_tree else (conn_node, new_node)\n\n            if best_cost < float('inf') and best_sol_start and best_sol_goal:\n                if it % self.shortcut_local_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_sol_start, best_sol_goal)\n                    path_after_local = quick_local_shortcut(raw_path)\n                    if it % self.shortcut_global_interval == 0 or it == self.max_iter:\n                        path_after_global = global_smooth(path_after_local)\n                    else:\n                        path_after_global = path_after_local\n                    return PlannerResult(True, path_after_global, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.54405,
          "time_improvement": 61.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 147.0,
          "node_improvement": 100.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019300460815429688,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 182.424034052097,
                    "smoothness_avg": 0.013544456505030241,
                    "success_improvement": 0.0,
                    "time_improvement": 25.16535782462595,
                    "node_improvement": 99.49634852681945,
                    "length_improvement": 0.01049624224208904,
                    "smoothness_improvement": 112.00015656178346,
                    "objective_score": 8.115905875541955
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025008130073547363,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 267.74552895014153,
                    "smoothness_avg": 0.009938292940300212,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89625541488331,
                    "node_improvement": 99.86561849089566,
                    "length_improvement": 10.618835808697503,
                    "smoothness_improvement": 155.7194356169902,
                    "objective_score": 32.61877528776845
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013741588592529297,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 132.60623477657154,
                    "smoothness_avg": 0.021438419722591737,
                    "success_improvement": 0.0,
                    "time_improvement": 72.92147347580986,
                    "node_improvement": 99.74570883661794,
                    "length_improvement": 11.929252891742708,
                    "smoothness_improvement": 172.69511645182806,
                    "objective_score": 29.897469360047726
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "\"A bidirectional RRT* planner with an optimized spatial KD-tree for fast neighbor queries, adaptive dynamic sampling mixing uniform, informed ellipsoidal, and goal bias; adaptive rewiring radius based on node density and best solution cost; combined incremental and iterative global shortcutting integrated seamlessly during planning; plus efficient tree connection using dynamically scaled connection radii, ensuring balance between exploration, exploitation, path smoothness, and runtime efficiency.\"",
          "planning_mechanism": "The planner alternates growing start and goal trees sampling from a mix of uniform and ellipsoidal informed distributions guided by the current best solution. It uses an efficient KD-tree spatial index for fast nearest and near neighbor queries enabling adaptive rewiring with radius scaled to node density and path quality. When trees connect feasibly with edges, the path is incrementally shortcut and globally smoothed periodically to reduce jaggedness and length while maintaining efficient planning. The planner stops early when a good path is found or runs until maximum iteration limit, consistently balancing speed and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.10,\n                 uniform_sample_rate=0.35, r_min=4.0, r_max=50.0,\n                 shortcut_attempts=40, global_smooth_interval=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_interval = global_smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Collision detection helpers\n        def node_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_free(p1, p2, resolution=0.35):\n            dist_sqr = sum((p1[i]-p2[i])**2 for i in range(dim))\n            segment_len = math.sqrt(dist_sqr)\n            if segment_len < 1e-14:\n                return True\n            steps = max(2, int(segment_len / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*i/steps for j in range(dim))\n                if node_in_obstacle(interp):\n                    return False\n            return True\n\n        # Fast spatial KD-tree for points (supports insert, nearest and near queries)\n        class KDTreeNode:\n            __slots__ = ('point','node','left','right','axis')\n            def __init__(self, point, node, axis=0):\n                self.point = point\n                self.node = node\n                self.left = None\n                self.right = None\n                self.axis = axis\n\n        class KDTree:\n            def __init__(self):\n                self.root = None\n                self.size = 0\n            def insert(self, node):\n                def _insert(root, point, node_, depth):\n                    if root is None:\n                        return KDTreeNode(point,node_,depth % dim)\n                    axis = root.axis\n                    if point[axis] < root.point[axis]:\n                        root.left = _insert(root.left, point, node_, depth+1)\n                    else:\n                        root.right = _insert(root.right, point, node_, depth+1)\n                    return root\n                self.root = _insert(self.root, node.position, node, 0)\n                self.size += 1\n            def nearest(self, point):\n                best = [None, float('inf')]  # node, distance sq\n                def _search(root):\n                    if root is None:\n                        return\n                    axis = root.axis\n                    d_axis = point[axis] - root.point[axis]\n                    d_sq = sum((root.point[i]-point[i])**2 for i in range(dim))\n                    if d_sq < best[1]:\n                        best[0] = root.node\n                        best[1] = d_sq\n                    # Explore closer side first\n                    first, second = (root.left, root.right) if d_axis < 0 else (root.right, root.left)\n                    _search(first)\n                    if d_axis**2 < best[1]:\n                        _search(second)\n                _search(self.root)\n                return best[0]\n            def near(self, point, radius):\n                r_sq = radius * radius\n                result = []\n                def _search(root):\n                    if root is None:\n                        return\n                    axis = root.axis\n                    d_axis = point[axis] - root.point[axis]\n                    inside = True\n                    for i in range(dim):\n                        if abs(root.point[i] - point[i]) > radius:\n                            inside = False\n                            break\n                    if inside:\n                        dist_sq = sum((root.point[i]-point[i])**2 for i in range(dim))\n                        if dist_sq <= r_sq:\n                            result.append(root.node)\n                    # Search children based on splitting plane and radius\n                    if d_axis < 0:\n                        _search(root.left)\n                        if d_axis*d_axis <= r_sq:\n                            _search(root.right)\n                    else:\n                        _search(root.right)\n                        if d_axis*d_axis <= r_sq:\n                            _search(root.left)\n                _search(self.root)\n                return result\n\n        # Distance\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        # Ellipsoid parameters for informed sampling\n        def ellipsoid_params(best_cost):\n            d_min = dist(start_pos, goal_pos)\n            if best_cost == float('inf') or best_cost < d_min * 1.00001:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n            diff = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = d_min\n            e1 = [d / length for d in diff]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                # build orthonormal basis using Gram-Schmidt for dim=3\n                a = e1\n                b = [1,0,0] if abs(a[0]) < 0.9 else [0,1,0]\n                proj = sum(a[i]*b[i] for i in range(3))\n                b = [b[i] - proj*a[i] for i in range(3)]\n                norm_b = math.sqrt(sum(x*x for x in b))\n                if norm_b < 1e-14:\n                    b = [0,0,1]\n                    norm_b = 1.0\n                b = [x / norm_b for x in b]\n                c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]\n                basis = [a, b, c]\n\n            a1 = best_cost * 0.5\n            sq = max(best_cost*best_cost - d_min*d_min, 1e-12) * 0.25\n            b_len = math.sqrt(sq)\n            return center, basis, a1, b_len\n\n        # Sample point from ellipsoidal informed set\n        def informed_sample(best_cost):\n            params = ellipsoid_params(best_cost)\n            if params is None:\n                return uniform_goal_bias_sample()\n            center, basis, a1, b_len = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    coords = [a1*ball[0], b_len*ball[1]]\n                else:\n                    while True:\n                        u = [random.uniform(-1,1) for _ in range(3)]\n                        norm_sq = sum(x*x for x in u)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x/norm for x in u]\n                    coords = [a1 * unit_ball[0], b_len * unit_ball[1], b_len * unit_ball[2]]\n                pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if not node_in_obstacle(pt):\n                    return pt\n\n        def uniform_goal_bias_sample():\n            while True:\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not node_in_obstacle(pt):\n                    return pt\n\n        # Blend sampling strategy: uniform with goal bias or informed ellipsoid\n        def sample(best_cost):\n            # Early phase: uniform w/ goal bias\n            if best_cost == float('inf'):\n                return uniform_goal_bias_sample()\n            # Blend uniform and informed sampling by uniform_sample_rate\n            if random.random() < self.uniform_sample_rate:\n                return uniform_goal_bias_sample()\n            else:\n                return informed_sample(best_cost)\n\n        # Steer from position from_p toward to_p, max step_size\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio*(to_p[i] - from_p[i]) for i in range(dim))\n\n        # Adaptive rewiring radius scaled by n_nodes and best_cost, bounded by r_min and r_max\n        def rewiring_radius(n_nodes, best_cost):\n            if n_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            if best_cost == float('inf'):\n                ratio = 1.0\n            else:\n                d_min = dist(start_pos, goal_pos)\n                ratio = best_cost / max(d_min*2.5, 1e-6)\n                ratio = max(0.30, min(1.0, ratio))\n            r = base * ratio\n            if r < self.r_min:\n                return self.r_min\n            if r > self.r_max:\n                return self.r_max\n            return r\n\n        # Extract path from start to goal node pair by retracing parents\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Incremental shortcutting to locally reduce path length and smooth path\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if edge_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        # Global shortcutting aggressively remove unnecessary waypoints iteratively\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            smoothed = path[:]\n            max_skip = max(3, min(25, len(smoothed)//4))\n            i = 0\n            while i + max_skip < len(smoothed):\n                if edge_free(smoothed[i], smoothed[i+max_skip]):\n                    smoothed = smoothed[:i+1] + smoothed[i+max_skip:]\n                    i = 0\n                else:\n                    i += 1\n            return smoothed\n\n        # Initialize trees and KD-trees\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes_all = tree_start + tree_goal\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(tree_start[0])\n        kd_goal.insert(tree_goal[0])\n\n        best_cost = float('inf')\n        best_nodes = (None, None)\n        improved_flag = False\n\n        for iter_count in range(self.max_iter):\n            expand_from_start = (iter_count % 2 == 0)\n            expand_tree = tree_start if expand_from_start else tree_goal\n            other_tree = tree_goal if expand_from_start else tree_start\n            kd_expand = kd_start if expand_from_start else kd_goal\n            kd_other = kd_goal if expand_from_start else kd_start\n\n            sample_pt = sample(best_cost)\n            near_node = kd_expand.nearest(sample_pt)\n            if near_node is None:\n                continue\n            new_pos = steer(near_node.position, sample_pt)\n            if node_in_obstacle(new_pos):\n                continue\n            if not edge_free(near_node.position, new_pos):\n                continue\n\n            # Find neighbors within rewiring radius\n            radius = rewiring_radius(len(expand_tree), best_cost)\n            near_nodes = kd_expand.near(new_pos, radius)\n\n            # Choose best parent with minimal cost within neighbors\n            min_cost = near_node.cost + dist(near_node.position, new_pos)\n            best_parent = near_node\n            for nd in near_nodes:\n                if nd is near_node:\n                    continue\n                cost_tmp = nd.cost + dist(nd.position, new_pos)\n                if cost_tmp < min_cost and edge_free(nd.position, new_pos):\n                    min_cost = cost_tmp\n                    best_parent = nd\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            expand_tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_expand.insert(new_node)\n\n            # Rewire neighbors if improved cost possible\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                cost_cand = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_cand + 1e-9 < nbr.cost and edge_free(new_node.position, nbr.position):\n                    if nbr.parent:\n                        # Remove edge from parent\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except Exception:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = cost_cand\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt connection to opposite tree\n            nearest_other = kd_other.nearest(new_pos)\n            if nearest_other is not None:\n                d_connect = dist(new_pos, nearest_other.position)\n                connect_thresh = min(self.step_size * 1.8, radius)\n                if d_connect <= connect_thresh and edge_free(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + d_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        if expand_from_start:\n                            best_nodes = (new_node, nearest_other)\n                        else:\n                            best_nodes = (nearest_other, new_node)\n                        raw_path = extract_path(best_nodes[0], best_nodes[1])\n                        shortcut_path = incremental_shortcut(raw_path)\n                        improved_flag = True\n                        if iter_count % self.global_smooth_interval == 0:\n                            shortcut_path = global_shortcut(shortcut_path)\n                        if len(shortcut_path) >= 2:\n                            return PlannerResult(True, shortcut_path, nodes_all, edges)\n\n            # Periodic global smoothing on improved path\n            if improved_flag and iter_count % self.global_smooth_interval == 0 and best_cost < float('inf') and best_nodes[0]:\n                raw_path = extract_path(best_nodes[0], best_nodes[1])\n                smooth_path = global_shortcut(raw_path)\n                if len(smooth_path) >= 2:\n                    improved_flag = False\n                    return PlannerResult(True, smooth_path, nodes_all, edges)\n\n        # Return final best found path if any\n        if best_nodes[0] and best_nodes[1]:\n            raw_path = extract_path(best_nodes[0], best_nodes[1])\n            smooth_path = incremental_shortcut(raw_path)\n            smooth_path = global_shortcut(smooth_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, nodes_all, edges)\n\n        return PlannerResult(False, [], nodes_all, edges)",
          "objective": -23.47006,
          "time_improvement": 25.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1405.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03365175724029541,
                    "num_nodes_avg": 147.2,
                    "path_length_avg": 165.78849909095945,
                    "smoothness_avg": 0.04472474368388074,
                    "success_improvement": 0.0,
                    "time_improvement": -30.47964169004711,
                    "node_improvement": 62.93125157391086,
                    "length_improvement": 9.128696561362021,
                    "smoothness_improvement": 600.0393599881239,
                    "objective_score": -0.6664777702563005
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032947635650634764,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 238.85571291338002,
                    "smoothness_avg": 0.08705038160507067,
                    "success_improvement": 0.0,
                    "time_improvement": 80.1011642179097,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 20.263087949016725,
                    "smoothness_improvement": 2139.8690185539913,
                    "objective_score": 46.88754712755291
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03844878673553467,
                    "num_nodes_avg": 327.7,
                    "path_length_avg": 126.62364776635016,
                    "smoothness_avg": 0.12385530165392429,
                    "success_improvement": 0.0,
                    "time_improvement": 24.23463383213742,
                    "node_improvement": 58.33439287984743,
                    "length_improvement": 15.902602323751779,
                    "smoothness_improvement": 1475.430294990515,
                    "objective_score": 24.189103018844868
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
          "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.21547,
          "time_improvement": 21.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1469.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025556087493896484,
                    "num_nodes_avg": 151.3,
                    "path_length_avg": 173.88763401105183,
                    "smoothness_avg": 0.047474639256938476,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9101035826373128,
                    "node_improvement": 61.89876605389071,
                    "length_improvement": 4.689432372653788,
                    "smoothness_improvement": 643.0811972002915,
                    "objective_score": 6.302096484384924
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031405282020568845,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 230.86304004149935,
                    "smoothness_avg": 0.09581397875517297,
                    "success_improvement": 0.0,
                    "time_improvement": 81.03267389975849,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 22.93127220998329,
                    "smoothness_improvement": 2365.362685390011,
                    "objective_score": 49.89537892286758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06047847270965576,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 119.93973012619429,
                    "smoothness_avg": 0.11787316210161418,
                    "success_improvement": 0.0,
                    "time_improvement": -19.176026584091733,
                    "node_improvement": 59.6694214876033,
                    "length_improvement": 20.341742166387515,
                    "smoothness_improvement": 1399.337921440741,
                    "objective_score": 13.448926931808694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive goal biasing, efficient nearest neighbor queries via dynamic grid hashing, curvature-guided cost evaluation, and iterative path improvement through constrained shortcutting. The planner grows two trees from start and goal simultaneously, leveraging curvature penalties to encourage smooth trajectories, and adapts neighbor radius dynamically by iteration count and problem dimension. It automatically updates the best path using shortcutting upon connecting the trees, balancing exploration and path quality to improve time efficiency, smoothness, and path length.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the goal vicinity and around the current best solution cost, uses spatial hashing for fast near node queries, combines path length and curvature penalties in cost calculations, performs local rewiring to optimize the tree, attempts to connect the trees frequently, and shortcuts the path iteratively to remove unnecessary nodes. Early stopping occurs upon finding a valid path with stable cost within iteration limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.2, base_radius=18.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.35):\n            length = math.dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.5\n        def grid_hash(p):\n            return tuple(int(coord/GRID_SIZE) for coord in p)\n\n        # spatial hash tables for start and goal trees\n        start_hash = {}\n        goal_hash = {}\n\n        def add_to_hash(hash_table, node):\n            h = grid_hash(node.position)\n            if h not in hash_table:\n                hash_table[h] = []\n            hash_table[h].append(node)\n\n        def nearby_nodes(hash_table, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hash_table:\n                    for node in hash_table[cell]:\n                        sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                        if sq <= radius_sq:\n                            candidates.append(node)\n            return candidates\n\n        def nearest(hash_table, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # search up to 2 grid expansions\n            for radius_cells in range(2):\n                candidates = []\n                if dim == 2:\n                    neighbors = [(gh[0]+dx, gh[1]+dy) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1)]\n                else:\n                    neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1) for dz in range(-radius_cells,radius_cells+1)]\n                for cell in neighbors:\n                    if cell in hash_table:\n                        candidates.extend(hash_table[cell])\n                for node in candidates:\n                    d = math.dist(node.position,p)\n                    if d < min_dist:\n                        min_dist = d\n                        min_node = node\n                if min_node is not None:\n                    break\n            if min_node is not None:\n                return min_node\n            # fallback linear search\n            all_nodes = []\n            for cell_nodes in hash_table.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n            v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n            len1 = math.sqrt(sum(c*c for c in v1))\n            len2 = math.sqrt(sum(c*c for c in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0,min(1.0,dot/(len1*len2)))\n            penalty = (1.0 - cos_ang) * 0.8\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear + pen\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = math.log(n_nodes) / n_nodes\n            r = self.base_radius * (val ** (1/dim))\n            return max(r, self.step_size * 1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position) + curvature_penalty(node, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-8 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 4 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = best_cost\n                c_best = max(c_best, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best / 2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x/norm for x in vec]\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0]*r1\n                    for i in range(1,dim):\n                        pt[i] = u[i]*r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            # uniform or if no good best_cost\n            for _ in range(50):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            # fallback uniform sample\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = path_cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = path_cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=130)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.15046,
          "time_improvement": 20.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1485.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03597238063812256,
                    "num_nodes_avg": 158.4,
                    "path_length_avg": 165.33660473594648,
                    "smoothness_avg": 0.040225506903328115,
                    "success_improvement": 0.0,
                    "time_improvement": -39.477510873634735,
                    "node_improvement": 60.11080332409973,
                    "length_improvement": 9.37638701806892,
                    "smoothness_improvement": 529.6165341234281,
                    "objective_score": -3.5693383806319274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0495330810546875,
                    "num_nodes_avg": 425.8,
                    "path_length_avg": 233.70047331301612,
                    "smoothness_avg": 0.09995486345747011,
                    "success_improvement": 0.0,
                    "time_improvement": 70.08432847383375,
                    "node_improvement": 71.39017671168448,
                    "length_improvement": 21.984055312962646,
                    "smoothness_improvement": 2471.9106313388115,
                    "objective_score": 46.57528488662177
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035744976997375486,
                    "num_nodes_avg": 384.8,
                    "path_length_avg": 124.71065505040485,
                    "smoothness_avg": 0.1222140100479562,
                    "success_improvement": 0.0,
                    "time_improvement": 29.562633809586238,
                    "node_improvement": 51.074380165289256,
                    "length_improvement": 17.173120998758485,
                    "smoothness_improvement": 1454.5531869101455,
                    "objective_score": 26.445428676681686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner employing a hybrid sampling technique that blends uniform, goal biasing, and adaptive ellipsoidal informed sampling; it uses an efficient k-d tree for nearest and near neighbor queries to reduce planning overhead. The rewiring radius and connection threshold adapt dynamically based on tree size and current best cost to balance exploration and exploitation. The planner incrementally applies shortcutting after path improvements along with periodic global smoothing to enhance path smoothness and shorten path length. The simultaneous expansion and frequent tree connection attempts accelerate convergence and improve path quality while collision checks ensure solution validity.",
          "planning_mechanism": "A bidirectional RRT* expands start and goal trees alternately. Sampling combines uniform, goal biasing, and adaptive ellipsoid informed sampling shrinking as better paths are found. Efficient nearest neighbor queries enable adaptive rewiring and connection attempts improving connectivity and cost. After each improved connection, incremental shortcutting and occasional global smoothing reduce path length and smoothness. Early stopping upon reaching stable quality reduces runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, r_min=4.0, r_max=30.0,\n                 goal_sample_rate=0.1, shortcut_attempts=100, smooth_interval=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_interval = smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n        import bisect\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Node lists and edges\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        iterations_since_improve = 0\n\n        # KD-tree implementation for fast nearest neighbor search\n        # Using list sorting as approximation given constraints\n        class KDTree:\n            def __init__(self, points=None):\n                self.points = points or []\n                self.sorted_indices = list(range(len(self.points)))\n                self.dim = dim\n                self._sort_all()\n\n            def _sort_all(self):\n                # Sort points along each dimension for heuristic near search\n                self.sorted_coords = []\n                for d in range(self.dim):\n                    indexed = sorted(((p.position[d], idx) for idx,p in enumerate(self.points)),\n                                     key=lambda x:x[0])\n                    self.sorted_coords.append(indexed)\n\n            def insert(self, node):\n                self.points.append(node)\n                idx = len(self.points)-1\n                for d in range(self.dim):\n                    coord = node.position[d]\n                    arr = self.sorted_coords[d]\n                    insert_pos = bisect.bisect_left([x[0] for x in arr], coord)\n                    arr.insert(insert_pos,(coord, idx))\n\n            def nearest(self, pt):\n                # Approximate nearest by checking each dimension sorted coord lists\n                best_node = None\n                best_dist = float('inf')\n                for node in self.points:\n                    d = math.dist(node.position, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, pt, radius):\n                r_sq = radius * radius\n                result = []\n                for node in self.points:\n                    d_sq = 0\n                    for i in range(dim):\n                        d_sq += (node.position[i] - pt[i])**2\n                        if d_sq > r_sq:\n                            break\n                    if d_sq <= r_sq:\n                        result.append(node)\n                return result\n\n        start_kdtree = KDTree(start_tree)\n        goal_kdtree = KDTree(goal_tree)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.4):\n            length = dist(a,b)\n            steps = max(1, int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def sample(current_iter):\n            # Hybrid sampling: goal bias + informed ellipsoid + uniform\n            p_goal_sample = self.goal_sample_rate\n            if best_cost < float('inf'):\n                # Ellipsoidal informed sampling\n                c_min = dist(start_pos, goal_pos)\n                c_best = max(best_cost, c_min + 1e-9)\n                center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n                a_len = c_best / 2\n                val = max(c_best*c_best - c_min*c_min, 0)\n                b_len = math.sqrt(val) / 2\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x / norm for x in vec]\n\n                # Construct orthonormal basis\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length_a1 = math.sqrt(sum(x*x for x in a1))\n                if length_a1 < 1e-15:\n                    basis = [[1 if i==j else 0 for i in range(dim)] for j in range(dim)]\n                else:\n                    e1 = [x / length_a1 for x in a1]\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append([-e1[1], e1[0]])\n                    else:\n                        # Gram Schmidt for 3D\n                        v = [1,0,0] if abs(e1[0]) < 0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(dim)) for i in range(dim)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0]*dim\n                            u[-1] = 1.0\n                            u_norm = 1.0\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2]-e1[2]*u[1],\n                             e1[2]*u[0]-e1[0]*u[2],\n                             e1[0]*u[1]-e1[1]*u[0]]\n                        basis.append(u)\n                        basis.append(w)\n\n                # Decide sampling mode by iteration and goal bias\n                choose_uniform = False\n                if random.random() < p_goal_sample:\n                    return goal_pos\n                if current_iter % 5 == 0:\n                    choose_uniform = True\n\n                if choose_uniform or best_cost == float('inf'):\n                    for _ in range(50):\n                        p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                        if not collision_node(p):\n                            return p\n\n                # Sample inside ellipsoid\n                for _ in range(25):\n                    u = unit_ball_sample()\n                    pt = [0]*dim\n                    if dim == 2:\n                        pt[0] = u[0]*a_len\n                        pt[1] = u[1]*b_len\n                    else:\n                        pt[0] = u[0]*a_len\n                        pt[1] = u[1]*b_len\n                        pt[2] = u[2]*b_len\n                    sample_p = [center[i] + sum(pt[j]*basis[j][i] for j in range(dim)) for i in range(dim)]\n                    sample_t = tuple(sample_p)\n                    if in_bounds(sample_t) and not collision_node(sample_t):\n                        return sample_t\n\n                # Fallback uniform\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # Before any solution: uniform or goal bias\n                if random.random() < p_goal_sample:\n                    return goal_pos\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i + 1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path, passes=3):\n            # Basic global smoothing via shortcut attempts over multiple passes\n            smooth_path = path[:]\n            for _ in range(passes):\n                smooth_path = incremental_shortcut(smooth_path)\n            return smooth_path\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            val = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            return max(self.r_min, min(self.r_max, val))\n\n        def connect_trees(node_a, node_b):\n            return extract_path(node_a, node_b)\n\n        for it in range(1, self.max_iter + 1):\n            sample_pos = sample(it)\n\n            # Alternate tree expansion\n            if it % 2 == 1:\n                expand_tree, expand_kd, other_tree, other_kd = start_tree, start_kdtree, goal_tree, goal_kdtree\n            else:\n                expand_tree, expand_kd, other_tree, other_kd = goal_tree, goal_kdtree, start_tree, start_kdtree\n\n            nearest_node = expand_kd.nearest(sample_pos)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(expand_tree))\n            near_nodes = expand_kd.near(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                if n is nearest_node:\n                    continue\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not collision_edge(n.position, new_pos):\n                    min_cost = tentative\n                    best_parent = n\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            expand_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            expand_kd.insert(new_node)\n\n            # Rewire neighbors to new_node if improves cost\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not collision_edge(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect to other tree\n            nearest_other = other_kd.nearest(new_pos)\n            if nearest_other is not None:\n                dist_conn = dist(new_pos, nearest_other.position)\n                conn_radius = max(self.step_size*1.2, r)\n                if dist_conn <= conn_radius and not collision_edge(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        if it % 2 == 1:\n                            solution_nodes = (new_node, nearest_other)\n                        else:\n                            solution_nodes = (nearest_other, new_node)\n\n                        raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n                        improved_path = incremental_shortcut(raw_path)\n                        if it % self.smooth_interval == 0:\n                            improved_path = global_smooth(improved_path)\n\n                        # Early stopping on stable near-optimal path\n                        if best_cost < float('inf') and len(improved_path) >= 2:\n                            return PlannerResult(True, improved_path, nodes, edges)\n                        iterations_since_improve = 0\n            else:\n                iterations_since_improve += 1\n                if iterations_since_improve > self.smooth_interval:\n                    iterations_since_improve = 0\n                    # perform global smoothing on last best path to improve quality if stuck\n                    if best_cost < float('inf') and solution_nodes[0] and solution_nodes[1]:\n                        raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n                        improved_path = global_smooth(raw_path)\n                        if len(improved_path) >= 2:\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n            final_path = global_smooth(incremental_shortcut(raw_path))\n            return PlannerResult(True, final_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -22.74261,
          "time_improvement": 19.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1711.0,
          "node_improvement": 71.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04078545570373535,
                    "num_nodes_avg": 147.9,
                    "path_length_avg": 166.4464658584535,
                    "smoothness_avg": 0.05400458778946319,
                    "success_improvement": 0.0,
                    "time_improvement": -58.13948758718552,
                    "node_improvement": 62.75497355829766,
                    "length_improvement": 8.768054549947896,
                    "smoothness_improvement": 745.2890717445006,
                    "objective_score": -8.454568187464416
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050977444648742674,
                    "num_nodes_avg": 322.0,
                    "path_length_avg": 242.74383553946228,
                    "smoothness_avg": 0.11769675882875945,
                    "success_improvement": 0.0,
                    "time_improvement": 69.21200020504703,
                    "node_improvement": 78.3645770342001,
                    "length_improvement": 18.96512070302588,
                    "smoothness_improvement": 2928.4223782127924,
                    "objective_score": 46.784784374393595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028009629249572753,
                    "num_nodes_avg": 226.8,
                    "path_length_avg": 127.57406637885784,
                    "smoothness_avg": 0.12253400941393153,
                    "success_improvement": 0.0,
                    "time_improvement": 44.80554533704865,
                    "node_improvement": 71.16338207247298,
                    "length_improvement": 15.27137953539513,
                    "smoothness_improvement": 1458.6235552254554,
                    "objective_score": 29.89760909847895
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.60434,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021024632453918456,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 179.86562069368742,
                    "smoothness_avg": 0.04340391432894737,
                    "success_improvement": 0.0,
                    "time_improvement": 18.480140883479937,
                    "node_improvement": 62.37723495341224,
                    "length_improvement": 1.41280314464036,
                    "smoothness_improvement": 579.365512356565,
                    "objective_score": 9.288551713611021
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02810840606689453,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.75216437677005,
                    "smoothness_avg": 0.0991357257905606,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02383326220045,
                    "node_improvement": 81.69723845998791,
                    "length_improvement": 17.960853947188074,
                    "smoothness_improvement": 2450.8336291682162,
                    "objective_score": 47.93783049281406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0594691276550293,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 129.64938979692397,
                    "smoothness_avg": 0.1243235500601021,
                    "success_improvement": 0.0,
                    "time_improvement": -17.187058813027633,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 13.893048537397146,
                    "smoothness_improvement": 1481.3863801545947,
                    "objective_score": 10.586643379302972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamically focused elliptical informed sampling around the current best path to concentrate sampling in promising regions and reduce wasted exploration. It maintains spatial hashing for efficient neighbor queries and employs adaptive rewiring radius that shrinks gently over iterations for steady path refinement. Shortcut smoothing is integrated continuously during planning and aggressively post-planning to remove unnecessary nodes and smooth corners, improving path quality and smoothness. The planner expands trees alternately from start and goal, connects trees when nearby nodes appear, and propagates cost improvements downstream. The algorithm terminates early on solution stability or max iterations, returning a smooth, short, collision-free path with efficient planning time.",
          "planning_mechanism": "A bidirectional RRT* planner alternately extends two trees from start and goal positions. Sampling is guided by an informed ellipsoidal region defined by the current best path cost to focus growth and reduce redundant exploration. Each extension steers towards sampled points constrained by collision-free edges within bounds. Neighbors are found efficiently using spatial hashing with a balanced cell size to enable quick rewiring within an adaptive radius that decreases slightly over iterations. Rewiring updates parents to lower-cost connections and propagates cost changes downstream. Tree connections are attempted when new nodes lie close to the opposite tree. An iterative shortcut routine is applied periodically and post-planning to shorten and smooth the path. Early pruning discards expansions unlikely to improve solution. Planning halts early when the best solution stabilizes or maximum iterations are reached, returning the best found collision-free path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_sample_rate=0.15,\n                 r_min=4.5,\n                 r_max=18.0,\n                 spatial_hash_cell=8.0,\n                 early_prune_threshold=1e-4,\n                 no_improve_limit=160,\n                 shortcut_attempts=60,\n                 smoothing_passes=3,\n                 smoothing_freq=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.spatial_hash_cell = spatial_hash_cell\n        self.early_prune_threshold = early_prune_threshold\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_attempts = shortcut_attempts\n        self.smoothing_passes = smoothing_passes\n        self.smoothing_freq = smoothing_freq\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos, goal_pos = map.start, map.goal\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=0.3):\n            length = dist(a, b)\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                t = i / steps\n                pt = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            r = self.step_size / length\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        # Spatial hash for efficient neighbor queries\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.buckets = {}\n\n            def _hash(self, p):\n                return tuple(int(coord // self.cell_size) for coord in p)\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                if key not in self.buckets:\n                    self.buckets[key] = []\n                self.buckets[key].append(node)\n\n            def query(self, p, radius):\n                base = self._hash(p)\n                cell_radius = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                for dx in range(-cell_radius, cell_radius + 1):\n                    for dy in range(-cell_radius, cell_radius + 1):\n                        if dim == 2:\n                            key = (base[0] + dx, base[1] + dy)\n                            if key in self.buckets:\n                                neighbors.extend(self.buckets[key])\n                        else:\n                            for dz in range(-cell_radius, cell_radius + 1):\n                                key = (base[0] + dx, base[1] + dy, base[2] + dz)\n                                if key in self.buckets:\n                                    neighbors.extend(self.buckets[key])\n                return neighbors\n\n        # Extract path from start tree node and goal tree node\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        # Iterative shortcut smoothing that tries aggressively within passes\n        def iterative_shortcut(path, attempts):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(self.smoothing_passes):\n                count = 0\n                while count < attempts:\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path) - 3)\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    if not edge_in_obstacle(new_path[i], new_path[j]):\n                        new_path = new_path[:i + 1] + new_path[j:]\n                        count = 0\n                    else:\n                        count += 1\n            return new_path\n\n        # Informed sampling: sample inside ellipsoidal region around current best path\n        def informed_sample(it, best_cost):\n            if best_cost == float('inf'):\n                # No solution yet, do uniform or goal-biased sample\n                p = random.random()\n                if p < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            else:\n                # Ellipsoid parameters\n                c_min = dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    c_min = best_cost  # Clamp\n                rand_angle = random.uniform(0, 2 * math.pi) if dim == 2 else None\n                # Define coordinate axes u1 along start->goal\n                if dim == 2:\n                    dx = goal_pos[0] - start_pos[0]\n                    dy = goal_pos[1] - start_pos[1]\n                    dist_norm = math.hypot(dx, dy)\n                    if dist_norm == 0:\n                        dist_norm = 1.0\n                    u1 = (dx / dist_norm, dy / dist_norm)\n                    # Orthogonal vector\n                    u2 = (-u1[1], u1[0])\n                    # Radii of ellipse\n                    a = best_cost / 2.0\n                    b = math.sqrt(a * a - (c_min / 2.0) ** 2) if a > (c_min / 2.0) else 0.0\n                    # Sample random point in unit circle\n                    r = random.uniform(0, 1) ** 0.5  # sqrt for uniform in circle\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = r * math.cos(theta)\n                    y_ball = r * math.sin(theta)\n                    # Scale by ellipse radii\n                    x_ell = a * x_ball\n                    y_ell = b * y_ball\n                    # Rotate and translate\n                    center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n                    px = center[0] + x_ell * u1[0] + y_ell * u2[0]\n                    py = center[1] + x_ell * u1[1] + y_ell * u2[1]\n                    pt = (px, py)\n                    # Clamp to bounds\n                    clamped = tuple(min(max(pt[i], 0.0), bounds[i]) for i in range(dim))\n                    if not in_obstacle(clamped):\n                        return clamped\n                    # If fail, fallback uniform near start/goal\n                    if random.random() < 0.5:\n                        return start_pos\n                    else:\n                        return goal_pos\n                else:\n                    # 3D ellipsoid sampling not implemented, fallback uniform\n                    p = random.random()\n                    if p < self.goal_sample_rate:\n                        return goal_pos\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not in_obstacle(pt):\n                            return pt\n\n        # Adaptive rewiring radius\n        def rewiring_radius(n_nodes, it):\n            if n_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            decay_factor = max(0.5, 1 - it / self.max_iter)\n            return max(self.r_min, min(self.r_max, base * decay_factor))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        sh_start = SpatialHash(self.spatial_hash_cell)\n        sh_goal = SpatialHash(self.spatial_hash_cell)\n        sh_start.insert(start_tree[0])\n        sh_goal.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        iter_since_improve = 0\n        improved = False\n\n        for it in range(self.max_iter):\n            sample = informed_sample(it, best_cost)\n\n            # Alternate active tree each iteration\n            if it % 2 == 0:\n                active_tree, other_tree = start_tree, goal_tree\n                sh_active, sh_other = sh_start, sh_goal\n                target_pos = goal_pos\n            else:\n                active_tree, other_tree = goal_tree, start_tree\n                sh_active, sh_other = sh_goal, sh_start\n                target_pos = start_pos\n\n            # Find nearest in active tree to sample via spatial hash query first\n            search_radius_nearest = self.step_size * 3\n            near_cands = sh_active.query(sample, search_radius_nearest)\n            if near_cands:\n                nearest_node = min(near_cands, key=lambda n: dist(n.position, sample))\n            else:\n                nearest_node = min(active_tree, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample)\n            if (\n                any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)) or\n                in_obstacle(new_pos) or\n                edge_in_obstacle(nearest_node.position, new_pos)\n            ):\n                continue\n\n            cost_to_new = nearest_node.cost + dist(nearest_node.position, new_pos)\n            estimate_total = cost_to_new + dist(new_pos, target_pos)\n            if estimate_total > best_cost + self.early_prune_threshold:\n                continue\n\n            r = rewiring_radius(len(active_tree) + 1, it)\n            near_nodes = [n for n in sh_active.query(new_pos, r) if dist(n.position, new_pos) <= r]\n            if nearest_node not in near_nodes:\n                near_nodes.append(nearest_node)\n\n            min_cost = cost_to_new\n            best_parent = nearest_node\n            for node_cand in near_nodes:\n                if node_cand is nearest_node:\n                    continue\n                c_cost = node_cand.cost + dist(node_cand.position, new_pos)\n                if c_cost + 1e-12 < min_cost and not edge_in_obstacle(node_cand.position, new_pos):\n                    min_cost = c_cost\n                    best_parent = node_cand\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            sh_active.insert(new_node)\n\n            for nbr in near_nodes:\n                if nbr is new_node or nbr is best_parent:\n                    continue\n                c_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if c_cost + 1e-12 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                    nbr.parent = new_node\n                    nbr.cost = c_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n                    propagate_cost(nbr)\n\n            # Attempt connection to other tree\n            r_connect = r * 1.5\n            near_other = [n for n in sh_other.query(new_pos, r_connect) if dist(n.position, new_pos) <= r_connect]\n            if near_other:\n                nearest_other = min(near_other, key=lambda n: dist(n.position, new_pos))\n            else:\n                nearest_other = min(other_tree, key=lambda n: dist(n.position, new_pos))\n\n            dist_conn = dist(new_pos, nearest_other.position)\n            threshold_conn = min(self.step_size * 2.0, r * 1.5)\n            if dist_conn <= threshold_conn and not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_conn + nearest_other.cost\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    path_raw = extract_path(solution_nodes[0], solution_nodes[1])\n                    path_smooth = iterative_shortcut(path_raw, self.shortcut_attempts)\n                    improved = True\n                    iter_since_improve = 0\n                    # Return immediately at breakthrough\n                    return PlannerResult(True, path_smooth, nodes, edges)\n\n            iter_since_improve += 1\n            if iter_since_improve >= self.no_improve_limit and best_cost < float('inf'):\n                # Early stop on convergence\n                break\n\n            # Periodic smoothing of best path\n            if improved and it % self.smoothing_freq == 0 and best_cost < float('inf'):\n                path_raw = extract_path(solution_nodes[0], solution_nodes[1])\n                path_smooth = iterative_shortcut(path_raw, self.shortcut_attempts)\n                improved = False\n                return PlannerResult(True, path_smooth, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            path_raw = extract_path(solution_nodes[0], solution_nodes[1])\n            path_smooth = iterative_shortcut(path_raw, self.shortcut_attempts)\n            return PlannerResult(True, path_smooth, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -22.58954,
          "time_improvement": 17.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1717.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04179184436798096,
                    "num_nodes_avg": 100.9,
                    "path_length_avg": 164.58602995501673,
                    "smoothness_avg": 0.04962295421166896,
                    "success_improvement": 0.0,
                    "time_improvement": -62.041608697058926,
                    "node_improvement": 74.5907831780408,
                    "length_improvement": 9.78778894911503,
                    "smoothness_improvement": 676.7069913824159,
                    "objective_score": -9.356274282736582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04539477825164795,
                    "num_nodes_avg": 285.9,
                    "path_length_avg": 241.8708039746049,
                    "smoothness_avg": 0.11690706556425605,
                    "success_improvement": 0.0,
                    "time_improvement": 72.58367042259849,
                    "node_improvement": 80.79016327353357,
                    "length_improvement": 19.256563768195562,
                    "smoothness_improvement": 2908.1030017240523,
                    "objective_score": 47.86955439631714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03057429790496826,
                    "num_nodes_avg": 288.5,
                    "path_length_avg": 126.74531576970128,
                    "smoothness_avg": 0.13108174624638463,
                    "success_improvement": 0.0,
                    "time_improvement": 39.75173021638334,
                    "node_improvement": 63.31849968213604,
                    "length_improvement": 15.8217962291337,
                    "smoothness_improvement": 1567.3501368059558,
                    "objective_score": 29.255347486425002
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant integrating adaptive sampling with frequent multi-scale smoothing, combining both incremental shortcutting after each path improvement and refined global smoothing with cubic spline interpolation for enhanced path smoothness and length optimization. The planner alternates growth of two trees with dynamic rewiring radius tuned by node density and current best path cost to balance exploration and exploitation. Frequent smoothing iterations prevent jaggedness early on, while spline-based smoothing refines path curvature globally, improving quality and reducing planning time. Efficient collision checks and coherent tree updates maintain path validity and robustness.",
          "planning_mechanism": "The planner implements a bidirectional RRT* algorithm that alternates tree growth from start and goal. It samples points from a hybrid strategy mixing uniform and ellipsoidal informed sampling based on current best path cost. Nodes are connected using a dynamic rewiring radius dependent on node density and path cost. Upon finding a better connection, an incremental shortcutting method quickly improves path quality, followed periodically by a global smoothing step that fits a cubic spline through the path, further enhancing smoothness. Collision checking is performed at both node and edge levels to maintain feasibility. The approach balances fast convergence, path optimality, and smoothness using multi-scale smoothing integrated directly into the planning loop.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=40, global_smooth_freq=100, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.3):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            if random.random() < self.uniform_sample_rate:\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            params = compute_ellipsoid_params()\n            if params is None:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.35, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j], resolution=0.3):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def fit_cubic_spline(path):\n            # For 2D/3D, generate cubic spline interpolation on each axis independently using natural boundary conditions\n            n = len(path)\n            if n < 4:\n                return path[:]\n            pts = list(zip(*path))  # unpack to axis sequences\n            dims_len = len(pts)\n            spline_pts = []\n\n            def cubic_spline_1d(xs, ys):\n                # Solve tridiagonal system for natural cubic spline coefficients\n                n = len(xs)\n                h = [xs[i+1]-xs[i] for i in range(n-1)]\n                al = [0]*(n)\n                for i in range(1,n-1):\n                    al[i] = (3/h[i])*(ys[i+1]-ys[i]) - (3/h[i-1])*(ys[i]-ys[i-1])\n                l = [1]*n\n                mu = [0]*n\n                z = [0]*n\n                for i in range(1,n-1):\n                    l[i] = 2*(xs[i+1]-xs[i-1]) - h[i-1]*mu[i-1]\n                    mu[i] = h[i]/l[i]\n                    z[i] = (al[i]-h[i-1]*z[i-1])/l[i]\n                c = [0]*n\n                b = [0]*(n-1)\n                d = [0]*(n-1)\n                c[n-1] = 0\n                for j in reversed(range(n-1)):\n                    c[j] = z[j] - mu[j]*c[j+1]\n                    b[j] = (ys[j+1]-ys[j])/h[j] - h[j]*(c[j+1]+2*c[j])/3\n                    d[j] = (c[j+1]-c[j])/(3*h[j])\n                return list(zip(ys[:-1], b, c[:-1], d, xs[:-1]))\n\n            # Parameterize by cumulative chord length t\n            t = [0]\n            for i in range(1,n):\n                seg_dist = dist(path[i], path[i-1])\n                t.append(t[-1] + seg_dist)\n            # Compute spline coeff for each axis\n            splines = []\n            for axis in range(dim):\n                splines.append(cubic_spline_1d(t, pts[axis]))\n\n            # Sample spline densely across segments\n            sample_points = []\n            sample_per_segment = max(5, int(self.step_size))  # adaptive density\n            for seg_i in range(n-1):\n                ys, bs, cs, ds, xs_start = splines[seg_i]\n                dt = (t[seg_i+1] - t[seg_i]) / sample_per_segment\n                for s in range(sample_per_segment):\n                    ti = s*dt\n                    val = ys + bs*ti + cs*ti*ti + ds*ti*ti*ti\n                    if seg_i == 0:\n                        sample_points.append([val] if dim==1 else [val])\n                    else:\n                        sample_points[-1].append(val)\n                # final point at segment end:\n                val = ys + bs*dt*sample_per_segment + cs*(dt*sample_per_segment)**2 + ds*(dt*sample_per_segment)**3\n                if dim == 1:\n                    sample_points.append([val])\n                else:\n                    if len(sample_points) < seg_i+2:\n                        sample_points.append([val])\n                    else:\n                        sample_points[-1].append(val)\n\n            # Correct format for 2D or 3D points\n            result = []\n            for i in range(len(sample_points)):\n                if dim == 2:\n                    pt = (float(sample_points[i][0]), float(sample_points[i][1]))\n                else:\n                    pt = tuple(float(sample_points[i][j]) for j in range(dim))\n                result.append(pt)\n            # Remove consecutive duplicates\n            filtered = [result[0]]\n            for p in result[1:]:\n                if dist(p, filtered[-1]) > 1e-5:\n                    filtered.append(p)\n            return filtered\n\n        def global_smooth(path):\n            # Apply multi-scale smoothing: incremental shortcut then spline fit (with collision checks)\n            path_s = incremental_shortcut(path)\n            # Fit spline and verify collisions between spline points\n            spline_path = path_s[:]\n\n            if len(spline_path) < 4:\n                return spline_path\n            # Generate parameterization t by chord length\n            def chord_length_param(pts):\n                tvals = [0.0]\n                for i in range(1,len(pts)):\n                    tvals.append(tvals[-1] + dist(pts[i], pts[i-1]))\n                return tvals\n\n            # Generate spline points sample at ~step_size/2 intervals:\n            try:\n                spline_pts = self._fit_cubic_spline_with_collision_check(spline_path, is_edge_in_obstacle, dist, self.step_size/2, is_in_obstacle)\n                if spline_pts is not None:\n                    return spline_pts\n                else:\n                    return path_s\n            except Exception:\n                return path_s\n\n        def _fit_cubic_spline_with_collision_check(path, is_edge_collide_func, dist_func, max_res, node_in_obs_func):\n            # Build cubic spline interpolation for each coordinate (2D/3D), then sample dense path\n            # Check collision on segments, if collision: reduce sampling / fallback\n            # Return None if no collision-free spline path found\n            if len(path) < 4:\n                return path[:]\n\n            n = len(path)\n            dim = len(path[0])\n            import math\n\n            # Chord length parameterization\n            t = [0]\n            for i in range(1, n):\n                t.append(t[-1] + dist_func(path[i], path[i-1]))\n\n            # Solve spline coefficients for each dimension\n            def solve_tridiag(xs, ys):\n                n = len(xs)\n                h = [xs[i+1] - xs[i] for i in range(n-1)]\n                al = [0]*n\n                for i in range(1,n-1):\n                    al[i] = 3*( (ys[i+1]-ys[i])/h[i] - (ys[i]-ys[i-1])/h[i-1] )\n                l = [1]*n\n                mu = [0]*n\n                z = [0]*n\n                for i in range(1,n-1):\n                    l[i] = 2*(xs[i+1]-xs[i-1]) - h[i-1]*mu[i-1]\n                    mu[i] = h[i]/l[i]\n                    z[i] = (al[i] - h[i-1]*z[i-1]) / l[i]\n                b = [0]*(n-1)\n                c = [0]*n\n                d = [0]*(n-1)\n                c[n-1] = 0\n                for j in reversed(range(n-1)):\n                    c[j]=z[j] - mu[j]*c[j+1]\n                    b[j] = (ys[j+1]-ys[j])/h[j] - h[j]*(c[j+1]+2*c[j])/3\n                    d[j] = (c[j+1]-c[j])/(3*h[j])\n                return list(zip(ys[:-1], b, c[:-1], d, xs[:-1]))\n\n            splines = []\n            for axis in range(dim):\n                spl = solve_tridiag(t, [p[axis] for p in path])\n                splines.append(spl)\n\n            # Sample spline on each segment with resolution max_res\n            sample_pts = []\n            for seg_i in range(n-1):\n                seg_len = t[seg_i+1] - t[seg_i]\n                samples_num = max(2, int(math.ceil(seg_len / max_res)))\n                for si in range(samples_num):\n                    tau = (t[seg_i+1] - t[seg_i]) * (si/samples_num)\n                    pt_coords = []\n                    for axis in range(dim):\n                        y,a,b,c,d,xs = splines[axis][seg_i]\n                        y_val = y + a*tau + b*tau*tau + c*tau*tau*tau\n                        pt_coords.append(y_val)\n                    pt = tuple(pt_coords)\n                    if node_in_obs_func(pt):\n                        return None\n                    if len(sample_pts) > 0:\n                        prev = sample_pts[-1]\n                        if is_edge_collide_func(prev, pt):\n                            return None\n                    sample_pts.append(pt)\n            # Append last point explicitly\n            sample_pts.append(path[-1])\n            return sample_pts\n\n        self._fit_cubic_spline_with_collision_check = _fit_cubic_spline_with_collision_check  # bind method\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    improved_since_last_global_smooth = True\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -22.51724,
          "time_improvement": 24.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1502.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03055291175842285,
                    "num_nodes_avg": 136.5,
                    "path_length_avg": 168.18036162790688,
                    "smoothness_avg": 0.04566262596478101,
                    "success_improvement": 0.0,
                    "time_improvement": -18.464333091440217,
                    "node_improvement": 65.62578695542685,
                    "length_improvement": 7.817678803373811,
                    "smoothness_improvement": 614.7192543281838,
                    "objective_score": 2.2249036262331403
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03276522159576416,
                    "num_nodes_avg": 264.2,
                    "path_length_avg": 248.38845043028738,
                    "smoothness_avg": 0.10298150707376563,
                    "success_improvement": 0.0,
                    "time_improvement": 80.21133380217684,
                    "node_improvement": 82.24820264731572,
                    "length_improvement": 17.080785781237296,
                    "smoothness_improvement": 2549.788351589376,
                    "objective_score": 47.060813367342305
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04496357440948486,
                    "num_nodes_avg": 313.9,
                    "path_length_avg": 130.1547483370754,
                    "smoothness_avg": 0.11340443198065453,
                    "success_improvement": 0.0,
                    "time_improvement": 11.396900433217718,
                    "node_improvement": 60.08900190718373,
                    "length_improvement": 13.55741345761628,
                    "smoothness_improvement": 1342.4960041494808,
                    "objective_score": 18.265998225282488
               }
          ],
          "success_rate": 1.0
     }
]