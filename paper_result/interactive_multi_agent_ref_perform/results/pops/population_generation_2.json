[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive radius rewiring, informed sampling after first solution, frequent incremental shortcutting to improve path smoothness and length, early termination on solution stagnation, and efficient collision checks. It alternates growing start and goal trees, connects and rewires nodes within adaptive radius based on node count, and progressively shortcuts the best path during planning for better convergence in less time.",
          "planning_mechanism": "The Planner grows two trees from start and goal, samples points uniformly or within an ellipsoidal informed subset after a solution is found, extends and rewires nodes within an adaptive radius logarithmically decreasing with node count, attempts connections between trees to form a solution, and applies incremental shortcutting after solution improvements and periodically to smooth and shorten paths, terminating early if no improvements occur for a defined interval.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=20, max_shortcut_attempts=40, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            if dim == 2:\n                cos_theta = dir_vec[0]/length\n                sin_theta = dir_vec[1]/length\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1*x_ball[0], a2*x_ball[1]]\n                    pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                          center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                # 3D sampling inside prolate hyperspheroid\n                from math import sqrt\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq==0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    # Rotation matrix mapping x-axis to dir_vec unit vector\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i]-from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size*8.0\n            return min(self.step_size*30, self.gamma_rrt_star*(math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        last_improve_iter = 0\n        no_improve_limit = 100\n\n        for iter in range(self.max_iter):\n            if best_cost < float('inf') and random.random() < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = iter\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        path = extract_path(solution_start, solution_goal)\n                        for _ in range(2):\n                            path = shortcut_path(path)\n                        # Replace last path with shortcut improved\n                        if len(path) < len(extract_path(solution_start, solution_goal)):\n                            # best path shortened\n                            continue\n\n            if best_cost < float('inf') and (iter - last_improve_iter) > no_improve_limit:\n                break\n\n            if best_cost < float('inf') and iter % self.shortcut_interval == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -32.21382,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1551.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02305736541748047,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 168.73944907303084,
                    "smoothness_avg": 0.04309848636832513,
                    "success_improvement": 0.0,
                    "time_improvement": 10.598523681644005,
                    "node_improvement": 71.74515235457064,
                    "length_improvement": 7.511234115393865,
                    "smoothness_improvement": 574.5849015253947,
                    "objective_score": 10.559222081356495
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02576143741607666,
                    "num_nodes_avg": 208.1,
                    "path_length_avg": 237.2903072590682,
                    "smoothness_avg": 0.1076212802971938,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44129290220465,
                    "node_improvement": 86.01760397769269,
                    "length_improvement": 20.785665414129483,
                    "smoothness_improvement": 2669.1730585217547,
                    "objective_score": 51.149652411747866
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018548035621643068,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 128.3642742559325,
                    "smoothness_avg": 0.11870521723960548,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45011559832764,
                    "node_improvement": 76.78321678321677,
                    "length_improvement": 14.746561089097684,
                    "smoothness_improvement": 1409.9216013800688,
                    "objective_score": 34.93257933985725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional Anytime Informed RRT* planner integrating adaptive density-based rewiring radius, ellipsoidal informed sampling, incremental path shortcutting, and optimized data structures for enhanced planning efficiency, robustness, and path quality. It grows trees from start and goal, alternates expansions, samples within shrinking ellipsoidal informed sets, dynamically adapts rewiring radius based on node density, rewires neighbors to improve cost locally, attempts early tree connection to reduce search time, and frequently applies a focused incremental shortcutting method to continuously smooth and shorten the path while maintaining collision safety.",
          "planning_mechanism": "The algorithm alternates expansions between two bidirectional trees and samples points concentrated in an ellipsoidal informed region defined by the current best solution cost. It incorporates a density-adaptive rewiring radius for efficient pruning and rewiring, performs collision-checked parent selection and neighbor rewiring, connects trees when nodes are reachable, and incrementally shortcuts the current best path at frequent intervals to improve smoothness and length without excessive computation. This continuous interplay of sampling, rewiring, connection, and shortcutting rapidly converges towards an optimal, smooth path with reduced runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0, shortcut_freq=25, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def unit_ball_vol(d):\n            if d == 2:\n                return math.pi\n            if d == 3:\n                return 4.0/3.0*math.pi\n            from math import gamma, pi\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [direction[0]/length, direction[1]/length]\n                    cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [direction[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball)<=1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            dist_sq = 0.0\n            diff_vec = []\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                diff_vec.append(diff)\n                dist_sq += diff*diff\n            dist = dist_sq**0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            new_pos = tuple(from_pos[i] + diff_vec[i]*ratio for i in range(dim))\n            return new_pos\n\n        def is_edge_collision_free(p1, p2):\n            # Collision check in intervals of max 1.0 units for efficiency\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / 1.0))\n            for step_i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(step_i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not is_edge_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                tentative = n.cost + math.dist(n.position, new_pos)\n                if tentative < min_cost:\n                    if is_edge_collision_free(n.position, new_pos):\n                        min_cost = tentative\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent if beneficial\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if is_edge_collision_free(new_node.position, n.position):\n                        if n.parent is not None:\n                            try: edges.remove((n.parent, n))\n                            except ValueError: pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect to nearest node in other tree within step_size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_edge_collision_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            shortcut_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) <3:\n                    break\n                i = random.randint(0,len(shortcut_path)-3)\n                j = random.randint(i+2,len(shortcut_path)-1)\n                if is_edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False",
          "objective": -32.21323,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01826310157775879,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 166.80041346603122,
                    "smoothness_avg": 0.03850615988076263,
                    "success_improvement": 0.0,
                    "time_improvement": 29.187562688064194,
                    "node_improvement": 67.01082850667338,
                    "length_improvement": 8.574050257575799,
                    "smoothness_improvement": 502.7050195984601,
                    "objective_score": 16.414224058957036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02589578628540039,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 234.42132183759287,
                    "smoothness_avg": 0.0955636258647175,
                    "success_improvement": 0.0,
                    "time_improvement": 84.36015244901614,
                    "node_improvement": 83.86749983202311,
                    "length_improvement": 21.743415326984575,
                    "smoothness_improvement": 2358.9209251966936,
                    "objective_score": 50.14869955687905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028525924682617186,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 126.10181619096082,
                    "smoothness_avg": 0.1209255471006773,
                    "success_improvement": 0.0,
                    "time_improvement": 43.78815790153682,
                    "node_improvement": 70.10807374443738,
                    "length_improvement": 16.24917800917602,
                    "smoothness_improvement": 1438.1640333251999,
                    "objective_score": 30.07677434259266
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.35436,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020946669578552245,
                    "num_nodes_avg": 169.2,
                    "path_length_avg": 156.9968252907203,
                    "smoothness_avg": 0.020851635172459877,
                    "success_improvement": 0.0,
                    "time_improvement": 18.782430240028845,
                    "node_improvement": 57.39108536892471,
                    "length_improvement": 13.947552284259512,
                    "smoothness_improvement": 226.3733704995064,
                    "objective_score": 15.135127295061892
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029881834983825684,
                    "num_nodes_avg": 307.0,
                    "path_length_avg": 231.7579073494588,
                    "smoothness_avg": 0.09111135278880159,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95276488074154,
                    "node_improvement": 79.3724383524827,
                    "length_improvement": 22.63253974525912,
                    "smoothness_improvement": 2244.360732110702,
                    "objective_score": 49.38715697193144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02644164562225342,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 123.73707639297194,
                    "smoothness_avg": 0.07830820806750623,
                    "success_improvement": 0.0,
                    "time_improvement": 47.89533993801242,
                    "node_improvement": 63.4837889383344,
                    "length_improvement": 17.819725586191648,
                    "smoothness_improvement": 896.0746265080132,
                    "objective_score": 29.54081046565878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
          "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -29.43149,
          "time_improvement": 46.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1325.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025296664237976073,
                    "num_nodes_avg": 157.7,
                    "path_length_avg": 169.82640352208247,
                    "smoothness_avg": 0.034435143239248046,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9159783497959368,
                    "node_improvement": 60.28708133971292,
                    "length_improvement": 6.915457157973212,
                    "smoothness_improvement": 438.98476880462505,
                    "objective_score": 6.918991643745834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026137399673461913,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 237.06092208208943,
                    "smoothness_avg": 0.09896313272769311,
                    "success_improvement": 0.0,
                    "time_improvement": 84.21422922761201,
                    "node_improvement": 84.65363166028354,
                    "length_improvement": 20.862240788691224,
                    "smoothness_improvement": 2446.3926853468774,
                    "objective_score": 50.01357666823272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02440671920776367,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 124.62874035050683,
                    "smoothness_avg": 0.09361395032374312,
                    "success_improvement": 0.0,
                    "time_improvement": 51.90526997765084,
                    "node_improvement": 72.01525746980292,
                    "length_improvement": 17.227524842071908,
                    "smoothness_improvement": 1090.7625382549713,
                    "objective_score": 31.361908589813254
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
          "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -28.03557,
          "time_improvement": 38.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1533.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive sampling radius, momentum-based tree extension, and batch rewiring to efficiently converge to high-quality solutions. The algorithm uses ellipsoidal informed sampling shrinking with the best path cost and adapts the rewiring radius scaling with tree density to balance exploration and local optimization. Momentum steering moves nodes further along promising directions to accelerate convergence. Batch rewiring is performed less frequently but covers a broader neighborhood for better path refinement. Incremental shortcutting runs immediately after improvements to incrementally shorten and smooth the path, enhancing path length and smoothness while reducing search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling within a shrinking ellipsoidal informed subset after the first found path. Each iteration attempts to extend in momentum-driven directions to improve progress speed. It adaptively chooses parent nodes and rewires a dynamically scaled neighborhood to optimize cost. Batch rewiring periodically repairs the trees globally. Paths are incrementally shortcut as soon as better solutions are found for continuous quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, gamma_adapt=45.0, batch_rewire_freq=50, max_shortcut_attempts=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_adapt = gamma_adapt\n        self.batch_rewire_freq = batch_rewire_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.2\n            val = self.gamma_adapt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 45.0)\n\n        def sample_ellipsoidal():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in direction]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0], [0,a_other,0], [0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer_momentum(from_pos, to_pos, momentum):\n            dist = math.dist(from_pos, to_pos)\n            if dist < 1e-12:\n                return from_pos\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            step = min(self.step_size, dist)\n            base_new = tuple(from_pos[i]+direction[i]*step for i in range(dim))\n            # Apply momentum to push further if within map bounds and free\n            momentum_step = 0.6 * self.step_size\n            candidate = tuple(base_new[i] + direction[i]*momentum_step for i in range(dim))\n            if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)):\n                return candidate\n            return base_new\n\n        def rewire_batch(tree):\n            n_nodes = len(tree)\n            if n_nodes <= 1:\n                return\n            r = radius(n_nodes) * 1.15  # slightly larger radius for batch rewiring\n            for n in tree:\n                near_nodes = self._near(tree, n.position, r)\n                for near in near_nodes:\n                    if near is n or n.parent is None:\n                        continue\n                    tentative_cost = n.cost + math.dist(n.position, near.position)\n                    if tentative_cost + 1e-9 < near.cost:\n                        if not self._is_edge_in_obstacle(n.position, near.position, obstacles, is_3d):\n                            # Rewire near node to n\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = n\n                            near.cost = tentative_cost\n                            n.add_child(near)\n                            edges.append((n, near))\n\n        def attempt_extend(tree_from, tree_to, sample, prev_dir):\n            nearest = self._nearest(tree_from, sample)\n            if prev_dir is None:\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n            else:\n                new_pos = steer_momentum(nearest.position, sample, prev_dir)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None, None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None, None\n\n            new_node = Node(new_pos)\n            rn = radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, rn)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            d_connect = math.dist(new_node.position, nearest_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_connect + nearest_other.cost\n                    return (new_node, nearest_other, total_cost, \n                            tuple((new_node.position[i] - nearest_other.position[i]) for i in range(dim)))\n            return None, None, None, None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            pth = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not self._is_edge_in_obstacle(pth[i], pth[j], obstacles, is_3d):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        prev_direction = None\n        for it in range(self.max_iter):\n            sample = sample_ellipsoidal()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(treeA, treeB, sample, prev_direction)\n                if res[0] is not None:\n                    new_node, connect_node, c_cost, direction_vec = res\n                    if c_cost + 1e-9 < best_cost:\n                        best_cost = c_cost\n                        prev_direction = direction_vec\n                        if treeA is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n                        # Incremental shortcut immediately on improvement\n                        raw_path = self._extract_path(sol_start, sol_goal)\n                        improved_path = incremental_shortcut(raw_path)\n                        if improved_path and len(improved_path) >= 2:\n                            # Batch rewiring occasionally for global improvement\n                            if it % self.batch_rewire_freq == 0:\n                                rewire_batch(start_tree)\n                                rewire_batch(goal_tree)\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n            # Occasionally batch rewire for global tree quality\n            if it > 0 and it % self.batch_rewire_freq == 0:\n                rewire_batch(start_tree)\n                rewire_batch(goal_tree)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur is not None:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_goal = []\n        cur = node_goal\n        while cur is not None:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -27.13468,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1399.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016662406921386718,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 161.76013706572985,
                    "smoothness_avg": 0.04759929459666155,
                    "success_improvement": 0.0,
                    "time_improvement": 35.394016149831984,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 11.336705620871545,
                    "smoothness_improvement": 645.0323239603604,
                    "objective_score": 20.645389837274323
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0229341983795166,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 235.63681484522058,
                    "smoothness_avg": 0.09687544838552706,
                    "success_improvement": 0.0,
                    "time_improvement": 86.14881346306589,
                    "node_improvement": 88.49694282066787,
                    "length_improvement": 21.33764877501207,
                    "smoothness_improvement": 2392.675063524693,
                    "objective_score": 50.610608621550476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06088290214538574,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 124.62617397516483,
                    "smoothness_avg": 0.09909509135315861,
                    "success_improvement": 0.0,
                    "time_improvement": -19.972976160105908,
                    "node_improvement": 70.59122695486333,
                    "length_improvement": 17.2292293063764,
                    "smoothness_improvement": 1160.4822475733902,
                    "objective_score": 10.14805597366102
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.77328,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1515.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An improved bidirectional RRT* planner integrating adaptive rewiring radius scaling and a probabilistic goal-biased informed sampling scheme, combined with frequent, iterative, and cautious shortcutting that preserves smoothness. This planner enhances path quality and smoothness by incorporating an adaptive neighbor radius based on the number of nodes and dimension, dynamically balancing exploration with goal bias, and applying incremental smoothing phases that limit abrupt path modifications. Tree connection attempts occur often to accelerate solution discovery. Meanwhile, rewiring drops parents only when a truly better cost is achievable, and cost updates propagate efficiently to maintain subtree consistency for smooth path refinement.",
          "planning_mechanism": "The planner grows two trees from start and goal, exploring with goal-biased, adaptive informed elliptical sampling that shrinks as better solutions are found. It steers with fixed steps and rewires within a dynamically scaled neighborhood radius calculated to maintain local path quality in accordance with dimensionality and tree size. The planner frequently attempts to connect the trees and propagates cost updates recursively on rewiring to ensure subtree cost consistency. After each successful connection, a multi-pass shortcutting method iteratively attempts valid shortcuts with limited aggressive node removal to enhance smoothness without causing sharp deviations. This approach optimizes both runtime and path quality robustly in complex environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b): return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            # Dimension-specific adaptive radius: r = min(r_max, max(r_min, gamma * (log n / n)^{1/d}))\n            # gamma empirically taken as 40\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            # goal biased informed sampling if solution found; else uniform with goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                # informed sampling inside ellipsoid aligned with start-goal\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    # degenerate\n                    return goal_pos\n\n                # Rotate samples to align ellipsoid with line between start and goal\n                # Build orthonormal basis\n                e1 = [x/length for x in a1]\n                # Generate orthogonal vectors with Gram-Schmidt\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    # Simple for 2D and 3D:\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        import math\n                        # Choose arbitrary\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            # fallback\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                # Compute ellipsoid axes\n                c_min = length\n                # safety margin to allow slightly larger sampling region for exploration\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                # Axes lengths (a): a1 = c_max/2, others scale by sqrt(c_max^2 - c_min^2)/2 or fallback\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    # sample in unit ball first\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1]]\n                        # rotate back to map coords\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        # 3D\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            # Euclidean distance nearest node\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            return [n for n in tree if ( (n.position[0]-p[0])**2 + (n.position[1]-p[1])**2 + ((n.position[2]-p[2])**2 if is_3d else 0.0)) <= r2]\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # start path reversed + goal path trimmed of start overlap\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=5, max_attempts_per_pass=200):\n            # cautious multi-pass shortcutting; avoid removing nodes that create sharp turns\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts +=1\n                        continue\n                    if is_free_edge(new_path[i], new_path[j]):\n                        # Check local smoothness before shortcut removal\n                        # compute turning angles if removing intermediate nodes between i and j\n                        prev_pt = new_path[i]\n                        next_pt = new_path[j]\n                        remove_indices = range(i+1, j)\n                        # crude smoothness check: angle at prev_pt and next_pt\n                        def angle(a,b,c):\n                            import math\n                            ab = [b[k]-a[k] for k in range(dim)]\n                            cb = [b[k]-c[k] for k in range(dim)]\n                            lab = math.sqrt(sum(x*x for x in ab))\n                            lcb = math.sqrt(sum(x*x for x in cb))\n                            if lab < 1e-8 or lcb < 1e-8:\n                                return 0\n                            dot = sum(ab[k]*cb[k] for k in range(dim))\n                            val = max(min(dot/(lab*lcb),1),-1)\n                            return math.acos(val)\n                        # For safety, check angle formed by prev_pt -> next_pt (expected to be ~0)\n                        # and angles before and after removing nodes\n                        if i>0:\n                            a = new_path[i-1]\n                            b = prev_pt\n                            c = next_pt\n                            a1 = angle(a,b,c)\n                            if a1 > math.pi*135/180: # >135 degrees sharp\n                                i+=1\n                                attempts+=1\n                                continue\n                        if j<len(new_path)-1:\n                            a = prev_pt\n                            b = next_pt\n                            c = new_path[j+1]\n                            a2 = angle(a,b,c)\n                            if a2 > math.pi*135/180:\n                                i+=1\n                                attempts+=1\n                                continue\n                        # Accept shortcut if angles okay:\n                        # Remove intermediate nodes:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        improved = True\n                        # Restart checking from start after change to propagate smoothing\n                        i = 0\n                        attempts +=1\n                        continue\n                    else:\n                        i+=1\n                        attempts+=1\n                if not improved:\n                    break\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate tree expansions for balance and exploration\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            # Compute adaptive neighbor radius for rewiring based on number of nodes in prop_tree\n            r = rewiring_radius(len(prop_tree))\n\n            near_nodes = near(prop_tree, new_pos, r)\n            # Choose parent minimizing cost + heuristic with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                # Use strict improvement only\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cost improves with new_node as parent\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old parent edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            # Attempt connection from new_node to other_tree for path joining\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            # After finding a solution, apply shortcutting iteratively every 80 iterations or at last iteration\n            if solution_nodes[0] and solution_nodes[1] and ( (it > 0 and it % 80 == 0) or it == self.max_iter-1 ):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n                if smoothed:\n                    return PlannerResult(True, smoothed, nodes, edges)\n\n        # Final return after max_iter or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n            return PlannerResult(True, smoothed, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.71512,
          "time_improvement": 54.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 465.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017966294288635255,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 163.95951929194274,
                    "smoothness_avg": 0.024923003054025138,
                    "success_improvement": 0.0,
                    "time_improvement": 30.338388437200997,
                    "node_improvement": 56.3082347015865,
                    "length_improvement": 10.131189371242641,
                    "smoothness_improvement": 290.09911896286457,
                    "objective_score": 16.630725748720206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03304464817047119,
                    "num_nodes_avg": 340.6,
                    "path_length_avg": 250.18134841864676,
                    "smoothness_avg": 0.025115402013338145,
                    "success_improvement": 0.0,
                    "time_improvement": 80.04257317904118,
                    "node_improvement": 77.11482899952965,
                    "length_improvement": 16.48226482701569,
                    "smoothness_improvement": 546.2373836960618,
                    "objective_score": 36.63331776840208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024051189422607422,
                    "num_nodes_avg": 287.7,
                    "path_length_avg": 129.7207213209384,
                    "smoothness_avg": 0.05176360916448404,
                    "success_improvement": 0.0,
                    "time_improvement": 52.60586020800652,
                    "node_improvement": 63.42021614748887,
                    "length_improvement": 13.84567353558893,
                    "smoothness_improvement": 558.4292877800516,
                    "objective_score": 26.88130862265557
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
          "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -26.27848,
          "time_improvement": 35.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.16492572596105,
          "time_improvement": 92.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003008270263671875,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 184.17006126805845,
                    "smoothness_avg": 0.01054995558932253,
                    "success_improvement": 0.0,
                    "time_improvement": 88.33588322571401,
                    "node_improvement": 82.85066733820196,
                    "length_improvement": -0.9465289423981464,
                    "smoothness_improvement": 65.12971456814059,
                    "objective_score": 26.25849617511602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008660387992858887,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 300.8164456420612,
                    "smoothness_avg": 0.0064472474436514295,
                    "success_improvement": 0.0,
                    "time_improvement": 94.76952943432936,
                    "node_improvement": 85.05005711214136,
                    "length_improvement": -0.4211880766230819,
                    "smoothness_improvement": 65.89232048978258,
                    "objective_score": 28.50760758677387
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0042524576187133786,
                    "num_nodes_avg": 126.3,
                    "path_length_avg": 160.72624335922288,
                    "smoothness_avg": 0.012431076585876402,
                    "success_improvement": 0.0,
                    "time_improvement": 91.62030753242554,
                    "node_improvement": 83.94151303242214,
                    "length_improvement": -6.746717877938324,
                    "smoothness_improvement": 58.122376605720596,
                    "objective_score": 23.72867341599327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -26.062040773062417,
          "time_improvement": 66.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 167.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012016057968139648,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 175.84673815929608,
                    "smoothness_avg": 0.016310939143948412,
                    "success_improvement": 0.0,
                    "time_improvement": 53.409537367863955,
                    "node_improvement": 66.1294384286074,
                    "length_improvement": 3.6156163450092893,
                    "smoothness_improvement": 155.30161737405683,
                    "objective_score": 18.96873910423504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018314409255981445,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 257.3377355314211,
                    "smoothness_avg": 0.010767991223558952,
                    "success_improvement": 0.0,
                    "time_improvement": 88.93895070058699,
                    "node_improvement": 83.00073909830007,
                    "length_improvement": 14.093256823589732,
                    "smoothness_improvement": 177.06817005275553,
                    "objective_score": 36.02298015459372
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022396659851074217,
                    "num_nodes_avg": 265.9,
                    "path_length_avg": 136.5245362961063,
                    "smoothness_avg": 0.0210441701583257,
                    "success_improvement": 0.0,
                    "time_improvement": 55.86619816574277,
                    "node_improvement": 66.19198982835347,
                    "length_improvement": 9.326903591935762,
                    "smoothness_improvement": 167.68029109483984,
                    "objective_score": 23.19440306035849
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an improved bidirectional Informed RRT* algorithm. It integrates elliptical informed sampling after an initial feasible path is found to concentrate search towards lower-cost solutions, adaptive rewiring radius based on tree cardinality and space dimension, and a gradient-based local smoothing post-processing to enhance path smoothness and length. The algorithm alternates tree expansions, rewires locally for cost improvements, attempts early tree connections, and continuously refines the path by restricting samples within the informed subset of the configuration space, improving planning efficiency, path quality, and convergence speed.",
          "planning_mechanism": "The algorithm starts growing two trees from start and goal positions using RRT* extensions. Initially, samples are uniform random with goal bias. Upon finding a first feasible path, the planner calculates an ellipsoidal informed sampling region tightly enclosing start and goal based on current best path cost, biasing new samples there. Nearby nodes are rewired using adaptive radius to improve costs. Early connection attempts between trees prune unnecessary expansions. After planning, a gradient-based smoothing is applied to the combined path to reduce sharp turns and shorten path length further, ensuring all nodes and edges respect collision constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.1, shortcut_iterations=120, smoothing_iters=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.0\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size * 1.5)\n\n        # Ellipse informed sampling helper\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoid centered between start and goal\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_best for i in range(dim))  # unit vector along start->goal\n\n            # Build orthonormal basis:\n            # Gram-Schmidt for higher dim (supporting 2D and 3D)\n            # We'll build transformation matrix with a1 as first column\n            import math as _math\n            # Create basis matrix Q = [a1, a2, a3,...]\n            orthonormal = [a1]\n            for i_dim in range(dim):\n                e = [0.0]*dim\n                e[i_dim] = 1.0\n                # Orthogonalize e wrt previous basis\n                for b in orthonormal:\n                    proj = sum(e[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        e[j] -= proj * b[j]\n                norm_e = math.sqrt(sum(v*v for v in e))\n                if norm_e > 1e-8:\n                    e = [v/norm_e for v in e]\n                    orthonormal.append(e)\n                if len(orthonormal) >= dim:\n                    break\n            Q = orthonormal[:dim]\n\n            # Radii of ellipse axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others]\n            elif dim == 3:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others, r_others]\n            else:\n                # For higher dim, fallback to bounding box sampling (should not occur here)\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Sample uniformly inside unit n-ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(px*px for px in x))\n                if norm_x > 1e-8:\n                    break\n            x_unit = [px/norm_x for px in x]\n            scale = random.uniform(0,1)**(1.0/dim)\n            x_scaled = [scale*v for v in x_unit]\n\n            # Map unit ball sample to ellipse point: center + Q * (radii * x_scaled)\n            sample = [center[i] + sum(Q[j][i]*radii[j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            # Clamp sample to map bounds\n            clamped = tuple(max(0.0, min(bounds[i], sample[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                return informed_sample(c_best)\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce length and sharp turns\n            # Random pairwise shortcutting with collision check\n            def check_shortcut(i,j):\n                return not is_edge_in_obstacle(path[i], path[j])\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if check_shortcut(i,j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def gradient_smooth_path(path, alpha=0.2, beta=0.4, iterations=40):\n            # Smooth path using gradient descent approach similar to path smoothing in PRM/RRT*\n            if len(path) < 3:\n                return path[:]\n            smoothed = [list(p) for p in path]\n            for _ in range(iterations):\n                for i in range(1,len(smoothed)-1):\n                    p = smoothed[i]\n                    p_old = p[:]\n                    # Smoothness term: pull point towards neighbors\n                    for d in range(dim):\n                        p[d] += alpha * (smoothed[i-1][d] + smoothed[i+1][d] - 2*p[d])\n                    # Data term: keeps it close to original vertex position\n                    for d in range(dim):\n                        p[d] += beta * (path[i][d] - p[d])\n\n                    # Clamp to bounds\n                    for d in range(dim):\n                        p[d] = max(0.0, min(bounds[d], p[d]))\n\n                    # Collision check for edges (i-1)-(i) and (i)-(i+1)\n                    prev_p = tuple(smoothed[i-1])\n                    nxt_p = tuple(smoothed[i+1])\n                    curr_p = tuple(p)\n                    if (is_in_obstacle(curr_p) or \n                        is_edge_in_obstacle(prev_p, curr_p) or \n                        is_edge_in_obstacle(curr_p, nxt_p)):\n                        # revert if invalid\n                        smoothed[i] = p_old\n                    else:\n                        smoothed[i] = p\n            return [tuple(p) for p in smoothed]\n\n        success = False\n        connection_pair = (None, None)\n        c_best = float('inf')\n        best_path_nodes = None\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point(c_best)\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connection with other tree within adaptive radius\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Build candidate path and update c_best if better\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    candidate_path_nodes = extract_path(node_start, node_goal)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path_nodes)-1):\n                        candidate_cost += dist(candidate_path_nodes[i], candidate_path_nodes[i+1])\n                    if candidate_cost < c_best:\n                        c_best = candidate_cost\n                        connection_pair = (node_start, node_goal)\n                        best_path_nodes = candidate_path_nodes\n                        success = True\n            if success and (it > 100 and it % 30 == 0):\n                # Early termination could be allowed if path cost is stable\n                break\n\n        path = []\n        if success and best_path_nodes:\n            # Post-processing: shortcut + gradient smoothing\n            path = shortcut_path(best_path_nodes)\n            path = gradient_smooth_path(path, iterations=self.smoothing_iters)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -24.91343,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04222602844238281,
                    "num_nodes_avg": 145.6,
                    "path_length_avg": 165.7015735704016,
                    "smoothness_avg": 0.03195078114288795,
                    "success_improvement": 0.0,
                    "time_improvement": -63.72509232767426,
                    "node_improvement": 63.33417275245531,
                    "length_improvement": 9.1763418166028,
                    "smoothness_improvement": 400.09910711794936,
                    "objective_score": -11.611227072750854
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934156894683838,
                    "num_nodes_avg": 346.2,
                    "path_length_avg": 234.8985415700393,
                    "smoothness_avg": 0.10549100772507927,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23952661781249,
                    "node_improvement": 76.7385607740375,
                    "length_improvement": 21.58410564428557,
                    "smoothness_improvement": 2614.3596108679344,
                    "objective_score": 48.89411942625476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02059016227722168,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 120.75685810991956,
                    "smoothness_avg": 0.12972022960082913,
                    "success_improvement": 0.0,
                    "time_improvement": 59.42599710311202,
                    "node_improvement": 67.60330578512396,
                    "length_improvement": 19.799044667050456,
                    "smoothness_improvement": 1550.031745571195,
                    "objective_score": 37.45738465901985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
          "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.21547,
          "time_improvement": 21.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1469.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025556087493896484,
                    "num_nodes_avg": 151.3,
                    "path_length_avg": 173.88763401105183,
                    "smoothness_avg": 0.047474639256938476,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9101035826373128,
                    "node_improvement": 61.89876605389071,
                    "length_improvement": 4.689432372653788,
                    "smoothness_improvement": 643.0811972002915,
                    "objective_score": 6.302096484384924
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031405282020568845,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 230.86304004149935,
                    "smoothness_avg": 0.09581397875517297,
                    "success_improvement": 0.0,
                    "time_improvement": 81.03267389975849,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 22.93127220998329,
                    "smoothness_improvement": 2365.362685390011,
                    "objective_score": 49.89537892286758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06047847270965576,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 119.93973012619429,
                    "smoothness_avg": 0.11787316210161418,
                    "success_improvement": 0.0,
                    "time_improvement": -19.176026584091733,
                    "node_improvement": 59.6694214876033,
                    "length_improvement": 20.341742166387515,
                    "smoothness_improvement": 1399.337921440741,
                    "objective_score": 13.448926931808694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive goal biasing, efficient nearest neighbor queries via dynamic grid hashing, curvature-guided cost evaluation, and iterative path improvement through constrained shortcutting. The planner grows two trees from start and goal simultaneously, leveraging curvature penalties to encourage smooth trajectories, and adapts neighbor radius dynamically by iteration count and problem dimension. It automatically updates the best path using shortcutting upon connecting the trees, balancing exploration and path quality to improve time efficiency, smoothness, and path length.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the goal vicinity and around the current best solution cost, uses spatial hashing for fast near node queries, combines path length and curvature penalties in cost calculations, performs local rewiring to optimize the tree, attempts to connect the trees frequently, and shortcuts the path iteratively to remove unnecessary nodes. Early stopping occurs upon finding a valid path with stable cost within iteration limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.2, base_radius=18.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.35):\n            length = math.dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.5\n        def grid_hash(p):\n            return tuple(int(coord/GRID_SIZE) for coord in p)\n\n        # spatial hash tables for start and goal trees\n        start_hash = {}\n        goal_hash = {}\n\n        def add_to_hash(hash_table, node):\n            h = grid_hash(node.position)\n            if h not in hash_table:\n                hash_table[h] = []\n            hash_table[h].append(node)\n\n        def nearby_nodes(hash_table, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hash_table:\n                    for node in hash_table[cell]:\n                        sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                        if sq <= radius_sq:\n                            candidates.append(node)\n            return candidates\n\n        def nearest(hash_table, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # search up to 2 grid expansions\n            for radius_cells in range(2):\n                candidates = []\n                if dim == 2:\n                    neighbors = [(gh[0]+dx, gh[1]+dy) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1)]\n                else:\n                    neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1) for dz in range(-radius_cells,radius_cells+1)]\n                for cell in neighbors:\n                    if cell in hash_table:\n                        candidates.extend(hash_table[cell])\n                for node in candidates:\n                    d = math.dist(node.position,p)\n                    if d < min_dist:\n                        min_dist = d\n                        min_node = node\n                if min_node is not None:\n                    break\n            if min_node is not None:\n                return min_node\n            # fallback linear search\n            all_nodes = []\n            for cell_nodes in hash_table.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n            v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n            len1 = math.sqrt(sum(c*c for c in v1))\n            len2 = math.sqrt(sum(c*c for c in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0,min(1.0,dot/(len1*len2)))\n            penalty = (1.0 - cos_ang) * 0.8\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear + pen\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = math.log(n_nodes) / n_nodes\n            r = self.base_radius * (val ** (1/dim))\n            return max(r, self.step_size * 1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position) + curvature_penalty(node, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-8 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 4 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = best_cost\n                c_best = max(c_best, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best / 2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x/norm for x in vec]\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0]*r1\n                    for i in range(1,dim):\n                        pt[i] = u[i]*r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            # uniform or if no good best_cost\n            for _ in range(50):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            # fallback uniform sample\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = path_cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = path_cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=130)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.15046,
          "time_improvement": 20.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1485.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03597238063812256,
                    "num_nodes_avg": 158.4,
                    "path_length_avg": 165.33660473594648,
                    "smoothness_avg": 0.040225506903328115,
                    "success_improvement": 0.0,
                    "time_improvement": -39.477510873634735,
                    "node_improvement": 60.11080332409973,
                    "length_improvement": 9.37638701806892,
                    "smoothness_improvement": 529.6165341234281,
                    "objective_score": -3.5693383806319274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0495330810546875,
                    "num_nodes_avg": 425.8,
                    "path_length_avg": 233.70047331301612,
                    "smoothness_avg": 0.09995486345747011,
                    "success_improvement": 0.0,
                    "time_improvement": 70.08432847383375,
                    "node_improvement": 71.39017671168448,
                    "length_improvement": 21.984055312962646,
                    "smoothness_improvement": 2471.9106313388115,
                    "objective_score": 46.57528488662177
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035744976997375486,
                    "num_nodes_avg": 384.8,
                    "path_length_avg": 124.71065505040485,
                    "smoothness_avg": 0.1222140100479562,
                    "success_improvement": 0.0,
                    "time_improvement": 29.562633809586238,
                    "node_improvement": 51.074380165289256,
                    "length_improvement": 17.173120998758485,
                    "smoothness_improvement": 1454.5531869101455,
                    "objective_score": 26.445428676681686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.60434,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021024632453918456,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 179.86562069368742,
                    "smoothness_avg": 0.04340391432894737,
                    "success_improvement": 0.0,
                    "time_improvement": 18.480140883479937,
                    "node_improvement": 62.37723495341224,
                    "length_improvement": 1.41280314464036,
                    "smoothness_improvement": 579.365512356565,
                    "objective_score": 9.288551713611021
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02810840606689453,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.75216437677005,
                    "smoothness_avg": 0.0991357257905606,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02383326220045,
                    "node_improvement": 81.69723845998791,
                    "length_improvement": 17.960853947188074,
                    "smoothness_improvement": 2450.8336291682162,
                    "objective_score": 47.93783049281406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0594691276550293,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 129.64938979692397,
                    "smoothness_avg": 0.1243235500601021,
                    "success_improvement": 0.0,
                    "time_improvement": -17.187058813027633,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 13.893048537397146,
                    "smoothness_improvement": 1481.3863801545947,
                    "objective_score": 10.586643379302972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization by combining uniform goal-biased sampling with a fixed rewiring radius, efficient nearest neighbor searches, and straightforward path shortcutting. It grows start and goal trees alternately, rewires local neighborhoods to reduce path cost, connects trees upon proximity, and refines solutions with repeated shortcutting for improved path length and smoothness.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased sampling to encourage progress toward the goal, connects new nodes to the lowest-cost nearby parent within a fixed radius, and rewires neighbors to optimize local costs. It attempts connections between the two trees whenever new nodes appear close enough. On successful connection, the combined path is shortcut multiple times with collision checking to enhance smoothness and reduce length before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        best_path = []\n        success = False\n\n        def dist(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim)) ** 0.5\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            if is_3d:\n                px, py, pz = p\n                for obs in obstacles:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                px, py = p\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                diff_sq = sum((node.position[i] - p[i]) ** 2 for i in range(dim))\n                if diff_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=60):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i + 1:j]\n                attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = goal if random.random() < self.goal_sample_rate else None\n            if sample is None:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        break\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[iteration % 2]\n\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos):\n                continue\n            if collision_edge(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(active_tree, new_pos, self.radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + dist(near_node.position, new_pos)\n                if cost < min_cost and not collision_edge(near_node.position, new_pos):\n                    min_cost = cost\n                    min_parent = near_node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not collision_edge(new_node.position, near_node.position):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            connect_node = nearest(other_tree, new_node.position)\n            dist_connect = dist(connect_node.position, new_node.position)\n            if dist_connect <= self.step_size and not collision_edge(connect_node.position, new_node.position):\n                # Extract and shortcut combined path\n                path = extract_path(new_node, connect_node)\n                shortcut = shortcut_path(path, max_attempts=100)\n                success = True\n                best_path = shortcut\n                break\n\n        if success:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        else:\n            return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -21.8498,
          "time_improvement": 19.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1418.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030353832244873046,
                    "num_nodes_avg": 128.9,
                    "path_length_avg": 169.60823786198122,
                    "smoothness_avg": 0.03531683911755182,
                    "success_improvement": 0.0,
                    "time_improvement": -17.69243213511502,
                    "node_improvement": 67.53966255351298,
                    "length_improvement": 7.035037213330819,
                    "smoothness_improvement": 452.7852239333236,
                    "objective_score": 1.1772188071306036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07687301635742187,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 233.5661530357017,
                    "smoothness_avg": 0.09866136858535729,
                    "success_improvement": 0.0,
                    "time_improvement": 53.57228224839836,
                    "node_improvement": 80.3063898407579,
                    "length_improvement": 22.028895287725014,
                    "smoothness_improvement": 2438.6280766126506,
                    "objective_score": 41.48216223021777
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03946213722229004,
                    "num_nodes_avg": 201.3,
                    "path_length_avg": 126.97503818424491,
                    "smoothness_avg": 0.1150503234947852,
                    "success_improvement": 0.0,
                    "time_improvement": 22.237773145387973,
                    "node_improvement": 74.40559440559441,
                    "length_improvement": 15.66922553959969,
                    "smoothness_improvement": 1363.4316227221486,
                    "objective_score": 22.89002538098695
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional informed RRT* planner with adaptive lazy collision checking and dynamic rewiring radius based on local node density, which alternates growing trees from start and goal using progressive ellipsoidal informed sampling. Nodes are selectively rewired based on cost improvement and collision verified lazily to minimize expensive checks. Integrated frequent incremental path shortcutting aggressively smooths and shortens paths during planning, while early tree connection attempts speed up convergence. The algorithm maintains map bounds and obstacles constraints, optimizes local neighborhood rewiring, and applies efficient parent selection to enhance planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner alternates expansions between two trees, from start and goal, sampling mostly within an ellipsoidal informed region shrinking with the best path cost. New samples are steered toward with step size limits, and the parent is chosen as the lowest cost collision-free node within a dynamic radius computed from node count and map dimension. Lazy collision checking defers edge verification until potentially connecting two trees or rewiring reduces cost. Trees connect early if reachable, yielding candidate paths. Incremental shortcutting runs frequently to improve path smoothness by removing redundant waypoints safely. This synergy accelerates finding short, smooth, and feasible paths while reducing computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, gamma=35.0,\n                 shortcut_freq=15, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        start_pos = map.start\n        goal_pos = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Data structures\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_nodes_pair = None\n\n        def dist_sq(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a,b):\n            return dist_sq(a,b)**0.5\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            max_r = self.step_size * 30.0\n            return min(r, max_r)\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_check(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            dist_ = dist(p1, p2)\n            steps = max(3, int(dist_ * 2))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if collision_check(interp):\n                    return False\n            return True\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_check(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            d_vec = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length = math.sqrt(sum(x*x for x in d_vec))\n            if length < 1e-14:\n                R = None\n            else:\n                if dim == 2:\n                    dx, dy = d_vec[0]/length, d_vec[1]/length\n                    cos_t, sin_t = dx, dy\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                else:\n                    # Rodrigues' rotation matrix 3D\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in d_vec]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1],\n                         a1[2]*a2[0]-a1[0]*a2[2],\n                         a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = math.sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],\n                              [v[2],0,-v[0]],\n                              [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            c_best = best_cost\n            c_min_val = c_min\n            a1 = c_best / 2.0\n            r_others = math.sqrt(max(c_best*c_best - c_min_val*c_min_val,0))/2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        return [r*math.cos(theta), r*math.sin(theta)]\n                else:\n                    while True:\n                        pt = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in pt) <= 1:\n                            return pt\n\n            for _ in range(100):\n                x_ball = sample_unit_ball()\n                if dim == 2:\n                    L = [[a1,0],[0,r_others]]\n                    x_ellipsoid = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    if R is None:\n                        pt = (center[0] + x_ellipsoid[0], center[1] + x_ellipsoid[1])\n                    else:\n                        pt = (center[0] + R[0][0]*x_ellipsoid[0] + R[0][1]*x_ellipsoid[1],\n                              center[1] + R[1][0]*x_ellipsoid[0] + R[1][1]*x_ellipsoid[1])\n                else:\n                    L = [[a1,0,0],[0,r_others,0],[0,0,r_others]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    if R is None:\n                        pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                    else:\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if not is_in_bounds(pt):\n                    continue\n                if collision_check(pt):\n                    continue\n                return pt\n            return sample_uniform()\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= radius_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            diff = [to_pos[i] - from_pos[i] for i in range(dim)]\n            d = math.sqrt(sum(x*x for x in diff))\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + diff[i]*ratio for i in range(dim))\n\n        # Lazy collision check cache for edges to reduce expensive calls\n        edge_valid_cache = {}\n\n        def lazy_edge_check(p1, p2):\n            key = (p1, p2)\n            if key in edge_valid_cache:\n                return edge_valid_cache[key]\n            coll_free = edge_collision_free(p1, p2)\n            edge_valid_cache[key] = coll_free\n            edge_valid_cache[(p2, p1)] = coll_free\n            return coll_free\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if collision_check(new_pos):\n                return None\n            if not lazy_edge_check(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            r = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for node in neighbors:\n                c = node.cost + dist(node.position, new_pos)\n                if c < min_cost and lazy_edge_check(node.position, new_pos):\n                    min_cost = c\n                    min_parent = node\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free lazily\n            for node in neighbors:\n                if node is min_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, node.position)\n                if new_c + 1e-8 < node.cost and lazy_edge_check(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, node))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = new_c\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            d_conn = dist(new_node.position, nearest_other.position)\n            if d_conn <= self.step_size and lazy_edge_check(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + d_conn + nearest_other.cost\n                return (new_node, nearest_other, total_cost)\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) -1)\n                if lazy_edge_check(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            # Alternate expansion order each iteration for balanced growth\n            order = [(start_tree, goal_tree), (goal_tree, start_tree)][it % 2]\n            res = attempt_extend(order[0], order[1], sample)\n            if res is not None:\n                n_new, n_connect, c_path = res\n                if c_path < best_cost:\n                    best_cost = c_path\n                    best_nodes_pair = (n_new, n_connect)\n            # After attempt from second tree as well\n            res = attempt_extend(order[1], order[0], sample)\n            if res is not None:\n                n_new, n_connect, c_path = res\n                if c_path < best_cost:\n                    best_cost = c_path\n                    best_nodes_pair = (n_new, n_connect)\n\n            # Apply shortcutting frequently and return better path if found\n            if best_nodes_pair is not None and best_cost < float('inf'):\n                if (it % self.shortcut_freq == 0) or (it == self.max_iter - 1):\n                    raw_path = extract_path(best_nodes_pair[0], best_nodes_pair[1])\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        # Return failure with constructed trees if no path found\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -19.76035,
          "time_improvement": 14.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1396.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0346923828125,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 165.4814303710184,
                    "smoothness_avg": 0.03999855904278786,
                    "success_improvement": 0.0,
                    "time_improvement": -34.514511275762764,
                    "node_improvement": 66.23016872324351,
                    "length_improvement": 9.297005792576952,
                    "smoothness_improvement": 526.064307280806,
                    "objective_score": -2.145828370778629
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06541202068328858,
                    "num_nodes_avg": 283.5,
                    "path_length_avg": 241.2475395225302,
                    "smoothness_avg": 0.09226072632381513,
                    "success_improvement": 0.0,
                    "time_improvement": 60.49418927799828,
                    "node_improvement": 80.95142108445877,
                    "length_improvement": 19.464627381970665,
                    "smoothness_improvement": 2273.9349410268956,
                    "objective_score": 41.19670791771636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0430621862411499,
                    "num_nodes_avg": 206.4,
                    "path_length_avg": 128.59923815230476,
                    "smoothness_avg": 0.11686797074880832,
                    "success_improvement": 0.0,
                    "time_improvement": 15.143686301703887,
                    "node_improvement": 73.75715193897013,
                    "length_improvement": 14.590509256905632,
                    "smoothness_improvement": 1386.5519616285583,
                    "objective_score": 20.230171252797337
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.483327093247905,
          "time_improvement": 35.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 180.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022586989402770995,
                    "num_nodes_avg": 95.7,
                    "path_length_avg": 168.64313046948791,
                    "smoothness_avg": 0.017505839022252202,
                    "success_improvement": 0.0,
                    "time_improvement": 12.422336132822434,
                    "node_improvement": 75.90027700831025,
                    "length_improvement": 7.564027868261686,
                    "smoothness_improvement": 174.00439523612755,
                    "objective_score": 9.13513953698438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03670787811279297,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 257.74323422045836,
                    "smoothness_avg": 0.010534876218801273,
                    "success_improvement": 0.0,
                    "time_improvement": 77.83015308834821,
                    "node_improvement": 83.2829402674192,
                    "length_improvement": 13.957889689556485,
                    "smoothness_improvement": 171.06995307438933,
                    "objective_score": 32.5791295056103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04266858100891113,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 130.54377171187787,
                    "smoothness_avg": 0.023278354893991073,
                    "success_improvement": 0.0,
                    "time_improvement": 15.919306212711263,
                    "node_improvement": 69.28162746344564,
                    "length_improvement": 13.299042655374924,
                    "smoothness_improvement": 196.09895602214036,
                    "objective_score": 13.735712237149036
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -17.795854854811235,
          "time_improvement": 71.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015041923522949219,
                    "num_nodes_avg": 140.4,
                    "path_length_avg": 205.55369204774252,
                    "smoothness_avg": 0.01041684624247792,
                    "success_improvement": 0.0,
                    "time_improvement": 41.67719749109079,
                    "node_improvement": 64.64366658272476,
                    "length_improvement": -12.667235818056396,
                    "smoothness_improvement": 63.046264238449346,
                    "objective_score": 5.218049077685646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016628527641296388,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 305.1784824883373,
                    "smoothness_avg": 0.00711472502770238,
                    "success_improvement": 0.0,
                    "time_improvement": 89.95714459329555,
                    "node_improvement": 84.19673452932877,
                    "length_improvement": -1.8773615301791229,
                    "smoothness_improvement": 83.06699949208468,
                    "objective_score": 26.276061457341616
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010075998306274415,
                    "num_nodes_avg": 181.0,
                    "path_length_avg": 156.9681958591822,
                    "smoothness_avg": 0.014159220130581652,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14471285055937,
                    "node_improvement": 76.98664971392245,
                    "length_improvement": -4.250801667402978,
                    "smoothness_improvement": 80.10423493608366,
                    "objective_score": 21.89345402940644
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A dual-tree bidirectional RRT* variant with adaptive radius and adaptive sampling that alternates expansions from both start and goal, combined with progressive informed sampling that focuses the search spatially as better solutions are found. It utilizes a dynamic rewiring radius based on node density to efficiently optimize locally, and incorporates frequent incremental path shortcutting to reduce path length and improve smoothness. A lazy collision-checking scheme for edges combined with early termination upon finding consistent improved solutions enhances computational efficiency and robustness.",
          "planning_mechanism": "A bidirectional planner builds two trees rooted at start and goal, alternately expanding toward sampled points that progressively focus inside an informed ellipsoid shrinking around the best known path cost. Each extension picks a parent minimizing cost with feasible collision-free edges and rewires nearby nodes within an adaptive radius to optimize path cost locally. When the two trees connect, the combined path is extracted, then progressively shortcut multiple random node pairs frequently to smooth and shorten the path during planning. Nodes and edges are stored efficiently, and the planner respects all obstacle constraints and map bounds. This synergistic integration yields faster convergence to high-quality, smooth, and short feasible paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, gamma=40.0,\n                 shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        start_pos = map.start\n        goal_pos = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_nodes_pair = None\n\n        def dist_sq(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a,b):\n            return dist_sq(a,b)**0.5\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            max_r = self.step_size * 40.0\n            return min(r, max_r)\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def collision_check(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d=obs\n                    px,py,pz=pos\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                        return True\n                else:\n                    x,y,w,h=obs\n                    px,py=pos\n                    if x<=px<=x+w and y<=py<=y+h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            dist_ = dist(p1, p2)\n            steps = max(1, int(dist_))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(dim))\n                if collision_check(interp):\n                    return False\n            return True\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_check(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            d_vec = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            c_best = best_cost\n            c_min_val = c_min\n            # Rotation matrix to align x-axis with d_vec for 2D and 3D\n            length = math.sqrt(sum(x*x for x in d_vec))\n            if length < 1e-14:\n                R = None\n            else:\n                if dim == 2:\n                    dx, dy = d_vec[0]/length, d_vec[1]/length\n                    cos_t, sin_t = dx, dy\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                else:\n                    # Use Rodrigues formula for 3D rotation aligning x-axis (1,0,0) to d_vec/length\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in d_vec]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1],\n                         a1[2]*a2[0]-a1[0]*a2[2],\n                         a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = math.sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            # Ellipsoid parameters\n            a1 = c_best / 2.0\n            r_others = math.sqrt(max(c_best*c_best - c_min_val*c_min_val, 0)) / 2.0\n\n            def sample_unit_ball():\n                while True:\n                    if dim == 2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        return [r*math.cos(theta), r*math.sin(theta)]\n                    else:\n                        pt = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in pt) <= 1:\n                            return pt\n            for _ in range(100):\n                x_ball = sample_unit_ball()\n                if dim == 2:\n                    L = [[a1,0],[0,r_others]]\n                    x_ellipsoid = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    if R is None:\n                        pt = (center[0] + x_ellipsoid[0], center[1] + x_ellipsoid[1])\n                    else:\n                        pt = (center[0] + R[0][0]*x_ellipsoid[0] + R[0][1]*x_ellipsoid[1],\n                              center[1] + R[1][0]*x_ellipsoid[0] + R[1][1]*x_ellipsoid[1])\n                else:\n                    L = [[a1,0,0],[0,r_others,0],[0,0,r_others]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    if R is None:\n                        pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                    else:\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if not is_in_bounds(pt):\n                    continue\n                if collision_check(pt):\n                    continue\n                return pt\n            return sample_uniform()\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= radius_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            diff = [to_pos[i]-from_pos[i] for i in range(dim)]\n            d = math.sqrt(sum(x*x for x in diff))\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            new_pos = tuple(from_pos[i] + diff[i]*ratio for i in range(dim))\n            return new_pos\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if collision_check(new_pos):\n                return None\n            if not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            r = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + dist(node.position, new_pos)\n                if c < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = c\n                    min_parent = node\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for node in neighbors:\n                if node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and edge_collision_free(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, node))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            d_conn = dist(new_node.position, nearest_other.position)\n            if d_conn <= self.step_size and edge_collision_free(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + d_conn + nearest_other.cost\n                return (new_node, nearest_other, total_cost)\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path)-3)\n                j = random.randint(i+2, len(shortcut_path)-1)\n                if edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, c_path = res\n                    if c_path < best_cost:\n                        best_cost = c_path\n                        best_nodes_pair = (n_new, n_connect)\n            if best_nodes_pair is not None and best_cost < float('inf'):\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(best_nodes_pair[0], best_nodes_pair[1])\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -15.59375,
          "time_improvement": -5.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1473.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01934182643890381,
                    "num_nodes_avg": 97.7,
                    "path_length_avg": 163.09996323771628,
                    "smoothness_avg": 0.04171144736670499,
                    "success_improvement": 0.0,
                    "time_improvement": 25.004968823521256,
                    "node_improvement": 75.39662553512969,
                    "length_improvement": 10.60232566510146,
                    "smoothness_improvement": 552.8747291466387,
                    "objective_score": 16.627259691850448
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05454413890838623,
                    "num_nodes_avg": 262.5,
                    "path_length_avg": 232.53217295072687,
                    "smoothness_avg": 0.09890208145311588,
                    "success_improvement": 0.0,
                    "time_improvement": 67.05788316581106,
                    "node_improvement": 82.36242693005443,
                    "length_improvement": 22.374067601556185,
                    "smoothness_improvement": 2444.82179207855,
                    "objective_score": 45.76591447106978
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10462684631347656,
                    "num_nodes_avg": 375.1,
                    "path_length_avg": 127.64705068500382,
                    "smoothness_avg": 0.1195941244863454,
                    "success_improvement": 0.0,
                    "time_improvement": -106.17272988234387,
                    "node_improvement": 52.3076923076923,
                    "length_improvement": 15.222906834392159,
                    "smoothness_improvement": 1421.2284359462928,
                    "objective_score": -15.611932684336402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm merges bidirectional RRT* with adaptive informed sampling and dynamic rewiring, enriched by enhanced smooth path extraction. The planner grows two trees from start and goal, uses an elliptical informed region for sampling, adjusts the neighborhood radius dynamically for rewiring, and aggressively post-processes the path using iterative shortcutting and Bezier curve smoothing. Tree expansion is carefully constrained to improve both efficiency and path quality, ensuring collision-free nodes and edges throughout. This consolidated approach aims to significantly boost efficiency, robustness, and smoothness while finding optimized paths quickly.",
          "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal, samples within an adaptive ellipsoidal informed set shaped by the best current path cost, finds nearest neighbors and rewires locally with an adaptive radius. Upon connecting, it extracts the full path and performs iterative shortcutting followed by a smooth Bezier path fitting, validating all collision constraints to produce a shortened and highly smooth trajectory. The approach balances exploration with continuous path optimization and aggressive smoothing for superior planning outcomes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if (x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if (x <= p[0] <= x + w and y <= p[1] <= y + h):\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[i] - p[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def adaptive_radius(iteration, tree_size):\n            if tree_size < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            return max(self.step_size, min(gamma, gamma * (math.log(tree_size)/tree_size)**(1/dim)))\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            foci_dist = c_min\n            val = c_best * c_best - foci_dist * foci_dist\n            r1 = c_best / 2.0\n            r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n            def unit_ball_sample():\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        u = [x / norm for x in vec]\n                        r = random.random() ** (1.0 / dim)\n                        return [u[i] * r for i in range(dim)]\n\n            while True:\n                u_sample = unit_ball_sample()\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=150):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def bezier_smooth(path, samples=100):\n            if len(path) < 3:\n                return path[:]\n            def lin_interp(p1, p2, t):\n                return tuple(p1[i] + (p2[i]-p1[i])*t for i in range(len(p1)))\n            def bezier(points, t):\n                pts = points[:]\n                while len(pts) > 1:\n                    pts = [lin_interp(pts[i], pts[i+1], t) for i in range(len(pts)-1)]\n                return pts[0]\n            control_pts = []\n            n = len(path)\n            for i in range(n):\n                p = path[i]\n                if i == 0:\n                    p_next = path[i+1]\n                    ctrl1 = tuple( p[j] + (p_next[j]-p[j]) * 0.3 for j in range(dim) )\n                    control_pts.append((p, ctrl1))\n                elif i == n-1:\n                    p_prev = path[i-1]\n                    ctrl2 = tuple( p[j] + (p_prev[j]-p[j]) * 0.3 for j in range(dim) )\n                    control_pts.append((ctrl2, p))\n                else:\n                    p_prev = path[i-1]\n                    p_next = path[i+1]\n                    ctrl1 = tuple(p[j] + (p_next[j]-p_prev[j]) * 0.15 for j in range(dim))\n                    ctrl2 = tuple(p[j] - (p_next[j]-p_prev[j]) * 0.15 for j in range(dim))\n                    control_pts.append((ctrl1, ctrl2))\n            smooth_path = []\n            # Piecewise Bezier curves between waypoints\n            for i in range(n-1):\n                p0 = path[i]\n                p3 = path[i+1]\n                if i == 0:\n                    p1 = control_pts[i][1]\n                    p2 = control_pts[i+1][0]\n                elif i == n-2:\n                    p1 = control_pts[i][0]\n                    p2 = control_pts[i+1][0] if len(control_pts[i+1]) > 1 else p3\n                else:\n                    p1 = control_pts[i][0]\n                    p2 = control_pts[i+1][1]\n                for t in [k/(samples-1) for k in range(samples)]:\n                    # Cubic B\u00e9zier formula:\n                    u = 1 - t\n                    pt = tuple(\n                        (u**3)*p0[d] + 3*(u**2)*t*p1[d] + 3*u*(t**2)*p2[d] + (t**3)*p3[d]\n                        for d in range(dim)\n                    )\n                    smooth_path.append(pt)\n            # Collision check and fallback:\n            filtered = []\n            for pt in smooth_path:\n                if not in_bounds(pt) or collision_node(pt):\n                    return path[:]\n            return smooth_path\n\n        for iteration in range(1, self.max_iter + 1):\n            sample = informed_sample()\n            for tree_a, tree_b in ((start_tree, goal_tree), (goal_tree, start_tree)):\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if (not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nn.position, new_pos)):\n                    continue\n\n                radius = adaptive_radius(iteration, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cand_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    # Construct candidate path\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_len = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_len += dist(candidate_path[k], candidate_path[k+1])\n                    if path_len < best_cost:\n                        # Post-process candidate path\n                        shortcut = shortcut_path(candidate_path, max_iters=150)\n                        smooth = bezier_smooth(shortcut, samples=50)\n                        # Validate smooth path\n                        valid = True\n                        for i in range(len(smooth)-1):\n                            if collision_edge(smooth[i], smooth[i+1]):\n                                valid = False\n                                break\n                        if valid:\n                            best_cost = path_len\n                            best_path = smooth\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -15.50094,
          "time_improvement": 19.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 738.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02978487014770508,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 179.02870411409452,
                    "smoothness_avg": 0.049272570619337513,
                    "success_improvement": 0.0,
                    "time_improvement": -15.486366934906105,
                    "node_improvement": 68.54696549987409,
                    "length_improvement": 1.8715303837070905,
                    "smoothness_improvement": 671.2227272922798,
                    "objective_score": -0.16687821378617818
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025112462043762208,
                    "num_nodes_avg": 181.1,
                    "path_length_avg": 252.77123501589048,
                    "smoothness_avg": 0.05054125811304572,
                    "success_improvement": 0.0,
                    "time_improvement": 84.83324376924836,
                    "node_improvement": 87.83175435060137,
                    "length_improvement": 15.61768613510334,
                    "smoothness_improvement": 1200.4629746454489,
                    "objective_score": 40.82289968506375
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.056411004066467284,
                    "num_nodes_avg": 299.7,
                    "path_length_avg": 131.80489373136044,
                    "smoothness_avg": 0.03487725206547758,
                    "success_improvement": 0.0,
                    "time_improvement": -11.160864668913323,
                    "node_improvement": 61.89446916719644,
                    "length_improvement": 12.461465458211887,
                    "smoothness_improvement": 343.63607190191635,
                    "objective_score": 5.846800233762717
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner featuring adaptive informed sampling within ellipsoidal subsets, efficient rewiring with a dynamic neighborhood radius based on node count, and incremental path shortcutting to progressively improve path length and smoothness while minimizing planning time. The planner grows two trees from start and goal positions, alternately extending toward samples constrained by the current best solution\u2019s cost, rewiring locally for cost improvement, and shortcutting the combined path periodically to ensure continuously refined solutions.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by steering nearest nodes toward informed samples inside the current ellipsoidal region defined by the best path cost; it dynamically adapts the rewiring radius as node count grows to optimize connectivity and prune costs locally. Upon connecting the two trees with a better path, it incrementally shortcut the path at regular intervals for smoother trajectories, returning the best feasible path when finished or timeout occurs.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=50.0, shortcut_interval=40, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            return min(self.step_size*50, self.gamma * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n            else:\n                # Compute rotation matrix from first axis to dir_vec\n                if dim == 2:\n                    cos_theta = dir_vec[0]/length\n                    sin_theta = dir_vec[1]/length\n                    R = [[cos_theta, -sin_theta],\n                         [sin_theta, cos_theta]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[ 0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1 = best_cost * 0.5\n            a2 = math.sqrt(best_cost**2 - c_min**2) * 0.5\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1, 0], [0, a2]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1,0,0],[0,a2,0],[0,0,a2]]\n                    x_scaled = [L[i][i]*x_ball[i] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: sum((n.position[i]-point[i])**2 for i in range(dim)))\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for step in range(steps+1):\n                inter = tuple(p1[i] + (p2[i]-p1[i]) * (step/steps) for i in range(dim))\n                if self._is_in_obstacle(inter, obstacles, is_3d):\n                    return False\n            return True\n\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if is_edge_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def extract_path(node_a, node_b):\n            path_a, path_b = [], []\n            n = node_a\n            while n:\n                path_a.append(n.position)\n                n = n.parent\n            n = node_b\n            while n:\n                path_b.append(n.position)\n                n = n.parent\n            return list(reversed(path_a)) + path_b\n\n        for it in range(self.max_iter):\n            p_sample = informed_sample() if best_cost < float('inf') else sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, p_sample)\n                new_pos = steer(nearest_node.position, p_sample)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                radius = near_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_to_new = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_to_new < min_cost and is_edge_free(near_node.position, new_pos):\n                        min_cost = cost_to_new\n                        min_parent = near_node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    smooth_path = progressive_shortcut(raw_path)\n                    if smooth_path and len(smooth_path) >= 2:\n                        return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
          "objective": -14.92668,
          "time_improvement": -4.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1314.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.037845396995544435,
                    "num_nodes_avg": 178.0,
                    "path_length_avg": 165.42944166192004,
                    "smoothness_avg": 0.03843563195093346,
                    "success_improvement": 0.0,
                    "time_improvement": -46.739850889072756,
                    "node_improvement": 55.175018886930246,
                    "length_improvement": 9.325501627847583,
                    "smoothness_improvement": 501.60110434278266,
                    "objective_score": -5.918648768299365
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052951812744140625,
                    "num_nodes_avg": 269.6,
                    "path_length_avg": 234.10634420651417,
                    "smoothness_avg": 0.08692195248727295,
                    "success_improvement": 0.0,
                    "time_improvement": 68.01957392838445,
                    "node_improvement": 81.88537257273398,
                    "length_improvement": 21.84856392636707,
                    "smoothness_improvement": 2136.5644448493013,
                    "objective_score": 44.19783275858208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06805832386016845,
                    "num_nodes_avg": 273.6,
                    "path_length_avg": 124.92852901095083,
                    "smoothness_avg": 0.11033978563707739,
                    "success_improvement": 0.0,
                    "time_improvement": -34.11252384905549,
                    "node_improvement": 65.21296884933248,
                    "length_improvement": 17.02841948820697,
                    "smoothness_improvement": 1303.5139288678422,
                    "objective_score": 6.500864182546746
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive informed sampling based on current best path cost combined with a heuristic-driven prioritized rewiring scheme. Instead of uniform or vanilla informed sampling, the algorithm dynamically shrinks its sampling ellipsoid region as solutions improve for faster convergence. The rewiring phase favors nodes estimated closer to the goal using a heuristic distance, guiding tree restructuring to yield shorter, smoother paths. Post-processing employs an iterative shortcutting approach that refines path smoothness while preserving collision-free guarantees. This approach balances global exploration and local optimization to enhance planning efficiency, path length, and smoothness while reducing runtime.",
          "planning_mechanism": "The planner grows two bidirectional trees from start and goal, sampling adaptive informed points inside a shrinking ellipsoid focused by the best path cost. It extends and rewires nodes by prioritizing neighbors nearer the goal heuristic, striving for low-cost rewiring. Trees attempt to connect continuously, updating best solutions. Upon finishing, the path undergoes iterative shortcut smoothing to remove unnecessary waypoints. This coordinated mechanism improves convergence speed, reduces excessive edge checks, and enhances solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, max_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        # Precompute dimension for convenience\n        dim = 3 if is_3d else 2\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside ellipsoid shrinking as best_cost improves\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            \n            # Alternate tree roles each iteration\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n            \n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n            \n            near_nodes = self._near(tree_a, new_pos, self.max_radius)\n            # Prioritize near nodes by heuristic to goal (or start)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n            \n            # Choose best parent based on cost + heuristic + collision free\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) >= min_cost + heuristic_a(new_pos):\n                    # Prune candidates that are not better in cost + heuristic\n                    continue\n                if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                    continue\n                min_cost = tentative_cost\n                best_parent = nnode\n            \n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            \n            # Rewire neighbors that improve cost with heuristic guidance\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                # Only rewire if new cost + heuristic less than existing\n                if new_cost + heuristic_a(neighbor.position) + 1e-8 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n            \n            # Try connection to other tree within step size and free space\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n            \n            # Periodically extract and iteratively shortcut path for smoothness improvement\n            if solution_nodes[0] and solution_nodes[1] and (iter % 150 == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final check after iterations\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # Uniform random sampling if no valid path found yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # Clamp c_max to reasonable upper bound\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # Degenerate case\n            return start\n\n        # Rotation matrix to align x-axis to direction vector (2D or 3D)\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            # 3D rotation matrix from x-axis to dir_vec using Rodrigues formula\n            a1 = [1, 0, 0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + ((1 - c)/(s**2))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            # Sample point in unit ball\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            # Check bounds\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _iterative_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.08602,
          "time_improvement": -15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1402.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05029592514038086,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 161.93878883699725,
                    "smoothness_avg": 0.047628044606518545,
                    "success_improvement": 0.0,
                    "time_improvement": -95.01490647056376,
                    "node_improvement": 50.21405187610174,
                    "length_improvement": 11.23878375412141,
                    "smoothness_improvement": 645.482324046268,
                    "objective_score": -18.53379006846494
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059864473342895505,
                    "num_nodes_avg": 338.1,
                    "path_length_avg": 225.87643224817134,
                    "smoothness_avg": 0.0890107769545784,
                    "success_improvement": 0.0,
                    "time_improvement": 63.844649222693185,
                    "node_improvement": 77.2828058859101,
                    "length_improvement": 24.59594542294319,
                    "smoothness_improvement": 2190.3114029125213,
                    "objective_score": 44.86251903513647
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05845465660095215,
                    "num_nodes_avg": 311.2,
                    "path_length_avg": 116.34668105324462,
                    "smoothness_avg": 0.11554898589311344,
                    "success_improvement": 0.0,
                    "time_improvement": -15.18798998915194,
                    "node_improvement": 60.43229497774952,
                    "length_improvement": 22.7280742780298,
                    "smoothness_improvement": 1369.7745716214542,
                    "objective_score": 15.929320428179569
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* algorithm featuring adaptive shrinking neighbor radius for rewiring, dynamic informed elliptical sampling with iterative refinement within each iteration, and a hierarchical multi-pass shortcut smoothing phase after solution detection. The rewiring propagates cost updates recursively to maintain cost consistency and improve smoothness. Balanced, frequent inter-tree connection attempts accelerate solution discovery and refinement. This mechanism balances exploration and exploitation to optimize planning efficiency, path length, and smoothness while reducing runtime.",
          "planning_mechanism": "The planner grows two trees from start and goal using an adaptive informed ellipsoid shaped sampling region that shrinks with improving best path cost. It extends towards samples with step size control and rewires neighbors within a radius that shrinks with iterations and tree size to prioritize relevant local improvements. Rewiring cost updates are propagated recursively to children to maintain consistent subtree costs. Frequent attempts connect the two trees to find solutions early and refine them continuously. Upon solution detection or at the end, a hierarchical multi-pass shortcut smoothing applies many collision-proof shortcuts iteratively to minimize path length and smooth sharp transitions, improving smoothness significantly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_max=25.0, r_min=6.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_max = r_max  # initial max radius for rewiring\n        self.r_min = r_min  # min radius for rewiring\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        def update_costs_recursively(node):\n            for child in node.children:\n                prev_cost = child.cost\n                child.cost = node.cost + math.dist(node.position, child.position)\n                if child.cost < prev_cost - 1e-10:\n                    update_costs_recursively(child)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside shrinking ellipsoid toward best path cost\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n\n            # Alternate tree roles each iteration for balanced growth\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive shrinking neighbor radius for rewiring: decreases with iteration count and tree size\n            radius = max(self.r_min, min(self.r_max,\n                                         (self.r_max * (1.0 - iter / self.max_iter)) * (50.0 / max(50, len(tree_a)))))\n\n            near_nodes = self._near(tree_a, new_pos, radius)\n            near_nodes = sorted(near_nodes, key=lambda n: heuristic_a(n.position))\n\n            # Choose best parent minimizing cost+distance heuristic, with collision check\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) + 1e-12 < min_cost + heuristic_a(new_pos):\n                    if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                        continue\n                    min_cost = tentative_cost\n                    best_parent = nnode\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors that improve cost: with updated heuristic and collision check\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + heuristic_a(neighbor.position) + 1e-12 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    # Remove old parent connection\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.parent.remove_child(neighbor)\n                    # Reassign parent and update cost recursively\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n                    update_costs_recursively(neighbor)\n\n            # Attempt connection to other tree for early and frequent solution update\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n\n            # If solution found, refine by dual-direction expansion & iterative shortcutting\n            if solution_nodes[0] and solution_nodes[1] and ((iter % 100 == 0 and iter > 0) or iter == self.max_iter-1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._hierarchical_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final fallback return best path found or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._hierarchical_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # uniform random sampling if no solution yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # clamp upper bound path cost\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        direction = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return start  # degenerate case\n\n        # Rotation matrix aligning x-axis to direction vector\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [direction[0]/length, direction[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            a1 = [1, 0, 0]\n            a2 = [direction[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j]+vx[i][j]+((1 - c)/(s*s))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        r2 = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= r2]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _hierarchical_shortcut(self, path, obstacles, is_3d, max_attempts=300):\n        # Multi-pass variable length shortcutting to aggressively smooth path\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        # Pass 1: large gap shortcuts then smaller\n        max_gap = len(path) - 1\n        attempts = 0\n        improved = True\n\n        while improved and attempts < max_attempts:\n            improved = False\n            # Try decreasing gap lengths from max_gap down to 2\n            gap = max_gap\n            while gap >= 2 and attempts < max_attempts:\n                i = 0\n                while i + gap < len(path) and attempts < max_attempts:\n                    j = i + gap\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        # Remove intermediate points between i and j\n                        del path[i+1:j]\n                        improved = True\n                        max_gap = min(max_gap, len(path)-1)\n                        attempts += 1\n                        # After modification, restart inner loops for best effect\n                        i = 0\n                        continue\n                    i += 1\n                    attempts += 1\n                gap -= 1\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -12.13998,
          "time_improvement": -19.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1355.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0422879695892334,
                    "num_nodes_avg": 205.4,
                    "path_length_avg": 161.53282315652058,
                    "smoothness_avg": 0.04887825440192836,
                    "success_improvement": 0.0,
                    "time_improvement": -63.96525983480396,
                    "node_improvement": 48.27499370435659,
                    "length_improvement": 11.461299976528542,
                    "smoothness_improvement": 665.0508222184554,
                    "objective_score": -8.987543853431784
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06295993328094482,
                    "num_nodes_avg": 396.0,
                    "path_length_avg": 226.80300620463316,
                    "smoothness_avg": 0.08946961077099067,
                    "success_improvement": 0.0,
                    "time_improvement": 61.975135742866414,
                    "node_improvement": 73.39246119733924,
                    "length_improvement": 24.28662836632365,
                    "smoothness_improvement": 2202.1175274934485,
                    "objective_score": 44.17510538012135
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07791128158569335,
                    "num_nodes_avg": 327.9,
                    "path_length_avg": 122.2144119025854,
                    "smoothness_avg": 0.10208041158209284,
                    "success_improvement": 0.0,
                    "time_improvement": -53.52829774708936,
                    "node_improvement": 58.308963763509226,
                    "length_improvement": 18.83100683921498,
                    "smoothness_improvement": 1198.4553005320156,
                    "objective_score": 1.2323912820622587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner emphasizing simplicity and efficiency by using uniform sampling with fixed goal bias, fixed-radius neighbor rewiring, and incremental shortcutting upon improvement. It maintains clear parent-child relationships, performs rigorous obstacle checking, and limits unnecessary complexity for robust planning.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending towards uniformly sampled or goal-biased points within map bounds. It connects new nodes via shortest cost parents within a fixed radius, rewires neighbors to improve costs, and checks collisions for nodes and edges strictly. When merging trees, it updates the best path and applies shortcutting to improve path quality before termination or timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, neighbor_radius=10.0, goal_sample_rate=0.1, shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(int(dist*2),1)\n            for i in range(steps+1):\n                interm = tuple(p1[j] + (p2[j]-p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def sample():\n            if random.random() < self.goal_sample_rate and not in_obstacle(goal_pos):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def nearest(nodes, point):\n            best, best_dist = None, float('inf')\n            for n in nodes:\n                d = sum((n.position[i]-point[i])**2 for i in range(dim))\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(nodes, point, radius):\n            r2 = radius*radius\n            return [n for n in nodes if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r2]\n\n        def reconnect_children(node):\n            for c in node.children:\n                old = c.cost\n                c.cost = node.cost + math.dist(node.position, c.position)\n                if c.cost < old:\n                    reconnect_children(c)\n\n        def extract_path(n_start, n_goal):\n            path_s, n = [], n_start\n            while n:\n                path_s.append(n.position)\n                n = n.parent\n            path_g, n = [], n_goal\n            while n:\n                path_g.append(n.position)\n                n = n.parent\n            if path_s[-1] == path_g[-1]:\n                path_g.pop()\n            return path_s[::-1] + path_g\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(path) >= 3:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if edge_free(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        best_cost = float('inf')\n        best_sol = None\n\n        for it in range(self.max_iter):\n            rnd = sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rnd)\n                new_pos = steer(nearest_node.position, rnd)\n                if in_obstacle(new_pos) or not edge_free(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for n_candidate in near_nodes:\n                    c = n_candidate.cost + math.dist(n_candidate.position, new_pos)\n                    if c < min_cost and edge_free(n_candidate.position, new_pos):\n                        min_cost = c\n                        min_parent = n_candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                for n_candidate in near_nodes:\n                    if n_candidate is min_parent:\n                        continue\n                    c_new = new_node.cost + math.dist(new_node.position, n_candidate.position)\n                    if c_new < n_candidate.cost and edge_free(new_node.position, n_candidate.position):\n                        if n_candidate.parent:\n                            n_candidate.parent.remove_child(n_candidate)\n                        n_candidate.parent = new_node\n                        n_candidate.cost = c_new\n                        new_node.add_child(n_candidate)\n                        reconnect_children(n_candidate)\n\n                connect_node = nearest(tree_b, new_pos)\n                dist_connect = math.dist(new_pos, connect_node.position)\n                if dist_connect <= self.step_size and edge_free(new_pos, connect_node.position):\n                    total = new_node.cost + dist_connect + connect_node.cost\n                    if total < best_cost:\n                        best_cost = total\n                        best_sol = (new_node, connect_node)\n\n            if best_sol and it % 100 == 0 and it > 10:\n                raw_path = extract_path(best_sol[0], best_sol[1])\n                improved_path = shortcut_path(raw_path)\n                return PlannerResult(True, improved_path, start_tree + goal_tree, [])\n\n        if best_sol:\n            raw_path = extract_path(best_sol[0], best_sol[1])\n            improved_path = shortcut_path(raw_path)\n            return PlannerResult(True, improved_path, start_tree + goal_tree, [])\n\n        return PlannerResult(False, [], start_tree + goal_tree, [])",
          "objective": -10.43564,
          "time_improvement": -20.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1491.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.036921906471252444,
                    "num_nodes_avg": 149.7,
                    "path_length_avg": 167.32641118511287,
                    "smoothness_avg": 0.036738141817402155,
                    "success_improvement": 0.0,
                    "time_improvement": -43.15915488400687,
                    "node_improvement": 62.30168723243516,
                    "length_improvement": 8.285742572779903,
                    "smoothness_improvement": 475.03169759419376,
                    "objective_score": -5.601142433563151
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07169718742370605,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 238.74598155752847,
                    "smoothness_avg": 0.09774875336604358,
                    "success_improvement": 0.0,
                    "time_improvement": 56.69824160646291,
                    "node_improvement": 78.68709265605052,
                    "length_improvement": 20.299719434041926,
                    "smoothness_improvement": 2415.1458296895357,
                    "objective_score": 41.2650332908117
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08882017135620117,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 124.87814004418192,
                    "smoothness_avg": 0.13228603509705425,
                    "success_improvement": 0.0,
                    "time_improvement": -75.02484154267036,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 17.061885440670125,
                    "smoothness_improvement": 1582.668602095117,
                    "objective_score": -4.356978187923448
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* variant with adaptive informed sampling, efficient nearest neighbor pruning, refined rewiring with cost propagation, and incremental shortcutting during planning to balance quick convergence and path quality. The method alternates tree expansions from start and goal using ellipsoidal informed samples based on current best cost, ensuring collision-free nodes and edges. Rewiring is performed with propagation of cost updates to descendants, enhancing path optimality and smoothness. Periodic incremental shortcutting refines the best found path progressively, improving solution quality without sacrificing efficiency.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling adaptively inside an ellipsoid shaped by the current best path cost to focus exploration. It uses efficient nearest and near neighbor searches with pruning, rewires with recursive cost updates to optimize path quality, and connects trees when possible. An iterative shortcutting process runs concurrently during planning to smooth and shorten the best path so far, enabling rapid high-quality path discovery.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, gamma=40.0, shortcut_freq=50, shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def in_obstacle(point):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = point\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = point\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_free(p1, p2):\n            dist_val = math.dist(p1, p2)\n            steps = max(int(dist_val * 5), 2)\n            for step in range(steps+1):\n                interm = tuple(p1[i] + (p2[i]-p1[i]) * step / steps for i in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            best_node = None\n            best_dist_sq = math.inf\n            for n in nodes:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d2 += diff*diff\n                    if d2 > best_dist_sq:\n                        break\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = n\n            return best_node\n\n        def near(nodes, point, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r2]\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def informed_sample(best_cost):\n            c_min = math.dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                return uniform_sample()\n            center = [(start_pos[i]+goal_pos[i])*0.5 for i in range(dim)]\n            foci_dist = c_min\n            a1 = best_cost * 0.5\n            val = best_cost*best_cost - foci_dist*foci_dist\n            a2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n\n            if dim == 2:\n                while True:\n                    r = math.sqrt(random.uniform(0,1))\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r * math.cos(theta) * a1\n                    y = r * math.sin(theta) * a2\n                    dx = goal_pos[0] - start_pos[0]\n                    dy = goal_pos[1] - start_pos[1]\n                    length = math.hypot(dx, dy)\n                    if length < 1e-9:\n                        length = 1e-9\n                    cos_t = dx / length\n                    sin_t = dy / length\n                    samp_x = center[0] + cos_t * x - sin_t * y\n                    samp_y = center[1] + sin_t * x + cos_t * y\n                    pt = (samp_x, samp_y)\n                    if in_bounds(pt) and not in_obstacle(pt):\n                        return pt\n            else:\n                # fallback uniform in 3D\n                return uniform_sample()\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 3.5\n            return min(self.step_size * 15.0, self.gamma * (math.log(n) / n) ** (1.0/dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cn = n_start\n            while cn:\n                path_start.append(cn.position)\n                cn = cn.parent\n            path_start.reverse()\n            path_goal = []\n            cn = n_goal\n            while cn:\n                path_goal.append(cn.position)\n                cn = cn.parent\n            # avoid duplicate connect node\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if is_edge_free(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for ch in node.children:\n                new_cost = node.cost + math.dist(node.position, ch.position)\n                if new_cost + 1e-6 < ch.cost:\n                    ch.cost = new_cost\n                    ch.parent = node\n                    propagate_costs(ch)\n\n        # Initialize trees and data\n        tree_start = [Node(start_pos, None, 0.0)]\n        tree_goal = [Node(goal_pos, None, 0.0)]\n        best_cost = math.inf\n        best_pair = None\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n\n            # Alternate expansions: start->goal then goal->start\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                near_r = near_radius(len(tree_a))\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if in_obstacle(new_pos) or not is_edge_free(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, near_r)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes:\n                    c_new = near_n.cost + math.dist(near_n.position, new_pos)\n                    if c_new + 1e-6 < min_cost and is_edge_free(near_n.position, new_pos):\n                        min_cost = c_new\n                        min_parent = near_n\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                for near_n in near_nodes:\n                    if near_n is min_parent:\n                        continue\n                    c_through = new_node.cost + math.dist(new_node.position, near_n.position)\n                    if c_through + 1e-6 < near_n.cost and is_edge_free(new_node.position, near_n.position):\n                        near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = c_through\n                        new_node.add_child(near_n)\n                        propagate_costs(near_n)\n\n                # Try connecting trees\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, nearest_other.position)\n\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if total_cost + 1e-6 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other)\n\n            # Incremental shortcutting on best path every shortcut_freq iterations\n            if best_pair and it > 10 and it % self.shortcut_freq == 0:\n                path = extract_path(best_pair[0], best_pair[1])\n                shortened = shortcut_path(path)\n                return PlannerResult(True, shortened, tree_start + tree_goal, [])\n\n        # After all iterations\n        if best_pair:\n            path = extract_path(best_pair[0], best_pair[1])\n            path = shortcut_path(path)\n            return PlannerResult(True, path, tree_start + tree_goal, [])\n        return PlannerResult(False, [], tree_start + tree_goal, [])",
          "objective": -9.13641,
          "time_improvement": -20.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1031.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05309784412384033,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 160.15977777778897,
                    "smoothness_avg": 0.03854235408064018,
                    "success_improvement": 0.0,
                    "time_improvement": -105.87892710389232,
                    "node_improvement": 65.75169982372199,
                    "length_improvement": 12.213887905907676,
                    "smoothness_improvement": 503.27153742350686,
                    "objective_score": -21.918987700505554
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059561967849731445,
                    "num_nodes_avg": 307.8,
                    "path_length_avg": 240.6258030091385,
                    "smoothness_avg": 0.057411370883333146,
                    "success_improvement": 0.0,
                    "time_improvement": 64.02734843654514,
                    "node_improvement": 79.31868574884096,
                    "length_improvement": 19.67218092583409,
                    "smoothness_improvement": 1377.2359245671594,
                    "objective_score": 37.89769270929979
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06042747497558594,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 122.72569602622848,
                    "smoothness_avg": 0.10311900058512694,
                    "success_improvement": 0.0,
                    "time_improvement": -19.075532854026633,
                    "node_improvement": 63.77622377622379,
                    "length_improvement": 18.491436269024923,
                    "smoothness_improvement": 1211.6660759899435,
                    "objective_score": 11.430532285156682
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* variant that employs adaptive neighborhood radius scaling, combined informed and goal-biased sampling, and aggressive incremental shortcutting applied frequently to strongly improve path length and smoothness. It features continuous rewiring with dynamic radius adjustments, goal bias to accelerate convergence, spatial pruning for efficient rewiring, and systematic incremental path shortcutting after each solution improvement to progressively smooth and shorten the path during planning, thereby reducing total search time and improving final path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Sampling combines uniform, informed ellipsoidal, and goal-biased strategies focused on promising regions defined by current best solution estimates. Nodes connect and rewire within dynamically computed adaptive radii that shrink as the tree grows, optimizing local connectivity and cost. Upon each improved solution, the path is incrementally shortcut multiple times to smooth and shorten it. The search terminates early if improvements stagnate, ensuring swift convergence to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=10, max_shortcut_attempts=80, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal directly\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_volume = self._unit_ball_volume(dim)\n        max_step = self.step_size\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                # Start with large radius for initial connectivity\n                return max_step * 8.0\n            return min(max_step * 30, self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n        # Check point collision\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pt\n                    if (x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pt\n                    if (x <= px <= x + w and y <= py <= y + h):\n                        return True\n            return False\n\n        # Check if segment intersects obstacle by discrete checking\n        def edge_in_obstacle(pt1, pt2, resolution=0.5):\n            dist = 0.0\n            for i in range(dim):\n                diff = pt2[i] - pt1[i]\n                dist += diff * diff\n            dist = dist**0.5\n            steps = max(int(dist / resolution), 1)\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(pt1[d] + t * (pt2[d] - pt1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Uniform free sample bounded by map size\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Biased goal sampling\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        # Ellipsoidal informed sampling centered on start-goal segment when best_cost < inf\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No path found yet or trivial bound: uniform sample\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                # Nearly identical start and goal\n                return sample_uniform()\n\n            # Rotation matrix R from unit vector e1 to dir_vec\n            if dim == 2:\n                a1 = [1, 0]\n                a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix via Rodrigues formula\n                from math import sqrt\n                a1 = [1, 0, 0]\n                a2 = [dir_vec[i] / length for i in range(3)]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                    I = [[int(i==j) for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            if best_cost**2 - c_min**2 < 0:  # Numerical safeguard\n                a_other = 0.0\n            else:\n                a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5  # uniform in unit disk\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if in_obstacle(pt):\n                    continue\n                return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - pt[i]\n                    dist_sq += delta*delta\n                if dist_sq < best_dist_sq:\n                    best_dist_sq = dist_sq\n                    best_node = node\n            return best_node\n\n        def near(tree, pt, radius):\n            radius_sq = radius * radius\n            near_nodes = []\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - pt[i]\n                    dist_sq += delta*delta\n                if dist_sq <= radius_sq:\n                    near_nodes.append(node)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio * diffs[i] for i in range(dim))\n            return new_pt\n\n        def connect_tree(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, max_step)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if improving cost\n            for neighbor in neighbors:\n                if neighbor is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old edge\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Attempt connection to other tree\n            closest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, closest_other.position)\n            if dist_to_other <= max_step:\n                if not edge_in_obstacle(new_node.position, closest_other.position):\n                    total_cost = new_node.cost + dist_to_other + closest_other.cost\n                    return new_node, closest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path1 = []\n            n = node_start\n            while n:\n                path1.append(n.position)\n                n = n.parent\n            path2 = []\n            n = node_goal\n            while n:\n                path2.append(n.position)\n                n = n.parent\n            return list(reversed(path1)) + path2\n\n        # Incremental shortcutting to smooth and shorten path, attempting multiple segments per call,\n        # aggressively applied after each improvement\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            path_new = path[:]\n            attempts = 0\n            successful = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(path_new) < 3:\n                    break\n                i = random.randint(0, len(path_new)-3)\n                j = random.randint(i+2, len(path_new)-1)\n                if not edge_in_obstacle(path_new[i], path_new[j]):\n                    # shortcut segment\n                    path_new = path_new[:i+1] + path_new[j:]\n                    successful += 1\n                    attempts = 0  # reset attempts after success to enable more reductions\n                else:\n                    attempts += 1\n            return path_new\n\n        last_improvement_iter = 0\n        improvement_threshold = 100  # iterations allowed without improvement before early stop\n\n        for iteration in range(self.max_iter):\n            # Sampling with combined bias: goal bias, informed sampling, uniform\n            p = random.random()\n            if best_cost < float('inf') and p > 1.0 - self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            # Alternate expansions and attempts\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect_tree(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        # assign solution nodes with consistent start-goal orientation\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        last_improvement_iter = iteration\n\n                        # progressively shortcut aggressively after each improvement\n                        raw_path = extract_path(solution_start, solution_goal)\n                        improved_path = shortcut_path(raw_path)\n                        # Post-smoothing iterative shortcutting for further reduction\n                        for _ in range(2):\n                            improved_path = shortcut_path(improved_path)\n\n            # Stop if no improvement for too long and found a solution\n            if best_cost < float('inf') and (iteration - last_improvement_iter) > improvement_threshold:\n                break\n\n            # Periodic shortcutting even if no improvements, to improve path quality incrementally\n            if best_cost < float('inf') and (iteration % self.shortcut_interval == 0) and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                # Accept and output current best path if improvement found in shortcut\n                if len(improved_path) < len(raw_path):\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            # Final shortcut before returning\n            raw_path = extract_path(solution_start, solution_goal)\n            improved_path = shortcut_path(raw_path)\n            return PlannerResult(True, improved_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -8.99674,
          "time_improvement": -22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1379.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06457171440124512,
                    "num_nodes_avg": 132.5,
                    "path_length_avg": 168.89889681679642,
                    "smoothness_avg": 0.04697172518327863,
                    "success_improvement": 0.0,
                    "time_improvement": -150.36713828120307,
                    "node_improvement": 66.63308990178797,
                    "length_improvement": 7.423838280424763,
                    "smoothness_improvement": 635.2094998521243,
                    "objective_score": -37.47979101684544
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05212686061859131,
                    "num_nodes_avg": 230.7,
                    "path_length_avg": 237.45130276031324,
                    "smoothness_avg": 0.09005704552374123,
                    "success_improvement": 0.0,
                    "time_improvement": 68.5178065496401,
                    "node_improvement": 84.49909292481354,
                    "length_improvement": 20.73192048181532,
                    "smoothness_improvement": 2217.2326467938706,
                    "objective_score": 44.080657487950575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042715144157409665,
                    "num_nodes_avg": 257.8,
                    "path_length_avg": 127.42936259429484,
                    "smoothness_avg": 0.10881519882806052,
                    "success_improvement": 0.0,
                    "time_improvement": 15.827551067869216,
                    "node_improvement": 67.22186904005086,
                    "length_improvement": 15.367484899048108,
                    "smoothness_improvement": 1284.12129719044,
                    "objective_score": 20.389362745741828
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional informed RRT* planner with adaptive elliptical sampling, dynamic neighborhood radius scaling, and integrated iterative shortcut smoothing, designed to efficiently balance fast and high-quality path discovery. The planner grows two trees from start and goal, alternates expansion, rewires neighbors within a radius adaptive to the tree size, employs early collision checks for pruning, and progressively refines paths via shortcut smoothing upon better solution discoveries.",
          "planning_mechanism": "class Node",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, goal_sample_rate=0.1, gamma=20.0, shortcut_iterations=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(3, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * (i / steps) for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(p_from, p_to):\n            d = dist(p_from, p_to)\n            if d <= self.step_size:\n                return p_to\n            ratio = self.step_size / d\n            return tuple(p_from[i] + (p_to[i] - p_from[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    best_node = node\n                    min_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def path_cost_to_goal(p):\n            return dist(p, goal_pos)\n\n        def ellipsoid_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == float('inf') or best_cost <= c_min:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                r_axes = [c_best * 0.5] + [0.0] * (dim - 1)\n            else:\n                r_axes = [c_best * 0.5] + [math.sqrt(val) * 0.5] * (dim - 1)\n\n            # Build a rotation matrix aligning the first axis with vector start->goal (2D or 3D)\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = dist(start_pos, goal_pos)\n            if length < 1e-12:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n            elif dim == 2:\n                cos_t = dir_vec[0] / length\n                sin_t = dir_vec[1] / length\n                R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                # For 3D, use simplified identity rotation (could be improved)\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n            while True:\n                # Sample inside unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit_vec = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [unit_vec[i] * r for i in range(dim)]\n\n                # Scale and rotate to ellipse\n                ellip_sample = [ball_sample[i] * r_axes[i] for i in range(dim)]\n                sample = tuple(center[i] + sum(R[i][j] * ellip_sample[j] for j in range(dim)) for i in range(dim))\n\n                if in_bounds(sample) and not collision_node(sample):\n                    return sample\n\n        def neighbor_radius(n):\n            # Adaptive radius per RRT* theory\n            if n <= 1:\n                return self.step_size * 3\n            return min(self.step_size * 30, self.gamma * (math.log(n) / n) ** (1.0 / dim))\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            attempts = 0\n            while attempts < self.shortcut_iterations and len(p) > 2:\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not collision_edge(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return p\n\n        def update_parent(node, new_parent, new_cost):\n            if node.parent:\n                node.parent.remove_child(node)\n            node.parent = new_parent\n            node.cost = new_cost\n            new_parent.add_child(node)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, near_n.position)\n                if c_new < near_n.cost and not collision_edge(new_node.position, near_n.position):\n                    update_parent(near_n, new_node, c_new)\n\n        # INIT TREES\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node_start = None\n        best_goal_node_goal = None\n\n        for iteration in range(self.max_iter):\n            # Goal bias sampling w goal rate, else ellipsoid informed sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = ellipsoid_sample(best_cost)\n\n            # Expand both trees in alternation\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    c_through = near_node.cost + dist(near_node.position, new_pos)\n                    if c_through < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = c_through\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    # connection found\n                    candidate_path = reconstruct_path(new_node, nearest_other)\n                    path_length = sum(dist(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if path_length < best_cost:\n                        best_cost = path_length\n                        best_path = shortcut_path(candidate_path)\n                        best_goal_node_start = new_node\n                        best_goal_node_goal = nearest_other\n                        # Early return to emphasize fast good path discovery\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        else:\n            # No path found\n            return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": -7.92799,
          "time_improvement": -27.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1556.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06218047142028808,
                    "num_nodes_avg": 209.6,
                    "path_length_avg": 170.65713981641753,
                    "smoothness_avg": 0.046792040593840505,
                    "success_improvement": 0.0,
                    "time_improvement": -141.09545225538363,
                    "node_improvement": 47.21732561067741,
                    "length_improvement": 6.460117431189191,
                    "smoothness_improvement": 632.3970458360865,
                    "objective_score": -35.29057998872114
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06650593280792236,
                    "num_nodes_avg": 405.3,
                    "path_length_avg": 237.2815875959224,
                    "smoothness_avg": 0.10226831765137792,
                    "success_improvement": 0.0,
                    "time_improvement": 59.83351735728928,
                    "node_improvement": 72.76758718000403,
                    "length_improvement": 20.788576288669137,
                    "smoothness_improvement": 2531.4374740617627,
                    "objective_score": 43.08038835069708
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05069839954376221,
                    "num_nodes_avg": 319.3,
                    "path_length_avg": 129.37319798947232,
                    "smoothness_avg": 0.12609257913307942,
                    "success_improvement": 0.0,
                    "time_improvement": 0.096124437453579,
                    "node_improvement": 59.40241576605213,
                    "length_improvement": 14.076481985065964,
                    "smoothness_improvement": 1503.8882993867228,
                    "objective_score": 15.994168019209265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that alternates tree expansions with goal bias, fixed-radius rewiring, and straightforward path shortcutting for efficient planning and improved path quality. It uses simple nearest neighbor searches and basic collision checks to maintain clarity and generalizability.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased towards the goal, connects nodes using fixed step sizes and radius for rewiring, and upon connecting the trees, extracts and shortcuts the path to reduce length and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        for i in range(self.max_iter):\n            sample = goal if self._random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[i % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._collides(new_pos, obstacles, dim):\n                continue\n            if self._edge_collides(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost, min_parent = nearest.cost + self._dist(nearest.position, new_pos), nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._dist(near.position, new_pos)\n                if cost < min_cost and not self._edge_collides(near.position, new_pos, obstacles, dim):\n                    min_cost, min_parent = cost, near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._edge_collides(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            if self._dist(new_node.position, connect_node.position) <= self.step_size and not self._edge_collides(new_node.position, connect_node.position, obstacles, dim):\n                path = self._extract_path(new_node, connect_node)\n                path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(self._random() * bounds[i] for i in range(dim))\n            if not self._collides(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best, best_dist = node, dist\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return self._dist_sq(a, b) ** 0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _collides(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_collides(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            point = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._collides(point, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=40):\n        path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(path) > 2:\n            i = int(self._random() * (len(path) - 2))\n            j = int(i + 2 + self._random() * (len(path) - i - 2))\n            if j >= len(path):\n                j = len(path) - 1\n            if not self._edge_collides(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path\n\n    def _random(self):\n        # To allow testing replace with random.random(), here stub for determinism if needed\n        import random\n        return random.random()",
          "objective": -6.82375,
          "time_improvement": -25.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 998.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04590208530426025,
                    "num_nodes_avg": 161.1,
                    "path_length_avg": 170.32708573767837,
                    "smoothness_avg": 0.02884305512385804,
                    "success_improvement": 0.0,
                    "time_improvement": -77.97845148348269,
                    "node_improvement": 59.430873835305974,
                    "length_improvement": 6.641025301787684,
                    "smoothness_improvement": 351.4564463850669,
                    "objective_score": -17.65163803204686
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09899413585662842,
                    "num_nodes_avg": 319.9,
                    "path_length_avg": 232.70596040537356,
                    "smoothness_avg": 0.06308823090997337,
                    "success_improvement": 0.0,
                    "time_improvement": 40.21215744617372,
                    "node_improvement": 78.50567761875966,
                    "length_improvement": 22.316052347000596,
                    "smoothness_improvement": 1523.3056219296157,
                    "objective_score": 33.069806751700554
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06967871189117432,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 123.85483726002462,
                    "smoothness_avg": 0.09591030345606508,
                    "success_improvement": 0.0,
                    "time_improvement": -37.30558409690246,
                    "node_improvement": 68.34075015893197,
                    "length_improvement": 17.741514425465155,
                    "smoothness_improvement": 1119.97198059895,
                    "objective_score": 5.053093329203105
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An optimized bidirectional informed RRT* planner with dynamic neighbor radius adapting to node count and iteration, improved heuristic-guided sampling leveraging ellipsoidal informed sampling around the current best cost, enhanced rewiring limited by dynamic radius, and curvature-aware cost function to promote smoother paths. The planner maintains two trees growing toward each other, performs efficient spatial hashing for near neighbor queries, conducts local rewiring to reduce path cost and curvature penalties, and iteratively shortcuts the best path to improve smoothness, enabling faster convergence to high-quality paths. It terminates early upon finding a satisfactory path under iteration limits.",
          "planning_mechanism": "The planner alternates expansion of start and goal trees using the informed sampling strategy guided by the best cost to date. It uses spatial grids for nearest neighbor and near-node queries within a dynamically computed radius based on current iteration and node count. New nodes are steered towards random samples, checked for collisions, and connected to the best parent among neighbors. Rewiring improves the tree by reducing path cost including curvature penalty. The two trees attempt to connect at each iteration, updating the best path found and performing shortcutting to improve smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=3.0, base_radius=16.0, goal_sample_rate=0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b, res=0.4):\n            length = math.dist(a,b)\n            steps = max(1, int(length/res))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size/dist\n            return tuple(frm[i] + (to[i] - frm[i])*ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.3\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        def add_to_hash(hashmap, node):\n            h = grid_hash(node.position)\n            if h not in hashmap:\n                hashmap[h] = []\n            hashmap[h].append(node)\n\n        def nearby_nodes(hashmap, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hashmap:\n                    for n in hashmap[cell]:\n                        d2 = 0\n                        for i in range(dim):\n                            diff = n.position[i] - p[i]\n                            d2 += diff*diff\n                        if d2 <= radius_sq:\n                            candidates.append(n)\n            return candidates\n\n        def nearest(hashmap, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # expand cells progressively\n            for radius_cells in range(3):\n                check_cells = []\n                rng = range(-radius_cells, radius_cells+1)\n                if dim == 2:\n                    check_cells = [(gh[0]+dx, gh[1]+dy) for dx in rng for dy in rng]\n                else:\n                    check_cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in rng for dy in rng for dz in rng]\n                for c in check_cells:\n                    if c in hashmap:\n                        for n in hashmap[c]:\n                            d = math.dist(n.position, p)\n                            if d < min_dist:\n                                min_dist = d\n                                min_node = n\n                if min_node:\n                    return min_node\n            # fallback to linear scan\n            all_nodes = []\n            for nodes_list in hashmap.values():\n                all_nodes.extend(nodes_list)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i] - parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i] - parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(a*a for a in v1))\n            len2 = math.sqrt(sum(a*a for a in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0, min(1.0, dot/(len1*len2)))\n            penalty = (1.0 - cos_ang)*0.85\n            return penalty\n\n        def cost(parent, child_pos):\n            return parent.cost + math.dist(parent.position, child_pos) + curvature_penalty(parent, child_pos)\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes <= 2:\n                return self.base_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            rad = self.base_radius * val\n            return max(rad, self.step_size*1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position,c.position) + curvature_penalty(node,c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = cost(new_node, n.position)\n                if c_cost + 1e-9 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 3 != 0 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = max(best_cost, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best/2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-12:\n                            return [x / norm for x in vec]\n\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0] * r1\n                    for i in range(1, dim):\n                        pt[i] = u[i] * r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            for _ in range(40):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = {}\n        goal_hash = {}\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0.0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=150)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -6.76437,
          "time_improvement": 19.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1633.0,
          "node_improvement": 54.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03511323928833008,
                    "num_nodes_avg": 168.6,
                    "path_length_avg": 168.33553634796726,
                    "smoothness_avg": 0.044382753798602896,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -36.14631914175707,
                    "node_improvement": 57.542180810878875,
                    "length_improvement": 7.732625080407921,
                    "smoothness_improvement": 594.6864756406034,
                    "objective_score": -53.230888316079344
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045547866821289064,
                    "num_nodes_avg": 446.2,
                    "path_length_avg": 232.36821325534112,
                    "smoothness_avg": 0.11382562635653662,
                    "success_improvement": 0.0,
                    "time_improvement": 72.49121206413825,
                    "node_improvement": 70.01948531882013,
                    "length_improvement": 22.428802067194113,
                    "smoothness_improvement": 2828.8153514384817,
                    "objective_score": 49.34872161675035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04101715087890625,
                    "num_nodes_avg": 505.2,
                    "path_length_avg": 122.84298054352023,
                    "smoothness_avg": 0.12382294015630269,
                    "success_improvement": 0.0,
                    "time_improvement": 19.17353655711958,
                    "node_improvement": 35.7660521296885,
                    "length_improvement": 18.4135414771283,
                    "smoothness_improvement": 1475.0186591294457,
                    "objective_score": 24.175279149060085
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive rewiring radius, enhanced goal bias, and robust path shortcutting and smoothing to yield faster planning, shorter paths, and much smoother trajectories compared to prior approaches. Efficient nearest neighbor search and incremental rewiring optimize path quality, while combined post-processing steps ensure globally smooth collision-free paths.",
          "planning_mechanism": "The planner alternately grows trees from start and goal, sampling with increased goal bias and adaptive informed ellipsoid for focused exploration. New nodes are connected to near lower cost parents and rewired locally. Upon connection within step size, the assembled path undergoes iterative shortcutting and cubic Bezier smoothing, with collision checks ensuring validity and improving smoothness. Early returns on improvements reduce planning time, yielding high-quality, smooth paths faster.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, base_radius=18.0, goal_sample_rate=0.18, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a, b, res=0.3):\n            length = dist(a, b)\n            steps = max(3, int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            px, py = p[:2]\n            if dim == 3:\n                pz = p[2]\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[i]-p[i])**2 for i in range(dim)) <= r_sq]\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def adaptive_radius(iteration, size):\n            if size < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            r = gamma * (math.log(size+1) / size) ** (1/dim)\n            return max(self.step_size, min(gamma, r))\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-12 < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                est_new = cost_through_new + heuristic_cost_to_go(near_node.position)\n                est_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_new + 1e-12 < est_old and cost_through_new + 1e-12 < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost if best_cost < float('inf') else None\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best is None:\n                for _ in range(30):\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-12\n            r1 = c_best / 2\n            val = c_best**2 - foci_dist**2\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm > 1e-12:\n                        return [x/nrm for x in v]\n\n            for _ in range(30):\n                u = sample_unit_ball(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u[0]*r1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = u[i]*r_rest\n                pt = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if all(0 <= pt[i] <= bounds[i] for i in range(dim)) and not collision_node(pt):\n                    return pt\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            return pt\n\n        def bezier_interp(p0, p1, p2, p3, t):\n            u = 1 - t\n            b = [0]*dim\n            for i in range(dim):\n                b[i] = (u**3)*p0[i] + 3*(u**2)*t*p1[i] + 3*u*(t**2)*p2[i] + (t**3)*p3[i]\n            return tuple(b)\n\n        def smooth_path_bezier(raw_path):\n            if len(raw_path) < 4:\n                return raw_path[:]\n            smoothed = [raw_path[0]]\n            n = len(raw_path)\n            for i in range(1, n - 2):\n                p0, p1, p2, p3 = raw_path[i-1], raw_path[i], raw_path[i+1], raw_path[i+2]\n                c1 = tuple((2*p1[j] + p2[j]) / 3 for j in range(dim))\n                c2 = tuple((p1[j] + 2*p2[j]) / 3 for j in range(dim))\n                steps = max(4, int(dist(p1, p2) / 1.2))\n                for step in range(steps):\n                    t = step / steps\n                    pt = bezier_interp(p1, c1, c2, p2, t)\n                    if not collision_node(pt) and not collision_edge(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        smoothed.append(p1)\n                        break\n                if smoothed[-1] != p2:\n                    smoothed.append(p2)\n            smoothed.append(raw_path[-2])\n            smoothed.append(raw_path[-1])\n            return smoothed\n\n        def shortcut_path(path, max_iters):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) -1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter_count in range(1, self.max_iter + 1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(iter_count, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost + 1e-12 < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_conn = dist(conn_node.position, new_node.position)\n                if dist_conn <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path) -1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        shortcut = shortcut_path(candidate_path, self.shortcut_iters)\n                        smoothed = smooth_path_bezier(shortcut)\n                        collision_found = False\n                        for idx in range(len(smoothed)-1):\n                            if collision_edge(smoothed[idx], smoothed[idx+1]):\n                                collision_found = True\n                                break\n                        if not collision_found:\n                            best_path = smoothed\n                            # Early stopping upon improvement\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        else:\n            return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -5.7552,
          "time_improvement": -3.0,
          "length_improvement": 11.0,
          "smoothness_improvement": -36.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0439871072769165,
                    "num_nodes_avg": 133.2,
                    "path_length_avg": 182.25373650658258,
                    "smoothness_avg": 0.003497385240857566,
                    "success_improvement": 0.0,
                    "time_improvement": -70.55341138623243,
                    "node_improvement": 66.45681188617478,
                    "length_improvement": 0.1038390254758362,
                    "smoothness_improvement": -45.25832628697128,
                    "objective_score": -21.330011632019083
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0382990837097168,
                    "num_nodes_avg": 231.1,
                    "path_length_avg": 243.08988262407175,
                    "smoothness_avg": 0.002877263408384887,
                    "success_improvement": 0.0,
                    "time_improvement": 76.86913909619183,
                    "node_improvement": 84.47221662299268,
                    "length_improvement": 18.849600225770182,
                    "smoothness_improvement": -25.965940093191204,
                    "objective_score": 34.2406721638537
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05805528163909912,
                    "num_nodes_avg": 315.5,
                    "path_length_avg": 128.3375660894498,
                    "smoothness_avg": 0.004978908556474413,
                    "success_improvement": 0.0,
                    "time_improvement": -14.401000521026393,
                    "node_improvement": 59.88556897647806,
                    "length_improvement": 14.76429938156926,
                    "smoothness_improvement": -36.66865066644684,
                    "objective_score": 4.354936219301403
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* variant with adaptive informed sampling, enhanced rewiring that updates descendant costs recursively for global improvements, and curvature-aware path shortcutting to improve smoothness and path length. The planner alternates expanding trees from start and goal, samples within an ellipsoidal informed region focusing search, connects nodes with minimum cost parents, and rewires incorporating full descendant cost updates to maintain path optimality. After finding a path, it applies iterative shortcutting with curvature constraints to ensure smooth transitions and feasible trajectories.",
          "planning_mechanism": "The planner alternates expansion of two trees from start and goal, uses adaptive ellipsoidal informed sampling to focus node sampling within a progressively shrinking region defined by current best path cost, and rewires nodes with recursive cost propagation for global cost updates. It attempts early connections between the trees when nodes are within step size and the connecting edge is collision-free. Upon finding a path, it applies iterative curvature-aware shortcutting that only shortens paths if curvature constraints are met, thus improving smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, neighbor_radius=15.0, goal_sample_rate=0.15, smooth_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def path_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a = c_best / 2.0\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                b = 0.0\n            else:\n                b = math.sqrt(val) / 2.0\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball[0] * a\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball[i] * b\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_cost_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_parent_cost_recursive(child)\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            update_parent_cost_recursive(child)\n\n        def rewire_full(tree, new_node, near_nodes):\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def curvature(p1, p2, p3):\n            # Approximate curvature at p2 w.r.t neighbors p1 and p3\n            import math\n            a = math.dist(p1, p2)\n            b = math.dist(p2, p3)\n            c = math.dist(p1, p3)\n            if a < 1e-6 or b < 1e-6:\n                return 0.0\n            # Law of cosines to get angle at p2\n            try:\n                cos_angle = (a*a + b*b - c*c) / (2 * a * b)\n                cos_angle = min(1.0, max(-1.0, cos_angle))\n                angle = math.acos(cos_angle)\n                radius = c / (2 * math.sin(angle)) if abs(angle) > 1e-6 else float('inf')\n                curvature_val = 1.0 / radius if radius > 1e-6 else float('inf')\n                return curvature_val\n            except:\n                return 0.0\n\n        def curvature_aware_shortcut(path, max_curvature=0.15, iterations=None):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            iters = iterations if iterations is not None else self.smooth_iter\n            for _ in range(iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if collision_edge(new_path[i], new_path[j]):\n                    continue\n                # Check curvature if shortcut applied: Inspect neighbors around shortcut\n                before = new_path[max(i-1, 0)]\n                after = new_path[min(j+1, len(new_path)-1)]\n                # For indices i-1, i, j and i, j, j+1 triplets for curvature check\n                # First triplet:\n                curv1 = curvature(before, new_path[i], new_path[j]) if i > 0 else 0.0\n                # Second triplet:\n                curv2 = curvature(new_path[i], new_path[j], after) if j < len(new_path)-1 else 0.0\n                if curv1 <= max_curvature and curv2 <= max_curvature:\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_full(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        # Apply curvature-aware smoothing with more iterations after connection\n                        best_path = curvature_aware_shortcut(candidate_path, iterations=self.smooth_iter)\n                        # Early return for best found path\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": -5.73861,
          "time_improvement": -36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1263.0,
          "node_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05177156925201416,
                    "num_nodes_avg": 143.9,
                    "path_length_avg": 165.93075816926788,
                    "smoothness_avg": 0.041603726714277645,
                    "success_improvement": 0.0,
                    "time_improvement": -100.73649519988538,
                    "node_improvement": 63.76227650465878,
                    "length_improvement": 9.050722106301821,
                    "smoothness_improvement": 551.1886670170101,
                    "objective_score": -22.03457196109947
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06509325504302979,
                    "num_nodes_avg": 331.0,
                    "path_length_avg": 233.69307486837343,
                    "smoothness_avg": 0.08407213264203503,
                    "success_improvement": 0.0,
                    "time_improvement": 60.68670886258219,
                    "node_improvement": 77.75986024323053,
                    "length_improvement": 21.986525126736794,
                    "smoothness_improvement": 2063.2365275890634,
                    "objective_score": 41.71411037276205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08536667823791504,
                    "num_nodes_avg": 355.9,
                    "path_length_avg": 120.11866214506578,
                    "smoothness_avg": 0.1001327204763105,
                    "success_improvement": 0.0,
                    "time_improvement": -68.21955084611585,
                    "node_improvement": 54.7488874761602,
                    "length_improvement": 20.2229040392802,
                    "smoothness_improvement": 1173.6808134300672,
                    "objective_score": -2.4637187631162982
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that uses uniform sampling with a fixed goal bias, fixed step size for node extension, and fixed neighbor radius for rewiring; it performs both node and edge collision checks before adding nodes and edges to ensure validity. The planner dynamically rewires neighbors to improve path cost and incrementally shortcut the best path found. This approach focuses on clarity, efficiency, and robust path quality improvement without adaptive parameters or complex data structures.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points mostly uniformly with some goal bias, connecting new valid nodes by rewiring neighbors within a fixed radius and ensuring no collisions. It attempts to connect the two trees and updates the best solution. Upon finding a solution, it repeatedly shortcuts the path to improve smoothness and length, terminating when iterations or time limits are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=5.0, neighbor_radius=8.0, goal_sample_rate=0.1, shortcut_attempts=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(int(dist * 2), 1)\n            for i in range(steps + 1):\n                interm = tuple(p1[j] + (p2[j]-p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def sample():\n            if random.random() < self.goal_sample_rate and not in_obstacle(goal_pos):\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in nodes:\n                d = 0.0\n                for i in range(dim):\n                    d += (node.position[i] - point[i])**2\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(nodes, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in nodes:\n                d = 0.0\n                for i in range(dim):\n                    d += (node.position[i] - point[i])**2\n                if d <= r2:\n                    result.append(node)\n            return result\n\n        def reconnect_tree(node):\n            for child in node.children:\n                new_cost = node.cost + math.dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    reconnect_tree(child)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if edge_free(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        best_solution = None\n        best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            rnd_point = sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rnd_point)\n                new_pos = steer(nearest_node.position, rnd_point)\n                if in_obstacle(new_pos) or not edge_free(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near_nodes:\n                    cost_candidate = candidate.cost + math.dist(candidate.position, new_pos)\n                    if cost_candidate < min_cost and edge_free(candidate.position, new_pos):\n                        min_cost = cost_candidate\n                        min_parent = candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                for candidate in near_nodes:\n                    if candidate == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, candidate.position)\n                    if cost_through_new < candidate.cost and edge_free(new_node.position, candidate.position):\n                        if candidate.parent:\n                            candidate.parent.remove_child(candidate)\n                        candidate.parent = new_node\n                        candidate.cost = cost_through_new\n                        new_node.add_child(candidate)\n                        reconnect_tree(candidate)\n\n                connect_node = nearest(tree_b, new_pos)\n                dist_connect = math.dist(new_pos, connect_node.position)\n                if dist_connect <= self.step_size and edge_free(new_pos, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_solution = (new_node, connect_node)\n\n            if best_solution and it % 100 == 0 and it > 10:\n                path_raw = extract_path(best_solution[0], best_solution[1])\n                path_short = shortcut_path(path_raw)\n                return PlannerResult(True, path_short, start_tree + goal_tree, [])\n\n        if best_solution:\n            path_raw = extract_path(best_solution[0], best_solution[1])\n            path_short = shortcut_path(path_raw)\n            return PlannerResult(True, path_short, start_tree + goal_tree, [])\n\n        return PlannerResult(False, [], start_tree + goal_tree, [])",
          "objective": -3.83976,
          "time_improvement": 16.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1205.0,
          "node_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0238999605178833,
                    "num_nodes_avg": 147.6,
                    "path_length_avg": 168.32792043945477,
                    "smoothness_avg": 0.032217335755568455,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 7.331487550208231,
                    "node_improvement": 62.83052127927474,
                    "length_improvement": 7.73679948054541,
                    "smoothness_improvement": 404.27126563900515,
                    "objective_score": -41.137117718415254
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05381460189819336,
                    "num_nodes_avg": 341.7,
                    "path_length_avg": 235.67732581751108,
                    "smoothness_avg": 0.07653969904503002,
                    "success_improvement": 0.0,
                    "time_improvement": 67.49848950602671,
                    "node_improvement": 77.04091916952227,
                    "length_improvement": 21.324125046417823,
                    "smoothness_improvement": 1869.421585745501,
                    "objective_score": 42.39112980838621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0640702486038208,
                    "num_nodes_avg": 354.0,
                    "path_length_avg": 121.88420568382999,
                    "smoothness_avg": 0.11338447456704906,
                    "success_improvement": 0.0,
                    "time_improvement": -26.25381079835431,
                    "node_improvement": 54.99046408137317,
                    "length_improvement": 19.050314086981878,
                    "smoothness_improvement": 1342.2421473215222,
                    "objective_score": 10.265255949290445
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m2",
          "algorithm_description": "A Bidirectional Adaptive Informed RRT* planner with dynamic neighborhood radius, goal biasing, and iterative path smoothing employing Bezier-based shortcutting. The planner efficiently balances exploration and exploitation by sampling within an ellipsoidal informed set after the first solution, applying adaptive rewiring radius, and progressively improving path quality with combined shortcutting and spline smoothing while strictly enforcing collision-free constraints throughout.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately expanding towards samples drawn with goal bias and adaptive informed ellipsoid distribution once a solution is found. A dynamic radius for neighbor searches provides efficient rewiring balancing. Upon connecting both trees with a collision-free path, it applies iterative shortcutting and cubic Bezier smoothing to refine path length and smoothness, updating the best solution dynamically. Early returns occur after improvements to reduce planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5500, step_size=6.0, base_radius=25.0, goal_sample_rate=0.12, shortcut_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a, b, res=0.4):\n            length = dist(a, b)\n            steps = max(2, int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[i]-p[i])**2 for i in range(dim)) <= r_sq]\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def adaptive_radius(iteration, size):\n            if size < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            r = gamma * (math.log(size+1) / size) ** (1/dim)\n            return max(self.step_size, min(gamma, r))\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-9 < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                est_new = cost_through_new + heuristic_cost_to_go(near_node.position)\n                est_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_new + 1e-9 < est_old and cost_through_new + 1e-9 < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost if best_cost < float('inf') else None\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best is None:\n                for _ in range(20):\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-8\n            r1 = c_best / 2\n            val = c_best**2 - foci_dist**2\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def sample_unit_ball(d):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm > 1e-8:\n                        return [x/nrm for x in v]\n\n            for _ in range(25):\n                u = sample_unit_ball(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u[0]*r1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = u[i]*r_rest\n                pt = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if all(0 <= pt[i] <= bounds[i] for i in range(dim)) and not collision_node(pt):\n                    return pt\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            return pt\n\n        def bezier_interp(p0, p1, p2, p3, t):\n            u = 1 - t\n            b = [0]*dim\n            for i in range(dim):\n                b[i] = (u**3)*p0[i] + 3*(u**2)*t*p1[i] + 3*u*(t**2)*p2[i] + (t**3)*p3[i]\n            return tuple(b)\n\n        def smooth_path_bezier(raw_path):\n            if len(raw_path) < 4:\n                return raw_path[:]\n            smoothed = [raw_path[0]]\n            n = len(raw_path)\n            for i in range(1, n - 2):\n                p0, p1, p2, p3 = raw_path[i-1], raw_path[i], raw_path[i+1], raw_path[i+2]\n                c1 = tuple((2*p1[j] + p2[j]) / 3 for j in range(dim))\n                c2 = tuple((p1[j] + 2*p2[j]) / 3 for j in range(dim))\n                steps = max(4, int(dist(p1, p2) / 1.0))\n                for step in range(steps):\n                    t = step / steps\n                    pt = bezier_interp(p1, c1, c2, p2, t)\n                    if not collision_node(pt) and not collision_edge(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        smoothed.append(p1)\n                        break\n                if smoothed[-1] != p2:\n                    smoothed.append(p2)\n            smoothed.append(raw_path[-2])\n            smoothed.append(raw_path[-1])\n            return smoothed\n\n        def shortcut_path(path, max_iters):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) -1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter_count in range(1, self.max_iter + 1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(iter_count, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost + 1e-9 < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_conn = dist(conn_node.position, new_node.position)\n                if dist_conn <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path) -1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost + 1e-9 < best_cost:\n                        best_cost = path_cost\n                        shortcut = shortcut_path(candidate_path, self.shortcut_iters)\n                        smoothed = smooth_path_bezier(shortcut)\n                        collision_found = False\n                        for idx in range(len(smoothed)-1):\n                            if collision_edge(smoothed[idx], smoothed[idx+1]):\n                                collision_found = True\n                                break\n                        if not collision_found:\n                            best_path = smoothed\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        else:\n            return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -2.46263,
          "time_improvement": -13.0,
          "length_improvement": 11.0,
          "smoothness_improvement": -51.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035960149765014646,
                    "num_nodes_avg": 157.6,
                    "path_length_avg": 181.56656105102078,
                    "smoothness_avg": 0.0027544049045480725,
                    "success_improvement": 0.0,
                    "time_improvement": -39.43008749751557,
                    "node_improvement": 60.31226391337196,
                    "length_improvement": 0.4804907816611706,
                    "smoothness_improvement": -56.88758195783864,
                    "objective_score": -11.825169690047163
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03835206031799317,
                    "num_nodes_avg": 278.0,
                    "path_length_avg": 247.3650706049829,
                    "smoothness_avg": 0.002081426354041347,
                    "success_improvement": 0.0,
                    "time_improvement": 76.83714369477482,
                    "node_improvement": 81.32097023449573,
                    "length_improvement": 17.42241942327895,
                    "smoothness_improvement": -46.44340071971108,
                    "objective_score": 33.272377758801255
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09013075828552246,
                    "num_nodes_avg": 422.3,
                    "path_length_avg": 126.80626393019686,
                    "smoothness_avg": 0.0039954997642482545,
                    "success_improvement": 0.0,
                    "time_improvement": -77.60742234756923,
                    "node_improvement": 46.306420851875394,
                    "length_improvement": 15.781317362972057,
                    "smoothness_improvement": -49.17753791587718,
                    "objective_score": -14.059323976066917
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant with dynamic informed sampling, adaptive rewiring radius, progressive multi-pass aggressive path shortcutting, and path smoothing via iterative linear interpolation. The planner focuses sampling within a dynamically shrinking informed ellipsoid around the current best solution, adaptively adjusts the rewiring radius with tree growth logarithm, alternates bidirectional tree extension, rewires neighbors to minimize cost, attempts rapid tree connection, and employs a multi-stage shortcutting strategy combined with linear path smoothing post-planning to produce paths that are both shorter and smoother with reduced planning time.",
          "planning_mechanism": "The planner alternates expanding two trees from start and goal using samples focused inside an ellipsoidal informed subset whose size shrinks as better solutions are found, adapts rewiring radius proportionally to the logarithm of the current tree size for better asymptotic optimality, quickly attempts to connect the trees when nodes are near, and after main planning applies aggressive multi-pass shortcutting and iterative linear path smoothing to improve smoothness and path length. The use of progressive shortcutting during planning (every fixed interval) similarly refines paths early, maintaining high-quality candidates. Collision checking with fine resolution occurs on node placement and edge creation to guarantee safety.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=7.0, base_radius=18.0, goal_sample_rate=0.05, shortcut_interval=60, shortcut_passes=3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_passes = shortcut_passes\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=0.5):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if sum((node.position[i] - point[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def informed_sample(best_cost, c_min, start, goal):\n            # Sample inside ellipsoid defined by current best cost\n            # If no solution yet, uniform sample\n            if best_cost == float('inf') or best_cost <= c_min:\n                return uniform_sample()\n            center = tuple(0.5 * (start[i] + goal[i]) for i in range(dim))\n            direction = [goal[i] - start[i] for i in range(dim)]\n            length = dist(start, goal)\n            if length < 1e-12:\n                return uniform_sample()\n\n            # Rotation matrix - using 2D or 3D logic\n            if dim == 2:\n                dx, dy = direction[0] / length, direction[1] / length\n                cos_theta, sin_theta = dx, dy\n                R = ((cos_theta, -sin_theta), (sin_theta, cos_theta))\n            else:\n                from math import sqrt\n                a1 = [1.0] + [0.0] * (dim - 1)\n                a2 = [d / length for d in direction]\n                v = [a1[1]*a2[2] - a1[2]*a2[1],\n                     a1[2]*a2[0] - a1[0]*a2[2],\n                     a1[0]*a2[1] - a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(dim))\n                if abs(s) < 1e-16:\n                    R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n                else:\n                    vx = [[0, -v[2], v[1]],\n                          [v[2], 0, -v[0]],\n                          [-v[1], v[0], 0]]\n                    I = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n                    vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(dim)) for j in range(dim)] for i in range(dim)]\n                    def mat_add(A, B):\n                        return [[A[i][j] + B[i][j] for j in range(dim)] for i in range(dim)]\n                    def mat_sub(A, B):\n                        return [[A[i][j] - B[i][j] for j in range(dim)] for i in range(dim)]\n                    def mat_scale(A, s):\n                        return [[A[i][j] * s for j in range(dim)] for i in range(dim)]\n                    s_sq = s * s\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / s_sq) for j in range(dim)] for i in range(dim)]\n\n            # Sample random point in unit ball\n            while True:\n                sample_ball = [random.uniform(-1, 1) for _ in range(dim)]\n                if sum(x * x for x in sample_ball) <= 1:\n                    break\n\n            # Ellipsoid axes lengths\n            a1_val = best_cost / 2.0\n            term = max(best_cost ** 2 - c_min ** 2, 0.0)\n            a_other = math.sqrt(term) / 2.0 if term > 0 else 0.0\n\n            # Scale sample in unit ball\n            if dim == 2:\n                L = [[a1_val, 0.0], [0.0, a_other]]\n                x_scaled = [L[0][0] * sample_ball[0] + L[0][1] * sample_ball[1],\n                            L[1][0] * sample_ball[0] + L[1][1] * sample_ball[1]]\n                pt = (\n                    center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                    center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1]\n                )\n            else:\n                L = [[0.0]*dim for _ in range(dim)]\n                L[0][0] = a1_val\n                for i in range(1, dim):\n                    L[i][i] = a_other\n                x_scaled = [sum(L[i][j] * sample_ball[j] for j in range(dim)) for i in range(dim)]\n                pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n\n            # Validate within map bounds and free space\n            if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                return uniform_sample()\n            if is_in_obstacle(pt):\n                return uniform_sample()\n            return pt\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            r = self.base_radius * (math.log(n) / n) ** (1.0 / dim)\n            # Ensure radius is never less than step_size * 1.5 to maintain connectivity\n            return max(r, self.step_size * 1.5)\n\n        def shortcut_path(path, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            new_path = path[:]\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def smooth_path_iterative_linear(path, iterations=3):\n            # Iteratively apply linear interpolation shortcutting to reduce sharp angle turns\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                new_path = [path[0]]\n                i = 0\n                while i < len(path) - 1:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        if not is_edge_in_obstacle(path[i], path[j]):\n                            break\n                        j -= 1\n                    new_path.append(path[j])\n                    i = j\n                path = new_path\n            return path\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        nodes_all = nodes_start + nodes_goal\n        edges = []\n\n        best_cost = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        solution_pair = None\n\n        for it in range(self.max_iter):\n            # Alternate expanding start and goal trees per iteration\n            for tree_a, tree_b in [(nodes_start, nodes_goal), (nodes_goal, nodes_start)]:\n                # Sampling\n                if best_cost < float('inf'):\n                    q_rand = informed_sample(best_cost, c_min, start_pos, goal_pos)\n                else:\n                    # Goal bias sampling\n                    if random.random() < self.goal_sample_rate:\n                        q_rand = goal_pos if tree_a is nodes_start else start_pos\n                    else:\n                        q_rand = uniform_sample()\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent for q_new minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c + 1e-9 < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes_all.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt to connect to the other tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    total_cost = q_new.cost + dist_connect + nearest_other.cost\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        if tree_a is nodes_start:\n                            solution_pair = (q_new, nearest_other)\n                        else:\n                            solution_pair = (nearest_other, q_new)\n\n            # Progressive shortcutting every shortcut_interval iterations to improve path quality early\n            if solution_pair is not None and (it % self.shortcut_interval == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_pair[0], solution_pair[1])\n                short_path = raw_path[:]\n                for _ in range(self.shortcut_passes):\n                    short_path = shortcut_path(short_path, max_attempts=100)\n                short_path = smooth_path_iterative_linear(short_path, iterations=3)\n                # Return early best path found so far with improved smoothing\n                return PlannerResult(True, short_path, nodes_all, edges)\n\n        # If no connection found after max_iter, return failure with empty path\n        return PlannerResult(False, [], nodes_all, edges)",
          "objective": 2.53066,
          "time_improvement": -10.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1520.0,
          "node_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05508248805999756,
                    "num_nodes_avg": 117.2,
                    "path_length_avg": 168.32975539382585,
                    "smoothness_avg": 0.053279436912490166,
                    "success_improvement": 0.0,
                    "time_improvement": -113.57408631424228,
                    "node_improvement": 70.48602367161925,
                    "length_improvement": 7.735793712977911,
                    "smoothness_improvement": 733.9388858295396,
                    "objective_score": -25.76105523733824
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.0475142240524292,
                    "num_nodes_avg": 234.0,
                    "path_length_avg": 232.20716163508487,
                    "smoothness_avg": 0.09815075111935158,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 71.30362397598876,
                    "node_improvement": 84.27736343479137,
                    "length_improvement": 22.48256573364951,
                    "smoothness_improvement": 2425.489521429429,
                    "objective_score": -2.9919257598665183
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04400918483734131,
                    "num_nodes_avg": 239.3,
                    "path_length_avg": 125.04610014200352,
                    "smoothness_avg": 0.11804364211045812,
                    "success_improvement": 0.0,
                    "time_improvement": 13.277575521813345,
                    "node_improvement": 69.57406230133503,
                    "length_improvement": 16.950334341097403,
                    "smoothness_improvement": 1401.5064145697108,
                    "objective_score": 21.161005334051
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling within an ellipsoidal region defined by the current best path cost, combined with efficient rewiring that propagates cost improvements to descendants, and iterative incremental shortcutting applied throughout planning to progressively shorten and smooth the path. The planner alternates expansion between start and goal trees, connecting them upon finding collision-free connections within step size, resulting in faster convergence, better path length, and improved smoothness.",
          "planning_mechanism": "A bidirectional RRT* variant grows two trees from start and goal alternately, samples new nodes inside an ellipsoid shaped by the best known path cost to focus search, steers incrementally towards sampled points with collision checks, rewires neighbors with recursive cost updates for optimization, and iteratively applies shortcutting to the best found path during planning to maintain smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, c_best=float('inf'), radius_factor=2.0, shortcut_freq=20, shortcut_trials=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.c_best = c_best\n        self.radius_factor = radius_factor\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map):\n        import math\n        import random\n\n        dim = len(map.size)\n        start = map.start\n        goal = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = o\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(int(dist * 6), 2)\n            for s in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * s / steps for i in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in nodes:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d2 += diff * diff\n                    if d2 > best_dist_sq:\n                        break\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near(nodes, point, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def rotation_to_unit(vector):\n            import numpy as np\n            norm = math.sqrt(sum(v * v for v in vector))\n            if norm == 0:\n                return [1.0] + [0.0] * (len(vector) - 1)\n            return [v / norm for v in vector]\n\n        # Sample within informed ellipsoid based on c_best and distance between start-goal\n        def informed_sample():\n            c_min = math.dist(start, goal)\n            if self.c_best == float('inf'):\n                # No solution yet: uniform sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(p):\n                        return p\n            else:\n                # Ellipsoidal informed sampling\n                center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n                diff = [goal[i] - start[i] for i in range(dim)]\n                c_min_eps = max(c_min, 1e-6)\n                if dim == 2:\n                    a1 = [diff[0] / c_min_eps, diff[1] / c_min_eps]\n                    rotation = a1\n                elif dim == 3:\n                    norm = math.sqrt(diff[0]**2 + diff[1]**2 + diff[2]**2)\n                    if norm > 0:\n                        rotation = [diff[0]/norm, diff[1]/norm, diff[2]/norm]\n                    else:\n                        rotation = [1.0,0.0,0.0]\n                else:\n                    rotation = [1.0] + [0.0]*(dim-1)\n                r1 = self.c_best / 2.0\n                r2 = math.sqrt(self.c_best ** 2 - c_min**2) / 2.0 if self.c_best > c_min else 0.0\n                while True:\n                    # Sample uniformly in unit ball\n                    if dim == 2:\n                        theta = random.uniform(0, 2*math.pi)\n                        r = math.sqrt(random.uniform(0,1))\n                        x_ball = r * math.cos(theta)\n                        y_ball = r * math.sin(theta)\n                        sample_ball = (x_ball, y_ball)\n                        x = sample_ball[0]*r1\n                        y = sample_ball[1]*r2\n                        # Rotate\n                        sample = (center[0] + rotation[0]*x - rotation[1]*y,\n                                  center[1] + rotation[1]*x + rotation[0]*y)\n                    elif dim == 3:\n                        while True:\n                            u = random.uniform(-1,1)\n                            v = random.uniform(-1,1)\n                            w = random.uniform(-1,1)\n                            if u*u+v*v+w*w <=1:\n                                break\n                        sample_ball = (u,v,w)\n                        x = sample_ball[0]*r1\n                        y = sample_ball[1]*r2\n                        z = sample_ball[2]*r2\n                        # Rotate along direction - approximate via axis alignment (only first axis)\n                        sample = tuple(center[i] + (rotation[i]*x if i==0 else 0) + (sample_ball[i]*r2 if i>0 else 0) for i in range(dim))\n                    else:\n                        sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if in_bounds(sample) and not in_obstacle(sample):\n                        return sample\n\n        def extract_path(n_start, n_goal):\n            path1 = []\n            n = n_start\n            while n:\n                path1.append(n.position)\n                n = n.parent\n            path1.reverse()\n            path2 = []\n            n = n_goal\n            while n:\n                path2.append(n.position)\n                n = n.parent\n            if path1 and path2 and path1[-1] == path2[0]:\n                path2 = path2[1:]\n            return path1 + path2\n\n        def shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path\n            for _ in range(self.shortcut_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if is_edge_free(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-9 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        best_cost = float('inf')\n        best_pair = None\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                radius = self.radius_factor * self.step_size\n                near_nodes = near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for node in near_nodes:\n                    c_new = node.cost + math.dist(node.position, new_pos)\n                    if c_new + 1e-9 < min_cost and is_edge_free(node.position, new_pos):\n                        min_cost = c_new\n                        min_parent = node\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                for node in near_nodes:\n                    if node is min_parent:\n                        continue\n                    c_through = new_node.cost + math.dist(new_node.position, node.position)\n                    if c_through + 1e-9 < node.cost and is_edge_free(new_node.position, node.position):\n                        update_parent(node, new_node, c_through)\n                        propagate_costs(node)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other)\n                        self.c_best = best_cost\n\n            if best_pair and it > 5 and it % self.shortcut_freq == 0:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut(path)\n                return PlannerResult(True, path, tree_start + tree_goal, [])\n\n        if best_pair:\n            path = extract_path(best_pair[0], best_pair[1])\n            path = shortcut(path)\n            return PlannerResult(True, path, tree_start + tree_goal, [])\n\n        return PlannerResult(False, [], tree_start + tree_goal, [])",
          "objective": 2.79702,
          "time_improvement": -49.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 691.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07392475605010987,
                    "num_nodes_avg": 155.7,
                    "path_length_avg": 172.7258306059307,
                    "smoothness_avg": 0.028565516017328353,
                    "success_improvement": 0.0,
                    "time_improvement": -186.63215452810044,
                    "node_improvement": 60.79073281289348,
                    "length_improvement": 5.326235228953743,
                    "smoothness_improvement": 347.11235668206115,
                    "objective_score": -51.05834343764758
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0608121395111084,
                    "num_nodes_avg": 257.0,
                    "path_length_avg": 241.41054192049654,
                    "smoothness_avg": 0.03943420209479791,
                    "success_improvement": 0.0,
                    "time_improvement": 63.27230304108947,
                    "node_improvement": 82.73197608009137,
                    "length_improvement": 19.410212489765613,
                    "smoothness_improvement": 914.6704232068487,
                    "objective_score": 35.20117052222045
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06331155300140381,
                    "num_nodes_avg": 258.1,
                    "path_length_avg": 123.3527558509088,
                    "smoothness_avg": 0.07152159621632938,
                    "success_improvement": 0.0,
                    "time_improvement": -24.75876101895663,
                    "node_improvement": 67.18372536554355,
                    "length_improvement": 18.074972990852377,
                    "smoothness_improvement": 809.7494246966228,
                    "objective_score": 7.466102612307552
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive dynamic informed ellipsoidal sampling, combined with an efficient multi-resolution spatial hashing for neighbor queries; employs a progressive rewiring strategy balancing cost and curvature penalties; features a robust dual-phase smoothing combining targeted shortcutting and simplified spline interpolation for enhanced smoothness and path quality. The planner dynamically adjusts neighbor radius based on node density and iteration, carefully manages tree expansions from start and goal aiming for early convergence, and updates paths in an incremental manner to improve both runtime and path metrics.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions using adaptive, ellipsoidal informed sampling based on the current best path cost to focus exploration. Spatial hashing enables fast neighborhood searches for rewiring new nodes progressively, considering both cost and curvature penalties to encourage smooth, short paths. Connections between trees are attempted frequently to find paths early. Once a solution path is found, it undergoes dual-phase smoothing: an initial aggressive shortcutting pass removes unnecessary nodes while respecting angle constraints, followed by a lightweight cubic spline interpolation to further smooth segments. This hierarchy yields efficient planning, improved path feasibility, and enhanced path smoothness while controlling computation time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, base_radius=20.0, goal_sample_rate=0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability sampling goal directly\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Collision checks:\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_collision(a, b, resolution=0.4):\n            dist_ab = math.dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                pt = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Spatial hash grid parameters for neighborhood:\n        GRID_CELL = self.step_size * 2.5\n        def grid_hash(p):\n            return tuple(int(p[i] // GRID_CELL) for i in range(dim))\n\n        def add_node_to_hash(hmap, node):\n            g = grid_hash(node.position)\n            if g not in hmap:\n                hmap[g] = []\n            hmap[g].append(node)\n\n        def nearby_nodes(hmap, p, radius):\n            radius_sq = radius * radius\n            gh = grid_hash(p)\n            offsets = [-1, 0, 1]\n            neighbors = []\n            if dim == 2:\n                cells = [(gh[0] + dx, gh[1] + dy) for dx in offsets for dy in offsets]\n            else:\n                cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in offsets for dy in offsets for dz in offsets]\n            for cell in cells:\n                if cell in hmap:\n                    for n in hmap[cell]:\n                        d2 = sum((n.position[i] - p[i]) ** 2 for i in range(dim))\n                        if d2 <= radius_sq:\n                            neighbors.append(n)\n            return neighbors\n\n        def nearest_node(hmap, p):\n            gh = grid_hash(p)\n            min_dist = float('inf')\n            result = None\n            search_range = 1\n            while search_range <= 3:\n                checked_cells = []\n                rng = range(-search_range, search_range + 1)\n                if dim == 2:\n                    checked_cells = [(gh[0] + dx, gh[1] + dy) for dx in rng for dy in rng]\n                else:\n                    checked_cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in rng for dy in rng for dz in rng]\n                for c in checked_cells:\n                    if c in hmap:\n                        for n in hmap[c]:\n                            d = math.dist(n.position, p)\n                            if d < min_dist:\n                                min_dist = d\n                                result = n\n                if result:\n                    return result\n                search_range += 1\n            # Fallback linear scan\n            all_nodes = []\n            for cell_nodes in hmap.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position, p))\n\n        # Curvature penalty encourages smooth paths:\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i] - parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i] - parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x * x for x in v1))\n            len2 = math.sqrt(sum(x * x for x in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return 0.0\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            cos_ang = max(-1.0, min(1.0, dot / (len1 * len2)))\n            return (1.0 - cos_ang) * 0.7  # tuned lower penalty for smoothness\n\n        def node_cost(parent, child_pos):\n            return parent.cost + math.dist(parent.position, child_pos) + curvature_penalty(parent, child_pos)\n\n        def radius_for_rewiring(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.base_radius * val, self.step_size * 1.2)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position) + curvature_penalty(node, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewire(tree_map, new_node, neighbors):\n            for n in neighbors:\n                if n is new_node.parent:\n                    continue\n                c_cost = node_cost(new_node, n.position)\n                if c_cost + 1e-12 < n.cost and not is_edge_collision(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    update_subtree_costs(n)\n\n        def extract_path(n_from_start, n_from_goal):\n            path_start = []\n            cur = n_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def ellipsoidal_informed_sample(iteration, best_cost):\n            if iteration % 4 != 0 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = max(best_cost, c_min + 1e-9)\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                r1 = c_best * 0.5\n                diff_sq = c_best * c_best - c_min * c_min\n                r_rest = math.sqrt(diff_sq) * 0.5 if diff_sq > 0 else 0.0\n\n                def unit_sphere_point():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-12:\n                            return [x / norm for x in vec]\n\n                for _ in range(30):\n                    u = unit_sphere_point()\n                    pt = [0.0] * dim\n                    pt[0] = u[0] * r1\n                    for i in range(1, dim):\n                        pt[i] = u[i] * r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n            # Uniform random fallback\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # Last resort bound-only random:\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Path smoothing helpers:\n        def angle_between(a, b, c):\n            # angle at point b between vectors ba and bc\n            v1 = [a[i] - b[i] for i in range(dim)]\n            v2 = [c[i] - b[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x * x for x in v1))\n            len2 = math.sqrt(sum(x * x for x in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return 0.0\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            val = max(min(dot / (len1 * len2), 1), -1)\n            return math.acos(val)\n\n        def aggressive_shortcut(path, max_tries=120):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_collision(new_path[i], new_path[j]):\n                    # Check angle smoothness at neighbors\n                    accept = True\n                    if i > 0:\n                        if angle_between(new_path[i - 1], new_path[i], new_path[j]) < (math.pi * 110 / 180):\n                            accept = False\n                    if j < len(new_path) - 1:\n                        if angle_between(new_path[i], new_path[j], new_path[j + 1]) < (math.pi * 110 / 180):\n                            accept = False\n                    if accept:\n                        del new_path[i + 1:j]\n            return new_path\n\n        def cubic_spline_path(path):\n            # Simplified spline: interpolate points uniformly between every pair via 3 intermediate points,\n            # only replacing segments if collision-free; reduce complexity and avoid curve-specific libs.\n            if len(path) < 3:\n                return path[:]\n\n            def interpolate(p0, p1, t):\n                return tuple(p0[i] + t * (p1[i] - p0[i]) for i in range(dim))\n\n            new_path = [path[0]]\n            for i in range(len(path) - 1):\n                p0, p1 = path[i], path[i + 1]\n                dist_seg = math.dist(p0, p1)\n                num_interp = max(2, int(dist_seg / (self.step_size / 3)))\n\n                segment_points = [interpolate(p0, p1, t / num_interp) for t in range(1, num_interp)]\n                # Check collisions for all segment edges (between interpolated points)\n                safe = True\n                last_pt = p0\n                for pt in segment_points:\n                    if is_edge_collision(last_pt, pt):\n                        safe = False\n                        break\n                    last_pt = pt\n                if safe and not is_edge_collision(last_pt, p1):\n                    new_path.extend(segment_points)\n                new_path.append(p1)\n            return new_path\n\n        # Initialize trees\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n\n        start_hash = {}\n        goal_hash = {}\n        add_node_to_hash(start_hash, start_tree[0])\n        add_node_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        for it in range(1, self.max_iter + 1):\n            sample = ellipsoidal_informed_sample(it, best_cost)\n            for (expand_hash, target_hash, expand_tree, target_tree) in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest = nearest_node(expand_hash, sample)\n                if nearest is None:\n                    continue\n                new_pos = steer(nearest.position, sample)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_collision(nearest.position, new_pos):\n                    continue\n\n                radius = radius_for_rewiring(it, len(expand_tree))\n                neighbors = nearby_nodes(expand_hash, new_pos, radius)\n\n                best_parent = nearest\n                best_cost_to_new = node_cost(nearest, new_pos)\n                for nb in neighbors:\n                    if nb is nearest:\n                        continue\n                    if is_edge_collision(nb.position, new_pos):\n                        continue\n                    c = node_cost(nb, new_pos)\n                    if c < best_cost_to_new:\n                        best_cost_to_new = c\n                        best_parent = nb\n\n                new_node = Node(new_pos, best_parent, best_cost_to_new)\n                best_parent.add_child(new_node)\n                expand_tree.append(new_node)\n                nodes.append(new_node)\n                add_node_to_hash(expand_hash, new_node)\n\n                rewire(expand_hash, new_node, neighbors)\n\n                # Attempt connection to other tree\n                nearest_other = nearest_node(target_hash, new_node.position)\n                if nearest_other and math.dist(new_node.position, nearest_other.position) <= self.step_size:\n                    if not is_edge_collision(new_node.position, nearest_other.position):\n                        path_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n                        if path_cost + 1e-10 < best_cost:\n                            best_cost = path_cost\n                            best_pair = (new_node, nearest_other)\n\n            # Early stopping on good path quality\n            if best_cost < float('inf') and it % 60 == 0:\n                path_raw = extract_path(best_pair[0], best_pair[1])\n                path_shortcut = aggressive_shortcut(path_raw, max_tries=100)\n                path_smooth = cubic_spline_path(path_shortcut)\n                if len(path_smooth) > 1:\n                    return PlannerResult(True, path_smooth, nodes, [])\n\n        if best_cost < float('inf'):\n            path_raw = extract_path(best_pair[0], best_pair[1])\n            path_shortcut = aggressive_shortcut(path_raw, max_tries=120)\n            path_smooth = cubic_spline_path(path_shortcut)\n            if len(path_smooth) > 1:\n                return PlannerResult(True, path_smooth, nodes, [])\n        return PlannerResult(False, [], nodes, [])",
          "objective": 3.40909,
          "time_improvement": 16.0,
          "length_improvement": 14.0,
          "smoothness_improvement": -53.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03869884014129639,
                    "num_nodes_avg": 191.0,
                    "path_length_avg": 167.61590711511727,
                    "smoothness_avg": 0.0029384356273275325,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -50.048948689386144,
                    "node_improvement": 51.90128431125661,
                    "length_improvement": 8.127065266187925,
                    "smoothness_improvement": -54.007101517229295,
                    "objective_score": -60.408480954689225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04068357944488525,
                    "num_nodes_avg": 343.9,
                    "path_length_avg": 239.71117463186488,
                    "smoothness_avg": 0.0019374517887491942,
                    "success_improvement": 0.0,
                    "time_improvement": 75.42901484690302,
                    "node_improvement": 76.89309950950751,
                    "length_improvement": 19.97751020428618,
                    "smoothness_improvement": -50.147969985365926,
                    "objective_score": 34.36447072671578
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038884973526000975,
                    "num_nodes_avg": 364.6,
                    "path_length_avg": 127.79160926508757,
                    "smoothness_avg": 0.0035860758417901504,
                    "success_improvement": 0.0,
                    "time_improvement": 23.375104710332348,
                    "node_improvement": 53.64272091544818,
                    "length_improvement": 15.126897908640395,
                    "smoothness_improvement": -54.385379989013884,
                    "objective_score": 15.81674325833887
               }
          ],
          "success_rate": 0.9666666666666667
     }
]