[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood scaling, combined probabilistic goal and ellipsoidal informed sampling, enhanced rewiring, and aggressive progressive shortcutting to improve planning efficiency, path smoothness, and length. The planner alternates expansions from start and goal trees, dynamically adapts rewiring radius based on node density, and balances exploration with exploitation by mixing goal bias with ellipsoidal sampling. It uses efficient nearest neighbor queries, performs rewiring immediately after node addition, and aggressively shortcuts paths every iteration after improvements, yielding faster convergence to high-quality, smooth paths.",
          "planning_mechanism": "The planner maintains two trees from start and goal, alternately extending them toward samples drawn probabilistically either from the goal (goal bias) or ellipsoidal informed region based on current best path cost. For each new node, it selects the best parent and rewires neighbors within an adaptive radius to minimize cost. Upon path improvements, it aggressively applies progressive shortcutting with more attempts to significantly smooth and shorten the path. The adaptive rewiring radius shrinks as the tree grows, balancing local optimization and global exploration for efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.10,\n                 shortcut_attempts=80):\n        # max_iter: max iterations for planning\n        # step_size: maximum extension length per step\n        # gamma: rewiring radius scaling factor\n        # goal_sample_rate: probability of sampling directly at goal to bias search\n        # shortcut_attempts: max shortcut tries per path smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            rad = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(rad, self.step_size * 40.0)\n\n        def sample():\n            # Combined goal bias and ellipsoidal informed sampling\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No solution yet, uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return self._sample_free(bounds, obstacles, is_3d)\n            # After first solution, use mixture of goal bias and ellipsoidal informed sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return self._sample_ellipsoidal_informed(bounds, obstacles, is_3d,\n                                                         best_cost, c_min,\n                                                         start_pos, goal_pos, dim)\n\n        def extend_and_rewire(tree_from, tree_to, sample):\n            nearest = self._nearest(tree_from, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            r = adaptive_radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, r)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-free edges\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if it's cost efficient and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to the other tree\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n\n            return None\n\n        def aggressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    # Reset attempts on success to allow more smoothing\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            smp = sample()\n\n            # Alternate tree expansions to balance growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = extend_and_rewire(tree_a, tree_b, smp)\n                if res is not None:\n                    new_node, connect_node, total_cost = res\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start = new_node\n                            solution_goal = connect_node\n                        else:\n                            solution_start = connect_node\n                            solution_goal = new_node\n\n                        raw_path = self._extract_path(solution_start, solution_goal)\n                        smoothed_path = aggressive_shortcut(raw_path)\n                        if smoothed_path and len(smoothed_path) >= 2:\n                            # Return improved solution immediately on improvement for speed\n                            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_ellipsoidal_informed(self, bounds, obstacles, is_3d, best_cost, c_min,\n                                    start_pos, goal_pos, dim):\n        import random\n        import math\n\n        center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n        direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n        length = math.dist(start_pos, goal_pos)\n\n        if dim == 2:\n            if length < 1e-12:\n                R = [[1, 0],\n                     [0, 1]]\n            else:\n                a1 = [1, 0]\n                a2 = [direction[0] / length, direction[1] / length]\n                cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_t, -sin_t],\n                     [sin_t, cos_t]]\n        else:\n            from math import sqrt\n            if length < 1e-12:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                a1 = [1,0,0]\n                a2 = [d/length for d in direction]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        a1_val = best_cost * 0.5\n        a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0)) * 0.5\n\n        while True:\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0],\n                     [0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (\n                    center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                    center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1]\n                )\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val, 0, 0],\n                     [0, a_other, 0],\n                     [0, 0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0/3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim/2)) / gamma(dim/2 + 1)",
          "objective": -32.52068,
          "time_improvement": 47.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1734.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020076465606689454,
                    "num_nodes_avg": 116.8,
                    "path_length_avg": 162.49456117438694,
                    "smoothness_avg": 0.04179993549748345,
                    "success_improvement": 0.0,
                    "time_improvement": 22.15651562983882,
                    "node_improvement": 70.58675396625536,
                    "length_improvement": 10.93415612922186,
                    "smoothness_improvement": 554.2597605483732,
                    "objective_score": 15.978747169226628
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034181642532348636,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 238.180902638735,
                    "smoothness_avg": 0.12075947586833821,
                    "success_improvement": 0.0,
                    "time_improvement": 79.35588159570369,
                    "node_improvement": 81.99287778001747,
                    "length_improvement": 20.48835904203003,
                    "smoothness_improvement": 3007.2282936270713,
                    "objective_score": 51.13592137206448
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03004302978515625,
                    "num_nodes_avg": 247.2,
                    "path_length_avg": 125.47417143071527,
                    "smoothness_avg": 0.1369214674928818,
                    "success_improvement": 0.0,
                    "time_improvement": 40.798622122433216,
                    "node_improvement": 68.56961220597584,
                    "length_improvement": 16.666029773699346,
                    "smoothness_improvement": 1641.6309600180152,
                    "objective_score": 30.447359301039647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive radius rewiring, informed sampling after first solution, frequent incremental shortcutting to improve path smoothness and length, early termination on solution stagnation, and efficient collision checks. It alternates growing start and goal trees, connects and rewires nodes within adaptive radius based on node count, and progressively shortcuts the best path during planning for better convergence in less time.",
          "planning_mechanism": "The Planner grows two trees from start and goal, samples points uniformly or within an ellipsoidal informed subset after a solution is found, extends and rewires nodes within an adaptive radius logarithmically decreasing with node count, attempts connections between trees to form a solution, and applies incremental shortcutting after solution improvements and periodically to smooth and shorten paths, terminating early if no improvements occur for a defined interval.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=20, max_shortcut_attempts=40, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            if dim == 2:\n                cos_theta = dir_vec[0]/length\n                sin_theta = dir_vec[1]/length\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1*x_ball[0], a2*x_ball[1]]\n                    pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                          center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                # 3D sampling inside prolate hyperspheroid\n                from math import sqrt\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq==0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    # Rotation matrix mapping x-axis to dir_vec unit vector\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i]-from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size*8.0\n            return min(self.step_size*30, self.gamma_rrt_star*(math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        last_improve_iter = 0\n        no_improve_limit = 100\n\n        for iter in range(self.max_iter):\n            if best_cost < float('inf') and random.random() < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = iter\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        path = extract_path(solution_start, solution_goal)\n                        for _ in range(2):\n                            path = shortcut_path(path)\n                        # Replace last path with shortcut improved\n                        if len(path) < len(extract_path(solution_start, solution_goal)):\n                            # best path shortened\n                            continue\n\n            if best_cost < float('inf') and (iter - last_improve_iter) > no_improve_limit:\n                break\n\n            if best_cost < float('inf') and iter % self.shortcut_interval == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -32.21382,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1551.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02305736541748047,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 168.73944907303084,
                    "smoothness_avg": 0.04309848636832513,
                    "success_improvement": 0.0,
                    "time_improvement": 10.598523681644005,
                    "node_improvement": 71.74515235457064,
                    "length_improvement": 7.511234115393865,
                    "smoothness_improvement": 574.5849015253947,
                    "objective_score": 10.559222081356495
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02576143741607666,
                    "num_nodes_avg": 208.1,
                    "path_length_avg": 237.2903072590682,
                    "smoothness_avg": 0.1076212802971938,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44129290220465,
                    "node_improvement": 86.01760397769269,
                    "length_improvement": 20.785665414129483,
                    "smoothness_improvement": 2669.1730585217547,
                    "objective_score": 51.149652411747866
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018548035621643068,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 128.3642742559325,
                    "smoothness_avg": 0.11870521723960548,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45011559832764,
                    "node_improvement": 76.78321678321677,
                    "length_improvement": 14.746561089097684,
                    "smoothness_improvement": 1409.9216013800688,
                    "objective_score": 34.93257933985725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional Anytime Informed RRT* planner integrating adaptive density-based rewiring radius, ellipsoidal informed sampling, incremental path shortcutting, and optimized data structures for enhanced planning efficiency, robustness, and path quality. It grows trees from start and goal, alternates expansions, samples within shrinking ellipsoidal informed sets, dynamically adapts rewiring radius based on node density, rewires neighbors to improve cost locally, attempts early tree connection to reduce search time, and frequently applies a focused incremental shortcutting method to continuously smooth and shorten the path while maintaining collision safety.",
          "planning_mechanism": "The algorithm alternates expansions between two bidirectional trees and samples points concentrated in an ellipsoidal informed region defined by the current best solution cost. It incorporates a density-adaptive rewiring radius for efficient pruning and rewiring, performs collision-checked parent selection and neighbor rewiring, connects trees when nodes are reachable, and incrementally shortcuts the current best path at frequent intervals to improve smoothness and length without excessive computation. This continuous interplay of sampling, rewiring, connection, and shortcutting rapidly converges towards an optimal, smooth path with reduced runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0, shortcut_freq=25, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def unit_ball_vol(d):\n            if d == 2:\n                return math.pi\n            if d == 3:\n                return 4.0/3.0*math.pi\n            from math import gamma, pi\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [direction[0]/length, direction[1]/length]\n                    cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [direction[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball)<=1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            dist_sq = 0.0\n            diff_vec = []\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                diff_vec.append(diff)\n                dist_sq += diff*diff\n            dist = dist_sq**0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            new_pos = tuple(from_pos[i] + diff_vec[i]*ratio for i in range(dim))\n            return new_pos\n\n        def is_edge_collision_free(p1, p2):\n            # Collision check in intervals of max 1.0 units for efficiency\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / 1.0))\n            for step_i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(step_i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not is_edge_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                tentative = n.cost + math.dist(n.position, new_pos)\n                if tentative < min_cost:\n                    if is_edge_collision_free(n.position, new_pos):\n                        min_cost = tentative\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent if beneficial\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if is_edge_collision_free(new_node.position, n.position):\n                        if n.parent is not None:\n                            try: edges.remove((n.parent, n))\n                            except ValueError: pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect to nearest node in other tree within step_size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_edge_collision_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            shortcut_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) <3:\n                    break\n                i = random.randint(0,len(shortcut_path)-3)\n                j = random.randint(i+2,len(shortcut_path)-1)\n                if is_edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False",
          "objective": -32.21323,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01826310157775879,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 166.80041346603122,
                    "smoothness_avg": 0.03850615988076263,
                    "success_improvement": 0.0,
                    "time_improvement": 29.187562688064194,
                    "node_improvement": 67.01082850667338,
                    "length_improvement": 8.574050257575799,
                    "smoothness_improvement": 502.7050195984601,
                    "objective_score": 16.414224058957036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02589578628540039,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 234.42132183759287,
                    "smoothness_avg": 0.0955636258647175,
                    "success_improvement": 0.0,
                    "time_improvement": 84.36015244901614,
                    "node_improvement": 83.86749983202311,
                    "length_improvement": 21.743415326984575,
                    "smoothness_improvement": 2358.9209251966936,
                    "objective_score": 50.14869955687905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028525924682617186,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 126.10181619096082,
                    "smoothness_avg": 0.1209255471006773,
                    "success_improvement": 0.0,
                    "time_improvement": 43.78815790153682,
                    "node_improvement": 70.10807374443738,
                    "length_improvement": 16.24917800917602,
                    "smoothness_improvement": 1438.1640333251999,
                    "objective_score": 30.07677434259266
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* variant with adaptive rewiring, efficient ellipsoidal sampling focused on the current best path cost, continuous rewiring with cost propagation, and frequent incremental shortcutting to ensure efficient convergence to high-quality, smooth, and short paths. Sampling is restricted within an ellipsoid based on the best solution cost, rewiring radius adapts to node density, and shortcutting continuously improves smoothness and path length during planning.",
          "planning_mechanism": "The planner grows bidirectional trees from start and goal, alternately sampling points focused on an informed ellipsoid region to guide exploration toward promising areas. On each extension, it rewires neighbors dynamically adapting the radius based on sampling density, propagates cost improvements efficiently, and frequently performs incremental shortcutting to refine the best path, thereby ensuring fast convergence, robustness, and high-quality smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=30.0, shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_nodes = [Node(start_pos, None, 0.0)]\n        goal_nodes = [Node(goal_pos, None, 0.0)]\n        nodes = start_nodes + goal_nodes\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[: i + 1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = math.sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [\n                            [0, -v[2], v[1]],\n                            [v[2], 0, -v[0]],\n                            [-v[1], v[0], 0],\n                        ]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [\n                            [\n                                sum(vx[i][k] * vx[k][j] for k in range(3))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n                        R = [\n                            [\n                                I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                        L[1][0] * x_ball[0] + L[1][1] * x_ball[1],\n                    ]\n                    pt = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0],\n                        L[1][1] * x_ball[1],\n                        L[2][2] * x_ball[2],\n                    ]\n                    pt = tuple(\n                        center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim))\n                        for i in range(dim)\n                    )\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-10 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-10 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if (\n                dist_connect <= self.step_size\n                and not is_edge_in_obstacle(new_node.position, nearest_other.position)\n            ):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            # Alternate tree roles to maintain bidirectionality\n            for (tree_a, tree_b) in [(start_nodes, goal_nodes), (goal_nodes, start_nodes)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (\n                            (new_node, connect_node)\n                            if tree_a is start_nodes\n                            else (connect_node, new_node)\n                        )\n\n            if best_cost < float(\"inf\") and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.90769,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1713.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018351244926452636,
                    "num_nodes_avg": 106.7,
                    "path_length_avg": 166.32115349423978,
                    "smoothness_avg": 0.045429712971989604,
                    "success_improvement": 0.0,
                    "time_improvement": 28.845800073030155,
                    "node_improvement": 73.13019390581718,
                    "length_improvement": 8.836740242474923,
                    "smoothness_improvement": 611.0736602123392,
                    "objective_score": 17.0111524684557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053799915313720706,
                    "num_nodes_avg": 275.9,
                    "path_length_avg": 244.29920467196445,
                    "smoothness_avg": 0.11771383242798397,
                    "success_improvement": 0.0,
                    "time_improvement": 67.50735951830073,
                    "node_improvement": 81.46207081905531,
                    "length_improvement": 18.445893717778457,
                    "smoothness_improvement": 2928.861694218456,
                    "objective_score": 45.96405255724957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02596104145050049,
                    "num_nodes_avg": 190.7,
                    "path_length_avg": 125.21405267786288,
                    "smoothness_avg": 0.1335209899284163,
                    "success_improvement": 0.0,
                    "time_improvement": 48.842395856970974,
                    "node_improvement": 75.75333757151938,
                    "length_improvement": 16.83878826381995,
                    "smoothness_improvement": 1598.3771363951587,
                    "objective_score": 32.747877397359055
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
          "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.45446,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1289.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103193283081056,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 173.3649996406287,
                    "smoothness_avg": 0.03905650881261121,
                    "success_improvement": 0.0,
                    "time_improvement": 25.93023309560016,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 4.975896552754276,
                    "smoothness_improvement": 511.3191754837242,
                    "objective_score": 13.321203737751233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022163128852844237,
                    "num_nodes_avg": 240.8,
                    "path_length_avg": 245.67296527562377,
                    "smoothness_avg": 0.08351123895740013,
                    "success_improvement": 0.0,
                    "time_improvement": 86.6145035068227,
                    "node_improvement": 83.8204663038366,
                    "length_improvement": 17.987292886770433,
                    "smoothness_improvement": 2048.8043290880164,
                    "objective_score": 47.020748429549144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017162418365478514,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 131.41011815324833,
                    "smoothness_avg": 0.11058336040285022,
                    "success_improvement": 0.0,
                    "time_improvement": 66.18054762740364,
                    "node_improvement": 71.51938970120788,
                    "length_improvement": 12.723656600001021,
                    "smoothness_improvement": 1306.6121819096536,
                    "objective_score": 34.02141915776997
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.35436,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020946669578552245,
                    "num_nodes_avg": 169.2,
                    "path_length_avg": 156.9968252907203,
                    "smoothness_avg": 0.020851635172459877,
                    "success_improvement": 0.0,
                    "time_improvement": 18.782430240028845,
                    "node_improvement": 57.39108536892471,
                    "length_improvement": 13.947552284259512,
                    "smoothness_improvement": 226.3733704995064,
                    "objective_score": 15.135127295061892
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029881834983825684,
                    "num_nodes_avg": 307.0,
                    "path_length_avg": 231.7579073494588,
                    "smoothness_avg": 0.09111135278880159,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95276488074154,
                    "node_improvement": 79.3724383524827,
                    "length_improvement": 22.63253974525912,
                    "smoothness_improvement": 2244.360732110702,
                    "objective_score": 49.38715697193144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02644164562225342,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 123.73707639297194,
                    "smoothness_avg": 0.07830820806750623,
                    "success_improvement": 0.0,
                    "time_improvement": 47.89533993801242,
                    "node_improvement": 63.4837889383344,
                    "length_improvement": 17.819725586191648,
                    "smoothness_improvement": 896.0746265080132,
                    "objective_score": 29.54081046565878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
          "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -29.43149,
          "time_improvement": 46.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1325.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025296664237976073,
                    "num_nodes_avg": 157.7,
                    "path_length_avg": 169.82640352208247,
                    "smoothness_avg": 0.034435143239248046,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9159783497959368,
                    "node_improvement": 60.28708133971292,
                    "length_improvement": 6.915457157973212,
                    "smoothness_improvement": 438.98476880462505,
                    "objective_score": 6.918991643745834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026137399673461913,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 237.06092208208943,
                    "smoothness_avg": 0.09896313272769311,
                    "success_improvement": 0.0,
                    "time_improvement": 84.21422922761201,
                    "node_improvement": 84.65363166028354,
                    "length_improvement": 20.862240788691224,
                    "smoothness_improvement": 2446.3926853468774,
                    "objective_score": 50.01357666823272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02440671920776367,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 124.62874035050683,
                    "smoothness_avg": 0.09361395032374312,
                    "success_improvement": 0.0,
                    "time_improvement": 51.90526997765084,
                    "node_improvement": 72.01525746980292,
                    "length_improvement": 17.227524842071908,
                    "smoothness_improvement": 1090.7625382549713,
                    "objective_score": 31.361908589813254
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with dynamic goal-biased informed sampling, adaptive rewiring radius tuned by node density, efficient incremental rewiring with robust edge and child updates, and a geometry-driven post-processing smoothing combining heuristic shortcutting and path simplification for enhanced smoothness and path length within reduced planning time. This algorithm integrates focused sampling around the current best path, frequent rewiring to optimize locally, and geometry-aware shortcutting with checks for collision-free paths. It balances exploration and exploitation by adapting sampling and rewiring adaptively and uses early termination based on no improvement stagnation to improve efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending them toward samples generated either uniformly, toward the goal directly with goal bias, or within an ellipsoidal informed subset defined by the best solution cost. New nodes choose parents from neighbors within an adaptive radius decreasing with node number and dimension, ensuring efficient rewiring and local cost optimization. Upon connecting the two trees, the best path is extracted and a geometry-driven post-processing smoothing method attempts shortcutting only between points with larger Euclidean distance and removes unnecessary waypoints to reduce jagged turns. The algorithm applies early stopping if no improvement is made for a defined iteration window, yielding faster convergence and better path length and smoothness without compromising robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, gamma=35.0,\n                 goal_sample_rate=0.15, shortcut_interval=15, max_shortcut_attempts=50,\n                 no_improve_limit=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.no_improve_limit = no_improve_limit\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                diff = p2[i] - p1[i]\n                dist += diff*diff\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            # Build rotation matrix to align x-axis with dir_vec\n            if dim == 2:\n                cos_theta = dir_vec[0] / length\n                sin_theta = dir_vec[1] / length\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [a1 * x_ball[0], a2 * x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                from math import sqrt\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq == 0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            return min(self.step_size * 28.0, self.gamma * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        last_improve_iter = 0\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try + 1e-10 < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost and edge is collision free\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost + 1e-10 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent is not None:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + dist_to_other\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += math.dist(path[i], path[i+1])\n            return length\n\n        def geometric_shortcut(path):\n            # Heuristic geometry-aware shortcut: only try pairs with distance > 3*step_size to reduce attempts\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if math.dist(new_path[i], new_path[j]) > 3*self.step_size:\n                    if not edge_in_obstacle(new_path[i], new_path[j]):\n                        # Shortcut feasible, replace intermediate nodes\n                        new_path = new_path[:i+1] + new_path[j:]\n                        attempts = 0  # reset attempts on success\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            # Post-process: Remove collinear or near-collinear nodes to smooth path further\n            def is_collinear(p1,p2,p3, tol=1e-3):\n                # Check area of triangle formed by these 3 points\n                if dim == 2:\n                    area = abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n                else:\n                    # For 3D use vector triple product for area of parallelogram\n                    import numpy as np\n                    a = np.array(p2)-np.array(p1)\n                    b = np.array(p3)-np.array(p1)\n                    cross = (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n                    area = (cross[0]**2 + cross[1]**2 + cross[2]**2)**0.5 / 2.0\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n            # Remove near-collinear middle points\n            i = 1\n            while i < len(new_path)-1:\n                if is_collinear(new_path[i-1], new_path[i], new_path[i+1]):\n                    new_path.pop(i)\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            r = random.random()\n            if best_cost < float('inf') and r < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-10 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = it\n                        if tree_from is start_tree:\n                            sol_start, sol_goal = n_start, n_goal\n                        else:\n                            sol_start, sol_goal = n_goal, n_start\n\n            if best_cost < float('inf'):\n                if (it - last_improve_iter) > self.no_improve_limit:\n                    break\n                if it % self.shortcut_interval == 0 and sol_start is not None and sol_goal is not None:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = geometric_shortcut(raw_path)\n                    if len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and sol_start and sol_goal:\n            raw_path = extract_path(sol_start, sol_goal)\n            final_path = geometric_shortcut(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -28.78012,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1275.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020882630348205568,
                    "num_nodes_avg": 147.3,
                    "path_length_avg": 170.37169066289314,
                    "smoothness_avg": 0.02821399372542354,
                    "success_improvement": 0.0,
                    "time_improvement": 19.030732751249133,
                    "node_improvement": 62.90606900025183,
                    "length_improvement": 6.616576635467197,
                    "smoothness_improvement": 341.61026947087623,
                    "objective_score": 11.387217154009438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030633068084716795,
                    "num_nodes_avg": 267.9,
                    "path_length_avg": 242.56536860233672,
                    "smoothness_avg": 0.10851433639409444,
                    "success_improvement": 0.0,
                    "time_improvement": 81.49905511330289,
                    "node_improvement": 81.9995968554727,
                    "length_improvement": 19.024698103524358,
                    "smoothness_improvement": 2692.152035137315,
                    "objective_score": 49.325295571792054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03129546642303467,
                    "num_nodes_avg": 269.8,
                    "path_length_avg": 125.02772119995618,
                    "smoothness_avg": 0.06998655864811568,
                    "success_improvement": 0.0,
                    "time_improvement": 38.33062953989469,
                    "node_improvement": 65.69612205975844,
                    "length_improvement": 16.96254075929408,
                    "smoothness_improvement": 790.2238601336318,
                    "objective_score": 25.627832618213013
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing dynamic adaptive rewiring radius, ellipsoidal informed sampling post initial solution, efficient k-nearest rewiring leveraging approximate nearest neighbor heuristic, and a refined incremental shortcutting mechanism combining curvature preservation with iterative path smoothing. This planner aggressively prunes and updates trees for faster convergence, improves path length by adaptive rewiring and ellipsoidal sampling, while enhancing path smoothness by integrating curvature-aware incremental shortcutting and smoothing every fixed iteration interval. Early exits during collision checks and consistent graph maintenance reduce planning time and increase robustness.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions from start and goal states. It performs ellipsoidal informed sampling inside an adaptive prolate hyperspheroid once a valid path is found, focusing search near the best solution. Adaptive near radius for rewiring scales logarithmically with node count and dimension. The planner uses approximate nearest neighbors by early exiting distance checks to improve rewiring efficiency. Rewiring considers curvature preservation to avoid sharp turns. The incremental shortcutting aggressively shortcuts edges without increasing curvature beyond a small angle threshold, followed by midpoint smoothing. Path extraction reconciles the two trees once a connection occurs, and path smoothing is applied periodically to maintain smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.5, gamma_rrt_star=45.0,\n                 shortcut_interval=30, max_shortcut_attempts=45, curvature_threshold=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.curvature_threshold = curvature_threshold  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 45)\n\n        def angle_between(a, b, c):\n            # Returns angle at b formed by points a-b-c in radians\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_preserving_rewire(new_node, near_nodes_list):\n            import math\n            for near in near_nodes_list:\n                if near is new_node.parent or near is new_node:\n                    continue\n                dist_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_cost\n                if potential_cost + 1e-15 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Check curvature increase if rewired\n                        prev_parent = near.parent\n                        if prev_parent is None:\n                            continue\n                        ang_before = angle_between(prev_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position,\n                                                  near.children[0].position) if near.children else 0.0\n                        # Accept if curvature doesn't increase noticeably or children absent\n                        if len(near.children) == 0 or ang_after < ang_before + self.curvature_threshold:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = potential_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_subtree_costs(near, edges)\n\n        def incremental_curvature_shortcut(path):\n            # Iteratively tries shortcuts preserving curvature within threshold\n            if len(path) < 3:\n                return path[:]\n            import random\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                L = len(new_path)\n                for i in range(L - 2):\n                    for j in range(L - 1, i + 1, -1):\n                        if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                            # Check curvature preservation between three-waypoints if applicable\n                            if i > 0 and j < L - 1:\n                                ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1])\n                                ang_after = angle_between(new_path[i-1], new_path[j], new_path[j+1])\n                                if ang_after < ang_before + self.curvature_threshold:\n                                    new_path = new_path[:i+1] + new_path[j:]\n                                    changed = True\n                                    break\n                            else:\n                                new_path = new_path[:i+1] + new_path[j:]\n                                changed = True\n                                break\n                    if changed:\n                        break\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(a, midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(midpoint, c, obstacles, is_3d)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-6:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_connection(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Efficient approximate k-nearest rewiring (early exit heuristic)\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    # Early exit collision check\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes trying to preserve curvature and improve cost\n            curvature_preserving_rewire(new_node, near_nodes)\n\n            # Try connect to tree_b within step_size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost + 1e-15 < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_connection(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, conn_node, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, conn_node\n                        else:\n                            solution_start, solution_goal = conn_node, new_node\n\n            # Apply incremental path smoothing and curvature-aware shortcutting every shortcut_interval iterations once solution found\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    shortcut_path = incremental_curvature_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(shortcut_path)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extract_path(self, node_start, node_goal):\n        s_path = []\n        n = node_start\n        while n is not None:\n            s_path.append(n.position)\n            n = n.parent\n        g_path = []\n        n = node_goal\n        while n is not None:\n            g_path.append(n.position)\n            n = n.parent\n        return s_path[::-1] + g_path\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq >= best_dist_sq:  # early exit\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist += d * d\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * diff_vec[i] for i in range(len(from_pos)))\n        return new_pos\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
          "objective": -28.74503,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1723.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0299816370010376,
                    "num_nodes_avg": 148.2,
                    "path_length_avg": 167.3939001155781,
                    "smoothness_avg": 0.050243287597786124,
                    "success_improvement": 0.0,
                    "time_improvement": -16.24930089808597,
                    "node_improvement": 62.67942583732058,
                    "length_improvement": 8.248750820561371,
                    "smoothness_improvement": 686.4165559506581,
                    "objective_score": 3.506543002664322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024869823455810548,
                    "num_nodes_avg": 213.3,
                    "path_length_avg": 234.52362942815247,
                    "smoothness_avg": 0.11434926003010829,
                    "success_improvement": 0.0,
                    "time_improvement": 84.97978616358722,
                    "node_improvement": 85.66821205402137,
                    "length_improvement": 21.70926210849506,
                    "smoothness_improvement": 2842.288823017571,
                    "objective_score": 52.73093722926106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03181536197662353,
                    "num_nodes_avg": 263.6,
                    "path_length_avg": 123.95805243875779,
                    "smoothness_avg": 0.13682429202352978,
                    "success_improvement": 0.0,
                    "time_improvement": 37.30614787659427,
                    "node_improvement": 66.48442466624284,
                    "length_improvement": 17.672963818329237,
                    "smoothness_improvement": 1640.3948952206044,
                    "objective_score": 29.99759713007884
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
          "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -28.03557,
          "time_improvement": 38.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1533.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive sampling radius, momentum-based tree extension, and batch rewiring to efficiently converge to high-quality solutions. The algorithm uses ellipsoidal informed sampling shrinking with the best path cost and adapts the rewiring radius scaling with tree density to balance exploration and local optimization. Momentum steering moves nodes further along promising directions to accelerate convergence. Batch rewiring is performed less frequently but covers a broader neighborhood for better path refinement. Incremental shortcutting runs immediately after improvements to incrementally shorten and smooth the path, enhancing path length and smoothness while reducing search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling within a shrinking ellipsoidal informed subset after the first found path. Each iteration attempts to extend in momentum-driven directions to improve progress speed. It adaptively chooses parent nodes and rewires a dynamically scaled neighborhood to optimize cost. Batch rewiring periodically repairs the trees globally. Paths are incrementally shortcut as soon as better solutions are found for continuous quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, gamma_adapt=45.0, batch_rewire_freq=50, max_shortcut_attempts=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_adapt = gamma_adapt\n        self.batch_rewire_freq = batch_rewire_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.2\n            val = self.gamma_adapt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 45.0)\n\n        def sample_ellipsoidal():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in direction]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0], [0,a_other,0], [0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer_momentum(from_pos, to_pos, momentum):\n            dist = math.dist(from_pos, to_pos)\n            if dist < 1e-12:\n                return from_pos\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            step = min(self.step_size, dist)\n            base_new = tuple(from_pos[i]+direction[i]*step for i in range(dim))\n            # Apply momentum to push further if within map bounds and free\n            momentum_step = 0.6 * self.step_size\n            candidate = tuple(base_new[i] + direction[i]*momentum_step for i in range(dim))\n            if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)):\n                return candidate\n            return base_new\n\n        def rewire_batch(tree):\n            n_nodes = len(tree)\n            if n_nodes <= 1:\n                return\n            r = radius(n_nodes) * 1.15  # slightly larger radius for batch rewiring\n            for n in tree:\n                near_nodes = self._near(tree, n.position, r)\n                for near in near_nodes:\n                    if near is n or n.parent is None:\n                        continue\n                    tentative_cost = n.cost + math.dist(n.position, near.position)\n                    if tentative_cost + 1e-9 < near.cost:\n                        if not self._is_edge_in_obstacle(n.position, near.position, obstacles, is_3d):\n                            # Rewire near node to n\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = n\n                            near.cost = tentative_cost\n                            n.add_child(near)\n                            edges.append((n, near))\n\n        def attempt_extend(tree_from, tree_to, sample, prev_dir):\n            nearest = self._nearest(tree_from, sample)\n            if prev_dir is None:\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n            else:\n                new_pos = steer_momentum(nearest.position, sample, prev_dir)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None, None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None, None\n\n            new_node = Node(new_pos)\n            rn = radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, rn)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            d_connect = math.dist(new_node.position, nearest_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_connect + nearest_other.cost\n                    return (new_node, nearest_other, total_cost, \n                            tuple((new_node.position[i] - nearest_other.position[i]) for i in range(dim)))\n            return None, None, None, None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            pth = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not self._is_edge_in_obstacle(pth[i], pth[j], obstacles, is_3d):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        prev_direction = None\n        for it in range(self.max_iter):\n            sample = sample_ellipsoidal()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(treeA, treeB, sample, prev_direction)\n                if res[0] is not None:\n                    new_node, connect_node, c_cost, direction_vec = res\n                    if c_cost + 1e-9 < best_cost:\n                        best_cost = c_cost\n                        prev_direction = direction_vec\n                        if treeA is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n                        # Incremental shortcut immediately on improvement\n                        raw_path = self._extract_path(sol_start, sol_goal)\n                        improved_path = incremental_shortcut(raw_path)\n                        if improved_path and len(improved_path) >= 2:\n                            # Batch rewiring occasionally for global improvement\n                            if it % self.batch_rewire_freq == 0:\n                                rewire_batch(start_tree)\n                                rewire_batch(goal_tree)\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n            # Occasionally batch rewire for global tree quality\n            if it > 0 and it % self.batch_rewire_freq == 0:\n                rewire_batch(start_tree)\n                rewire_batch(goal_tree)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur is not None:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_goal = []\n        cur = node_goal\n        while cur is not None:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -27.13468,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1399.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016662406921386718,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 161.76013706572985,
                    "smoothness_avg": 0.04759929459666155,
                    "success_improvement": 0.0,
                    "time_improvement": 35.394016149831984,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 11.336705620871545,
                    "smoothness_improvement": 645.0323239603604,
                    "objective_score": 20.645389837274323
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0229341983795166,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 235.63681484522058,
                    "smoothness_avg": 0.09687544838552706,
                    "success_improvement": 0.0,
                    "time_improvement": 86.14881346306589,
                    "node_improvement": 88.49694282066787,
                    "length_improvement": 21.33764877501207,
                    "smoothness_improvement": 2392.675063524693,
                    "objective_score": 50.610608621550476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06088290214538574,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 124.62617397516483,
                    "smoothness_avg": 0.09909509135315861,
                    "success_improvement": 0.0,
                    "time_improvement": -19.972976160105908,
                    "node_improvement": 70.59122695486333,
                    "length_improvement": 17.2292293063764,
                    "smoothness_improvement": 1160.4822475733902,
                    "objective_score": 10.14805597366102
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.77328,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1515.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An improved bidirectional RRT* planner integrating adaptive rewiring radius scaling and a probabilistic goal-biased informed sampling scheme, combined with frequent, iterative, and cautious shortcutting that preserves smoothness. This planner enhances path quality and smoothness by incorporating an adaptive neighbor radius based on the number of nodes and dimension, dynamically balancing exploration with goal bias, and applying incremental smoothing phases that limit abrupt path modifications. Tree connection attempts occur often to accelerate solution discovery. Meanwhile, rewiring drops parents only when a truly better cost is achievable, and cost updates propagate efficiently to maintain subtree consistency for smooth path refinement.",
          "planning_mechanism": "The planner grows two trees from start and goal, exploring with goal-biased, adaptive informed elliptical sampling that shrinks as better solutions are found. It steers with fixed steps and rewires within a dynamically scaled neighborhood radius calculated to maintain local path quality in accordance with dimensionality and tree size. The planner frequently attempts to connect the trees and propagates cost updates recursively on rewiring to ensure subtree cost consistency. After each successful connection, a multi-pass shortcutting method iteratively attempts valid shortcuts with limited aggressive node removal to enhance smoothness without causing sharp deviations. This approach optimizes both runtime and path quality robustly in complex environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b): return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            # Dimension-specific adaptive radius: r = min(r_max, max(r_min, gamma * (log n / n)^{1/d}))\n            # gamma empirically taken as 40\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            # goal biased informed sampling if solution found; else uniform with goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                # informed sampling inside ellipsoid aligned with start-goal\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    # degenerate\n                    return goal_pos\n\n                # Rotate samples to align ellipsoid with line between start and goal\n                # Build orthonormal basis\n                e1 = [x/length for x in a1]\n                # Generate orthogonal vectors with Gram-Schmidt\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    # Simple for 2D and 3D:\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        import math\n                        # Choose arbitrary\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            # fallback\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                # Compute ellipsoid axes\n                c_min = length\n                # safety margin to allow slightly larger sampling region for exploration\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                # Axes lengths (a): a1 = c_max/2, others scale by sqrt(c_max^2 - c_min^2)/2 or fallback\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    # sample in unit ball first\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1]]\n                        # rotate back to map coords\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        # 3D\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            # Euclidean distance nearest node\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            return [n for n in tree if ( (n.position[0]-p[0])**2 + (n.position[1]-p[1])**2 + ((n.position[2]-p[2])**2 if is_3d else 0.0)) <= r2]\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # start path reversed + goal path trimmed of start overlap\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=5, max_attempts_per_pass=200):\n            # cautious multi-pass shortcutting; avoid removing nodes that create sharp turns\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts +=1\n                        continue\n                    if is_free_edge(new_path[i], new_path[j]):\n                        # Check local smoothness before shortcut removal\n                        # compute turning angles if removing intermediate nodes between i and j\n                        prev_pt = new_path[i]\n                        next_pt = new_path[j]\n                        remove_indices = range(i+1, j)\n                        # crude smoothness check: angle at prev_pt and next_pt\n                        def angle(a,b,c):\n                            import math\n                            ab = [b[k]-a[k] for k in range(dim)]\n                            cb = [b[k]-c[k] for k in range(dim)]\n                            lab = math.sqrt(sum(x*x for x in ab))\n                            lcb = math.sqrt(sum(x*x for x in cb))\n                            if lab < 1e-8 or lcb < 1e-8:\n                                return 0\n                            dot = sum(ab[k]*cb[k] for k in range(dim))\n                            val = max(min(dot/(lab*lcb),1),-1)\n                            return math.acos(val)\n                        # For safety, check angle formed by prev_pt -> next_pt (expected to be ~0)\n                        # and angles before and after removing nodes\n                        if i>0:\n                            a = new_path[i-1]\n                            b = prev_pt\n                            c = next_pt\n                            a1 = angle(a,b,c)\n                            if a1 > math.pi*135/180: # >135 degrees sharp\n                                i+=1\n                                attempts+=1\n                                continue\n                        if j<len(new_path)-1:\n                            a = prev_pt\n                            b = next_pt\n                            c = new_path[j+1]\n                            a2 = angle(a,b,c)\n                            if a2 > math.pi*135/180:\n                                i+=1\n                                attempts+=1\n                                continue\n                        # Accept shortcut if angles okay:\n                        # Remove intermediate nodes:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        improved = True\n                        # Restart checking from start after change to propagate smoothing\n                        i = 0\n                        attempts +=1\n                        continue\n                    else:\n                        i+=1\n                        attempts+=1\n                if not improved:\n                    break\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate tree expansions for balance and exploration\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            # Compute adaptive neighbor radius for rewiring based on number of nodes in prop_tree\n            r = rewiring_radius(len(prop_tree))\n\n            near_nodes = near(prop_tree, new_pos, r)\n            # Choose parent minimizing cost + heuristic with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                # Use strict improvement only\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cost improves with new_node as parent\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old parent edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            # Attempt connection from new_node to other_tree for path joining\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            # After finding a solution, apply shortcutting iteratively every 80 iterations or at last iteration\n            if solution_nodes[0] and solution_nodes[1] and ( (it > 0 and it % 80 == 0) or it == self.max_iter-1 ):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n                if smoothed:\n                    return PlannerResult(True, smoothed, nodes, edges)\n\n        # Final return after max_iter or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n            return PlannerResult(True, smoothed, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.71512,
          "time_improvement": 54.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 465.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017966294288635255,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 163.95951929194274,
                    "smoothness_avg": 0.024923003054025138,
                    "success_improvement": 0.0,
                    "time_improvement": 30.338388437200997,
                    "node_improvement": 56.3082347015865,
                    "length_improvement": 10.131189371242641,
                    "smoothness_improvement": 290.09911896286457,
                    "objective_score": 16.630725748720206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03304464817047119,
                    "num_nodes_avg": 340.6,
                    "path_length_avg": 250.18134841864676,
                    "smoothness_avg": 0.025115402013338145,
                    "success_improvement": 0.0,
                    "time_improvement": 80.04257317904118,
                    "node_improvement": 77.11482899952965,
                    "length_improvement": 16.48226482701569,
                    "smoothness_improvement": 546.2373836960618,
                    "objective_score": 36.63331776840208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024051189422607422,
                    "num_nodes_avg": 287.7,
                    "path_length_avg": 129.7207213209384,
                    "smoothness_avg": 0.05176360916448404,
                    "success_improvement": 0.0,
                    "time_improvement": 52.60586020800652,
                    "node_improvement": 63.42021614748887,
                    "length_improvement": 13.84567353558893,
                    "smoothness_improvement": 558.4292877800516,
                    "objective_score": 26.88130862265557
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
          "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -26.27848,
          "time_improvement": 35.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.16492572596105,
          "time_improvement": 92.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003008270263671875,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 184.17006126805845,
                    "smoothness_avg": 0.01054995558932253,
                    "success_improvement": 0.0,
                    "time_improvement": 88.33588322571401,
                    "node_improvement": 82.85066733820196,
                    "length_improvement": -0.9465289423981464,
                    "smoothness_improvement": 65.12971456814059,
                    "objective_score": 26.25849617511602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008660387992858887,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 300.8164456420612,
                    "smoothness_avg": 0.0064472474436514295,
                    "success_improvement": 0.0,
                    "time_improvement": 94.76952943432936,
                    "node_improvement": 85.05005711214136,
                    "length_improvement": -0.4211880766230819,
                    "smoothness_improvement": 65.89232048978258,
                    "objective_score": 28.50760758677387
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0042524576187133786,
                    "num_nodes_avg": 126.3,
                    "path_length_avg": 160.72624335922288,
                    "smoothness_avg": 0.012431076585876402,
                    "success_improvement": 0.0,
                    "time_improvement": 91.62030753242554,
                    "node_improvement": 83.94151303242214,
                    "length_improvement": -6.746717877938324,
                    "smoothness_improvement": 58.122376605720596,
                    "objective_score": 23.72867341599327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -26.062040773062417,
          "time_improvement": 66.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 167.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012016057968139648,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 175.84673815929608,
                    "smoothness_avg": 0.016310939143948412,
                    "success_improvement": 0.0,
                    "time_improvement": 53.409537367863955,
                    "node_improvement": 66.1294384286074,
                    "length_improvement": 3.6156163450092893,
                    "smoothness_improvement": 155.30161737405683,
                    "objective_score": 18.96873910423504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018314409255981445,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 257.3377355314211,
                    "smoothness_avg": 0.010767991223558952,
                    "success_improvement": 0.0,
                    "time_improvement": 88.93895070058699,
                    "node_improvement": 83.00073909830007,
                    "length_improvement": 14.093256823589732,
                    "smoothness_improvement": 177.06817005275553,
                    "objective_score": 36.02298015459372
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022396659851074217,
                    "num_nodes_avg": 265.9,
                    "path_length_avg": 136.5245362961063,
                    "smoothness_avg": 0.0210441701583257,
                    "success_improvement": 0.0,
                    "time_improvement": 55.86619816574277,
                    "node_improvement": 66.19198982835347,
                    "length_improvement": 9.326903591935762,
                    "smoothness_improvement": 167.68029109483984,
                    "objective_score": 23.19440306035849
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an improved bidirectional Informed RRT* algorithm. It integrates elliptical informed sampling after an initial feasible path is found to concentrate search towards lower-cost solutions, adaptive rewiring radius based on tree cardinality and space dimension, and a gradient-based local smoothing post-processing to enhance path smoothness and length. The algorithm alternates tree expansions, rewires locally for cost improvements, attempts early tree connections, and continuously refines the path by restricting samples within the informed subset of the configuration space, improving planning efficiency, path quality, and convergence speed.",
          "planning_mechanism": "The algorithm starts growing two trees from start and goal positions using RRT* extensions. Initially, samples are uniform random with goal bias. Upon finding a first feasible path, the planner calculates an ellipsoidal informed sampling region tightly enclosing start and goal based on current best path cost, biasing new samples there. Nearby nodes are rewired using adaptive radius to improve costs. Early connection attempts between trees prune unnecessary expansions. After planning, a gradient-based smoothing is applied to the combined path to reduce sharp turns and shorten path length further, ensuring all nodes and edges respect collision constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.1, shortcut_iterations=120, smoothing_iters=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.0\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size * 1.5)\n\n        # Ellipse informed sampling helper\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoid centered between start and goal\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_best for i in range(dim))  # unit vector along start->goal\n\n            # Build orthonormal basis:\n            # Gram-Schmidt for higher dim (supporting 2D and 3D)\n            # We'll build transformation matrix with a1 as first column\n            import math as _math\n            # Create basis matrix Q = [a1, a2, a3,...]\n            orthonormal = [a1]\n            for i_dim in range(dim):\n                e = [0.0]*dim\n                e[i_dim] = 1.0\n                # Orthogonalize e wrt previous basis\n                for b in orthonormal:\n                    proj = sum(e[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        e[j] -= proj * b[j]\n                norm_e = math.sqrt(sum(v*v for v in e))\n                if norm_e > 1e-8:\n                    e = [v/norm_e for v in e]\n                    orthonormal.append(e)\n                if len(orthonormal) >= dim:\n                    break\n            Q = orthonormal[:dim]\n\n            # Radii of ellipse axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others]\n            elif dim == 3:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others, r_others]\n            else:\n                # For higher dim, fallback to bounding box sampling (should not occur here)\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Sample uniformly inside unit n-ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(px*px for px in x))\n                if norm_x > 1e-8:\n                    break\n            x_unit = [px/norm_x for px in x]\n            scale = random.uniform(0,1)**(1.0/dim)\n            x_scaled = [scale*v for v in x_unit]\n\n            # Map unit ball sample to ellipse point: center + Q * (radii * x_scaled)\n            sample = [center[i] + sum(Q[j][i]*radii[j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            # Clamp sample to map bounds\n            clamped = tuple(max(0.0, min(bounds[i], sample[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                return informed_sample(c_best)\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce length and sharp turns\n            # Random pairwise shortcutting with collision check\n            def check_shortcut(i,j):\n                return not is_edge_in_obstacle(path[i], path[j])\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if check_shortcut(i,j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def gradient_smooth_path(path, alpha=0.2, beta=0.4, iterations=40):\n            # Smooth path using gradient descent approach similar to path smoothing in PRM/RRT*\n            if len(path) < 3:\n                return path[:]\n            smoothed = [list(p) for p in path]\n            for _ in range(iterations):\n                for i in range(1,len(smoothed)-1):\n                    p = smoothed[i]\n                    p_old = p[:]\n                    # Smoothness term: pull point towards neighbors\n                    for d in range(dim):\n                        p[d] += alpha * (smoothed[i-1][d] + smoothed[i+1][d] - 2*p[d])\n                    # Data term: keeps it close to original vertex position\n                    for d in range(dim):\n                        p[d] += beta * (path[i][d] - p[d])\n\n                    # Clamp to bounds\n                    for d in range(dim):\n                        p[d] = max(0.0, min(bounds[d], p[d]))\n\n                    # Collision check for edges (i-1)-(i) and (i)-(i+1)\n                    prev_p = tuple(smoothed[i-1])\n                    nxt_p = tuple(smoothed[i+1])\n                    curr_p = tuple(p)\n                    if (is_in_obstacle(curr_p) or \n                        is_edge_in_obstacle(prev_p, curr_p) or \n                        is_edge_in_obstacle(curr_p, nxt_p)):\n                        # revert if invalid\n                        smoothed[i] = p_old\n                    else:\n                        smoothed[i] = p\n            return [tuple(p) for p in smoothed]\n\n        success = False\n        connection_pair = (None, None)\n        c_best = float('inf')\n        best_path_nodes = None\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point(c_best)\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connection with other tree within adaptive radius\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Build candidate path and update c_best if better\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    candidate_path_nodes = extract_path(node_start, node_goal)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path_nodes)-1):\n                        candidate_cost += dist(candidate_path_nodes[i], candidate_path_nodes[i+1])\n                    if candidate_cost < c_best:\n                        c_best = candidate_cost\n                        connection_pair = (node_start, node_goal)\n                        best_path_nodes = candidate_path_nodes\n                        success = True\n            if success and (it > 100 and it % 30 == 0):\n                # Early termination could be allowed if path cost is stable\n                break\n\n        path = []\n        if success and best_path_nodes:\n            # Post-processing: shortcut + gradient smoothing\n            path = shortcut_path(best_path_nodes)\n            path = gradient_smooth_path(path, iterations=self.smoothing_iters)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -24.91343,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04222602844238281,
                    "num_nodes_avg": 145.6,
                    "path_length_avg": 165.7015735704016,
                    "smoothness_avg": 0.03195078114288795,
                    "success_improvement": 0.0,
                    "time_improvement": -63.72509232767426,
                    "node_improvement": 63.33417275245531,
                    "length_improvement": 9.1763418166028,
                    "smoothness_improvement": 400.09910711794936,
                    "objective_score": -11.611227072750854
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934156894683838,
                    "num_nodes_avg": 346.2,
                    "path_length_avg": 234.8985415700393,
                    "smoothness_avg": 0.10549100772507927,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23952661781249,
                    "node_improvement": 76.7385607740375,
                    "length_improvement": 21.58410564428557,
                    "smoothness_improvement": 2614.3596108679344,
                    "objective_score": 48.89411942625476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02059016227722168,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 120.75685810991956,
                    "smoothness_avg": 0.12972022960082913,
                    "success_improvement": 0.0,
                    "time_improvement": 59.42599710311202,
                    "node_improvement": 67.60330578512396,
                    "length_improvement": 19.799044667050456,
                    "smoothness_improvement": 1550.031745571195,
                    "objective_score": 37.45738465901985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is an Informed Bidirectional RRT* (Informed Bi-RRT*) that grows two trees from start and goal positions. It integrates focused ellipsoidal sampling around the current best path for efficient exploration, combines asymptotically optimal rewiring for path improvement, and applies post-planning path shortcutting for smoothness enhancement. The approach balances fast convergence, robust path quality improvement, and smooth, shorter final paths by combining informed sampling, smart rewiring, and path shortcutting techniques.",
          "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal, using ellipsoidal informed sampling restricted to promising regions around the current shortest path cost. Each extension step rewires nearby nodes to improve path cost locally. Upon connecting trees, it extracts the path and applies iterative shortcutting to remove unnecessary waypoints and smooth rough turns. Early pruning of nodes and careful collision checks maintain robustness and computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=7000, step_size=7.0, radius_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor  # factor multiplied by step_size for rewiring radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        nodes = []\n\n        best_cost = float('inf')\n        best_path = []\n        connected = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def node_path_cost(node):\n            return node.cost\n\n        def is_collision_point(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_collision_edge(f, t):\n            d = dist(f, t)\n            steps = max(1, int(d / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(len(f)))\n                if is_collision_point(interp):\n                    return True\n            return False\n\n        def extract_path(node_start, node_goal):\n            path_from_start = []\n            n = node_start\n            while n:\n                path_from_start.append(n.position)\n                n = n.parent\n            path_from_goal = []\n            n = node_goal\n            while n:\n                path_from_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_from_start)) + path_from_goal\n\n        def radius():\n            # radius depends on dimension and step size, uses standard RRT* ball radius scaling with factor\n            dim = 3 if is_3d else 2\n            return max(self.step_size * self.radius_factor, self.step_size * (math.log(len(start_tree) + len(goal_tree) + 1) / (len(start_tree) + len(goal_tree) + 1)) ** (1/dim))\n\n        def near_nodes(tree, point, rad):\n            return [n for n in tree if dist(n.position, point) <= rad]\n\n        def informed_sample():\n            # If we have a path, sample inside ellipsoid defined by start, goal, and best_cost\n            if best_cost == float('inf'):\n                # no solution yet, sample uniformly in bounds\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_collision_point(p):\n                        return p\n            else:\n                # ellipsoidal sampling focused on the best path cost\n                c_min = dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    # Numerical safety: best_cost cannot be less than min dist (due to floating point)\n                    c_best = c_min\n                else:\n                    c_best = best_cost\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n\n                # Compute rotation matrix from standard basis to unit vector from start->goal\n                direction = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 0 else 0.0 for i in range(len(bounds)))\n                # For 2D or 3D, build a rotation matrix U aligning x axis to direction vector\n                # We'll do 2D and 3D separately to reduce complexity\n\n                def sample_unit_ball():\n                    # Uniformly sample a point in the unit ball in n-dim\n                    while True:\n                        sample = tuple(random.uniform(-1,1) for _ in range(len(bounds)))\n                        if sum(x*x for x in sample) <= 1:\n                            return sample\n\n                # Radii of ellipsoid axes (r1,...,rn)\n                r1 = c_best / 2.0\n                if is_3d:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    r3 = r2\n                    radii = (r1, r2, r3)\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    radii = (r1, r2)\n\n                # Sample point in unit ball\n                while True:\n                    unit_sample = sample_unit_ball()\n                    scaled = tuple(unit_sample[i]*radii[i] for i in range(len(bounds)))\n\n                    # Rotation matrix U aligns x-axis to direction vector\n                    # For 2D: construct 2D rotation matrix\n                    if not is_3d:\n                        ux, uy = direction[0], direction[1]\n                        rot_sample = (scaled[0]*ux - scaled[1]*uy, scaled[0]*uy + scaled[1]*ux)\n                    else:\n                        # For 3D, use Householder reflection or simple rotation by aligning vector\n                        # We'll approximate: let u = direction vector\n                        # Find orthonormal basis [u, v, w]\n                        # We'll do a simple alignment: assume u is normalized\n                        u = direction\n                        # arbitrary orthogonal vector to u\n                        if abs(u[0]) < 0.9:\n                            v = (1,0,0)\n                        else:\n                            v = (0,1,0)\n                        # make v orthonormal to u\n                        dot_uv = sum(u[i]*v[i] for i in range(3))\n                        v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                        v_len = math.sqrt(sum(x*x for x in v))\n                        if v_len > 0:\n                            v = tuple(x/v_len for x in v)\n                        else:\n                            # fallback orthogonal vector\n                            if abs(u[2]) < 0.9:\n                                v = (0,0,1)\n                            else:\n                                v = (1,0,0)\n                            dot_uv = sum(u[i]*v[i] for i in range(3))\n                            v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                            v_len = math.sqrt(sum(x*x for x in v))\n                            if v_len > 0:\n                                v = tuple(x/v_len for x in v)\n\n                        # w = u cross v\n                        w = (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n\n                        # scaled sample coords: [x,y,z]\n                        x, y, z = scaled\n                        rot_sample = (u[0]*x + v[0]*y + w[0]*z,\n                                      u[1]*x + v[1]*y + w[1]*z,\n                                      u[2]*x + v[2]*y + w[2]*z)\n\n                    point = tuple(center[i] + rot_sample[i] for i in range(len(bounds)))\n\n                    # Reject if out of bounds or in collision\n                    in_bounds = all(0 <= point[i] <= bounds[i] for i in range(len(bounds)))\n                    if in_bounds and not is_collision_point(point):\n                        return point\n\n        def try_extend(tree_from, tree_to):\n            nonlocal best_cost, best_path, connected\n            sample = informed_sample()\n            nearest = min(tree_from, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_collision_point(new_pos) or is_collision_edge(nearest.position, new_pos):\n                return False\n\n            # Create new node, find near nodes for rewiring\n            new_node = Node(new_pos)\n            near_rad = radius()\n            near = [n for n in tree_from if dist(n.position, new_pos) <= near_rad]\n\n            # Choose best parent minimizing cost\n            cost_min = nearest.cost + dist(nearest.position, new_pos)\n            parent_min = nearest\n            for p in near:\n                if not is_collision_edge(p.position, new_pos) and p.cost + dist(p.position, new_pos) < cost_min:\n                    cost_min = p.cost + dist(p.position, new_pos)\n                    parent_min = p\n            new_node.parent = parent_min\n            new_node.cost = cost_min\n            parent_min.add_child(new_node)\n            tree_from.append(new_node)\n\n            # Rewire near nodes if cheaper through new_node\n            for n in near:\n                if n is parent_min:\n                    continue\n                edge_cost = dist(new_node.position, n.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < n.cost and not is_collision_edge(new_node.position, n.position):\n                    # Change parent\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n\n            # Try to connect to other tree\n            nearest_other = min(tree_to, key=lambda node: dist(node.position, new_pos))\n            if dist(new_pos, nearest_other.position) <= self.step_size and not is_collision_edge(new_node.position, nearest_other.position):\n                # connection found, build path\n                connected = True\n                path = extract_path(new_node, nearest_other)\n                cost_path = 0.0\n                for i in range(len(path) - 1):\n                    cost_path += dist(path[i], path[i+1])\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    best_path = path\n                return True\n            return False\n\n        for i in range(self.max_iter):\n            if connected:\n                # Continue improving trees for better paths until iterations end\n                progressed = (try_extend(start_tree, goal_tree) or try_extend(goal_tree, start_tree))\n                if not progressed:\n                    break\n            else:\n                # Regular bidirectional grow\n                if try_extend(start_tree, goal_tree):\n                    connected = True\n                if not connected:\n                    try_extend(goal_tree, start_tree)\n\n        if not best_path:\n            # No path found\n            return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n        # Path shortcutting to smooth and shorten path\n        shortcut_path = self._shortcut_path(best_path, is_collision_point, is_collision_edge)\n\n        return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n    def _shortcut_path(self, path, is_collision_point, is_collision_edge, max_iter=150):\n        if len(path) <= 2:\n            return path[:]\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            # Try to shortcut between path[i] and path[j]\n            if not is_collision_edge(path[i], path[j]):\n                # Shortcut: remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
          "objective": -24.81658,
          "time_improvement": 30.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1375.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02101633548736572,
                    "num_nodes_avg": 109.5,
                    "path_length_avg": 172.32714291787394,
                    "smoothness_avg": 0.049746205597541,
                    "success_improvement": 0.0,
                    "time_improvement": 18.51231112692918,
                    "node_improvement": 72.4250818433644,
                    "length_improvement": 5.544762268388349,
                    "smoothness_improvement": 678.6361432159815,
                    "objective_score": 12.273731415191671
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017328310012817382,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 235.9789361832376,
                    "smoothness_avg": 0.0925726072219917,
                    "success_improvement": 0.0,
                    "time_improvement": 89.53450866755713,
                    "node_improvement": 88.21474165154875,
                    "length_improvement": 21.223438824965278,
                    "smoothness_improvement": 2281.9598611757096,
                    "objective_score": 51.00421520112486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05953328609466553,
                    "num_nodes_avg": 301.0,
                    "path_length_avg": 124.124788332228,
                    "smoothness_avg": 0.09950538690435078,
                    "success_improvement": 0.0,
                    "time_improvement": -17.313486408915992,
                    "node_improvement": 61.72917991099809,
                    "length_improvement": 17.562225776996367,
                    "smoothness_improvement": 1165.701176699687,
                    "objective_score": 11.171795427021458
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner employing simplified adaptive radius rewiring and refined elliptical informed sampling, combined with efficient collision checking and iterative cautious shortcutting to improve path length and smoothness while maintaining fast convergence and robustness. The planner symmetrically grows trees from start and goal, samples within an informed ellipsoid adapting to the best found path, selects parents minimizing cost with collision-free edges, and performs local rewiring. Periodic cautious shortcutting is applied to enhance smoothness without sharp deviations, balancing exploration and exploitation efficiently.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal alternately, samples points using goal-biased uniform sampling or elliptical informed sampling based on current best cost. It extends trees toward samples with fixed step size, selects optimal parents within an adaptive neighborhood radius, and rewires nearby nodes if cost improves without collision. Trees attempt connection each iteration within step size. Upon connection, the path is extracted and improved via cautious multi-pass shortcutting that avoids sharp turns, outputting a collision-free, smoother, shorter path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, r_min=5.0, r_max=25.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def node_collision(p):\n            px, py = p[0], p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            dist_val = dist(a, b)\n            steps = max(1, int(dist_val / resolution))\n            for s in range(steps + 1):\n                t = s / steps\n                interp = tuple(a[i] + t * (b[i] - a[i]) for i in range(dim))\n                if node_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 35.0\n            val = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample(best_cost):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n            # informed ellipse sampling\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                foci_dist = c_min\n                val = c_best * c_best - foci_dist * foci_dist\n                r1 = c_best / 2.0\n                r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-8:\n                            u = [x / norm for x in vec]\n                            r = random.random() ** (1.0 / dim)\n                            return [u[i] * r for i in range(dim)]\n\n                while True:\n                    u_sample = unit_ball_sample()\n                    sample_pt = [0.0] * dim\n                    sample_pt[0] = u_sample[0] * r1\n                    for i in range(1, dim):\n                        sample_pt[i] = u_sample[i] * r_rest\n                    pt = tuple(center[i] + sample_pt[i] for i in range(dim))\n                    if in_bounds(pt) and not node_collision(pt):\n                        return pt\n            else:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_node = n\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def update_costs(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-14 < child.cost:\n                    child.cost = new_cost\n                    update_costs(child)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=4, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path) - 2 and attempts < max_attempts:\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    if edge_collision(new_path[i], new_path[j]):\n                        i += 1\n                        attempts += 1\n                        continue\n                    # Check turning angles to avoid sharp bends\n                    def angle(a, b, c):\n                        import math\n                        ab = [b[d] - a[d] for d in range(dim)]\n                        cb = [b[d] - c[d] for d in range(dim)]\n                        lab = math.sqrt(sum(x * x for x in ab))\n                        lcb = math.sqrt(sum(x * x for x in cb))\n                        if lab < 1e-8 or lcb < 1e-8:\n                            return 0\n                        dot = sum(ab[d] * cb[d] for d in range(dim))\n                        val = max(min(dot / (lab * lcb), 1.0), -1.0)\n                        return math.acos(val)\n\n                    cond = True\n                    if i > 0:\n                        a, b, c = new_path[i - 1], new_path[i], new_path[j]\n                        if angle(a, b, c) > 3 * math.pi / 4:  # >135 degrees\n                            cond = False\n                    if cond and j < len(new_path) - 1:\n                        a, b, c = new_path[i], new_path[j], new_path[j + 1]\n                        if angle(a, b, c) > 3 * math.pi / 4:\n                            cond = False\n                    if cond:\n                        new_path = new_path[:i + 1] + new_path[j:]\n                        improved = True\n                        i = 0\n                        attempts += 1\n                    else:\n                        i += 1\n                        attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        for it in range(self.max_iter):\n            pt = sample(best_cost)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, pt)\n            new_pos = steer(nearest_node.position, pt)\n\n            if not in_bounds(new_pos):\n                continue\n            if node_collision(new_pos):\n                continue\n            if edge_collision(nearest_node.position, new_pos):\n                continue\n\n            r = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for cand in near_nodes:\n                if cand is nearest_node:\n                    continue\n                cost_cand = cand.cost + dist(cand.position, new_pos)\n                if cost_cand + 1e-14 < min_cost and not edge_collision(cand.position, new_pos):\n                    min_cost = cost_cand\n                    min_parent = cand\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent or near_node is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-14 < near_node.cost and not edge_collision(new_node.position, near_node.position):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    update_costs(near_node)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_con = dist(nearest_other.position, new_node.position)\n            if dist_con <= self.step_size and not edge_collision(nearest_other.position, new_node.position):\n                total_cost = new_node.cost + dist_con + nearest_other.cost\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        solution_nodes = (new_node, nearest_other)\n                    else:\n                        solution_nodes = (nearest_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and (it % 60 == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n                if short_path:\n                    return PlannerResult(True, short_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n            return PlannerResult(True, short_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.49867,
          "time_improvement": 49.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 442.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022717666625976563,
                    "num_nodes_avg": 183.8,
                    "path_length_avg": 169.35702476940347,
                    "smoothness_avg": 0.023703810745518868,
                    "success_improvement": 0.0,
                    "time_improvement": 11.91565479849687,
                    "node_improvement": 53.714429614706624,
                    "length_improvement": 7.172731090098877,
                    "smoothness_improvement": 271.0161118162685,
                    "objective_score": 9.233415652689729
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032560324668884276,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 255.25648444467683,
                    "smoothness_avg": 0.02286526971496877,
                    "success_improvement": 0.0,
                    "time_improvement": 80.33508199289592,
                    "node_improvement": 80.58187193442183,
                    "length_improvement": 14.788038341835955,
                    "smoothness_improvement": 488.33985895423257,
                    "objective_score": 35.41504689774151
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0229816198348999,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 126.47150951572493,
                    "smoothness_avg": 0.05237959417986045,
                    "success_improvement": 0.0,
                    "time_improvement": 54.71350360419659,
                    "node_improvement": 71.13795295613478,
                    "length_improvement": 16.003645305772068,
                    "smoothness_improvement": 566.2645717083553,
                    "objective_score": 28.847561123263993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A Dual-Tree Probabilistic Roadmap with Incremental Local Optimization (DTPRM-ILO). This algorithm grows two random graphs rooted at start and goal using probabilistic roadmap sampling with connection radius adapting to graph size. Each new node connection and rewiring consider both collision-free edges and cost improvement. Periodically, incremental local path optimization via shortcutting and curvature smoothing refines candidate connection paths proactively. This approach balances exploration and exploitation, enhances robustness and path quality, reduces computation by efficient local updates and dynamic pruning of suboptimal branches. It terminates once a valid connection is found and sufficiently smooth path is obtained or on iteration limit.",
          "planning_mechanism": "The planner creates two expanding probabilistic roadmaps (graphs) grown from start and goal by sampling random collision-free nodes in the map. New nodes attempt connection to nearby nodes within a dynamically computed radius, favoring connections improving path cost while maintaining collision-free edges. Rewiring propagates cost improvements through the graphs. In each iteration, the planner attempts to connect the graphs by checking for collision-free edges between nodes from opposing graphs. Upon successful connection, the combined path is extracted and incrementally optimized using incremental shortcutting and curvature-limited smoothing. The process repeats until a smooth, low-cost path is found or maximum iterations are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, node):\n        self.children.append(node)\n\n    def remove_child(self, node):\n        if node in self.children:\n            self.children.remove(node)\nclass Planner:\n    def __init__(self, max_iter=5000, r_min=3.0, r_max=15.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_graph = [Node(start_pos)]\n        goal_graph = [Node(goal_pos)]\n        nodes_all = start_graph + goal_graph\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_node():\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def near_nodes(graph, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in graph:\n                dx = n.position[0] - point[0]\n                dy = n.position[1] - point[1]\n                dz = n.position[2] - point[2] if is_3d else 0.0\n                if dx * dx + dy * dy + dz * dz <= r2:\n                    result.append(n)\n            return result\n\n        def connection_radius(n_nodes):\n            # Adaptive radius using log-factor and graph size\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 15.0\n            return max(self.r_min, min(self.r_max, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))))\n\n        def is_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        def reconstruct_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a, b, c):\n            import math\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-9 or lcb < 1e-9:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if is_free_edge(path[i], path[j]):\n                        # Preserve curvature: only if angle does not increase beyond threshold\n                        if i > 0 and j < len(path) - 1:\n                            ang_before = angle_between(path[i-1], path[i], path[i+1]) if i+1 < len(path) else 0.0\n                            ang_after = angle_between(path[i-1], path[j], path[j+1]) if (j+1) < len(path) else 0.0\n                            if ang_after < ang_before + 0.2:\n                                break\n                            else:\n                                j -= 1\n                        else:\n                            break\n                    else:\n                        j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path)-1):\n                a = new_path[i-1]\n                b = new_path[i]\n                c = new_path[i+1]\n                midpoint = tuple((a[j] + c[j]) * 0.5 for j in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    is_free_edge(a, midpoint) and is_free_edge(midpoint, c)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-3:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def update_subtree_costs(node):\n            for child in node.children:\n                prev_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-15 < prev_cost:\n                    child.cost = new_cost\n                    update_subtree_costs(child)\n\n        def rewire(graph, new_node, radius):\n            near = near_nodes(graph, new_node.position, radius)\n            for neighbor in near:\n                if neighbor is new_node.parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-15 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        if neighbor.parent is not None:\n                            neighbor.parent.remove_child(neighbor)\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n                        update_subtree_costs(neighbor)\n\n        best_solution = None\n        best_cost = float('inf')\n        best_nodes = None\n\n        for it in range(self.max_iter):\n            sample_pt = sample_node()\n            for graph_roots, other_graph_roots in [(start_graph, goal_graph),(goal_graph, start_graph)]:\n                radius = connection_radius(len(graph_roots))\n                # Find nearest node for attempt connection\n                nearest_node = None\n                min_dist = float('inf')\n                for n in graph_roots:\n                    d = dist(n.position, sample_pt)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n                if nearest_node is None:\n                    continue\n                direction_dist = min_dist\n                # New node position is sample_pt itself, no steering to keep probabilistic roadmap nature\n                new_pos = sample_pt\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if not is_free_edge(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                graph_roots.append(new_node)\n                nodes_all.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(graph_roots, new_node, radius)\n\n                # Attempt to connect new_node with other_graph nodes\n                radius_other = connection_radius(len(other_graph_roots))\n                near_others = near_nodes(other_graph_roots, new_node.position, radius_other)\n                for other_node in near_others:\n                    if is_free_edge(new_node.position, other_node.position):\n                        total_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                        if total_cost + 1e-15 < best_cost:\n                            best_cost = total_cost\n                            best_solution = (new_node, other_node)\n                            best_nodes = (start_graph, goal_graph) if start_graph is graph_roots else (goal_graph, start_graph)\n\n            # If a solution exists, extract and optimize path\n            if best_solution is not None and it % 50 == 0:\n                n1, n2 = best_solution\n                path = reconstruct_path(n1, n2)\n                if len(path) >= 3:\n                    path = incremental_shortcut(path)\n                    path = smooth_path(path)\n                if path:\n                    return PlannerResult(True, path, nodes_all, edges)\n\n        # If ended without intermediate return but solution found, extract and optimize\n        if best_solution is not None:\n            n1, n2 = best_solution\n            path = reconstruct_path(n1, n2)\n            if len(path) >= 3:\n                path = incremental_shortcut(path)\n                path = smooth_path(path)\n            return PlannerResult(True, path, nodes_all, edges)\n\n        # Else planning failed\n        return PlannerResult(False, [], nodes_all, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.79526,
          "time_improvement": 63.0,
          "length_improvement": -8.0,
          "smoothness_improvement": 1886.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023380041122436523,
                    "num_nodes_avg": 178.6,
                    "path_length_avg": 204.66609096189143,
                    "smoothness_avg": 0.08196450351646048,
                    "success_improvement": 0.0,
                    "time_improvement": 9.347397029799074,
                    "node_improvement": 55.02392344497608,
                    "length_improvement": -12.180727597962154,
                    "smoothness_improvement": 1182.9224688008014,
                    "objective_score": 1.4103948941664388
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007231664657592773,
                    "num_nodes_avg": 114.9,
                    "path_length_avg": 276.5380841464404,
                    "smoothness_avg": 0.11558975370987438,
                    "success_improvement": 0.0,
                    "time_improvement": 95.63241171601906,
                    "node_improvement": 92.27978230195525,
                    "length_improvement": 7.683627804504005,
                    "smoothness_improvement": 2874.207618889435,
                    "objective_score": 47.670938291955295
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0076017618179321286,
                    "num_nodes_avg": 132.6,
                    "path_length_avg": 178.70626179196276,
                    "smoothness_avg": 0.1338258146720928,
                    "success_improvement": 0.0,
                    "time_improvement": 85.02032660697179,
                    "node_improvement": 83.14049586776859,
                    "length_improvement": -18.68819000449183,
                    "smoothness_improvement": 1602.2544846349017,
                    "objective_score": 22.30445640257095
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
          "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.21547,
          "time_improvement": 21.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1469.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025556087493896484,
                    "num_nodes_avg": 151.3,
                    "path_length_avg": 173.88763401105183,
                    "smoothness_avg": 0.047474639256938476,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9101035826373128,
                    "node_improvement": 61.89876605389071,
                    "length_improvement": 4.689432372653788,
                    "smoothness_improvement": 643.0811972002915,
                    "objective_score": 6.302096484384924
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031405282020568845,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 230.86304004149935,
                    "smoothness_avg": 0.09581397875517297,
                    "success_improvement": 0.0,
                    "time_improvement": 81.03267389975849,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 22.93127220998329,
                    "smoothness_improvement": 2365.362685390011,
                    "objective_score": 49.89537892286758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06047847270965576,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 119.93973012619429,
                    "smoothness_avg": 0.11787316210161418,
                    "success_improvement": 0.0,
                    "time_improvement": -19.176026584091733,
                    "node_improvement": 59.6694214876033,
                    "length_improvement": 20.341742166387515,
                    "smoothness_improvement": 1399.337921440741,
                    "objective_score": 13.448926931808694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive goal biasing, efficient nearest neighbor queries via dynamic grid hashing, curvature-guided cost evaluation, and iterative path improvement through constrained shortcutting. The planner grows two trees from start and goal simultaneously, leveraging curvature penalties to encourage smooth trajectories, and adapts neighbor radius dynamically by iteration count and problem dimension. It automatically updates the best path using shortcutting upon connecting the trees, balancing exploration and path quality to improve time efficiency, smoothness, and path length.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the goal vicinity and around the current best solution cost, uses spatial hashing for fast near node queries, combines path length and curvature penalties in cost calculations, performs local rewiring to optimize the tree, attempts to connect the trees frequently, and shortcuts the path iteratively to remove unnecessary nodes. Early stopping occurs upon finding a valid path with stable cost within iteration limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.2, base_radius=18.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.35):\n            length = math.dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.5\n        def grid_hash(p):\n            return tuple(int(coord/GRID_SIZE) for coord in p)\n\n        # spatial hash tables for start and goal trees\n        start_hash = {}\n        goal_hash = {}\n\n        def add_to_hash(hash_table, node):\n            h = grid_hash(node.position)\n            if h not in hash_table:\n                hash_table[h] = []\n            hash_table[h].append(node)\n\n        def nearby_nodes(hash_table, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hash_table:\n                    for node in hash_table[cell]:\n                        sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                        if sq <= radius_sq:\n                            candidates.append(node)\n            return candidates\n\n        def nearest(hash_table, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # search up to 2 grid expansions\n            for radius_cells in range(2):\n                candidates = []\n                if dim == 2:\n                    neighbors = [(gh[0]+dx, gh[1]+dy) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1)]\n                else:\n                    neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1) for dz in range(-radius_cells,radius_cells+1)]\n                for cell in neighbors:\n                    if cell in hash_table:\n                        candidates.extend(hash_table[cell])\n                for node in candidates:\n                    d = math.dist(node.position,p)\n                    if d < min_dist:\n                        min_dist = d\n                        min_node = node\n                if min_node is not None:\n                    break\n            if min_node is not None:\n                return min_node\n            # fallback linear search\n            all_nodes = []\n            for cell_nodes in hash_table.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n            v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n            len1 = math.sqrt(sum(c*c for c in v1))\n            len2 = math.sqrt(sum(c*c for c in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0,min(1.0,dot/(len1*len2)))\n            penalty = (1.0 - cos_ang) * 0.8\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear + pen\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = math.log(n_nodes) / n_nodes\n            r = self.base_radius * (val ** (1/dim))\n            return max(r, self.step_size * 1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position) + curvature_penalty(node, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-8 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 4 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = best_cost\n                c_best = max(c_best, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best / 2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x/norm for x in vec]\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0]*r1\n                    for i in range(1,dim):\n                        pt[i] = u[i]*r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            # uniform or if no good best_cost\n            for _ in range(50):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            # fallback uniform sample\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = path_cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = path_cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=130)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.15046,
          "time_improvement": 20.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1485.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03597238063812256,
                    "num_nodes_avg": 158.4,
                    "path_length_avg": 165.33660473594648,
                    "smoothness_avg": 0.040225506903328115,
                    "success_improvement": 0.0,
                    "time_improvement": -39.477510873634735,
                    "node_improvement": 60.11080332409973,
                    "length_improvement": 9.37638701806892,
                    "smoothness_improvement": 529.6165341234281,
                    "objective_score": -3.5693383806319274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0495330810546875,
                    "num_nodes_avg": 425.8,
                    "path_length_avg": 233.70047331301612,
                    "smoothness_avg": 0.09995486345747011,
                    "success_improvement": 0.0,
                    "time_improvement": 70.08432847383375,
                    "node_improvement": 71.39017671168448,
                    "length_improvement": 21.984055312962646,
                    "smoothness_improvement": 2471.9106313388115,
                    "objective_score": 46.57528488662177
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035744976997375486,
                    "num_nodes_avg": 384.8,
                    "path_length_avg": 124.71065505040485,
                    "smoothness_avg": 0.1222140100479562,
                    "success_improvement": 0.0,
                    "time_improvement": 29.562633809586238,
                    "node_improvement": 51.074380165289256,
                    "length_improvement": 17.173120998758485,
                    "smoothness_improvement": 1454.5531869101455,
                    "objective_score": 26.445428676681686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner employing a hybrid sampling technique that blends uniform, goal biasing, and adaptive ellipsoidal informed sampling; it uses an efficient k-d tree for nearest and near neighbor queries to reduce planning overhead. The rewiring radius and connection threshold adapt dynamically based on tree size and current best cost to balance exploration and exploitation. The planner incrementally applies shortcutting after path improvements along with periodic global smoothing to enhance path smoothness and shorten path length. The simultaneous expansion and frequent tree connection attempts accelerate convergence and improve path quality while collision checks ensure solution validity.",
          "planning_mechanism": "A bidirectional RRT* expands start and goal trees alternately. Sampling combines uniform, goal biasing, and adaptive ellipsoid informed sampling shrinking as better paths are found. Efficient nearest neighbor queries enable adaptive rewiring and connection attempts improving connectivity and cost. After each improved connection, incremental shortcutting and occasional global smoothing reduce path length and smoothness. Early stopping upon reaching stable quality reduces runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, r_min=4.0, r_max=30.0,\n                 goal_sample_rate=0.1, shortcut_attempts=100, smooth_interval=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_interval = smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n        import bisect\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Node lists and edges\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        iterations_since_improve = 0\n\n        # KD-tree implementation for fast nearest neighbor search\n        # Using list sorting as approximation given constraints\n        class KDTree:\n            def __init__(self, points=None):\n                self.points = points or []\n                self.sorted_indices = list(range(len(self.points)))\n                self.dim = dim\n                self._sort_all()\n\n            def _sort_all(self):\n                # Sort points along each dimension for heuristic near search\n                self.sorted_coords = []\n                for d in range(self.dim):\n                    indexed = sorted(((p.position[d], idx) for idx,p in enumerate(self.points)),\n                                     key=lambda x:x[0])\n                    self.sorted_coords.append(indexed)\n\n            def insert(self, node):\n                self.points.append(node)\n                idx = len(self.points)-1\n                for d in range(self.dim):\n                    coord = node.position[d]\n                    arr = self.sorted_coords[d]\n                    insert_pos = bisect.bisect_left([x[0] for x in arr], coord)\n                    arr.insert(insert_pos,(coord, idx))\n\n            def nearest(self, pt):\n                # Approximate nearest by checking each dimension sorted coord lists\n                best_node = None\n                best_dist = float('inf')\n                for node in self.points:\n                    d = math.dist(node.position, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, pt, radius):\n                r_sq = radius * radius\n                result = []\n                for node in self.points:\n                    d_sq = 0\n                    for i in range(dim):\n                        d_sq += (node.position[i] - pt[i])**2\n                        if d_sq > r_sq:\n                            break\n                    if d_sq <= r_sq:\n                        result.append(node)\n                return result\n\n        start_kdtree = KDTree(start_tree)\n        goal_kdtree = KDTree(goal_tree)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.4):\n            length = dist(a,b)\n            steps = max(1, int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def sample(current_iter):\n            # Hybrid sampling: goal bias + informed ellipsoid + uniform\n            p_goal_sample = self.goal_sample_rate\n            if best_cost < float('inf'):\n                # Ellipsoidal informed sampling\n                c_min = dist(start_pos, goal_pos)\n                c_best = max(best_cost, c_min + 1e-9)\n                center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n                a_len = c_best / 2\n                val = max(c_best*c_best - c_min*c_min, 0)\n                b_len = math.sqrt(val) / 2\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x / norm for x in vec]\n\n                # Construct orthonormal basis\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length_a1 = math.sqrt(sum(x*x for x in a1))\n                if length_a1 < 1e-15:\n                    basis = [[1 if i==j else 0 for i in range(dim)] for j in range(dim)]\n                else:\n                    e1 = [x / length_a1 for x in a1]\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append([-e1[1], e1[0]])\n                    else:\n                        # Gram Schmidt for 3D\n                        v = [1,0,0] if abs(e1[0]) < 0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(dim)) for i in range(dim)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0]*dim\n                            u[-1] = 1.0\n                            u_norm = 1.0\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2]-e1[2]*u[1],\n                             e1[2]*u[0]-e1[0]*u[2],\n                             e1[0]*u[1]-e1[1]*u[0]]\n                        basis.append(u)\n                        basis.append(w)\n\n                # Decide sampling mode by iteration and goal bias\n                choose_uniform = False\n                if random.random() < p_goal_sample:\n                    return goal_pos\n                if current_iter % 5 == 0:\n                    choose_uniform = True\n\n                if choose_uniform or best_cost == float('inf'):\n                    for _ in range(50):\n                        p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                        if not collision_node(p):\n                            return p\n\n                # Sample inside ellipsoid\n                for _ in range(25):\n                    u = unit_ball_sample()\n                    pt = [0]*dim\n                    if dim == 2:\n                        pt[0] = u[0]*a_len\n                        pt[1] = u[1]*b_len\n                    else:\n                        pt[0] = u[0]*a_len\n                        pt[1] = u[1]*b_len\n                        pt[2] = u[2]*b_len\n                    sample_p = [center[i] + sum(pt[j]*basis[j][i] for j in range(dim)) for i in range(dim)]\n                    sample_t = tuple(sample_p)\n                    if in_bounds(sample_t) and not collision_node(sample_t):\n                        return sample_t\n\n                # Fallback uniform\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # Before any solution: uniform or goal bias\n                if random.random() < p_goal_sample:\n                    return goal_pos\n                for _ in range(50):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i + 1:j]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path, passes=3):\n            # Basic global smoothing via shortcut attempts over multiple passes\n            smooth_path = path[:]\n            for _ in range(passes):\n                smooth_path = incremental_shortcut(smooth_path)\n            return smooth_path\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            val = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            return max(self.r_min, min(self.r_max, val))\n\n        def connect_trees(node_a, node_b):\n            return extract_path(node_a, node_b)\n\n        for it in range(1, self.max_iter + 1):\n            sample_pos = sample(it)\n\n            # Alternate tree expansion\n            if it % 2 == 1:\n                expand_tree, expand_kd, other_tree, other_kd = start_tree, start_kdtree, goal_tree, goal_kdtree\n            else:\n                expand_tree, expand_kd, other_tree, other_kd = goal_tree, goal_kdtree, start_tree, start_kdtree\n\n            nearest_node = expand_kd.nearest(sample_pos)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(expand_tree))\n            near_nodes = expand_kd.near(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                if n is nearest_node:\n                    continue\n                tentative = n.cost + dist(n.position, new_pos)\n                if tentative < min_cost and not collision_edge(n.position, new_pos):\n                    min_cost = tentative\n                    best_parent = n\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            expand_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            expand_kd.insert(new_node)\n\n            # Rewire neighbors to new_node if improves cost\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not collision_edge(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect to other tree\n            nearest_other = other_kd.nearest(new_pos)\n            if nearest_other is not None:\n                dist_conn = dist(new_pos, nearest_other.position)\n                conn_radius = max(self.step_size*1.2, r)\n                if dist_conn <= conn_radius and not collision_edge(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        if it % 2 == 1:\n                            solution_nodes = (new_node, nearest_other)\n                        else:\n                            solution_nodes = (nearest_other, new_node)\n\n                        raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n                        improved_path = incremental_shortcut(raw_path)\n                        if it % self.smooth_interval == 0:\n                            improved_path = global_smooth(improved_path)\n\n                        # Early stopping on stable near-optimal path\n                        if best_cost < float('inf') and len(improved_path) >= 2:\n                            return PlannerResult(True, improved_path, nodes, edges)\n                        iterations_since_improve = 0\n            else:\n                iterations_since_improve += 1\n                if iterations_since_improve > self.smooth_interval:\n                    iterations_since_improve = 0\n                    # perform global smoothing on last best path to improve quality if stuck\n                    if best_cost < float('inf') and solution_nodes[0] and solution_nodes[1]:\n                        raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n                        improved_path = global_smooth(raw_path)\n                        if len(improved_path) >= 2:\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = connect_trees(solution_nodes[0], solution_nodes[1])\n            final_path = global_smooth(incremental_shortcut(raw_path))\n            return PlannerResult(True, final_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -22.74261,
          "time_improvement": 19.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1711.0,
          "node_improvement": 71.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04078545570373535,
                    "num_nodes_avg": 147.9,
                    "path_length_avg": 166.4464658584535,
                    "smoothness_avg": 0.05400458778946319,
                    "success_improvement": 0.0,
                    "time_improvement": -58.13948758718552,
                    "node_improvement": 62.75497355829766,
                    "length_improvement": 8.768054549947896,
                    "smoothness_improvement": 745.2890717445006,
                    "objective_score": -8.454568187464416
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050977444648742674,
                    "num_nodes_avg": 322.0,
                    "path_length_avg": 242.74383553946228,
                    "smoothness_avg": 0.11769675882875945,
                    "success_improvement": 0.0,
                    "time_improvement": 69.21200020504703,
                    "node_improvement": 78.3645770342001,
                    "length_improvement": 18.96512070302588,
                    "smoothness_improvement": 2928.4223782127924,
                    "objective_score": 46.784784374393595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028009629249572753,
                    "num_nodes_avg": 226.8,
                    "path_length_avg": 127.57406637885784,
                    "smoothness_avg": 0.12253400941393153,
                    "success_improvement": 0.0,
                    "time_improvement": 44.80554533704865,
                    "node_improvement": 71.16338207247298,
                    "length_improvement": 15.27137953539513,
                    "smoothness_improvement": 1458.6235552254554,
                    "objective_score": 29.89760909847895
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.60434,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021024632453918456,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 179.86562069368742,
                    "smoothness_avg": 0.04340391432894737,
                    "success_improvement": 0.0,
                    "time_improvement": 18.480140883479937,
                    "node_improvement": 62.37723495341224,
                    "length_improvement": 1.41280314464036,
                    "smoothness_improvement": 579.365512356565,
                    "objective_score": 9.288551713611021
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02810840606689453,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.75216437677005,
                    "smoothness_avg": 0.0991357257905606,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02383326220045,
                    "node_improvement": 81.69723845998791,
                    "length_improvement": 17.960853947188074,
                    "smoothness_improvement": 2450.8336291682162,
                    "objective_score": 47.93783049281406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0594691276550293,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 129.64938979692397,
                    "smoothness_avg": 0.1243235500601021,
                    "success_improvement": 0.0,
                    "time_improvement": -17.187058813027633,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 13.893048537397146,
                    "smoothness_improvement": 1481.3863801545947,
                    "objective_score": 10.586643379302972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization by combining uniform goal-biased sampling with a fixed rewiring radius, efficient nearest neighbor searches, and straightforward path shortcutting. It grows start and goal trees alternately, rewires local neighborhoods to reduce path cost, connects trees upon proximity, and refines solutions with repeated shortcutting for improved path length and smoothness.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal using goal-biased sampling to encourage progress toward the goal, connects new nodes to the lowest-cost nearby parent within a fixed radius, and rewires neighbors to optimize local costs. It attempts connections between the two trees whenever new nodes appear close enough. On successful connection, the combined path is shortcut multiple times with collision checking to enhance smoothness and reduce length before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        best_path = []\n        success = False\n\n        def dist(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim)) ** 0.5\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            if is_3d:\n                px, py, pz = p\n                for obs in obstacles:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                px, py = p\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                diff_sq = sum((node.position[i] - p[i]) ** 2 for i in range(dim))\n                if diff_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=60):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i + 1:j]\n                attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = goal if random.random() < self.goal_sample_rate else None\n            if sample is None:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        break\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[iteration % 2]\n\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos):\n                continue\n            if collision_edge(nearest_node.position, new_pos):\n                continue\n\n            near_nodes = near(active_tree, new_pos, self.radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost = near_node.cost + dist(near_node.position, new_pos)\n                if cost < min_cost and not collision_edge(near_node.position, new_pos):\n                    min_cost = cost\n                    min_parent = near_node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not collision_edge(new_node.position, near_node.position):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            connect_node = nearest(other_tree, new_node.position)\n            dist_connect = dist(connect_node.position, new_node.position)\n            if dist_connect <= self.step_size and not collision_edge(connect_node.position, new_node.position):\n                # Extract and shortcut combined path\n                path = extract_path(new_node, connect_node)\n                shortcut = shortcut_path(path, max_attempts=100)\n                success = True\n                best_path = shortcut\n                break\n\n        if success:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        else:\n            return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -21.8498,
          "time_improvement": 19.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1418.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030353832244873046,
                    "num_nodes_avg": 128.9,
                    "path_length_avg": 169.60823786198122,
                    "smoothness_avg": 0.03531683911755182,
                    "success_improvement": 0.0,
                    "time_improvement": -17.69243213511502,
                    "node_improvement": 67.53966255351298,
                    "length_improvement": 7.035037213330819,
                    "smoothness_improvement": 452.7852239333236,
                    "objective_score": 1.1772188071306036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07687301635742187,
                    "num_nodes_avg": 293.1,
                    "path_length_avg": 233.5661530357017,
                    "smoothness_avg": 0.09866136858535729,
                    "success_improvement": 0.0,
                    "time_improvement": 53.57228224839836,
                    "node_improvement": 80.3063898407579,
                    "length_improvement": 22.028895287725014,
                    "smoothness_improvement": 2438.6280766126506,
                    "objective_score": 41.48216223021777
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03946213722229004,
                    "num_nodes_avg": 201.3,
                    "path_length_avg": 126.97503818424491,
                    "smoothness_avg": 0.1150503234947852,
                    "success_improvement": 0.0,
                    "time_improvement": 22.237773145387973,
                    "node_improvement": 74.40559440559441,
                    "length_improvement": 15.66922553959969,
                    "smoothness_improvement": 1363.4316227221486,
                    "objective_score": 22.89002538098695
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A novel Bidirectional Anytime Informed RRT* (BAI-RRT*) leveraging adaptive neighborhood rewiring, dynamic goal-biased ellipsoidal informed sampling, and continuous incremental path smoothing. It maintains dual trees from start and goal, with enhanced rewiring rules ensuring subtree cost consistency. The planner applies immediate shortcutting and curvature-limited smoothing during planning to produce efficiently optimized, smooth, and short collision-free paths with faster convergence and higher robustness.",
          "planning_mechanism": "The planner grows two trees simultaneously with alternated expansions, sampling nodes either uniformly or informed by the current best solution cost using an ellipsoid surrounding start and goal. Adaptive radius for rewiring scales with tree size and problem dimensionality improving local connectivity. Rewiring updates propagate cost changes to child nodes efficiently. Continuous lightweight shortcutting and curvature-limited smoothing are applied each iteration to refine the solution path incrementally and avoid sharp angles. The algorithm terminates early once a sufficiently smooth and short path is found or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, node):\n        self.children.append(node)\n\n    def remove_child(self, node):\n        if node in self.children:\n            self.children.remove(node)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.5, r_min=4.0, r_max=28.0, goal_sample_rate=0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n):\n            if n < 2:\n                return self.r_max\n            gamma = 40.0\n            return max(self.r_min, min(self.r_max, gamma * (math.log(n) / n) ** (1 / dim)))\n\n        def sample():\n            # Goal biased + ellipsoidal informed sampling after a solution is found\n            if best_cost == float('inf'):\n                # Uniform random with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                # Informed ellipsoid sampling\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                c_min = dist(start_pos, goal_pos)\n                c_max = min(best_cost * 1.03, sum(bounds) * 10)\n                length = c_min\n                if length < 1e-15:\n                    return goal_pos\n\n                # Orthonormal basis\n                def orthonormal_basis(dim, e1):\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append((-e1[1], e1[0]))\n                    elif dim == 3:\n                        # Gram-Schmidt for 3D\n                        v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                        u = [v[i] - e1[i] * sum(v[j] * e1[j] for j in range(3)) for i in range(3)]\n                        norm_u = math.sqrt(sum(x * x for x in u))\n                        if norm_u < 1e-15:\n                            u = [0, 0, 1]\n                            norm_u = 1.0\n                        u = [x / norm_u for x in u]\n                        w = [e1[1] * u[2] - e1[2] * u[1],\n                             e1[2] * u[0] - e1[0] * u[2],\n                             e1[0] * u[1] - e1[1] * u[0]]\n                        basis.extend([u, w])\n                    return basis\n\n                e1 = [a / length for a in a1]\n                B = orthonormal_basis(dim, e1)\n\n                a1_len = c_max / 2.0\n                try:\n                    a_others = max(((c_max ** 2 - c_min ** 2) / 4.0) ** 0.5, 1e-8)\n                except Exception:\n                    a_others = a1_len\n\n                while True:\n                    if dim == 2:\n                        r = random.uniform(0, 1) ** 0.5\n                        theta = random.uniform(0, 2 * math.pi)\n                        unit_ball = [r * math.cos(theta), r * math.sin(theta)]\n                        coords = [a1_len * unit_ball[0], a_others * unit_ball[1]]\n                        pt = tuple(center[i] + sum(coords[j] * B[j][i] for j in range(dim)) for i in range(dim))\n                    else:\n                        # 3D sample in unit ball\n                        while True:\n                            u = [random.uniform(-1, 1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x * x for x in u))\n                            if 0 < norm_u <= 1:\n                                unit_ball = [x / norm_u for x in u]\n                                break\n                        coords = [a1_len * unit_ball[0], a_others * unit_ball[1], a_others * unit_ball[2]]\n                        pt = tuple(center[i] + sum(coords[j] * B[j][i] for j in range(dim)) for i in range(dim))\n                    if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt, obstacles, is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                dx = n.position[0] - point[0]\n                dy = n.position[1] - point[1]\n                dz = n.position[2] - point[2] if is_3d else 0.0\n                if dx * dx + dy * dy + dz * dz <= r2:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        def path_from_to(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a, b, c):\n            # returns angle at point b formed by a-b-c in radians\n            import math\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-8 or lcb < 1e-8:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def incremental_shortcut(path):\n            # Try to shortcut small segments inline; only remove nodes if edges are collision free and angles remain smooth\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if is_free_edge(path[i], path[j]):\n                        # Check curvature smoothness if intermediate nodes removed\n                        if i > 0 and j < len(path) - 1:\n                            ang_before = angle_between(path[i - 1], path[i], path[i + 1]) if i + 1 < len(path) else 0.0\n                            ang_after = angle_between(path[i - 1], path[j], path[j + 1]) if (j + 1) < len(path) else 0.0\n                            if ang_after < ang_before + 0.15:\n                                break\n                            else:\n                                j -= 1\n                        else:\n                            break\n                    else:\n                        j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def smooth_path(path):\n            # Limited curvature smoothing by midpoint averaging where collision free and angles improve\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path) - 1):\n                a = new_path[i - 1]\n                b = new_path[i]\n                c = new_path[i + 1]\n                midpoint = tuple((a[j] + c[j]) * 0.5 for j in range(dim))\n                if is_free_node(point := midpoint) and is_free_edge(a, point) and is_free_edge(point, c):\n                    angle_old = angle_between(a, b, c)\n                    angle_new = angle_between(a, point, c)\n                    if angle_new < angle_old + 1e-4:\n                        new_path[i] = point\n                        changed = True\n            return new_path if changed else path\n\n        # Main iteration loop\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            # Parent selection minimizing cost with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost + 1e-15 < min_cost:\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring near nodes\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-15 < nbr.cost:\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            # Attempt connect to other tree\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            # If solution found, do incremental smoothing and shortcutting every 25 iterations for responsiveness\n            if solution_nodes[0] is not None and solution_nodes[1] is not None and (it % 25 == 0 or it == self.max_iter - 1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                if len(raw_path) >= 3:\n                    raw_path = incremental_shortcut(raw_path)\n                    raw_path = smooth_path(raw_path)\n                if raw_path:\n                    return PlannerResult(True, raw_path, nodes, edges)\n\n        # Final return fallback\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            if len(raw_path) >= 3:\n                raw_path = incremental_shortcut(raw_path)\n                raw_path = smooth_path(raw_path)\n            return PlannerResult(True, raw_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -20.57491,
          "time_improvement": 10.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1509.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01461324691772461,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 160.98208188855222,
                    "smoothness_avg": 0.04138808889515978,
                    "success_improvement": 0.0,
                    "time_improvement": 43.33932673596827,
                    "node_improvement": 71.29186602870814,
                    "length_improvement": 11.763169992555863,
                    "smoothness_improvement": 547.8134668827964,
                    "objective_score": 22.79876735073798
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02194514274597168,
                    "num_nodes_avg": 279.7,
                    "path_length_avg": 233.23154944800126,
                    "smoothness_avg": 0.10921209349027608,
                    "success_improvement": 0.0,
                    "time_improvement": 86.74615695198732,
                    "node_improvement": 81.20674595175703,
                    "length_improvement": 22.140595596329685,
                    "smoothness_improvement": 2710.1058277961906,
                    "objective_score": 52.85873358237496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1021653652191162,
                    "num_nodes_avg": 508.9,
                    "path_length_avg": 125.19054758373325,
                    "smoothness_avg": 0.10772478778215958,
                    "success_improvement": 0.0,
                    "time_improvement": -101.32225130385797,
                    "node_improvement": 35.295613477431665,
                    "length_improvement": 16.854399228148544,
                    "smoothness_improvement": 1270.2513491723514,
                    "objective_score": -13.932779108406503
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* inspired planner with blended uniform and adaptive ellipsoidal informed sampling, incremental rewiring with adaptive radius based on current solution and node density, and efficient anytime shortcut-based smoothing. The planner dynamically balances exploration and exploitation by gradually biasing sampling towards an informed ellipsoidal subset after the first solution. Rewiring radius and connection thresholds adapt according to progress, improving computational efficiency and path quality. Shortcuts are periodically performed incrementally during planning with early path updates allowing faster convergence to smooth, shorter, and collision-free paths.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points either uniformly or inside an ellipsoidal informed region when a solution is found. Nodes steer towards samples with fixed step size avoiding obstacles. Rewiring is performed locally using an adaptive radius tied to the current best solution cost and tree size. The two trees attempt connection whenever nodes are close enough on each iteration. Solution updates trigger adaptive radius shrinkage and intensify sampling inside the smaller informed region, focusing search. Paths are incrementally shortcut each iteration with collision checks to reduce jagged turns and path length, enabling anytime quality improvement and early termination after stable good solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=20.0, goal_sample_rate=0.1, shortcut_freq=50, shortcut_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collides(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r2]\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            n = max(n_nodes,1)\n            radius = gamma * (math.log(n)/n)**(1/dim)\n            # Shrinks radius as solution cost improves\n            if c_best < float('inf'):\n                radius = min(radius, c_best / 5.0)\n            return max(radius, self.step_size*1.5)\n\n        def sample(c_best):\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling around start-goal line\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dist_sg = dist(start, goal)\n            a1 = tuple((goal[i] - start[i]) / c_best for i in range(dim))  # unit vec along line\n            # Orthonormal basis via Gram-Schmidt\n            basis = [a1]\n            for i_dim in range(dim):\n                e = [0.0] * dim\n                e[i_dim] = 1.0\n                for b in basis:\n                    proj = sum(e[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        e[j] -= proj * b[j]\n                norm_e = math.sqrt(sum(x*x for x in e))\n                if norm_e > 1e-8:\n                    e = [x/norm_e for x in e]\n                    basis.append(e)\n                if len(basis) >= dim:\n                    break\n            # Radii per axis\n            r1 = c_best / 2.0\n            if dim == 2:\n                r2 = math.sqrt(max(c_best*c_best - dist_sg*dist_sg, 0)) / 2\n                radii = [r1, r2]\n            elif dim == 3:\n                r2 = math.sqrt(max(c_best*c_best - dist_sg*dist_sg, 0)) / 2\n                radii = [r1, r2, r2]\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Sample unit ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xx*xx for xx in x))\n                if norm_x > 1e-8:\n                    break\n            unit_x = [xx / norm_x for xx in x]\n            scale = random.uniform(0,1)**(1/dim)\n            scaled = [scale * xx for xx in unit_x]\n            sample_pt = [center[i] + sum(basis[j][i] * radii[j] * scaled[j] for j in range(dim)) for i in range(dim)]\n            clamped = tuple(max(0.0, min(bounds[i], sample_pt[i])) for i in range(dim))\n            return clamped\n\n        def path_length(path):\n            s = 0.0\n            for i in range(len(path)-1):\n                s += dist(path[i], path[i+1])\n            return s\n\n        def extract_path(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()[::-1]\n            if len(path_s)>0 and len(path_g)>0 and path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def rewire(tree, new_node, neighbors):\n            nonlocal edges\n            for n in neighbors:\n                if n is new_node.parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_new + 1e-12 < n.cost:\n                    if not edge_collides(new_node.position, n.position):\n                        if n.parent is not None:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            if n in n.parent.children:\n                                n.parent.children.remove(n)\n                        n.parent = new_node\n                        n.cost = cost_new\n                        new_node.children.append(n)\n                        edges.append((new_node, n))\n\n        def incremental_shortcut(path):\n            if len(path)<3:\n                return path[:]\n            for _ in range(self.shortcut_iters):\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_collides(path[i], path[j]):\n                    # shortcut possible\n                    path = path[:i+1] + path[j:]\n            return path\n\n        c_best = float('inf')\n        solution_nodes = (None, None)\n        success = False\n        best_path = []\n\n        for it in range(self.max_iter):\n            # Alternate trees for expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample(c_best)\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if in_obstacle(q_new_pos):\n                    continue\n                if edge_collides(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a), c_best)\n                neighbors = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for nbr in neighbors:\n                    c = nbr.cost + dist(nbr.position, q_new_pos)\n                    if c + 1e-12 < min_cost and not edge_collides(nbr.position, q_new_pos):\n                        min_cost = c\n                        min_parent = nbr\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, neighbors)\n\n                near_other = nearest(tree_b, q_new.position)\n                dist_conn = dist(q_new.position, near_other.position)\n                connect_radius = max(self.step_size*1.5, adaptive_radius(len(tree_b), c_best))\n                if dist_conn <= connect_radius and not edge_collides(q_new.position, near_other.position):\n                    candidate_path = extract_path(q_new, near_other) if tree_a is start_tree else extract_path(near_other, q_new)\n                    candidate_cost = path_length(candidate_path)\n                    if candidate_cost + 1e-12 < c_best:\n                        c_best = candidate_cost\n                        solution_nodes = (q_new, near_other) if tree_a is start_tree else (near_other, q_new)\n                        best_path = candidate_path\n                        success = True\n\n            if success and it % self.shortcut_freq == 0:\n                best_path = incremental_shortcut(best_path)\n\n            if success and (it>200 and it % 100 == 0):\n                break\n\n        if success:\n            best_path = incremental_shortcut(best_path)\n        else:\n            best_path = []\n\n        return PlannerResult(success, best_path, nodes, edges)",
          "objective": -20.29394,
          "time_improvement": 7.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1590.0,
          "node_improvement": 52.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.039613747596740724,
                    "num_nodes_avg": 278.4,
                    "path_length_avg": 159.92231177219156,
                    "smoothness_avg": 0.035916285555064945,
                    "success_improvement": 0.0,
                    "time_improvement": -53.59636513226316,
                    "node_improvement": 29.89171493326619,
                    "length_improvement": 12.344046786465272,
                    "smoothness_improvement": 462.16786239917786,
                    "objective_score": -6.361642155803895
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04807093143463135,
                    "num_nodes_avg": 370.4,
                    "path_length_avg": 237.87604813803787,
                    "smoothness_avg": 0.11653928767250495,
                    "success_improvement": 0.0,
                    "time_improvement": 70.9673986730692,
                    "node_improvement": 75.1125445138749,
                    "length_improvement": 20.590128249113008,
                    "smoothness_improvement": 2898.639811669588,
                    "objective_score": 48.137495609736504
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048401260375976564,
                    "num_nodes_avg": 389.2,
                    "path_length_avg": 123.77941219431334,
                    "smoothness_avg": 0.11861964525198684,
                    "success_improvement": 0.0,
                    "time_improvement": 4.622758564635697,
                    "node_improvement": 50.514939605848696,
                    "length_improvement": 17.79160816275492,
                    "smoothness_improvement": 1408.8331320138268,
                    "objective_score": 19.105958127112793
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional informed RRT* planner with adaptive lazy collision checking and dynamic rewiring radius based on local node density, which alternates growing trees from start and goal using progressive ellipsoidal informed sampling. Nodes are selectively rewired based on cost improvement and collision verified lazily to minimize expensive checks. Integrated frequent incremental path shortcutting aggressively smooths and shortens paths during planning, while early tree connection attempts speed up convergence. The algorithm maintains map bounds and obstacles constraints, optimizes local neighborhood rewiring, and applies efficient parent selection to enhance planning efficiency, path quality, and robustness.",
          "planning_mechanism": "The planner alternates expansions between two trees, from start and goal, sampling mostly within an ellipsoidal informed region shrinking with the best path cost. New samples are steered toward with step size limits, and the parent is chosen as the lowest cost collision-free node within a dynamic radius computed from node count and map dimension. Lazy collision checking defers edge verification until potentially connecting two trees or rewiring reduces cost. Trees connect early if reachable, yielding candidate paths. Incremental shortcutting runs frequently to improve path smoothness by removing redundant waypoints safely. This synergy accelerates finding short, smooth, and feasible paths while reducing computational overhead.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, gamma=35.0,\n                 shortcut_freq=15, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        start_pos = map.start\n        goal_pos = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Data structures\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_nodes_pair = None\n\n        def dist_sq(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a,b):\n            return dist_sq(a,b)**0.5\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            max_r = self.step_size * 30.0\n            return min(r, max_r)\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_check(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            dist_ = dist(p1, p2)\n            steps = max(3, int(dist_ * 2))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if collision_check(interp):\n                    return False\n            return True\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_check(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            d_vec = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            length = math.sqrt(sum(x*x for x in d_vec))\n            if length < 1e-14:\n                R = None\n            else:\n                if dim == 2:\n                    dx, dy = d_vec[0]/length, d_vec[1]/length\n                    cos_t, sin_t = dx, dy\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                else:\n                    # Rodrigues' rotation matrix 3D\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in d_vec]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1],\n                         a1[2]*a2[0]-a1[0]*a2[2],\n                         a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = math.sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],\n                              [v[2],0,-v[0]],\n                              [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            c_best = best_cost\n            c_min_val = c_min\n            a1 = c_best / 2.0\n            r_others = math.sqrt(max(c_best*c_best - c_min_val*c_min_val,0))/2.0\n\n            def sample_unit_ball():\n                if dim == 2:\n                    while True:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        return [r*math.cos(theta), r*math.sin(theta)]\n                else:\n                    while True:\n                        pt = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in pt) <= 1:\n                            return pt\n\n            for _ in range(100):\n                x_ball = sample_unit_ball()\n                if dim == 2:\n                    L = [[a1,0],[0,r_others]]\n                    x_ellipsoid = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    if R is None:\n                        pt = (center[0] + x_ellipsoid[0], center[1] + x_ellipsoid[1])\n                    else:\n                        pt = (center[0] + R[0][0]*x_ellipsoid[0] + R[0][1]*x_ellipsoid[1],\n                              center[1] + R[1][0]*x_ellipsoid[0] + R[1][1]*x_ellipsoid[1])\n                else:\n                    L = [[a1,0,0],[0,r_others,0],[0,0,r_others]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    if R is None:\n                        pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                    else:\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if not is_in_bounds(pt):\n                    continue\n                if collision_check(pt):\n                    continue\n                return pt\n            return sample_uniform()\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= radius_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            diff = [to_pos[i] - from_pos[i] for i in range(dim)]\n            d = math.sqrt(sum(x*x for x in diff))\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[i] + diff[i]*ratio for i in range(dim))\n\n        # Lazy collision check cache for edges to reduce expensive calls\n        edge_valid_cache = {}\n\n        def lazy_edge_check(p1, p2):\n            key = (p1, p2)\n            if key in edge_valid_cache:\n                return edge_valid_cache[key]\n            coll_free = edge_collision_free(p1, p2)\n            edge_valid_cache[key] = coll_free\n            edge_valid_cache[(p2, p1)] = coll_free\n            return coll_free\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if collision_check(new_pos):\n                return None\n            if not lazy_edge_check(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            r = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for node in neighbors:\n                c = node.cost + dist(node.position, new_pos)\n                if c < min_cost and lazy_edge_check(node.position, new_pos):\n                    min_cost = c\n                    min_parent = node\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision-free lazily\n            for node in neighbors:\n                if node is min_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, node.position)\n                if new_c + 1e-8 < node.cost and lazy_edge_check(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, node))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = new_c\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            d_conn = dist(new_node.position, nearest_other.position)\n            if d_conn <= self.step_size and lazy_edge_check(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + d_conn + nearest_other.cost\n                return (new_node, nearest_other, total_cost)\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) -1)\n                if lazy_edge_check(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            # Alternate expansion order each iteration for balanced growth\n            order = [(start_tree, goal_tree), (goal_tree, start_tree)][it % 2]\n            res = attempt_extend(order[0], order[1], sample)\n            if res is not None:\n                n_new, n_connect, c_path = res\n                if c_path < best_cost:\n                    best_cost = c_path\n                    best_nodes_pair = (n_new, n_connect)\n            # After attempt from second tree as well\n            res = attempt_extend(order[1], order[0], sample)\n            if res is not None:\n                n_new, n_connect, c_path = res\n                if c_path < best_cost:\n                    best_cost = c_path\n                    best_nodes_pair = (n_new, n_connect)\n\n            # Apply shortcutting frequently and return better path if found\n            if best_nodes_pair is not None and best_cost < float('inf'):\n                if (it % self.shortcut_freq == 0) or (it == self.max_iter - 1):\n                    raw_path = extract_path(best_nodes_pair[0], best_nodes_pair[1])\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        # Return failure with constructed trees if no path found\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -19.76035,
          "time_improvement": 14.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1396.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0346923828125,
                    "num_nodes_avg": 134.1,
                    "path_length_avg": 165.4814303710184,
                    "smoothness_avg": 0.03999855904278786,
                    "success_improvement": 0.0,
                    "time_improvement": -34.514511275762764,
                    "node_improvement": 66.23016872324351,
                    "length_improvement": 9.297005792576952,
                    "smoothness_improvement": 526.064307280806,
                    "objective_score": -2.145828370778629
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06541202068328858,
                    "num_nodes_avg": 283.5,
                    "path_length_avg": 241.2475395225302,
                    "smoothness_avg": 0.09226072632381513,
                    "success_improvement": 0.0,
                    "time_improvement": 60.49418927799828,
                    "node_improvement": 80.95142108445877,
                    "length_improvement": 19.464627381970665,
                    "smoothness_improvement": 2273.9349410268956,
                    "objective_score": 41.19670791771636
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0430621862411499,
                    "num_nodes_avg": 206.4,
                    "path_length_avg": 128.59923815230476,
                    "smoothness_avg": 0.11686797074880832,
                    "success_improvement": 0.0,
                    "time_improvement": 15.143686301703887,
                    "node_improvement": 73.75715193897013,
                    "length_improvement": 14.590509256905632,
                    "smoothness_improvement": 1386.5519616285583,
                    "objective_score": 20.230171252797337
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* with adaptive informed sampling, precise collision checks, dynamic rewiring with downstream cost updates, and enhanced iterative path shortcutting. The planner restricts samples inside an ellipsoidal informed region based on best path cost, alternates tree expansions with adaptive radius, rewires and propagates cost changes recursively to children for smoother optimized trees, and applies repeated global shortcutting steps to produce short, smooth, and efficient paths quickly.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling informed points inside an ellipsoid around the current best path to focus search. It chooses parent nodes minimizing path cost within a shrinking radius, rewires neighbors updating costs of all descendants to maintain optimality, and attempts to connect the two trees when close. Upon connection, it extracts and iteratively shortcuts the combined path to smooth sharp turns. Early stopping returns a collision-free, minimal-cost, and smooth path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_cost_recursive(self, new_cost):\n        cost_diff = new_cost - self.cost\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost_recursive(c.cost + cost_diff)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=8.0, goal_sample_rate=0.1, base_radius=25.0, shortcut_iterations=5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.25):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def uniform_sample():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n\n        def ellipsoidal_sample(best_cost):\n            c_min = dist(start, goal)\n            if best_cost == float('inf') or best_cost <= c_min:\n                return uniform_sample()\n            center = tuple(0.5 * (start[i] + goal[i]) for i in range(dim))\n            foci_dist = c_min\n            a1 = best_cost * 0.5\n            val = best_cost * best_cost - foci_dist * foci_dist\n            a2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in vec))\n                vec = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_pt = [vec[i] * r for i in range(dim)]\n                if dim == 2:\n                    sample = (center[0] + ball_pt[0] * a1, center[1] + ball_pt[1] * a2)\n                else:\n                    sample = tuple(center[i] + ball_pt[i] * (a1 if i == 0 else a2) for i in range(dim))\n                if in_bounds(sample) and not collision_node(sample):\n                    return sample\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.step_size * 3\n            return max(self.base_radius * (math.log(n) / n) ** (1.0 / dim), self.step_size * 1.5)\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            p = list(path)\n            for _ in range(self.shortcut_iterations):\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not collision_edge(p[i], p[j]):\n                    del p[i + 1:j]\n            return p\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Update parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        # Recursively update children's costs\n                        def update_descendants(n):\n                            for c in n.children:\n                                child_new_cost = n.cost + dist(n.position, c.position)\n                                if child_new_cost + 1e-9 < c.cost:\n                                    c.cost = child_new_cost\n                                    update_descendants(c)\n                        update_descendants(near_node)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        edges = []\n        best_cost = float('inf')\n        best_path = None\n\n        for iter_count in range(self.max_iter):\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = ellipsoidal_sample(best_cost)\n\n            # Alternate tree expansions\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                # Find best parent\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    cost_through = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through + 1e-9 < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                if new_node not in min_parent.children:\n                    min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                # Try connect to other tree\n                nearest_b = nearest(tree_b, new_node.position)\n                d_connect = dist(new_node.position, nearest_b.position)\n                connect_radius = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if d_connect <= connect_radius and not collision_edge(new_node.position, nearest_b.position):\n                    total_cost = new_node.cost + d_connect + nearest_b.cost\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_path = reconstruct_path(new_node, nearest_b)\n                        best_path = shortcut_path(best_path)\n                        if best_cost < float('inf'):\n                            # Early return best found path for efficiency\n                            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        # If no path found after max_iter\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": -18.74655,
          "time_improvement": 41.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 289.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027685046195983887,
                    "num_nodes_avg": 107.9,
                    "path_length_avg": 174.1596858314236,
                    "smoothness_avg": 0.020553205324360287,
                    "success_improvement": 0.0,
                    "time_improvement": -7.344614488627172,
                    "node_improvement": 72.82800302190886,
                    "length_improvement": 4.5403164589710645,
                    "smoothness_improvement": 221.70229532596025,
                    "objective_score": 1.6293170054242887
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027205395698547363,
                    "num_nodes_avg": 199.3,
                    "path_length_avg": 257.87265749162214,
                    "smoothness_avg": 0.0156752529849365,
                    "success_improvement": 0.0,
                    "time_improvement": 83.56920942271773,
                    "node_improvement": 86.6088826177518,
                    "length_improvement": 13.914684476399708,
                    "smoothness_improvement": 303.3355497307787,
                    "objective_score": 34.93625126130903
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026490187644958495,
                    "num_nodes_avg": 177.1,
                    "path_length_avg": 141.4808021388786,
                    "smoothness_avg": 0.034796946700385786,
                    "success_improvement": 0.0,
                    "time_improvement": 47.79968531696869,
                    "node_improvement": 77.48251748251748,
                    "length_improvement": 6.035187811184158,
                    "smoothness_improvement": 342.6145935854742,
                    "objective_score": 19.674091249728473
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.483327093247905,
          "time_improvement": 35.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 180.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022586989402770995,
                    "num_nodes_avg": 95.7,
                    "path_length_avg": 168.64313046948791,
                    "smoothness_avg": 0.017505839022252202,
                    "success_improvement": 0.0,
                    "time_improvement": 12.422336132822434,
                    "node_improvement": 75.90027700831025,
                    "length_improvement": 7.564027868261686,
                    "smoothness_improvement": 174.00439523612755,
                    "objective_score": 9.13513953698438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03670787811279297,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 257.74323422045836,
                    "smoothness_avg": 0.010534876218801273,
                    "success_improvement": 0.0,
                    "time_improvement": 77.83015308834821,
                    "node_improvement": 83.2829402674192,
                    "length_improvement": 13.957889689556485,
                    "smoothness_improvement": 171.06995307438933,
                    "objective_score": 32.5791295056103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04266858100891113,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 130.54377171187787,
                    "smoothness_avg": 0.023278354893991073,
                    "success_improvement": 0.0,
                    "time_improvement": 15.919306212711263,
                    "node_improvement": 69.28162746344564,
                    "length_improvement": 13.299042655374924,
                    "smoothness_improvement": 196.09895602214036,
                    "objective_score": 13.735712237149036
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -17.795854854811235,
          "time_improvement": 71.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015041923522949219,
                    "num_nodes_avg": 140.4,
                    "path_length_avg": 205.55369204774252,
                    "smoothness_avg": 0.01041684624247792,
                    "success_improvement": 0.0,
                    "time_improvement": 41.67719749109079,
                    "node_improvement": 64.64366658272476,
                    "length_improvement": -12.667235818056396,
                    "smoothness_improvement": 63.046264238449346,
                    "objective_score": 5.218049077685646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016628527641296388,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 305.1784824883373,
                    "smoothness_avg": 0.00711472502770238,
                    "success_improvement": 0.0,
                    "time_improvement": 89.95714459329555,
                    "node_improvement": 84.19673452932877,
                    "length_improvement": -1.8773615301791229,
                    "smoothness_improvement": 83.06699949208468,
                    "objective_score": 26.276061457341616
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010075998306274415,
                    "num_nodes_avg": 181.0,
                    "path_length_avg": 156.9681958591822,
                    "smoothness_avg": 0.014159220130581652,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14471285055937,
                    "node_improvement": 76.98664971392245,
                    "length_improvement": -4.250801667402978,
                    "smoothness_improvement": 80.10423493608366,
                    "objective_score": 21.89345402940644
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A dual-tree bidirectional RRT* variant with adaptive radius and adaptive sampling that alternates expansions from both start and goal, combined with progressive informed sampling that focuses the search spatially as better solutions are found. It utilizes a dynamic rewiring radius based on node density to efficiently optimize locally, and incorporates frequent incremental path shortcutting to reduce path length and improve smoothness. A lazy collision-checking scheme for edges combined with early termination upon finding consistent improved solutions enhances computational efficiency and robustness.",
          "planning_mechanism": "A bidirectional planner builds two trees rooted at start and goal, alternately expanding toward sampled points that progressively focus inside an informed ellipsoid shrinking around the best known path cost. Each extension picks a parent minimizing cost with feasible collision-free edges and rewires nearby nodes within an adaptive radius to optimize path cost locally. When the two trees connect, the combined path is extracted, then progressively shortcut multiple random node pairs frequently to smooth and shorten the path during planning. Nodes and edges are stored efficiently, and the planner respects all obstacle constraints and map bounds. This synergistic integration yields faster convergence to high-quality, smooth, and short feasible paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, gamma=40.0,\n                 shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        start_pos = map.start\n        goal_pos = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_nodes_pair = None\n\n        def dist_sq(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a,b):\n            return dist_sq(a,b)**0.5\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            max_r = self.step_size * 40.0\n            return min(r, max_r)\n\n        def is_in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        def collision_check(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d=obs\n                    px,py,pz=pos\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                        return True\n                else:\n                    x,y,w,h=obs\n                    px,py=pos\n                    if x<=px<=x+w and y<=py<=y+h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            dist_ = dist(p1, p2)\n            steps = max(1, int(dist_))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(dim))\n                if collision_check(interp):\n                    return False\n            return True\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_check(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            d_vec = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            c_best = best_cost\n            c_min_val = c_min\n            # Rotation matrix to align x-axis with d_vec for 2D and 3D\n            length = math.sqrt(sum(x*x for x in d_vec))\n            if length < 1e-14:\n                R = None\n            else:\n                if dim == 2:\n                    dx, dy = d_vec[0]/length, d_vec[1]/length\n                    cos_t, sin_t = dx, dy\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                else:\n                    # Use Rodrigues formula for 3D rotation aligning x-axis (1,0,0) to d_vec/length\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in d_vec]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1],\n                         a1[2]*a2[0]-a1[0]*a2[2],\n                         a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = math.sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            # Ellipsoid parameters\n            a1 = c_best / 2.0\n            r_others = math.sqrt(max(c_best*c_best - c_min_val*c_min_val, 0)) / 2.0\n\n            def sample_unit_ball():\n                while True:\n                    if dim == 2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        return [r*math.cos(theta), r*math.sin(theta)]\n                    else:\n                        pt = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in pt) <= 1:\n                            return pt\n            for _ in range(100):\n                x_ball = sample_unit_ball()\n                if dim == 2:\n                    L = [[a1,0],[0,r_others]]\n                    x_ellipsoid = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    if R is None:\n                        pt = (center[0] + x_ellipsoid[0], center[1] + x_ellipsoid[1])\n                    else:\n                        pt = (center[0] + R[0][0]*x_ellipsoid[0] + R[0][1]*x_ellipsoid[1],\n                              center[1] + R[1][0]*x_ellipsoid[0] + R[1][1]*x_ellipsoid[1])\n                else:\n                    L = [[a1,0,0],[0,r_others,0],[0,0,r_others]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    if R is None:\n                        pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                    else:\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if not is_in_bounds(pt):\n                    continue\n                if collision_check(pt):\n                    continue\n                return pt\n            return sample_uniform()\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= radius_sq:\n                    result.append(node)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            diff = [to_pos[i]-from_pos[i] for i in range(dim)]\n            d = math.sqrt(sum(x*x for x in diff))\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            new_pos = tuple(from_pos[i] + diff[i]*ratio for i in range(dim))\n            return new_pos\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if collision_check(new_pos):\n                return None\n            if not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            r = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + dist(node.position, new_pos)\n                if c < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = c\n                    min_parent = node\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for node in neighbors:\n                if node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost < node.cost and edge_collision_free(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, node))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            d_conn = dist(new_node.position, nearest_other.position)\n            if d_conn <= self.step_size and edge_collision_free(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + d_conn + nearest_other.cost\n                return (new_node, nearest_other, total_cost)\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path)-3)\n                j = random.randint(i+2, len(shortcut_path)-1)\n                if edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, c_path = res\n                    if c_path < best_cost:\n                        best_cost = c_path\n                        best_nodes_pair = (n_new, n_connect)\n            if best_nodes_pair is not None and best_cost < float('inf'):\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(best_nodes_pair[0], best_nodes_pair[1])\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -15.59375,
          "time_improvement": -5.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1473.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01934182643890381,
                    "num_nodes_avg": 97.7,
                    "path_length_avg": 163.09996323771628,
                    "smoothness_avg": 0.04171144736670499,
                    "success_improvement": 0.0,
                    "time_improvement": 25.004968823521256,
                    "node_improvement": 75.39662553512969,
                    "length_improvement": 10.60232566510146,
                    "smoothness_improvement": 552.8747291466387,
                    "objective_score": 16.627259691850448
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05454413890838623,
                    "num_nodes_avg": 262.5,
                    "path_length_avg": 232.53217295072687,
                    "smoothness_avg": 0.09890208145311588,
                    "success_improvement": 0.0,
                    "time_improvement": 67.05788316581106,
                    "node_improvement": 82.36242693005443,
                    "length_improvement": 22.374067601556185,
                    "smoothness_improvement": 2444.82179207855,
                    "objective_score": 45.76591447106978
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10462684631347656,
                    "num_nodes_avg": 375.1,
                    "path_length_avg": 127.64705068500382,
                    "smoothness_avg": 0.1195941244863454,
                    "success_improvement": 0.0,
                    "time_improvement": -106.17272988234387,
                    "node_improvement": 52.3076923076923,
                    "length_improvement": 15.222906834392159,
                    "smoothness_improvement": 1421.2284359462928,
                    "objective_score": -15.611932684336402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm merges bidirectional RRT* with adaptive informed sampling and dynamic rewiring, enriched by enhanced smooth path extraction. The planner grows two trees from start and goal, uses an elliptical informed region for sampling, adjusts the neighborhood radius dynamically for rewiring, and aggressively post-processes the path using iterative shortcutting and Bezier curve smoothing. Tree expansion is carefully constrained to improve both efficiency and path quality, ensuring collision-free nodes and edges throughout. This consolidated approach aims to significantly boost efficiency, robustness, and smoothness while finding optimized paths quickly.",
          "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal, samples within an adaptive ellipsoidal informed set shaped by the best current path cost, finds nearest neighbors and rewires locally with an adaptive radius. Upon connecting, it extracts the full path and performs iterative shortcutting followed by a smooth Bezier path fitting, validating all collision constraints to produce a shortened and highly smooth trajectory. The approach balances exploration with continuous path optimization and aggressive smoothing for superior planning outcomes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if (x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if (x <= p[0] <= x + w and y <= p[1] <= y + h):\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[i] - p[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def adaptive_radius(iteration, tree_size):\n            if tree_size < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            return max(self.step_size, min(gamma, gamma * (math.log(tree_size)/tree_size)**(1/dim)))\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            foci_dist = c_min\n            val = c_best * c_best - foci_dist * foci_dist\n            r1 = c_best / 2.0\n            r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n            def unit_ball_sample():\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        u = [x / norm for x in vec]\n                        r = random.random() ** (1.0 / dim)\n                        return [u[i] * r for i in range(dim)]\n\n            while True:\n                u_sample = unit_ball_sample()\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=150):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def bezier_smooth(path, samples=100):\n            if len(path) < 3:\n                return path[:]\n            def lin_interp(p1, p2, t):\n                return tuple(p1[i] + (p2[i]-p1[i])*t for i in range(len(p1)))\n            def bezier(points, t):\n                pts = points[:]\n                while len(pts) > 1:\n                    pts = [lin_interp(pts[i], pts[i+1], t) for i in range(len(pts)-1)]\n                return pts[0]\n            control_pts = []\n            n = len(path)\n            for i in range(n):\n                p = path[i]\n                if i == 0:\n                    p_next = path[i+1]\n                    ctrl1 = tuple( p[j] + (p_next[j]-p[j]) * 0.3 for j in range(dim) )\n                    control_pts.append((p, ctrl1))\n                elif i == n-1:\n                    p_prev = path[i-1]\n                    ctrl2 = tuple( p[j] + (p_prev[j]-p[j]) * 0.3 for j in range(dim) )\n                    control_pts.append((ctrl2, p))\n                else:\n                    p_prev = path[i-1]\n                    p_next = path[i+1]\n                    ctrl1 = tuple(p[j] + (p_next[j]-p_prev[j]) * 0.15 for j in range(dim))\n                    ctrl2 = tuple(p[j] - (p_next[j]-p_prev[j]) * 0.15 for j in range(dim))\n                    control_pts.append((ctrl1, ctrl2))\n            smooth_path = []\n            # Piecewise Bezier curves between waypoints\n            for i in range(n-1):\n                p0 = path[i]\n                p3 = path[i+1]\n                if i == 0:\n                    p1 = control_pts[i][1]\n                    p2 = control_pts[i+1][0]\n                elif i == n-2:\n                    p1 = control_pts[i][0]\n                    p2 = control_pts[i+1][0] if len(control_pts[i+1]) > 1 else p3\n                else:\n                    p1 = control_pts[i][0]\n                    p2 = control_pts[i+1][1]\n                for t in [k/(samples-1) for k in range(samples)]:\n                    # Cubic B\u00e9zier formula:\n                    u = 1 - t\n                    pt = tuple(\n                        (u**3)*p0[d] + 3*(u**2)*t*p1[d] + 3*u*(t**2)*p2[d] + (t**3)*p3[d]\n                        for d in range(dim)\n                    )\n                    smooth_path.append(pt)\n            # Collision check and fallback:\n            filtered = []\n            for pt in smooth_path:\n                if not in_bounds(pt) or collision_node(pt):\n                    return path[:]\n            return smooth_path\n\n        for iteration in range(1, self.max_iter + 1):\n            sample = informed_sample()\n            for tree_a, tree_b in ((start_tree, goal_tree), (goal_tree, start_tree)):\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if (not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nn.position, new_pos)):\n                    continue\n\n                radius = adaptive_radius(iteration, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cand_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    # Construct candidate path\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_len = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_len += dist(candidate_path[k], candidate_path[k+1])\n                    if path_len < best_cost:\n                        # Post-process candidate path\n                        shortcut = shortcut_path(candidate_path, max_iters=150)\n                        smooth = bezier_smooth(shortcut, samples=50)\n                        # Validate smooth path\n                        valid = True\n                        for i in range(len(smooth)-1):\n                            if collision_edge(smooth[i], smooth[i+1]):\n                                valid = False\n                                break\n                        if valid:\n                            best_cost = path_len\n                            best_path = smooth\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -15.50094,
          "time_improvement": 19.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 738.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02978487014770508,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 179.02870411409452,
                    "smoothness_avg": 0.049272570619337513,
                    "success_improvement": 0.0,
                    "time_improvement": -15.486366934906105,
                    "node_improvement": 68.54696549987409,
                    "length_improvement": 1.8715303837070905,
                    "smoothness_improvement": 671.2227272922798,
                    "objective_score": -0.16687821378617818
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025112462043762208,
                    "num_nodes_avg": 181.1,
                    "path_length_avg": 252.77123501589048,
                    "smoothness_avg": 0.05054125811304572,
                    "success_improvement": 0.0,
                    "time_improvement": 84.83324376924836,
                    "node_improvement": 87.83175435060137,
                    "length_improvement": 15.61768613510334,
                    "smoothness_improvement": 1200.4629746454489,
                    "objective_score": 40.82289968506375
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.056411004066467284,
                    "num_nodes_avg": 299.7,
                    "path_length_avg": 131.80489373136044,
                    "smoothness_avg": 0.03487725206547758,
                    "success_improvement": 0.0,
                    "time_improvement": -11.160864668913323,
                    "node_improvement": 61.89446916719644,
                    "length_improvement": 12.461465458211887,
                    "smoothness_improvement": 343.63607190191635,
                    "objective_score": 5.846800233762717
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner leveraging adaptive multi-scale rewiring combined with a hybrid sampling strategy that blends goal bias, uniform, and adaptive ellipsoidal informed sampling. The planner incorporates a dynamic neighborhood radius that adjusts using local node density heuristics and adaptive step sizing to efficiently explore and exploit search space. It performs early tree connection checks and aggressive but safe rewiring constrained via lazy collision checks with caching. A multi-tier smoothing process first applies incremental path shortcutting with adaptive sampling intervals, followed by localized Bezier curve fitting with curvature thresholding to balance smoothing and path length. Early stopping conditions on solution quality and progressive sample focusing ensure rapid convergence with high-quality paths. This approach balances exploration and exploitation, improving planning speed, path length, and smoothness robustly in complex environments.",
          "planning_mechanism": "The planner initializes trees at start and goal, growing them alternately. Sampling mixes uniform, goal bias, and ellipsoidal informed samples depending on solution progress to concentrate search. Steered samples connect to nearest nodes within adaptively computed neighborhoods based on local density. Parents are selected via cost heuristics with lazy edge collision checks cached to minimize expensive computations. Rewiring iteratively optimizes paths within neighborhoods, maintaining consistent subtree costs. Upon connecting trees, the planner extracts the path which undergoes multi-pass adaptive shortcutting and Bezier smoothing with curvature checks, progressively refining smoothness without excessive path length increase. Early termination triggers if solution quality plateaus, ensuring computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4500, base_step=5.0, gamma=35.0, goal_bias=0.1,\n                 shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.gamma = gamma\n        self.goal_bias = goal_bias\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        start = map.start\n        goal = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def in_collision(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_collision_free(a, b, resolution=1.0):\n            d = dist(a, b)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                p = tuple(a[j] + (b[j] - a[j]) * t for j in range(dim))\n                if in_collision(p):\n                    return False\n            return True\n\n        def steer(from_p, to_p, max_step):\n            diff = [to_p[i] - from_p[i] for i in range(dim)]\n            length = math.sqrt(sum(x * x for x in diff))\n            if length <= max_step:\n                return to_p\n            ratio = max_step / length\n            return tuple(from_p[i] + diff[i] * ratio for i in range(dim))\n\n        def density_radius(node_count):\n            if node_count <= 1:\n                return self.base_step * 3.5\n            val = self.gamma * (math.log(node_count) / node_count) ** (1.0 / dim)\n            return min(val, self.base_step * 25.0)\n\n        # Hybrid sampling: mixes goal bias, uniform, and adaptive ellipsoidal informed sampling\n        best_cost = float('inf')\n        c_min = dist(start, goal)\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        d_vec = tuple(goal[i] - start[i] for i in range(dim))\n\n        # Precompute rotation matrix for ellipsoidal sampling\n        def rotation_matrix():\n            length = c_min if c_min < 1e-14 else math.sqrt(sum(x * x for x in d_vec))\n            if length < 1e-14:\n                return None\n            if dim == 2:\n                dx, dy = d_vec[0] / length, d_vec[1] / length\n                return [[dx, -dy], [dy, dx]]\n            else:\n                a1 = [1, 0, 0]\n                a2 = [d / length for d in d_vec]\n                v = [a1[1] * a2[2] - a1[2] * a2[1],\n                     a1[2] * a2[0] - a1[0] * a2[2],\n                     a1[0] * a2[1] - a1[1] * a2[0]]\n                s = math.sqrt(sum(x * x for x in v))\n                c = sum(a1[i] * a2[i] for i in range(3))\n                if s < 1e-14:\n                    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n                return R\n\n        R = rotation_matrix()\n\n        def sample_unit_ball():\n            if dim == 2:\n                while True:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    p = [r * math.cos(theta), r * math.sin(theta)]\n                    return p\n            else:\n                while True:\n                    p = [random.uniform(-1, 1) for _ in range(3)]\n                    norm_p = math.sqrt(sum(x * x for x in p))\n                    if norm_p <= 1 and norm_p > 1e-15:\n                        return [x / norm_p for x in p]\n\n        def ellipsoidal_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return uniform_sample()\n            a1 = best_cost / 2.0\n            try:\n                r_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0)) / 2.0\n            except Exception:\n                r_other = a1\n            for _ in range(100):\n                x_ball = sample_unit_ball()\n                if dim == 2:\n                    L = [[a1, 0], [0, r_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1]]\n                    if R is None:\n                        pt = (center[0] + x_scaled[0], center[1] + x_scaled[1])\n                    else:\n                        pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                              center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    L = [[a1, 0, 0], [0, r_other, 0], [0, 0, r_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    if R is None:\n                        pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                    else:\n                        pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if not in_bounds(pt):\n                    continue\n                if in_collision(pt):\n                    continue\n                return pt\n            return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_collision(pt):\n                    return pt\n\n        def hybrid_sample():\n            r = random.random()\n            if best_cost == float('inf'):\n                # Mix uniform and goal bias without ellipsoidal focus before solution\n                if r < self.goal_bias:\n                    if not in_collision(goal):\n                        return goal\n                    else:\n                        return uniform_sample()\n                else:\n                    return uniform_sample()\n            else:\n                # After solution: mix ellipsoidal (60%), goal bias (20%), uniform (20%)\n                if r < 0.6:\n                    return ellipsoidal_sample()\n                elif r < 0.8:\n                    if not in_collision(goal):\n                        return goal\n                    else:\n                        return uniform_sample()\n                else:\n                    return uniform_sample()\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist_sq(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= r2:\n                    result.append(node)\n            return result\n\n        def rek_cost_update(node):\n            # Update children's costs recursively to keep cost consistent for rewiring\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children:\n                    c_new = curr.cost + dist(curr.position, ch.position)\n                    if c_new + 1e-15 < ch.cost:\n                        ch.cost = c_new\n                        stack.append(ch)\n\n        # Lazy edge check cache to minimize expensive collisions\n        edge_cache = {}\n\n        def lazy_edge_check(a, b):\n            key = (a, b)\n            if key in edge_cache:\n                return edge_cache[key]\n            free = edge_collision_free(a, b)\n            edge_cache[key] = free\n            edge_cache[(b, a)] = free\n            return free\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path_cost = float('inf')\n        best_pair = None\n\n        # Adaptive step size reduces when solution improves to allow finer discretization near path\n        def adapt_step(iteration):\n            if best_path_cost == float('inf'):\n                return self.base_step\n            factor = max(0.3, 1.0 - 0.7 * (best_path_cost - c_min) / best_path_cost)\n            return self.base_step * factor\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_start)) + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) -1)\n                if lazy_edge_check(shortened[i], shortened[j]):\n                    shortened = shortened[:i+1] + shortened[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortened\n\n        def bezier_point(t, p0, p1, p2, p3):\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n            return tuple(uuu * p0[i] + 3*uu*t * p1[i] + 3*u*tt * p2[i] + ttt * p3[i] for i in range(dim))\n\n        def bezier_curve_segment(ctrl_pts, n_points=10):\n            if len(ctrl_pts) != 4:\n                return ctrl_pts[:]\n            return [bezier_point(t, *ctrl_pts) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def curve_collision_free(points):\n            for i in range(len(points) - 1):\n                if not lazy_edge_check(points[i], points[i+1]):\n                    return False\n            return True\n\n        def curvature_at_point(p_prev, p_curr, p_next):\n            # Approximate curvature via angle between vectors\n            import math\n            v1 = [p_curr[i] - p_prev[i] for i in range(dim)]\n            v2 = [p_next[i] - p_curr[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_theta = max(min(dot/(len1*len2), 1.0), -1.0)\n            angle = math.acos(cos_theta)\n            return angle\n\n        def bezier_smooth_path(path):\n            if len(path) < 4:\n                return path[:]\n            smoothed = path[:]\n            i = 0\n            max_curvature = math.pi * 0.75  # ~135 deg max curvature allowed\n            while i <= len(smoothed) - 4:\n                p0, p1, p2, p3 = smoothed[i], smoothed[i+1], smoothed[i+2], smoothed[i+3]\n                curve_pts = bezier_curve_segment([p0, p1, p2, p3], n_points=8)\n\n                if not curve_collision_free(curve_pts):\n                    i += 1\n                    continue\n                # Check curvature of intermediate points to avoid sharp bends\n                curvature_ok = True\n                for j in range(1, len(curve_pts) - 1):\n                    c = curvature_at_point(curve_pts[j-1], curve_pts[j], curve_pts[j+1])\n                    if c > max_curvature:\n                        curvature_ok = False\n                        break\n                if curvature_ok:\n                    # Replace middle two points with curve points except start/end\n                    smoothed = smoothed[:i+1] + curve_pts[1:-1] + smoothed[i+3:]\n                    i += len(curve_pts) - 3  # advance index beyond newly inserted points\n                else:\n                    i += 1\n            return smoothed\n\n        def try_extend(tree_a, tree_b, sample_p):\n            nearest_node = nearest(tree_a, sample_p)\n            step_size = adapt_step(len(tree_a) + len(tree_b))\n            new_p = steer(nearest_node.position, sample_p, step_size)\n\n            if in_collision(new_p):\n                return None\n            if not lazy_edge_check(nearest_node.position, new_p):\n                return None\n\n            r = density_radius(len(tree_a))\n            neighbors = near(tree_a, new_p, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_p)\n            min_parent = nearest_node\n\n            # Select parent minimizing cost + verify edge lazily\n            for node in neighbors:\n                cost_cand = node.cost + dist(node.position, new_p)\n                if cost_cand + 1e-16 < min_cost:\n                    if lazy_edge_check(node.position, new_p):\n                        min_cost = cost_cand\n                        min_parent = node\n\n            new_node = Node(new_p, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for node in neighbors:\n                if node is min_parent or node is new_node:\n                    continue\n                new_cost_cand = new_node.cost + dist(new_node.position, node.position)\n                if new_cost_cand + 1e-16 < node.cost:\n                    if lazy_edge_check(new_node.position, node.position):\n                        old_parent = node.parent\n                        if old_parent is not None:\n                            try:\n                                edges.remove((old_parent, node))\n                            except ValueError:\n                                pass\n                            old_parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = new_cost_cand\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n                        rek_cost_update(node)\n\n            # Attempt to connect new_node to other tree within step size\n            nearest_other = nearest(tree_b, new_node.position)\n            d = dist(new_node.position, nearest_other.position)\n            if d <= step_size:\n                if lazy_edge_check(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + d + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        # Main loop\n        best_pair = None\n        best_path_cost = float('inf')\n        for it in range(self.max_iter):\n            samp = hybrid_sample()\n\n            # Alternate tree to extend per iteration\n            if it % 2 == 0:\n                res = try_extend(start_tree, goal_tree, samp)\n                if res:\n                    n_new, n_goal, cost_path = res\n                    if cost_path + 1e-12 < best_path_cost:\n                        best_path_cost = cost_path\n                        best_pair = (n_new, n_goal)\n            else:\n                res = try_extend(goal_tree, start_tree, samp)\n                if res:\n                    n_new, n_start, cost_path = res\n                    if cost_path + 1e-12 < best_path_cost:\n                        best_path_cost = cost_path\n                        best_pair = (n_start, n_new)\n\n            # Shortcut and smooth periodically\n            if best_pair and (it % self.shortcut_freq == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                shortcut_path = incremental_shortcut(raw_path)\n                smooth_path = bezier_smooth_path(shortcut_path)\n                if len(smooth_path) >= 2:\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n            # Early stop if no improvement in last 250 iters after path found\n            if best_pair and it > 0 and it % 250 == 0:\n                # Check if path cost stagnates\n                if best_path_cost <= (1.01 * c_min):\n                    raw_path = extract_path(best_pair[0], best_pair[1])\n                    shortcut_path = incremental_shortcut(raw_path)\n                    smooth_path = bezier_smooth_path(shortcut_path)\n                    if len(smooth_path) >= 2:\n                        return PlannerResult(True, smooth_path, nodes, edges)\n\n        # Post loop return best found or failure\n        if best_pair:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            shortcut_path = incremental_shortcut(raw_path)\n            smooth_path = bezier_smooth_path(shortcut_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -14.98571,
          "time_improvement": -3.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1310.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025359702110290528,
                    "num_nodes_avg": 137.0,
                    "path_length_avg": 164.42014380612903,
                    "smoothness_avg": 0.037995330495097596,
                    "success_improvement": 0.0,
                    "time_improvement": 1.6715584541643336,
                    "node_improvement": 65.4998740871317,
                    "length_improvement": 9.878713775954617,
                    "smoothness_improvement": 494.7094304290366,
                    "objective_score": 8.902242953967253
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08825304508209228,
                    "num_nodes_avg": 340.9,
                    "path_length_avg": 234.5522854996787,
                    "smoothness_avg": 0.08507897383388906,
                    "success_improvement": 0.0,
                    "time_improvement": 46.69927548127017,
                    "node_improvement": 77.09467177316402,
                    "length_improvement": 21.69969588700032,
                    "smoothness_improvement": 2089.143276653865,
                    "objective_score": 37.47531655985057
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07955119609832764,
                    "num_nodes_avg": 305.6,
                    "path_length_avg": 128.28847332395827,
                    "smoothness_avg": 0.11366993893215979,
                    "success_improvement": 0.0,
                    "time_improvement": -56.75983595890235,
                    "node_improvement": 61.14431023521932,
                    "length_improvement": 14.796904458862459,
                    "smoothness_improvement": 1345.8732329749432,
                    "objective_score": -1.4204419474785128
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner featuring adaptive informed sampling within ellipsoidal subsets, efficient rewiring with a dynamic neighborhood radius based on node count, and incremental path shortcutting to progressively improve path length and smoothness while minimizing planning time. The planner grows two trees from start and goal positions, alternately extending toward samples constrained by the current best solution\u2019s cost, rewiring locally for cost improvement, and shortcutting the combined path periodically to ensure continuously refined solutions.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by steering nearest nodes toward informed samples inside the current ellipsoidal region defined by the best path cost; it dynamically adapts the rewiring radius as node count grows to optimize connectivity and prune costs locally. Upon connecting the two trees with a better path, it incrementally shortcut the path at regular intervals for smoother trajectories, returning the best feasible path when finished or timeout occurs.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=50.0, shortcut_interval=40, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            return min(self.step_size*50, self.gamma * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n            else:\n                # Compute rotation matrix from first axis to dir_vec\n                if dim == 2:\n                    cos_theta = dir_vec[0]/length\n                    sin_theta = dir_vec[1]/length\n                    R = [[cos_theta, -sin_theta],\n                         [sin_theta, cos_theta]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[ 0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1 = best_cost * 0.5\n            a2 = math.sqrt(best_cost**2 - c_min**2) * 0.5\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1, 0], [0, a2]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1,0,0],[0,a2,0],[0,0,a2]]\n                    x_scaled = [L[i][i]*x_ball[i] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: sum((n.position[i]-point[i])**2 for i in range(dim)))\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for step in range(steps+1):\n                inter = tuple(p1[i] + (p2[i]-p1[i]) * (step/steps) for i in range(dim))\n                if self._is_in_obstacle(inter, obstacles, is_3d):\n                    return False\n            return True\n\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if is_edge_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def extract_path(node_a, node_b):\n            path_a, path_b = [], []\n            n = node_a\n            while n:\n                path_a.append(n.position)\n                n = n.parent\n            n = node_b\n            while n:\n                path_b.append(n.position)\n                n = n.parent\n            return list(reversed(path_a)) + path_b\n\n        for it in range(self.max_iter):\n            p_sample = informed_sample() if best_cost < float('inf') else sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, p_sample)\n                new_pos = steer(nearest_node.position, p_sample)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                radius = near_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_to_new = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_to_new < min_cost and is_edge_free(near_node.position, new_pos):\n                        min_cost = cost_to_new\n                        min_parent = near_node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    smooth_path = progressive_shortcut(raw_path)\n                    if smooth_path and len(smooth_path) >= 2:\n                        return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
          "objective": -14.92668,
          "time_improvement": -4.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1314.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.037845396995544435,
                    "num_nodes_avg": 178.0,
                    "path_length_avg": 165.42944166192004,
                    "smoothness_avg": 0.03843563195093346,
                    "success_improvement": 0.0,
                    "time_improvement": -46.739850889072756,
                    "node_improvement": 55.175018886930246,
                    "length_improvement": 9.325501627847583,
                    "smoothness_improvement": 501.60110434278266,
                    "objective_score": -5.918648768299365
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052951812744140625,
                    "num_nodes_avg": 269.6,
                    "path_length_avg": 234.10634420651417,
                    "smoothness_avg": 0.08692195248727295,
                    "success_improvement": 0.0,
                    "time_improvement": 68.01957392838445,
                    "node_improvement": 81.88537257273398,
                    "length_improvement": 21.84856392636707,
                    "smoothness_improvement": 2136.5644448493013,
                    "objective_score": 44.19783275858208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06805832386016845,
                    "num_nodes_avg": 273.6,
                    "path_length_avg": 124.92852901095083,
                    "smoothness_avg": 0.11033978563707739,
                    "success_improvement": 0.0,
                    "time_improvement": -34.11252384905549,
                    "node_improvement": 65.21296884933248,
                    "length_improvement": 17.02841948820697,
                    "smoothness_improvement": 1303.5139288678422,
                    "objective_score": 6.500864182546746
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive informed sampling based on current best path cost combined with a heuristic-driven prioritized rewiring scheme. Instead of uniform or vanilla informed sampling, the algorithm dynamically shrinks its sampling ellipsoid region as solutions improve for faster convergence. The rewiring phase favors nodes estimated closer to the goal using a heuristic distance, guiding tree restructuring to yield shorter, smoother paths. Post-processing employs an iterative shortcutting approach that refines path smoothness while preserving collision-free guarantees. This approach balances global exploration and local optimization to enhance planning efficiency, path length, and smoothness while reducing runtime.",
          "planning_mechanism": "The planner grows two bidirectional trees from start and goal, sampling adaptive informed points inside a shrinking ellipsoid focused by the best path cost. It extends and rewires nodes by prioritizing neighbors nearer the goal heuristic, striving for low-cost rewiring. Trees attempt to connect continuously, updating best solutions. Upon finishing, the path undergoes iterative shortcut smoothing to remove unnecessary waypoints. This coordinated mechanism improves convergence speed, reduces excessive edge checks, and enhances solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, max_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        # Precompute dimension for convenience\n        dim = 3 if is_3d else 2\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside ellipsoid shrinking as best_cost improves\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            \n            # Alternate tree roles each iteration\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n            \n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n            \n            near_nodes = self._near(tree_a, new_pos, self.max_radius)\n            # Prioritize near nodes by heuristic to goal (or start)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n            \n            # Choose best parent based on cost + heuristic + collision free\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) >= min_cost + heuristic_a(new_pos):\n                    # Prune candidates that are not better in cost + heuristic\n                    continue\n                if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                    continue\n                min_cost = tentative_cost\n                best_parent = nnode\n            \n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            \n            # Rewire neighbors that improve cost with heuristic guidance\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                # Only rewire if new cost + heuristic less than existing\n                if new_cost + heuristic_a(neighbor.position) + 1e-8 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n            \n            # Try connection to other tree within step size and free space\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n            \n            # Periodically extract and iteratively shortcut path for smoothness improvement\n            if solution_nodes[0] and solution_nodes[1] and (iter % 150 == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final check after iterations\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # Uniform random sampling if no valid path found yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # Clamp c_max to reasonable upper bound\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # Degenerate case\n            return start\n\n        # Rotation matrix to align x-axis to direction vector (2D or 3D)\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            # 3D rotation matrix from x-axis to dir_vec using Rodrigues formula\n            a1 = [1, 0, 0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + ((1 - c)/(s**2))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            # Sample point in unit ball\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            # Check bounds\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _iterative_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.08602,
          "time_improvement": -15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1402.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05029592514038086,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 161.93878883699725,
                    "smoothness_avg": 0.047628044606518545,
                    "success_improvement": 0.0,
                    "time_improvement": -95.01490647056376,
                    "node_improvement": 50.21405187610174,
                    "length_improvement": 11.23878375412141,
                    "smoothness_improvement": 645.482324046268,
                    "objective_score": -18.53379006846494
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059864473342895505,
                    "num_nodes_avg": 338.1,
                    "path_length_avg": 225.87643224817134,
                    "smoothness_avg": 0.0890107769545784,
                    "success_improvement": 0.0,
                    "time_improvement": 63.844649222693185,
                    "node_improvement": 77.2828058859101,
                    "length_improvement": 24.59594542294319,
                    "smoothness_improvement": 2190.3114029125213,
                    "objective_score": 44.86251903513647
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05845465660095215,
                    "num_nodes_avg": 311.2,
                    "path_length_avg": 116.34668105324462,
                    "smoothness_avg": 0.11554898589311344,
                    "success_improvement": 0.0,
                    "time_improvement": -15.18798998915194,
                    "node_improvement": 60.43229497774952,
                    "length_improvement": 22.7280742780298,
                    "smoothness_improvement": 1369.7745716214542,
                    "objective_score": 15.929320428179569
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, robust bidirectional RRT* planner with adaptive ellipsoidal informed sampling and frequent, lightweight incremental path shortcutting integrated during planning iterations. The algorithm balances exploration and exploitation through ellipsoidal sampling shrinking as better solutions are found, adapts rewiring radius to tree size for efficient local optimization, and applies shortcutting regularly upon improvements to maintain smoother, shorter paths. Tree expansions alternate sides, connecting with nearest neighbors and rewiring locally with collision checks to ensure path validity and quality without heavy computational overhead. This produces timely convergence to high-quality, smooth paths balanced across planning time, length, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal, samples within an adaptively shrinking ellipsoidal informed subset after initial solutions, extends trees toward samples using a fixed step size, rewires neighbors within an adaptive radius to reduce path cost, attempts to connect trees frequently, and applies incremental shortcutting on improved paths during planning to improve smoothness and reduce length progressively.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=25.0, goal_sample_rate=0.1, shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic(p, target):\n            return dist(p, target)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t*(b[j]-a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = 0\n                for i in range(dim):\n                    d_sq += (n.position[i] - point[i]) ** 2\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            val = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            c_max = min(best_cost * 1.05, sum(bounds)*1.5)\n            a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            if length < 1e-15:\n                return goal_pos\n            e1 = [x/length for x in a1]\n\n            # Generate orthonormal basis\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                # Gram-Schmidt for 3D\n                v = [1,0,0] if abs(e1[0]) < 0.9 else [0,1,0]\n                u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(dim)) for i in range(dim)]\n                u_norm = math.sqrt(sum(x*x for x in u))\n                if u_norm < 1e-15:\n                    u = [0]*dim\n                    u[-1] = 1.0\n                    u_norm = 1.0\n                u = [x/u_norm for x in u]\n                w = [e1[1]*u[2]-e1[2]*u[1],\n                     e1[2]*u[0]-e1[0]*u[2],\n                     e1[0]*u[1]-e1[1]*u[0]]\n                basis = [e1, u, w]\n\n            a_len = c_max / 2.0\n            b_len_sq = max((c_max*c_max - c_min*c_min)/4.0, 1e-8)\n            b_len = math.sqrt(b_len_sq)\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    coords = [a_len * unit_ball[0], b_len * unit_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_sample = [random.uniform(-1,1) for _ in range(3)]\n                        norm_sq = sum(x*x for x in u_sample)\n                        if norm_sq <= 1 and norm_sq > 0:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_sample]\n                    coords = [a_len * unit_ball[0], b_len * unit_ball[1], b_len * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt connection to other tree\n            nearest_other = nearest(other_tree, new_pos)\n            dist_conn = dist(new_pos, nearest_other.position)\n            if dist_conn <= self.step_size and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_conn + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        solution_nodes = (new_node, nearest_other)\n                    else:\n                        solution_nodes = (nearest_other, new_node)\n\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": -13.22857,
          "time_improvement": 51.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1545.0,
          "node_improvement": 71.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023602938652038573,
                    "num_nodes_avg": 148.4,
                    "path_length_avg": 173.93453305857608,
                    "smoothness_avg": 0.046684993365167494,
                    "success_improvement": 0.0,
                    "time_improvement": 8.483145288399767,
                    "node_improvement": 62.62906069000251,
                    "length_improvement": 4.663726261542782,
                    "smoothness_improvement": 630.7215242505763,
                    "objective_score": 8.49678696469848
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032700300216674805,
                    "num_nodes_avg": 301.6,
                    "path_length_avg": 241.7878757131836,
                    "smoothness_avg": 0.10230075379140147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.25054328825179,
                    "node_improvement": 79.73526842706443,
                    "length_improvement": 19.284247608815647,
                    "smoothness_improvement": 2532.272079307376,
                    "objective_score": 48.307071948301804
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.018891048431396485,
                    "num_nodes_avg": 227.7,
                    "path_length_avg": 133.77213545637804,
                    "smoothness_avg": 0.12353301308846183,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 62.77419072948863,
                    "node_improvement": 71.04895104895105,
                    "length_improvement": 11.15491717443958,
                    "smoothness_improvement": 1471.3308082267,
                    "objective_score": -17.118138435356155
               }
          ],
          "success_rate": 0.9666666666666667
     }
]